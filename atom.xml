<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xgp &amp; Blog</title>
  
  <subtitle>Today is still beautiful</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wsdlxgp.top/"/>
  <updated>2020-06-06T15:28:20.705Z</updated>
  <id>https://wsdlxgp.top/</id>
  
  <author>
    <name>Wu Shao Dong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>企业级私有仓库镜像仓库Harbor</title>
    <link href="https://wsdlxgp.top/posts/7597.html"/>
    <id>https://wsdlxgp.top/posts/7597.html</id>
    <published>2020-06-06T15:29:15.700Z</published>
    <updated>2020-06-06T15:28:20.705Z</updated>
    
    <content type="html"><![CDATA[<h1>企业级私有仓库镜像仓库Harbor</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -L https://github.com/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose<br>chmod +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><p>在网上下载docker-compose工具。**</p><p><a href="https://github.com/docker/compose/releases/tag/1.25.1-rc1" target="_blank" rel="noopener">https://github.com/docker/compose/releases/tag/1.25.1-rc1</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# tar -zxf docker-compose.tar.gz  -C /usr/local/bin/<br>//解压到命令目录<br>[root@docker02 ~]# chmod  +x /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# yum -y install yum-utils device-mapper-persistent-data lvm2<br>//安装依赖包<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker-compose -v<br>//查看版本信息<br>docker-compose version 1.24.0, build 0aa59064<br></code></pre></td></tr></table></figure><p><strong>在网上下载harbor并安装。</strong></p><p><a href="https://github.com/goharbor/harbor/releases" target="_blank" rel="noopener">https://github.com/goharbor/harbor/releases</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# tar -zxf harbor-offline-installer-v1.7.4.tgz  -C /usr/local/<br>//导入harbor离线安装包，解压到/usr/<br></code></pre></td></tr></table></figure><p><strong>修改harbor配置文件，并执行自带的安装脚本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# cd  /usr/local/harbor/<br>[root@docker02 harbor]#ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219112515851.png" alt="image-20191219112515851"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 harbor]# vim harbor.cfg <br>hostname = 192.168.1.13    #13 改为本机IP地址<br>harbor_admin_password = Harbor12345   #harbor密码<br>[root@docker02 harbor]# ./install.sh<br>//执行一下自带的安装脚本<br></code></pre></td></tr></table></figure><p><strong>在浏览器登陆一下harbor</strong></p><p><a href="http://192.168.1.13:80" target="_blank" rel="noopener">http://192.168.1.13:80</a> 用户名：admin，密码：Harbor12345</p><p>创建一个项目</p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219114104966.png" alt="image-20191219114104966"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219114109278.png" alt="image-20191219114109278"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219114127806.png" alt="image-20191219114127806"></p><p><strong>修改docker配置文件，连接私有仓库</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 harbor]# vim /usr/lib/systemd/system/docker.service <br><br>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.1.<br>13  #13行添加<br><br>[root@docker02 harbor]# systemctl  daemon-reload <br>[root@docker02 harbor]# systemctl restart docker<br>//重启docker<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 harbor]# docker ps<br>//发现运行的容器少了很多<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219114511909.png" alt="image-20191219114511909"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 harbor]# docker-compose start<br>//启动harker的文件中的容器<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219115045451.png" alt="image-20191219115045451"></p><p><strong>登陆harbor</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 harbor]# docker login -u admin -p Harbor12345 192.168.1.13<br>//登陆harbor<br></code></pre></td></tr></table></figure><p><strong>上传镜像到仓库</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 harbor]# docker tag centos:7  192.168.1.13/xgp/centos:7<br>//修改标签<br>[root@docker02 harbor]# docker push 192.168.1.13/xgp/centos:7 <br>//上传镜像<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219115614192.png" alt="image-20191219115614192"></p><p><strong>第二台加入仓库，测试下载</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 harbor]# vim /usr/lib/systemd/system/docker.service <br><br>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.1.<br>13  #13行添加<br><br>[root@docker02 harbor]# systemctl  daemon-reload <br>[root@docker02 harbor]# systemctl restart docker<br>//重启docker<br></code></pre></td></tr></table></figure><p><strong>登陆harbor</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 harbor]# docker login -u admin -p Harbor12345 192.168.1.13<br>//登陆harbor<br></code></pre></td></tr></table></figure><p><strong>下载刚刚上传的镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 xxx]# docker pull  192.168.1.13/xgp/centos:7<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 xxx]# docker images<br>//查看本地镜像<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219120319663.png" alt="image-20191219120319663"></p><p><em><strong>下载成功</strong></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;企业级私有仓库镜像仓库Harbor&lt;/h1&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>prometheus监控</title>
    <link href="https://wsdlxgp.top/posts/fe12.html"/>
    <id>https://wsdlxgp.top/posts/fe12.html</id>
    <published>2020-06-06T15:29:15.698Z</published>
    <updated>2020-06-06T15:14:22.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置AlertManager">配置AlertManager</h2><p><strong>AlertManager：用来接收prometheus发送来的报警信息，并且执行设置好的报警方式、报警内容。</strong></p><h3 id="下载镜像"><strong>下载镜像</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker pull alertmanager<br>//下载alertmanager镜像<br></code></pre></td></tr></table></figure><h3 id="基于alertmanager运行一台容器"><strong>基于alertmanager运行一台容器</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -d --name alertmanager -p 9093:9093 prom/alertmanager:latest<br></code></pre></td></tr></table></figure><h3 id="配置路由转发"><strong>配置路由转发</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# echo net.ipv4.ip_forward = 1 &gt;&gt; /etc/sysctl.conf <br>[root@docker01 ~]# sysctl -p<br></code></pre></td></tr></table></figure><h3 id="在部署alertmanager之前，我们需要对它的配置文件进行修改-所以我们先运行一个容器，先将其配置文件拷贝出来。"><strong>在部署alertmanager之前，我们需要对它的配置文件进行修改,所以我们先运行一个容器，先将其配置文件拷贝出来。</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker cp alertmanager:/etc/alertmanager/alertmanager.yml ./<br>//拷贝alertmanager的配置文件到本地<br></code></pre></td></tr></table></figure><h3 id="修改alertmanager的配置文件"><strong>修改alertmanager的配置文件</strong></h3><h4 id="配置文件简单介绍"><strong>配置文件简单介绍</strong></h4><blockquote><p><strong>AlertManager：用来接收Prometheus发送的报警信息，并且执行设置好的报警方式，报警内容。</strong></p><p><strong>AlertManager.yml配置文件：</strong></p><blockquote><p><strong>global：全局配置，包括报警解决后的超时时间、SMTP相关配置、各种渠道通知的API地址等消息。</strong></p><p><strong>route：用来设置报警的分发策略。</strong></p><p><strong>receivers：配置报警信息接收者信息。</strong></p><p><strong>inhibit_rules：抑制规则配置，当存在与另一个匹配的报警时，抑制规则将禁用用于有匹配的警报。</strong></p></blockquote></blockquote><h4 id="修改配置文件"><strong>修改配置文件</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# vim alertmanager.yml <br>//修改alertmanager配置文件<br>global:<br>  resolve_timeout: 5m<br>  smtp_from: '2877364346@qq.com'   #自己邮箱地址<br>  smtp_smarthost: 'smtp.qq.com:465'  #qq的邮箱地址及端口<br>  smtp_auth_username: '2877364346@qq.com'  <br>  smtp_auth_password: 'osjppnjkbuhcdfff' #需要在qq邮箱获取授权码<br>  smtp_require_tls: false<br>  smtp_hello: 'qq.com'<br>route:<br>  group_by: ['alertname']<br>  group_wait: 5s<br>  group_interval: 5s<br>  repeat_interval: 5m<br>  receiver: 'email'           #接收者改为邮箱<br>receivers:<br>- name: 'email'<br>  email_configs:<br>  - to: '2877364346@qq.com'<br>    send_resolved: true<br>    inhibit_rules:<br>  - source_match:<br>    severity: 'critical'<br>    target_match:<br>      severity: 'warning'<br>    equal: ['alertname', 'dev', 'instance']<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">global:<br>  resolve_timeout: 5m<br>  smtp_from: '2877364346@qq.com'<br>  smtp_smarthost: 'smtp.qq.com:465'<br>  smtp_auth_username: '2877364346@qq.com'<br>  smtp_auth_password: 'osjppnjkbuhcdfff'<br>  smtp_require_tls: false<br>  smtp_hello: 'qq.com'<br>route:<br>  group_by: ['alertname']<br>  group_wait: 5s<br>  group_interval: 5s<br>  repeat_interval: 5m<br>  receiver: 'email'<br>receivers:<br>- name: 'email'<br>  email_configs:<br>  - to: '2877364346@qq.com'<br>    send_resolved: true<br>inhibit_rules:<br>  - source_match:<br>      severity: 'critical'<br>    target_match:<br>      severity: 'warning'<br>    equal: ['alertname', 'dev', 'instance']<br></code></pre></td></tr></table></figure><h3 id="重新运行-alertmanager-容器"><strong>重新运行 alertmanager 容器</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker rm -f alertmanager<br>//删除alertmanager容器<br>[root@docker01 ~]# docker run -d --name alertmanager -v /root/alertmanager.yml:/etc/alertmanager/alertmanager.yml -p 9093:9093 prom/alertmanager:latest <br>//运行一台新的alertmanager容器，记得挂载配置文件<br></code></pre></td></tr></table></figure><h2 id="Prometheus配置和alertmanager报警规则"><strong>Prometheus配置和alertmanager报警规则</strong></h2><h3 id="创建存放规则的目录"><strong>创建存放规则的目录</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# mkdir -p prometheus/rules<br>//创建规则目录<br>[root@docker01 ~]# cd prometheus/rules/<br></code></pre></td></tr></table></figure><h3 id="编写规则"><strong>编写规则</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 rules]# vim node-up.rules <br>groups:<br>- name: node-up<br>  rules:<br>  - alert: node-up<br>    expr: up&#123;job="prometheus"&#125; == 0    #&#123;job="prometheus"&#125;中的prometheus需要和prometheus配置文件23行的相同<br>    for: 15s<br>    labels:<br>      severity: 1<br>      team: node<br>    annotations:<br>      summary: "&#123;&#123; $labels.instance &#125;&#125; 已停止运行超过 15s！"<br></code></pre></td></tr></table></figure><h3 id="修改-prometheus配置文件"><strong>修改 prometheus配置文件</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# vim prometheus.yml <br><br><span class="hljs-meta">#</span><span class="bash"> Alertmanager configuration  <span class="hljs-comment">#7</span></span><br>alerting:<br>  alertmanagers:<br>  - static_configs:<br>    - targets:<br>       - 192.168.1.11:9093  #去注释修改<br><br><span class="hljs-meta">#</span><span class="bash"> Load rules once and periodically evaluate them according to the global <span class="hljs-string">'evaluation_interval'</span>.   <span class="hljs-comment">#14行</span></span><br>rule_files:<br>  - "/usr/local/prometheus/rules/*.rules"  #添加（这个路径是prometheus容器内的路径）<br></code></pre></td></tr></table></figure><h3 id="重新运行prometheus-容器"><strong>重新运行prometheus 容器</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker rm -f prometheus <br>//删除prometheus容器<br>[root@docker01 ~]# docker run -d -p 9090:9090 --name prometheus --net=host -v /root/prometheus.yml:/etc/prometheus/prometheus.yml -v /root/prometheus/rules/node-up.rules:/usr/local/prometheus/rules/node-up.rules   prom/prometheus<br>//运行一台新的alertmanager容器，记得挂载规则文件<br></code></pre></td></tr></table></figure><h3 id="浏览器验证一下http-192-168-1-11-9090-rules"><strong>浏览器验证一下http://192.168.1.11:9090/rules</strong></h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191225101246355.png" alt="image-20191225101246355"></p><p>挂起docker02</p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191225101629745.png" alt="image-20191225101629745"></p><p>会收到邮件</p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191225104344774.png" alt="image-20191225104344774"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;配置AlertManager&quot;&gt;配置AlertManager&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;AlertManager：用来接收prometheus发送来的报警信息，并且执行设置好的报警方式、报警内容。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;下载镜像&quot;&gt;&lt;st
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>prometheus</title>
    <link href="https://wsdlxgp.top/posts/d356.html"/>
    <id>https://wsdlxgp.top/posts/d356.html</id>
    <published>2020-06-06T15:29:15.696Z</published>
    <updated>2020-06-06T15:15:09.861Z</updated>
    
    <content type="html"><![CDATA[<h1><strong>Prometheus（普罗米修斯）</strong></h1><h2 id="实验环境"><strong>实验环境</strong></h2><table><thead><tr><th style="text-align:left">docker01</th><th>docker02</th><th>docker03</th></tr></thead><tbody><tr><td style="text-align:left">192.168.1.11</td><td>192.168.1.13</td><td>192.168.1.20</td></tr><tr><td style="text-align:left">NodeEXporter</td><td>NodeEXporter</td><td>NodeEXporter</td></tr><tr><td style="text-align:left">cAdvisor</td><td>cAdvisor</td><td>cAdvisor</td></tr><tr><td style="text-align:left">Prometheus Server</td><td>空</td><td>空</td></tr><tr><td style="text-align:left">Grafana</td><td>空</td><td>空</td></tr></tbody></table><p><em><strong>全部关闭防火墙，禁用selinux</strong></em></p><p><strong>需要部署的组件：</strong></p><blockquote><p><strong>Prometheus Server:普罗米修斯的主服务器。</strong></p><p>Prometheus是一个开源的服务监控系统，它通过HTTP协议从远程的机器收集数据并存储在本地的时序数据库上。</p><ul><li>多维数据模型（时序列数据由metric名和一组key/value组成）</li><li>在多维度上灵活的查询语言(PromQl)</li><li>不依赖分布式存储，单主节点工作.</li><li>通过基于HTTP的pull方式采集时序数据</li><li>可以通过push gateway进行时序列数据推送(pushing)</li><li>可以通过服务发现或者静态配置去获取要采集的目标服务器</li><li>多种可视化图表及仪表盘支持</li><li>Prometheus通过安装在远程机器上的exporter来收集监控数据，后面我们将使用到node_exporter收集系统数据。</li></ul><p><strong><a href>NodeEXporter</a>:负责收集Host硬件信息和操作系统信息。</strong></p><p><strong><a href>cAdvisor</a>:负责收集Host.上运行的容器信息。</strong></p><p><strong>Grafana:负责展示普罗米修斯监控界面。</strong></p><p>Grafana 是一个开箱即用的可视化工具，具有功能齐全的度量仪表盘和图形编辑器，有灵活丰富的图形化选项，可以混合多种风格，支持多个数据源特点。</p></blockquote><p><em><strong>这些可以直接docker pull下载镜像（现在是本地导入镜像）</strong></em></p><p><strong>本地上传镜像</strong></p><p>docker01</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[09:05:42][docker01$  docker load -i node-exporter.tar &amp;&amp; docker load -i  mycadvisor.tar &amp;&amp; docker load -i prometheus.tar  &amp;&amp; docker load -i grafana.tar<br></code></pre></td></tr></table></figure><p>docker02和docker03</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[09:05:22]docker03]$ docker load -i node-exporter.tar &amp;&amp; docker load -i  mycadvisor.tar<br></code></pre></td></tr></table></figure><h2 id="各主机部署">各主机部署</h2><h3 id="1-3个节点，全部部署node-EXporter-和cAdvisor"><strong>1) 3个节点，全部部署node-EXporter,和cAdvisor.</strong></h3><h4 id="部署安装node-EXporter收集节点硬件和操作系统信息。"><strong>部署安装node-EXporter收集节点硬件和操作系统信息。</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[09:21:03[docker01]$  docker run -d -p 9100:9100 -v /proc:/host/proc -v /sys:/host/sys -v /:/rootfs --net=host prom/node-exporter --path.procfs /host/proc --path.sysfs /host/sys --collector.filesystem.ignored-mount-points "^/(sys|proc|dev|host|etc)($|/)"<br>//部署node-EXporter,收集硬件和系统信息。<br></code></pre></td></tr></table></figure><p><em><strong>PS: 注意，这里使用了–net=host， 这样Prometheus Server可以直接与Node-</strong></em><br><em><strong>EXporter通信。</strong></em></p><p><strong>验证</strong>:打开浏览器验证结果。<a href="http://192.168.1.11:9100/%EF%BC%8Chttp://192.168.1.13:9100/%EF%BC%8Chttp://192.168.1.20:9100/" target="_blank" rel="noopener">http://192.168.1.11:9100/，http://192.168.1.13:9100/，http://192.168.1.20:9100/</a></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224092308045.png" alt="image-20191224092308045"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224092328151.png" alt="image-20191224092328151"></p><h4 id="部署安装cAdvisor-收集节点容器信息。"><strong>部署安装cAdvisor,收集节点容器信息。</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[09:39:10[docker01]$ docker run -v /:/rootfs:ro -v /var/run:/var/run/:rw -v /sys:/sys:ro -v /var/lib/docker:/var/lib/docker:ro --detach=true --name=cadvisor --net=host google/cadvisor<br></code></pre></td></tr></table></figure><p><strong>验证</strong>:打开浏览器验证结果。<a href="http://192.168.1.11:8080" target="_blank" rel="noopener">http://192.168.1.11:8080</a>，<a href="http://192.168.1.13:8080" target="_blank" rel="noopener">http://192.168.1.13:8080</a>，<a href="http://192.168.1.20:8080" target="_blank" rel="noopener">http://192.168.1.20:8080</a></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224094211151.png" alt="image-20191224094211151"></p><h3 id="2-在docker01上部署Prometheus-Server服务。"><strong>2)在docker01上部署Prometheus Server服务。</strong></h3><p><em><strong>在部署prometheus之前，我们需要对它的配置文件进行修改,所以我们先运行一个容器，先将其配置文件拷贝出来。</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">09:51:22][docker01]$ docker run -d -p 9090:9090 --name prometheus --net=host prom/prometheus<br>//打开一台Prometheus<br>[09:51:00[docker01]$ docker cp prometheus:/etc/prometheus/prometheus.yml ./<br>//拷贝Prometheus的配置文件到本地<br></code></pre></td></tr></table></figure><h4 id="修改Prometheus的配置文件，添加监听端口（29行）"><strong>修改Prometheus的配置文件，添加监听端口（29行）</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[09:55:53][docker01][~]$ vim prometheus.yml <br>//修改配置文件这里指定了prometheus的监控项，包括它也会监控自己手机到的数据。<br>- targets: ['localhost:9090','localhost:8080','localhost:9100','192.168.1.13:8080','192.168.1.13:9100','192.168.1.20:8080','192.168.1.20:9100']<br></code></pre></td></tr></table></figure><h4 id="重新运行prometheus容器">重新运行prometheus容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[10:00:27][docker01][~]$ docker rm -f prometheus <br>//删除 prometheus容器<br>[10:02:45][docker01][~]$ docker run -d -p 9090:9090 --name prometheus --net=host  -v /root/prometheus.yml:/etc/prometheus/prometheus.yml   prom/prometheus<br>//运行一台新的 prometheus容器<br></code></pre></td></tr></table></figure><h4 id="浏览器访问，验证：http-192-168-1-11-9090-graph">浏览器访问，验证：<a href="http://192.168.1.11:9090/graph" target="_blank" rel="noopener">http://192.168.1.11:9090/graph</a></h4><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224100745680.png" alt="image-20191224100745680"></p><p><em><strong>ps：这里能够查看到我们各个监控项。</strong></em></p><p>如果现在挂起一台虚拟机（测试完之后继续运行）</p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224101214064.png" alt="image-20191224101214064"></p><h3 id="3-在docker01-上-部署grafana服务-用来展示prometheus收集到的数据。"><strong>3)在docker01.上,部署grafana服务,用来展示prometheus收集到的数据。</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# mkdir grafana-storage<br>//创建收集信息的目录<br>[root@docker01 ~]# chmod 777 grafana-storage/<br>//给予777权限<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -d -p 3000:3000 --name grafana -v /root/grafana-storage:/var/lib/grafana -e "GF_SECURITY_ADMIN_PASSWORD=123.com" grafana/grafana<br></code></pre></td></tr></table></figure><h4 id="浏览器访问验证：-http-192-168-1-11-3000-login">**浏览器访问验证：**<a href="http://192.168.1.11:3000/login" target="_blank" rel="noopener">http://192.168.1.11:3000/login</a></h4><p><strong>（&lt;默认&gt;用户名：admin，密码：<a href="http://123.com" target="_blank" rel="noopener">123.com</a>）</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224102458225.png" alt="image-20191224102458225"></p><h4 id="添加数据源"><strong>添加数据源</strong></h4><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224104423328.png" alt="image-20191224104423328"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224104456642.png" alt="image-20191224104456642"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224104700442.png" alt="image-20191224104700442"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224105029089.png" alt="image-20191224105029089"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224105050798.png" alt="image-20191224105050798"></p><p><em><strong>PS:看到这个提示， 说明prometheus和grafana服务的是 正常连接的。</strong></em></p><blockquote><p><strong>此时，虽然grafana收集到了数据，但怎么显示它,仍然是个问题，grafana支持自定 义显示信息,不过要自定义起来非常麻烦，不过好在，grafana官方为我们提供了- -些模板，来供我们使用。</strong></p><p>**grafana官网:**<a href="https://grafana.com/docs/grafana/latest/" target="_blank" rel="noopener">https://grafana.com/docs/grafana/latest/</a></p></blockquote><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224105657726.png" alt="image-20191224105657726"></p><p><img src="https://s1.51cto.com/images/blog/201912/24/4b062ba0ae732e66178334cb87eb7ee8.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="基于docker 搭建Prometheus+Grafana"></p><p><img src="https://s1.51cto.com/images/blog/201912/24/608fa3739e797bda40b4eb84b68af25b.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="基于docker 搭建Prometheus+Grafana"></p><p><img src="https://s1.51cto.com/images/blog/201912/24/f6e457dfef636c0fd406eb215ff824bc.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="基于docker 搭建Prometheus+Grafana"></p><h4 id="选中一款模板，然后，我们有2种方式可以套用这个模板。"><strong>选中一款模板，然后，我们有2种方式可以套用这个模板。</strong></h4><h5 id="第一种方式：通过JSON文件使用模板。"><strong>第一种方式：通过JSON文件使用模板。</strong></h5><p><img src="https://s1.51cto.com/images/blog/201912/24/545fab9136f340564d29233515fb5703.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="基于docker 搭建Prometheus+Grafana"></p><p><strong>下载完成之后，来到grafana控制台</strong></p><p><img src="https://s1.51cto.com/images/blog/201912/24/0265cc6e5015e1f4f41258e8d16962f8.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="基于docker 搭建Prometheus+Grafana"></p><p><img src="https://s1.51cto.com/images/blog/201912/24/0e8af545036ec8d7e69d61df3d7cf058.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="基于docker 搭建Prometheus+Grafana"></p><p><img src="https://s1.51cto.com/images/blog/201912/24/69763107eb04aa718249d19836443115.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="基于docker 搭建Prometheus+Grafana"></p><p><img src="https://s1.51cto.com/images/blog/201912/24/b1c3db375ebfa0b01159aa40be60d1a8.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="基于docker 搭建Prometheus+Grafana"></p><h5 id="第二种导入模板的方式">第二种导入模板的方式:**</h5><p><strong>可以直接通过模板的ID号。</strong></p><p><img src="https://s1.51cto.com/images/blog/201912/24/97392974a42d1c28a50e4df2aad426e9.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="基于docker 搭建Prometheus+Grafana"></p><p><strong>//这个id不好用换成8321了</strong></p><p><img src="https://s1.51cto.com/images/blog/201912/24/a445f9e04729c87a0b91f5f52f9024bd.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="基于docker 搭建Prometheus+Grafana"></p><p><strong>复制模板id之后，来到grafana控制台</strong></p><p><img src="https://s1.51cto.com/images/blog/201912/24/dfaa08945b13ba1f1dad9aaa5ea9ecd5.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="基于docker 搭建Prometheus+Grafana"></p><h1>排错思路</h1><p>防火墙是否关闭，selinux是否禁用<br>主机名称是否更改<br>镜像是否正常<br>各服务启动时挂载目录是否正确<br>grafana服务，是否创建所需目录，目录是否有权限<br>Prometheus服务是否修改配置文件</p><h1>总结</h1><p>恭喜！您已经设置了Prometheus服务器，Node Exporter和Grafana 等所有这些都可以使用的Docker。尽管这些目前都在同一台机器上运行，但这仅用于演示目的。在生产设置中，通常会在每台受监控的计算机上运行节点导出器，多个Prometheus服务器（根据组织的需要），以及单个Grafana服务器来绘制来自这些服务器的数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;strong&gt;Prometheus（普罗米修斯）&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&quot;实验环境&quot;&gt;&lt;strong&gt;实验环境&lt;/strong&gt;&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;docker
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>nginx+docker+nfs部署</title>
    <link href="https://wsdlxgp.top/posts/24f3.html"/>
    <id>https://wsdlxgp.top/posts/24f3.html</id>
    <published>2020-06-06T15:29:15.694Z</published>
    <updated>2020-06-06T15:16:15.518Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191221085649190.png" alt="image-20191221085649190"></p><h1>nginx（两台都是）</h1><p><strong>安装nginx</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nginx01 ~]# tar zxf nginx-1.14.0.tar.gz <br>//解压nginx安装包<br>[root@nginx01 ~]# cd nginx-1.14.0/<br>[root@nginx01 nginx-1.14.0]# yum -y install openssl-devel pcre-devel zlib-devel<br>//安装nginx依赖包<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nginx01 nginx-1.14.0]# ./configure --prefix=/usr/local/nginx1.14 --with-http_dav_module --with-http_stub_status_module --with-http_addition_module  --with-http_sub_module --with-http_flv_module --with-http_mp4_module --with-pcre --with-http_ssl_module --with-http_gzip_static_module --user=nginx --group=nginx &amp;&amp; make  &amp;&amp;  make install<br>//编译安装nginx<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nginx01 nginx-1.14.0]# useradd nginx -s /sbin/nologin -M<br>//创建所需用户<br>[root@nginx01 nginx-1.14.0]# ln -s /usr/local/nginx1.14/sbin/nginx /usr/local/sbin/<br>//链接命令<br>[root@nginx01 nginx-1.14.0]# nginx <br>//开启nginx<br>[root@nginx01 nginx-1.14.0]# netstat -anpt | grep nginx<br>//查看nginx是否开启<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191221090519105.png" alt="image-20191221090519105"></p><p><strong>部署nginx</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nginx01 ~]# cd /usr/local/nginx1.14/conf/<br>[root@nginx01 conf]# vim nginx.conf<br></code></pre></td></tr></table></figure><p>​        http模块加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backend &#123;<br>server 192.168.1.11:90 weight=1 max_fails=2 fail_timeout=10s;<br>server 192.168.1.13:90 weight=1 max_fails=2 fail_timeout=10s;<br>&#125;<br></code></pre></td></tr></table></figure><pre><code>    location / {       # root   html;       # index  index.html index.htm;       proxy_pass http://backend;  #添加    }</code></pre><h2 id="高可用环境">高可用环境</h2><p><strong>安装keepalived</strong></p><p>[root@nginx02 nginx-1.14.0]# yum -y install keepalived</p><p><strong>配置keepalived</strong></p><p>修改主和备nginx服务器上的keepalived 配置文件 /etc/keepalived/keepalived.conf 文件</p><p><strong>主nginx</strong></p><p>修改主nginx下/etc/keepalived/keepalived.conf文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">! Configuration File for keepalived<br>global_defs &#123;<br>   router_id LVS_DEVEL<br>&#125;   <br>vrrp_instance VI_1 &#123;<br>    state MASTER<br>    interface ens33<br>    virtual_router_id 51<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 1111<br>    &#125;   <br>    virtual_ipaddress &#123;<br>        192.168.1.40<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>备nginx</strong></p><p>修改备nginx下 /etc/keepalived /keepalived.conf文件</p><p>配置备nginx时需要注意：需要修改state为BACKUP , priority比MASTER低，virtual_router_id和master的值一致</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">! Configuration File for keepalived<br>global_defs &#123;<br>   router_id TWO<br>&#125;<br><br>vrrp_instance VI_1 &#123;<br>    state BACKUP<br>    interface ens33<br>    virtual_router_id 1<br>    priority 99<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 1111<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.1.40<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试（在做完docker的时候）</strong></p><p>主备nginx都启动keepalived</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl  start  keepalived<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nginx01 conf]# curl 192.168.1.40<br>wsd666<br></code></pre></td></tr></table></figure><h1>nfs（两台都是)</h1><p>nfs操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# yum -y install nfs-utils<br>//下载nfs服务<br><br>[root@nfs ~]# mkdir /database<br>//创建共享目录<br>[root@nfs02 ~]# chmod 777 /database/<br>//设置权限<br>[root@nfs ~]# vim /etc/exports<br>//设置权限如下<br>/database *(rw,sync,no_root_squash)<br></code></pre></td></tr></table></figure><p>开启各项服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs ~]# systemctl start rpcbind<br>[root@nfs ~]# systemctl enable rpcbind<br>[root@nfs ~]# systemctl start nfs-server<br>[root@nfs ~]# systemctl enable nfs-server<br></code></pre></td></tr></table></figure><p>docker01和docker02测试nfs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs01 ~]# vim /etc/rsyncd.conf <br>//建立rsync配置文件<br>uid = nobody<br>gid = nobody<br>use chroot = yes<br>address = 192.168.1.30<br>port 873<br>log file = /var/log/rsyncd.log<br>pid file = /var/run/rsyncd.pid<br>hosts allow = 192.168.1.0/24<br>[wwwroot]<br>path = /database<br>read only = no<br>dont compress = *.gz *.bz2 *.rar *.zip<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs01 ~]# mkdir /database<br>//创建共享目录<br>[root@nfs01 ~]# rsync --daemon<br>//启动rsync<br>[root@nfs01 ~]# netstat -anpt | grep rsync<br>//查看端口<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191221094558212.png" alt="image-20191221094558212"></p><p><strong>如果需要重启rsync服务，需要：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# kill  $(cat /var/run/rsyncd.pid)<br>//停止服务<br>[root@localhost ~]# rsync --daemon<br>//启动服务<br>[root@localhost ~]# kill -9 $(cat /var/run/rsyncd.pid)<br></code></pre></td></tr></table></figure><p>或者直接使用“netstat -anpt | grep rsync”命令查出进程号，使用“kill 进程号”一样。<br>使用第一种方法停止rsync服务必须删除存放rsync服务进程的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# rm -rf /var/run/rsyncd.pid<br></code></pre></td></tr></table></figure><h3 id="使用rsync备份工具">使用rsync备份工具</h3><p>配置好rsync同步源服务器之后，客户端就可以使用rsync工具来执行远程同步了。</p><h5 id="与rsync主机同步">与rsync主机同步</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync命令的选项：<br>-r：递归模式，包含目录及子目录中所有文件<br>-l：对于符号链接文件仍然复制为符号链接文件<br>-p：保留文件的权限标记<br>-t：保留文件的时间标记<br>-g：保留文件的属组标记（仅超级用户使用）<br>-o：保留文件的属主标记（仅超级用户使用）<br>-D：保留设备文件及其他特殊文件<br>-a：归档模式，递归并保留对象属性，等同于 -rlptgoD<br>-v：显示同步过程的详细（verbose）信息<br>-z：在传输文件时进行压缩（compress）<br>-H：保留硬连接文件<br>-A：保留ACL属性信息<br>--delete：删除目标位置有而原始位置没有的文件<br>--checksum：根据对象的校验和来决定是否跳过文件<br></code></pre></td></tr></table></figure><p><strong>rsync是一款快速增量备份工具，支持：<br>（1）本地复制；<br>（2）与其他SSH同步；<br>（3）与rsync主机同步。</strong></p><h5 id="手动与rsync主机同步">手动与rsync主机同步</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# rsync -avz 192.168.1.1::wwwroot /root<br>或者<br>[root@localhost ~]# rsync -avz rsync://192.168.1.1/wwwroot /root<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs01 database]# vim index.html<br>xgp666<br>//创建测试目录<br></code></pre></td></tr></table></figure><h2 id="配置inotify-rsync实时同步（两台都是）">配置inotify+rsync实时同步（两台都是）</h2><p><strong>(1)、软件安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -q rsync //查询rsync是否安装，一般为系统自带安装<br>yum install rsync -y //若没有安装，使用yum安装<br></code></pre></td></tr></table></figure><p><strong>安装inotify软件包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs02 ~]# tar zxf inotify-tools-3.14.tar.gz <br>[root@nfs02 ~]# cd inotify-tools-3.14/<br>[root@nfs02 inotify-tools-3.14]#  ./configure &amp;&amp; make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p><strong>（2）调整inotify内核参数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs02 ~]# vim /etc/sysctl.conf<br>fs.inotify.max_queued_events = 16384<br>fs.inotify.max_user_instances = 1024<br>fs.inotify.max_user_watches = 1048576<br><br>[root@nfs02 ~]# sysctl -p<br>//生效<br></code></pre></td></tr></table></figure><p><strong>(3)  编写触发式同步脚本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>A="inotifywait -mrq -e modify,move,create,delete /database/"<br>B="rsync -avz  /database/ 192.168.1.40::wwwroot"<br><span class="hljs-meta">$</span><span class="bash">A | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> DIRECTORY EVENT FILE</span><br>do<br>    if [ $(pgrep rsync | wc -l) -gt 0 ] ; then<br>        $B<br>    fi<br>done<br></code></pre></td></tr></table></figure><p><em><strong>此处需要注意，在两台服务器需要同步的目录之间，也需要将目录权限放到最大，避免因目录本身权限报错。</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs01 inotify-tools-3.14]# chmod  +x /opt/ino.sh<br></code></pre></td></tr></table></figure><p><strong>设置脚本开机自启</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs01 database]# vim /etc/rc.d/rc.local <br>/opt/ino.sh &amp;<br>/usr/bin/rsync --daemon<br></code></pre></td></tr></table></figure><p><strong>源服务器端测试</strong></p><ul><li>执行脚本后，当前终端会变成实时监控界面，需要重新打开终端操作。</li><li>在源服务器端共享模块目录下进行文件操作，然后去备份服务器下，可观察到文件已经被实时同步。</li></ul><h1>docker(两台都是)</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker pull nginx<br>[root@docker01 ~]# mkdir -p  /www  <br>//创建挂载目录<br></code></pre></td></tr></table></figure><p><strong>nfs创建好之后docker上挂载目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]#  mount  -t nfs 192.168.1.30:/database /www<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -itd --name nginx -p 90:80 -v /www/index.html:/usr/share/nginx/html/index.html nginx:latest<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://xgp-cunchu.test.upcdn.net//k8s/image-20191221085649190.png&quot; alt=&quot;image-20191221085649190&quot;&gt;&lt;/p&gt;
&lt;h1&gt;nginx（两台都是）&lt;/h1&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>docker数据持久化</title>
    <link href="https://wsdlxgp.top/posts/f8c7.html"/>
    <id>https://wsdlxgp.top/posts/f8c7.html</id>
    <published>2020-06-06T15:29:15.692Z</published>
    <updated>2020-06-06T15:20:42.720Z</updated>
    
    <content type="html"><![CDATA[<h1><strong>数据持久化</strong></h1><h2 id="Storage-Driver"><strong>Storage Driver</strong></h2><h3 id="数据存储方式"><strong>数据存储方式</strong></h3><p><strong>Centos7版本的docker，Storage Driver（数据存储方式）为：overlay2 ，Backing Filesystem（文件系统类型）: xfs</strong></p><h2 id="Data-Volume"><strong>Data Volume</strong></h2><p><strong>持久化存储：本质上是DockerHost文件系统中的目录或文件，能够直接被Mount到容器的文件系统中。在运行容器时，可通过-v实现。</strong></p><h3 id="特点："><strong>特点：</strong></h3><p><strong>1.</strong>   <strong>Data Volume是目录或文件，不能是没有格式化的磁盘（块设备）。</strong></p><p><strong>2.</strong>   <strong>容器可以读写volume中的数据。</strong></p><p><strong>3.</strong>   <strong>Volume数据可以永久保存，即使使用它的容器已经被销毁。</strong></p><p><strong>4.默认挂载到容器内的文件，容器是有读写权限。可以在运行容器是-v 后边加“:ro”限制容器的写入权限</strong></p><p><strong>5并且还可以挂载单独的文件到容器内部，一般他的使用场景是：如果不想对整个目录进行覆盖，而只希望添加某个文件，就可以使用挂载单个文件。</strong></p><p><strong>6.删除容器的操作，默认不会对dockerhost上的源文件操作，如果想要在删除容器时把源文件也删除，可以在删除容器时添加-v选项（一般不推荐使用这种方式，因为文件有可能被其他容器使用）&quot;Data Volume不支持&quot;</strong></p><p><strong>注意：dockerhost上需要被挂载的源文件或目录，必须是已经存在，否则，会被当作一个目录挂载到容器中。</strong></p><h2 id="Docker-Manager-Volume"><strong>Docker Manager Volume</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -itd --name t1 -P -v /usr/share/nginx/html nginx:latest<br><br>[root@docker01 ~]# docker ps<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191218190043268.png" alt="image-20191218190043268"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker inspect t1<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191218190105103.png" alt="image-20191218190105103"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">[root@docker01_data]#</span><span class="bash"><span class="hljs-built_in">cd</span> /var/lib/docker/volumes/17c50a065a6b10ccd01ca1ce8091fdf6282dc9dcb77a0f6695906257ecc03a63/_data</span><br><br>[root@docker01 _data]# echo "this is a testfile" &gt; index.html<br><br>[root@docker01 _data]# docker ps<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191218190137634.png" alt="image-20191218190137634"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 _data]# curl 127.0.0.1:32777<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191218190201473.png" alt="image-20191218190201473"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 _data]# docker volume ls<br></code></pre></td></tr></table></figure><h2 id="容器与容器的数据共享"><strong>容器与容器的数据共享</strong></h2><p><strong>Volume container：给其他容器提供volume存储卷的容器。并且它可以提供bind mount，也可以提供docker manager volume。</strong></p><p><strong>Volume container：给其他容器提供volume存储卷的容器。并且它可以提供bind mount，也可以提供docker manager volume。</strong></p><p><strong>创建一个vc_data容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker create --name vc_data -v ~/html:/usr/share/nginx/html -v /other/useful/tools busybox<br><br>[root@docker01 ~]# docker inspect vc_data<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219085456488.png" alt="image-20191219085456488"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -itd --name t3 -P --volumes-from vc_data nginx:latest<br><br>[root@docker01 ~]# docker ps<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219085509662.png" alt="image-20191219085509662"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# curl 127.0.0.1:32779<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219085526906.png" alt="image-20191219085526906"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# mkdir htdocs<br>//创建测试目录<br>[root@docker01 ~]# cd htdocs/<br>[root@docker01 htdocs]# echo The version one &gt; index.html<br>[root@docker01 htdocs]# docker run -itd --name web1 -P -v  ~/htdocs:/usr/local/apache2/htdocs httpd:latest <br>[root@docker01 htdocs]# docker ps<br></code></pre></td></tr></table></figure><p>![img](file:///C:\Users\huawei\AppData\Roaming\Tencent\Users\2877364346\QQ\WinTemp\RichOle\26LA}X1ZTD<code>80SPWLY_</code>TNF.png)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 htdocs]# curl 127.0.0.1:32768<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219090346253.png" alt="image-20191219090346253"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 htdocs]# echo The version TWO &gt; index.html <br>[root@docker01 htdocs]# curl 127.0.0.1:32768<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219090432507.png" alt="image-20191219090432507"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 htdocs]# rm -f index.html <br>[root@docker01 htdocs]# curl 127.0.0.1:32768<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219090526949.png" alt="image-20191219090526949"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# mkdir htdocs/<br>//创建一个测试目录<br><br>[root@docker01 htdocs]# vim index.html<br>//创建测试网页<br>&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;<br><br>[root@docker01 ~]# docker create --name vc_data -v ~/html:/usr/share/nginx/html -v /other/useful/tools busybox<br>//创建一个共享容器<br><br>[root@docker01 htdocs]# vim Dockerfile<br>//编写Dockerfile<br>FROM busybox<br>ADD index.html /usr/local/apache2/htdocs/index.html<br>VOLUME /usr/local/apache/htdocs<br><br>[root@docker01 htdocs]# docker build -t databack .<br>//通过当前Dockfile创建一个镜像<br>[root@docker01 htdocs]# docker create --name vc-new databack:latest<br>//通过databack创建一个容器<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 htdocs]# docker inspect vc-new<br>//查看vc-new的详细信息<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219093523695.png" alt="image-20191219093523695"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"> [root@docker01 htdocs]# docker run -itd --name new-web1 -P  --volumes-from vc-new httpd:latest <br>//通过volume卷和httpd运行一个容器<br>[root@docker01 htdocs]# docker ps<br>//查看容器信息<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219093622640.png" alt="image-20191219093622640"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 htdocs]# curl 127.0.0.1:32773<br>//测试访问一下网页<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219093643077.png" alt="image-20191219093643077"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 htdocs]# echo 12345 &gt;index.html <br>//更改网页内容<br>[root@docker01 htdocs]# curl 127.0.0.1:32773<br>//测试访问网页还是原来的内容<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219093714215.png" alt="image-20191219093714215"></p><h2 id="容器的跨主机数据共享">容器的跨主机数据共享</h2><p><strong>实验环境</strong></p><p><strong>docker01            docker02        docker03</strong></p><p><strong>httpd                    httpd               nfs</strong></p><p><strong>要求：docker01和docker02的主目录，是一样的。</strong></p><p>准备工作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# hostnamectl set-hostname nfs<br>[root@localhost ~]# hostnamectl set-hostname docker01<br>[root@localhost ~]# hostnamectl set-hostname docker02<br></code></pre></td></tr></table></figure><p>nfs操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# yum -y install nfs-utils<br>//下载nfs服务<br><br>[root@nfs ~]# mkdir /datashare<br>//创建共享目录<br><br>[root@nfs ~]# vim /etc/exports<br>//设置权限如下<br>/datashare *(rw,sync,no_root_squash)<br></code></pre></td></tr></table></figure><p>开启各项服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs ~]# systemctl start rpcbind<br>[root@nfs ~]# systemctl enable rpcbind<br>[root@nfs ~]# systemctl start nfs-server<br>[root@nfs ~]# systemctl enable nfs-server<br></code></pre></td></tr></table></figure><p>docker01和docker02测试nfs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 htdocs]# showmount -e 192.168.1.20<br>[root@docker02 htdocs]# showmount -e 192.168.1.20<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219095843491.png" alt="image-20191219095843491"><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219095904920.png" alt="image-20191219095904920"></p><p>docker01的操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# mkdir /xxx<br>[root@docker01 ~]# mount  -t nfs 192.168.1.10:/datashare /xxx<br>//挂载nfs上的共享目录<br>[root@docker01 ~]# mount | tail -1<br>//查看是否挂载<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219100246559.png" alt="image-20191219100246559"></p><p>nfs创建测试文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs ~]# cd datashare/<br>[root@nfs datashare]# vim index.html<br>&lt;div id="datetime"&gt;<br>    &lt;script&gt;<br>        setInterval("document.getElementById('datetime').innerHTML=new Date().toLocaleString();", 1000);<br>    &lt;/script&gt;<br>&lt;/div&gt;<br>xgp666<br></code></pre></td></tr></table></figure><p>docker01查看一下</p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219102514366.png" alt="image-20191219102514366"></p><p><strong>docker02的操作与docker01上一样</strong><br>这里先不考虑将代码写入镜像，先以这种方式，分别在docker01和docker02部署httpd服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -itd --name bdqn-web1 -P -v /xxx/:/usr/local/apache2/htdocs httpd:latest <br>[root@docker02 ~]# docker run -itd --name bdqn-web2 -P -v /xxx/:/usr/local/apache2/htdocs httpd:latest<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker ps <br>//查看端口<br>0.0.0.0:32775-&gt;80/tcp   bdqn-web<br>[root@docker02 ~]# docker ps<br>//查看端口<br>0.0.0.0:32769-&gt;80/tcp   bdqn-web2<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219103304742.png" alt="image-20191219103304742"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219103355640.png" alt="image-20191219103355640"></p><p><strong>此时，用浏览器访问,两个WEB服务的主界面是一样。但如果，NFS服务器上的源文件丢失,</strong><br><strong>则两个web服务都会异常。</strong></p><p><strong>想办法将元数据写入镜像内，在基于镜像创建一个vc_data容器，这里因为没有接触到docker-compose和docker-swarm等docker编排工具，所以需手动创建镜像！</strong></p><p>nfs操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs datashare]# echo xgp666 &gt; index.html <br>//更改测试文件<br></code></pre></td></tr></table></figure><p>docker02操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# cd /xxx/<br>[root@docker02 xxx]# vim Dockerfile<br>//编写Dockerfile<br>[root@docker02 xxx]# cat Dockerfile <br>FROM busybox<br>ADD index.html /usr/local/apache2/htdocs/index.html<br>VOLUME /usr/local/apache2/htdocs<br></code></pre></td></tr></table></figure><p>创建镜像并运行一个容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 xxx]# docker build -t back_data .<br>//基于Dockerfile创建镜像<br>[root@docker02 xxx]# docker create --name back_container1  back_data:latest <br>//基于刚刚创建的镜像创建容器<br></code></pre></td></tr></table></figure><p>运行容器，并导出镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 xxx]# docker run -itd --name bdqn-web3 -P  --volumes-from  back_container1 httpd:latest <br>//运行一台容器<br>[root@docker02 xxx]# docker save &gt; back_data.tar back_data:latest<br>//导出镜像，因为是在共享目录所以docker01也可以看到<br></code></pre></td></tr></table></figure><p>docker01</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 xxx]# docker load -i back_data.tar <br>//去共享目录，导入镜像<br>[root@docker01 xxx]# docker  create --name back_container2  back_data:latest<br>//基于刚刚创建的镜像运行容器<br>[root@docker01 xxx]# docker run  -itd --name bdqn-web4 -P  --volumes-from  back_container2 httpd:latest<br>//运行一台容器<br></code></pre></td></tr></table></figure><p>浏览器访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker ps <br>//查看端口<br> 0.0.0.0:32776-&gt;80/tcp   bdqn-web4<br>[root@docker02 ~]# docker ps<br>//查看端口<br>0.0.0.0:32770-&gt;80/tcp   bdqn-web3<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219105726940.png" alt="image-20191219105726940"></p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191219105748539.png" alt="image-20191219105748539">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;strong&gt;数据持久化&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&quot;Storage-Driver&quot;&gt;&lt;strong&gt;Storage Driver&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&quot;数据存储方式&quot;&gt;&lt;strong&gt;数据存储方式&lt;/strong&gt;&lt;/h3&gt;
&lt;p
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Docker实现服务发现</title>
    <link href="https://wsdlxgp.top/posts/b5a0.html"/>
    <id>https://wsdlxgp.top/posts/b5a0.html</id>
    <published>2020-06-06T15:29:15.690Z</published>
    <updated>2020-06-06T15:22:48.823Z</updated>
    
    <content type="html"><![CDATA[<p>更改时间</p><p>mv /etc/localtime/etc/localtime. bk<br>cp /usr/share/zoneinfo/Asia/Shanghai/etc/localtime</p><p>查看端口</p><p>[root@docker01 consul]# ss -lnt</p><p><strong>Consul:分布式、高可用的，服务发现和配置服务的工具。数据中心</strong><br><strong>Rigistrator:负责收集dockerhost_上,容器服务的信息，并且发送给consul</strong></p><p><strong>Consul-tpmplate:根据编辑好的模板，生产新的nginx配置文件，并负责重新加载nginx配置文件</strong></p><h1><strong>Docker + Consul + registrator实现服务发现</strong></h1><h2 id="1-实验环境">1.实验环境</h2><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226120640567.png" alt="image-20191226120640567"></p><blockquote><p><strong>上面示意图的大概流程如下：</strong><br>1、docker01主机上以二进制包的方式部署consul服务并后台运行，其身份为leader；<br>2、docker02、docker03以容器的方式运行consul服务，并加入到docker01的consul群集中；<br>3、在主机docker02、docker03上后台运行registrator容器，使其自动发现docker容器提供的服务；<br>4、在docker01上部署Nginx，提供反向代理服务，docker02、docker03主机上基于Nginx镜像，各运行两个web容器，提供不同的网页文件，以便测试效果；<br>5、在docker01上安装consul-template命令，将收集到的信息（registrator收集到容器的信息）写入template模板中，并且最终写入Nginx的配置文件中。<br>6、至此，实现客户端通过访问Nginx反向代理服务器（docker01），获得docker02、docker03服务器上运行的Nginx容器提供的网页文件。<br>注：registrator是一个自动发现docker container提供的服务，并且在后端服务注册中心（数据中心）注册服务。主要用来收集容器运行服务的信息，并且发送给consul。数据中心除了consul外，还有etcd、zookeeper等。</p></blockquote><table><thead><tr><th>主机</th><th>iP地址</th><th>服务</th></tr></thead><tbody><tr><td>docker01</td><td>192.168.1.11</td><td>consul+consul-template+nginx</td></tr><tr><td>docker02</td><td>192.168.1.13</td><td>consul+registrator</td></tr><tr><td>docker03</td><td>192.168.1.20</td><td>consul+registrator</td></tr></tbody></table><p><em><strong>三台主机关闭防火墙，禁用selinux，更改主机名如上所述。</strong></em></p><h3 id="（1）docker01去官网https-www-consul-io-downloads-html下载consul服务"><strong>（1）docker01去官网https://www.consul.io/downloads.html下载consul服务</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# unzip consul_1.5.1_linux_amd64.zip <br>//现在是本地导入压缩包，需要解压              <br>[root@docker01 ~]# mv consul /usr/local/bin/<br>//移动服务到bin目录<br>[root@docker01 ~]# chmod +x /usr/local/bin/consul<br>//给予一个可执行权限<br></code></pre></td></tr></table></figure><h3 id="（2）启动consul"><strong>（2）启动consul</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# consul agent -server -bootstrap -ui -data-dir=/var/lib/consul-data -bind=192.168.1.11 -client=0.0.0.0 -node=master<br></code></pre></td></tr></table></figure><p><strong>PS: //-bootstrap: 加入这个选项时，一般都在server单节点的时候用，自选举为leader。</strong></p><blockquote><p><strong>参数解释：</strong><br><strong>-server：添加一个服务</strong><br><strong>-bootstrap：一般在server单节点的时候使用，自选举为leader。</strong><br><strong>-data-dir：key/volume指定数据存放的目录</strong><br><strong>-ui：开启内部的web界面</strong><br><strong>-bind：指定开启服务的ip</strong><br><strong>-client：指定访问的客户端</strong><br><strong>-node：在集群内部通信使用的名称，默认是主机名。</strong></p></blockquote><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226093552465.png" alt="image-20191226093552465"></p><p><em><strong>现在这个ip是外部使用</strong></em></p><blockquote><p><strong>PS:开启的端口</strong><br>8300     集群节点<br>8301     集群内部的访问<br>8302     跨数据中心的通信<br>8500     web ui界面<br>8600     使用dns协议查看节点信息的端口</p></blockquote><p><em><strong>这时，这条命令会占用终端，可以使用nohup命令让它保持后台运行。</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# nohup consul agent -server -bootstrap -ui -data-dir=/var/lib/consule-data -bind=192.168.1.11  -client=0.0.0.0 -node=master &amp;<br></code></pre></td></tr></table></figure><h3 id="（3）查看consul端口的信息">（3）查看consul端口的信息**</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# consul info<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226093818580.png" alt="image-20191226093818580"></p><h3 id="（4）查看consul集群成员的信息"><strong>（4）查看consul集群成员的信息</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# consul members<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226094012082.png" alt="image-20191226094012082"></p><p><em><strong>现在这个ip是内部使用</strong></em></p><h2 id="2-docker02，docker03，加入consul集群">2. docker02，docker03，加入consul集群</h2><blockquote><p><strong>这里我们采用容器的方式去运行consul服务。</strong></p></blockquote><h3 id="（1）下载consu所需的l镜像"><strong>（1）下载consu所需的l镜像</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker pull consul<br></code></pre></td></tr></table></figure><h3 id="（2）基于consul镜像开启一台容器">（2）基于consul镜像开启一台容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker run -d --name consul -p 8301:8301 -p 8301:8301/udp -p 8500:8500 -p 8600:8600 -p 8600:8600/udp --restart always progrium/consul -join 192.168.1.11 -advertise 192.168.1.13 -client 0.0.0.0 -node=node01<br></code></pre></td></tr></table></figure><blockquote><p><strong>参数解释：</strong></p><p>-d：守护进程</p><p>–name：容器名称</p><p>–restart：容器随着docker服务一直运行</p><p>-advertise:声明本机地址</p><p>-join:声明服务端地址</p><p>-node:consul集群中的名称</p></blockquote><h3 id="（3）docker查看consul集群成员的信息">（3）docker查看consul集群成员的信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# consul members<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226121636780.png" alt="image-20191226121636780"></p><h3 id="（4）两台docker开启容器后，docker01查看">（4）两台docker开启容器后，docker01查看</h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226095528177.png" alt="image-20191226095528177"></p><h3 id="（5）浏览器访问http-192-168-1-11-8500">（5）浏览器访问http://192.168.1.11:8500</h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226095736827.png" alt="image-20191226095736827"></p><h2 id="3-docker01下载部署consul-template">3. docker01下载部署consul-template</h2><p>在<a href>https://github.com/hashicorp/consul-template</a>上，下载consul-template</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# unzip consul-template_0.19.5_linux_amd64.zip<br>//解压安装好的consul-template包<br>[root@docker01 ~]# mv consul-template /usr/local/bin/<br>//移动到命令目录<br>[root@docker01 ~]# chmod +x /usr/local/bin/consul-template <br>//给予一个可执行权限<br>​```shell <br><br><br><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 4. docker02、docker03_ 上部署registrator服务</span></span><br><br><span class="hljs-meta">&gt;</span><span class="bash"> **registrator是一个能自动发现docker container提供的服务,并在后端服务注册中心注册服务或取消服务的工具，后端注册中心支持conusl、etcd、 skydns2、zookeeper等。**</span><br><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## （1）下载registrator镜像</span></span><br><br>​```shell <br>[root@docker02 ~]# docker pull registrator<br>//下载registrator镜像<br></code></pre></td></tr></table></figure><h3 id="（2）基于registrator镜像，开启一台容器">（2）基于registrator镜像，开启一台容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker run -d  --name registrator -v /var/run/docker.sock:/tmp/docker.sock  --restart always gliderlabs/registrator consul://192.168.1.13:8500<br></code></pre></td></tr></table></figure><h3 id="（3）开启一台nginx容器">（3）开启一台nginx容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker run -d —P --name nginx nginx:latest<br></code></pre></td></tr></table></figure><h3 id="（4）浏览器查看一下http-192-168-1-11-8500-ui-dc1-nodes">（4）浏览器查看一下http://192.168.1.11:8500/ui/dc1/nodes</h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226105329200.png" alt="image-20191226105329200"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226122052852.png" alt="image-20191226122052852"></p><h2 id="5-docker01部署一个nginx服务">5.docker01部署一个nginx服务</h2><h3 id="（1）安装开启nginx服务">（1）安装开启nginx服务</h3><p>安装nginx依赖包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]#  yum -y install pcre pcre-devel openssl openssl-devel zlib zlib-devel<br></code></pre></td></tr></table></figure><p>编译安装nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# cd nginx-1.14.0/<br>[root@docker01 nginx-1.14.0]# ./configure --user=nginx --group=nginx  --with-http_stub_status_module --with-http_realip_module --with-pcre --with-http_ssl_module &amp;&amp; make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>创建所需用户和链接命令目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 nginx-1.14.0]# useradd -M -s /sbin/nologin nginx<br>[root@docker01 nginx-1.14.0]# ln -s /usr/local/nginx/sbin/* /usr/local/bin/<br></code></pre></td></tr></table></figure><p>检查nginx是否有问题，并开启nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 nginx-1.14.0]# nginx -t<br>nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok<br>nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful<br>[root@docker01 nginx-1.14.0]# nginx<br></code></pre></td></tr></table></figure><p><em><strong>PS:这里nginx作为反向代理，代理后端docker02、 docker03 上nginx的容器服务,所以我们先去docker02、docker03. 上部署一些服务， 为了方便等会看到负载的效果，所以，我们运行完成容器之后，做一个主界面内容的区分。</strong></em></p><h3 id="（2）安装完成之后，本机测试访问">（2）安装完成之后，本机测试访问</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 nginx-1.14.0]# curl 127.0.0.1<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226105739604.png" alt="image-20191226105739604"></p><h3 id="（3）docker02和docker03部署环境">（3）docker02和docker03部署环境</h3><table><thead><tr><th>主机</th><th>服务</th><th></th></tr></thead><tbody><tr><td>docker02</td><td>nginx</td><td>web01，web02</td></tr><tr><td>docker03</td><td>nginx</td><td>web03，web04</td></tr></tbody></table><h4 id="1-下载nginx镜像（docker02，docker03都要）"><strong>&lt;1&gt;下载nginx镜像（docker02，docker03都要）</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker pull nginx<br>//下载nginx镜像<br></code></pre></td></tr></table></figure><h4 id="2-docker01操作">&lt;2&gt;docker01操作</h4><p><em><strong>基于nginx镜像运行上述所说的容器并设置测试页面</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">web01<br>[root@docker02 ~]# docker run  -itd --name web01 -P nginx:latest<br>[root@docker02 ~]# docker exec -it web01 /bin/bash<br>root@44b59d07202f:/# cd /usr/share/nginx/html/<br>root@44b59d07202f:/usr/share/nginx/html# echo web01 &gt; index.html<br><br>web02<br>[root@docker02 ~]# docker run  -itd --name web02 -P nginx:latest<br>[root@docker02 ~]# docker exec -it web02 /bin/bash<br>root@44b59d07202f:/# cd /usr/share/nginx/html/<br>root@44b59d07202f:/usr/share/nginx/html# echo web02 &gt; index.html<br></code></pre></td></tr></table></figure><h4 id="3-docker02操作">&lt;3&gt;docker02操作</h4><p><em><strong>基于nginx镜像运行上述所说的容器并设置测试页面</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">web03<br>[root@docker03 ~]#  docker run  -itd --name web03 -P nginx:latest<br>[root@docker03 ~]#  docker exec -it web03 /bin/bash<br>root@fd8e8b2df136:/# cd /usr/share/nginx/html/<br>root@fd8e8b2df136:/usr/share/nginx/html#  echo web03 &gt; index.html<br>root@fd8e8b2df136:/usr/share/nginx/html# exit<br>true<br>web04<br>[root@docker03 ~]#  docker run  -itd --name web04 -P nginx:latest<br>[root@docker03 ~]#  docker exec -it web04 /bin/bash<br>root@fd8e8b2df136:/# cd /usr/share/nginx/html/<br>root@fd8e8b2df136:/usr/share/nginx/html#  echo web04 &gt; index.html<br>root@fd8e8b2df136:/usr/share/nginx/html# exit<br></code></pre></td></tr></table></figure><h3 id="（4）docker01更改nginx配置文件">（4）docker01更改nginx配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# cd /usr/local/nginx/<br>//进入nginx配置文件目录<br>[root@docker01 nginx]# mkdir consul<br>//创建consul目录<br>[root@docker01 nginx]# cd consul/<br>//进入consul目录<br></code></pre></td></tr></table></figure><h4 id="1-创建nginx-ctmpl模板">&lt;1&gt;创建nginx.ctmpl模板</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# vim nginx.ctmpl<br>upstream http_backend &#123;<br>        &#123;&#123;range service "nginx"&#125;&#125;<br>        server &#123;&#123; .Address &#125;&#125;:&#123;&#123; .Port &#125;&#125;;<br>        &#123;&#123; end &#125;&#125;<br>&#125;<br><br>server &#123;<br>        listen 8000;<br>        server_name localhost;<br>        location / &#123;<br>                proxy_pass http://http_backend;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-修改nginx配置文件，通过-include-参数包含刚刚创建的文件">&lt;2&gt;修改nginx配置文件，通过 include 参数包含刚刚创建的文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# cd /usr/local/nginx/conf/<br>[root@docker01 conf]# vim nginx.conf<br>  include /usr/local/nginx/consul/*.conf;  #文件最后添加（要在大括号里面）<br></code></pre></td></tr></table></figure><h4 id="3-生成一个vhost-conf配置文件，并重启nginx（会占用终端">&lt;3&gt; 生成一个vhost.conf配置文件，并重启nginx（会占用终端)</h4><p>使用consul-template命令，根据模板生产新的配置文件，并重新加载nginx的配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 conf]# consul-template -consul-addr 192.168.1.11:8500 -template "/usr/local/nginx/consul/nginx.ctmpl:/usr/local/nginx/consul/vhost.conf:/usr/local/bin/nginx -s reload"<br></code></pre></td></tr></table></figure><p><em><strong>这时，这条命令会占用终端，可以使用nohup命令让它保持后台运行,并重启nginx服务。</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 conf]# nohup consul-template -consul-addr 192.168.1.11:8500 -template   "/usr/local/nginx/consul/nginx.ctmpl:/usr/local/nginx/consul/vhost.conf:/usr/local/sbin/nginx -s reload"  &amp;<br></code></pre></td></tr></table></figure><p>查看一下文件是否生成，里面是否有内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# cd /usr/local/nginx/consul/<br>[root@docker01 consul]# ls<br>nginx.ctmpl  vhost.conf<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226113614544.png" alt="image-20191226113614544"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# cat vhost.conf<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226113633731.png" alt="image-20191226113633731"></p><p><strong>此时，应该能够看到，新生产的vhost.conf配置文件已经生效，访问本机8000端口可以得到不同容器提供的服务。</strong></p><h4 id="4-测试访问">&lt;4&gt;测试访问</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# curl 127.0.0.1:8000<br>web01<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226115250121.png" alt="image-20191226115250121"></p><p><strong>此时可以看到负载均衡的效果！</strong></p><h4 id="5-如果访问不成功">&lt;5&gt;如果访问不成功</h4><p>查看端口8000是否开启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# ss -lnt<br></code></pre></td></tr></table></figure><p>检查nginx配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# nginx -t<br>nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok<br>nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful<br></code></pre></td></tr></table></figure><p>检查自己编写的nginx配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# cd /usr/local/nginx/consul/<br>[root@docker01 consul]# cat nginx.ctmpl <br>upstream http_backend &#123;<br>true&#123;&#123;range service "nginx"&#125;&#125;<br>trueserver &#123;&#123; .Address &#125;&#125;:&#123;&#123; .Port &#125;&#125;;<br>true&#123;&#123; end &#125;&#125;<br>&#125;<br><br>server &#123;<br>truelisten 8000;<br>trueserver_name localhost;<br>truelocation / &#123;<br>truetrueproxy_pass http://http_backend;<br>true&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果nginx配置文件没问题，重启nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# nginx -s reload<br></code></pre></td></tr></table></figure><h4 id="6-测试自动发现">&lt;6&gt;测试自动发现</h4><p><strong>docker02 创建测试容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker run  -itd --name web05 -P nginx:latest<br>[root@docker02 ~]# docker exec -it web05 /bin/bash<br>root@44b59d07202f:/# cd /usr/share/nginx/html/<br>root@44b59d07202f:/usr/share/nginx/html# echo web02 &gt; index.html<br>[root@docker02 ~]# docker ps<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226115332704.png" alt="image-20191226115332704"></p><p><strong>docker01查看</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# cd /usr/local/nginx/consul/<br>[root@docker01 consul]# cat vhost.conf<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226115444855.png" alt="image-20191226115444855"></p><p><strong>docker01测试访问</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# curl 127.0.0.1:8000<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226115752718.png" alt="image-20191226115752718"></p><p><strong>//同上</strong></p><p><strong>此时可以看到负载均衡的效果！</strong></p><p><strong>这时不需要考虑后端的web服务器添加还是删除都会自动更新的，这是因为在运行consul-template这条命令后添加的/usr/local/sbin/nginx -s reload的作用！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;更改时间&lt;/p&gt;
&lt;p&gt;mv /etc/localtime/etc/localtime. bk&lt;br&gt;
cp /usr/share/zoneinfo/Asia/Shanghai/etc/localtime&lt;/p&gt;
&lt;p&gt;查看端口&lt;/p&gt;
&lt;p&gt;[root@docker01 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Docker的监控</title>
    <link href="https://wsdlxgp.top/posts/bdbf.html"/>
    <id>https://wsdlxgp.top/posts/bdbf.html</id>
    <published>2020-06-06T15:29:15.688Z</published>
    <updated>2020-06-06T15:23:13.739Z</updated>
    
    <content type="html"><![CDATA[<h1><strong>Docker的监控</strong></h1><h2 id="Docker自带的监控命令">Docker自带的监控命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker ps<br>//查看容器信息<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223110050156.png" alt="image-20191223110050156"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker top 容器名称<br>[root@docker01 ~]# docker top wordpress_wordpress_1 <br>//查看容器中运行的进程信息，支持 ps 命令参数。<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker stats wordpress_wordpress_1 <br>//实时查看容器统计信息，查看容器的CPU利用率、内存的使用量以及可用内存总量。<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker logs 容器名称<br>[root@docker01 ~]# docker logs wordpress_wordpress_1 <br>//查看容器的日志<br></code></pre></td></tr></table></figure><h1><strong>用 Sysdig 监控服务器和 Docker 容器</strong></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker pull sysdig<br>//下载sysdig镜像<br></code></pre></td></tr></table></figure><h3 id="通过sysdig运行容器">通过sysdig运行容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -it --rm --name sysdig --privileged=true --volume=/var/run/docker.sock:/host/var/run/docker.sock  --volume=/dev:/host/dev --volume=/proc:/host/proc:ro  --volume=/boot:/host/boot:ro  --volume=/lib/modules:/host/lib/modules:ro --volume=/usr:/host/usr:ro  sysdig/sysdig<br></code></pre></td></tr></table></figure><h3 id="下载插件失败后可以运行下边命令，重新下载">下载插件失败后可以运行下边命令，重新下载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@10ccab83a512:/# system-sysdig-loader<br>//下载插件失败后可以运行下边命令，重新下载<br></code></pre></td></tr></table></figure><h3 id="下载成功后，可以运行sysdig命令，查看监控项">下载成功后，可以运行sysdig命令，查看监控项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@10ccab83a512:/# sysdig<br>//运行sysdig命令，查看监控项，它会动态查看<br></code></pre></td></tr></table></figure><h3 id="使用-csysdig"><strong>使用 csysdig</strong></h3><p>csysdig 就是运 ncurses 库的用户界面的 sysdig 软件包，Ncurses 是一个能提供功能键定义 ( 快捷键 ), 屏幕绘制以及基于文本终端的图形互动功能的动态库。在 sysdig 软件包里还提供了一个工具 csysdig，该工具执行后，运行界面和 top 命令类似。csysdig 工作界面如图 5。</p><p><img src="https://www.ibm.com/developerworks/cn/linux/1607_caoyq_sysdig/image005.jpg" alt="csysdig 工作界面"></p><h4 id="运行csysdig命令，查看监控项">运行csysdig命令，查看监控项</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@10ccab83a512:/# csysdig<br>//运行csysdig命令，图形化界面查看监控项，它会动态查看<br></code></pre></td></tr></table></figure><h4 id="csysdig-使用如下快捷键：">csysdig 使用如下快捷键：</h4><p><strong>P：暂停屏幕输出信息</strong></p><p><strong>Enter：进入当前突出显示的条目。</strong></p><p><strong>Ctrl+F：列表搜索。</strong></p><p><strong>F1- 帮助信息</strong></p><p><strong>F2- 显示视图选择器。这将让你切换到另一个视图。</strong></p><p><strong>F4- 使用过滤器</strong></p><p><strong>F5- 查看 IO 输出信息</strong></p><p><strong>F7 显示帮助页面当前显示的视图。</strong></p><p><strong>F8 打开视图的操作面板。</strong></p><p><strong>F9，打开列排序面板。</strong></p><p><strong>Q 放弃退出。</strong></p><p><strong>Arrows, PgUP, PgDn, Home, End：图标上下左右的移动控制。</strong></p><h1>Docker监控方案之Weave Scope</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker pull scope<br>//下载scope镜像<br></code></pre></td></tr></table></figure><h3 id="执行如下脚本安装运行Weave-Scope"><strong>执行如下脚本安装运行Weave Scope</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# curl -L git.io/scope -o /usr/local/bin/scope<br>[root@docker01 ~]# chmod +x /usr/local/bin/scope<br>[root@docker01 ~]# scope launch<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223115631976.png" alt="image-20191223115631976"></p><h3 id="浏览器访问http-192-168-1-11-4040"><strong>浏览器访问http://192.168.1.11:4040/</strong></h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223115825581.png" alt="image-20191223115825581"></p><p><strong>然后就可以更好的监控，管理docker中的容器了</strong></p><h3 id="开启第docker02，加入docker01监控项"><strong>开启第docker02，加入docker01监控项</strong></h3><p><strong>docker01</strong></p><p><strong>删除weavescope容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker stop weavescope <br>weavescope<br>[root@docker01 ~]# docker rm weavescope <br>weavescope<br></code></pre></td></tr></table></figure><p><strong>docker02</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker pull scope<br>//下载scope镜像<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# curl -L git.io/scope -o /usr/local/bin/scope<br>[root@docker01 ~]# chmod +x /usr/local/bin/scope<br>[root@docker01 ~]# scope launch<br></code></pre></td></tr></table></figure><p><strong>docker01</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# scope launch 192.168.1.11 192.168.1.13<br></code></pre></td></tr></table></figure><p><strong>docker02</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# scope launch 192.168.1.13 192.168.1.11<br></code></pre></td></tr></table></figure><h3 id="浏览器访问http-192-168-1-11-4040-2"><strong>浏览器访问http://192.168.1.11:4040/</strong></h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223121541560.png" alt="image-20191223121541560"></p><p><strong>浏览器访问http://192.168.1.13:4040/也是可以的</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223121621404.png" alt="image-20191223121621404"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;strong&gt;Docker的监控&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&quot;Docker自带的监控命令&quot;&gt;Docker自带的监控命令&lt;/h2&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>docker部署LNMP环境</title>
    <link href="https://wsdlxgp.top/posts/32f5.html"/>
    <id>https://wsdlxgp.top/posts/32f5.html</id>
    <published>2020-06-06T15:29:15.686Z</published>
    <updated>2020-06-06T15:23:51.238Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"> ifdown ens33;ifup ens33<br>//重启网卡<br></code></pre></td></tr></table></figure><p><strong>首先要有确认环境中有需要的tar包，可以使用<a href>docker pull</a>来下载这些镜像</strong></p><p><img src="/posts/E:%5C%E8%BD%AF%E4%BB%B6%5Ctypora%5C%E6%96%87%E6%A1%A3%5CUntitled.assets%5Cimage-20191220084542746.png" alt="image-20191220084542746"></p><p><strong>现在我们是使用已经下载好的镜像，所以需要导入一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker load -i nginx.tar  &amp;&amp; docker load -i wordpress.tar  &amp;&amp; docker load -i mysql-5.7.tar &amp;&amp; docker load -i php.7.2-fpm.tar<br>//导入nginx,wordpress,mysql,php镜像<br></code></pre></td></tr></table></figure><h1>部署LNMP</h1><p><a href><strong>172.16.10.0/24</strong></a></p><p><a href><strong>Nginx：172.16.10.10</strong></a></p><p><a href><strong>Mysql：172.16.10.20</strong></a></p><p><a href><strong>Php    ：172.16.10.30</strong></a></p><p><em><strong>网站的访问主目录：/wwwroot</strong></em></p><p><em><strong>Nginx的配置文件：/docker</strong></em></p><p><em><strong>/etc/nginx/conf.d   #nginx配置文件</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -itd --name test nginx:latest <br>//先启动一台nginx，用来拷贝配置文件和访问主目录<br>[root@docker01 ~]# mkdir  -p /wwwroot /docker<br>//创建挂载目录<br>[root@docker01 ~]# docker cp test:/etc/nginx /docker/<br>//拷贝配置文件到挂载目录<br>[root@docker01 ~]# ls /docker/<br>nginx<br></code></pre></td></tr></table></figure><p><em><strong>/usr/share/nginx/html  #nginx主目录</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker cp test:/usr/share/nginx/html /wwwroot/<br>//拷贝访问目录到挂载目录<br>[root@docker01 ~]# ls /wwwroot/<br>html<br></code></pre></td></tr></table></figure><h2 id="1）创建一个自定义网络">1）创建一个自定义网络</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker network create -d bridge --subnet 172.16.10.0/24 --gateway 172.16.10.1 lnmp<br></code></pre></td></tr></table></figure><h2 id="2-运行nginx容器">2)运行nginx容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# netstat -anpt | grep 80<br>//查看80端口是否被占用<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -itd --name nginx -v /docker/nginx:/etc/nginx -v /wwwroot/html:/usr/share/nginx/html   -p 80:80 --network lnmp --ip 172.16.10.10 nginx<br>//运行一台nginx服务，并指明ip，映射端口，挂载目录<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker ps<br>//查看容器是否存在<br></code></pre></td></tr></table></figure><p><img src="/posts/E:%5C%E8%BD%AF%E4%BB%B6%5Ctypora%5C%E6%96%87%E6%A1%A3%5CUntitled.assets%5Cimage-20191220091933217.png" alt="image-20191220091933217"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# cd /wwwroot/html<br>[root@docker01 wwwroot]# vim index.html<br>hello lnmp!<br>//创建测试网页<br><br>[root@docker01 wwwroot]# curl 127.0.0.1<br>hello lnmp!<br>//测试访问<br></code></pre></td></tr></table></figure><h2 id="3-运行mysql容器">3)运行mysql容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 html]# docker run --name mysql -e MYSQL_ROOT_PASSWORD=123.com -d -p 3306:3306 --network lnmp --ip 172.16.10.20 mysql:5.7<br>//运行一台nginx服务，并指明ip，映射端口<br></code></pre></td></tr></table></figure><p><em><strong>-e：设置环境变量</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker ps<br></code></pre></td></tr></table></figure><p><img src="/posts/E:%5C%E8%BD%AF%E4%BB%B6%5Ctypora%5C%E6%96%87%E6%A1%A3%5Cdocker%E9%83%A8%E7%BD%B2LNMP%E7%8E%AF%E5%A2%83.assets%5Cimage-20191220120001710.png" alt="image-20191220120001710"></p><p><strong>安装mysql，并设置密码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 html]# yum -y install mysql<br>//安装mysql<br>[root@docker01 ~]# mysql -u root -p123.com -h 127.0.0.1 -P 3306<br></code></pre></td></tr></table></figure><p><strong>随便新建一个库做验证：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">MySQL [(none)]&gt; create database name;<br></code></pre></td></tr></table></figure><p><strong>再查看有没有刚创建的库：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">MySQL [(none)]&gt; show databases;<br></code></pre></td></tr></table></figure><p><img src="/posts/E:%5C%E8%BD%AF%E4%BB%B6%5Ctypora%5C%E6%96%87%E6%A1%A3%5Cdocker%E9%83%A8%E7%BD%B2LNMP%E7%8E%AF%E5%A2%83.assets%5Cimage-20191220140326212.png" alt="image-20191220140326212"></p><h2 id="4-运行php容器，并创建php页面">4)运行php容器，并创建php页面</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 html]# docker run -itd --name phpfpm -p 9000:9000 -v /wwwroot/html:/usr/share/nginx/html --network lnmp --ip 172.16.10.30 php:7.2-fpm<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# cd /wwwroot/html<br>[root@docker01 wwwroot]# vim test.php<br>&lt;?php<br>phpinfo();<br>?&gt;<br>//添加php测试界面<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker ps<br></code></pre></td></tr></table></figure><p><img src="/posts/E:%5C%E8%BD%AF%E4%BB%B6%5Ctypora%5C%E6%96%87%E6%A1%A3%5Cdocker%E9%83%A8%E7%BD%B2LNMP%E7%8E%AF%E5%A2%83.assets%5Cimage-20191220120518271.png" alt="image-20191220120518271"></p><h2 id="5-修改nginx配置文件，nginx和php连接">5)修改nginx配置文件，nginx和php连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 html]# cd /docker/nginx/conf.d/<br>[root@docker01 conf.d]# vim default.conf<br></code></pre></td></tr></table></figure><pre><code>location / {    root   /usr/share/nginx/html;    index  index.html index.htm index.php; #10添加index.php}</code></pre><p><img src="/posts/E:%5C%E8%BD%AF%E4%BB%B6%5Ctypora%5C%E6%96%87%E6%A1%A3%5Cdocker%E9%83%A8%E7%BD%B2LNMP%E7%8E%AF%E5%A2%83.assets%5Cimage-20191220094715896.png" alt="image-20191220094715896"></p><pre><code>location ~ \.php$ {             root    /usr/share/nginx/html;            fastcgi_pass   172.16.10.30:9000;    fastcgi_index  index.php;    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;        include        fastcgi_params;    }</code></pre><p><img src="/posts/E:%5C%E8%BD%AF%E4%BB%B6%5Ctypora%5C%E6%96%87%E6%A1%A3%5Cdocker%E9%83%A8%E7%BD%B2LNMP%E7%8E%AF%E5%A2%83.assets%5Cimage-20191220095010644.png" alt="image-20191220095010644"></p><p><strong>设置完毕后重启nginx</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 conf.d]# docker restart nginx<br>//重启nginx<br>[root@docker01 conf.d]# docker ps<br></code></pre></td></tr></table></figure><p><img src="/posts/E:%5C%E8%BD%AF%E4%BB%B6%5Ctypora%5C%E6%96%87%E6%A1%A3%5Cdocker%E9%83%A8%E7%BD%B2LNMP%E7%8E%AF%E5%A2%83.assets%5Cimage-20191220140527498.png" alt="image-20191220140527498"></p><p><strong>浏览器测试访问nginx和php</strong></p><p><img src="/posts/E:%5C%E8%BD%AF%E4%BB%B6%5Ctypora%5C%E6%96%87%E6%A1%A3%5Cdocker%E9%83%A8%E7%BD%B2LNMP%E7%8E%AF%E5%A2%83.assets%5CWC%7D%7B4@W%5DSXSI8PHBJM%7BM4S.png" alt="img"></p><p><img src="/posts/E:%5C%E8%BD%AF%E4%BB%B6%5Ctypora%5C%E6%96%87%E6%A1%A3%5Cdocker%E9%83%A8%E7%BD%B2LNMP%E7%8E%AF%E5%A2%83.assets%5Cimage-20191220101602664.png" alt="image-20191220101602664"></p><p><strong>说明是nginx和php的连接，没有问题，接下来是php和MySQL的连接。这里我们使用一个phpmyadmin的数据库管理工具</strong></p><h2 id="6-修改nginx配置文件，php和mysql连接">6)修改nginx配置文件，php和mysql连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 html]# cd /wwwroot/html<br></code></pre></td></tr></table></figure><p><strong>上传phpMyAdmin包如果没有请在https://github.com/phpmyadmin/phpmyadmin/releases下载</strong></p><p><img src="/posts/E:%5C%E8%BD%AF%E4%BB%B6%5Ctypora%5C%E6%96%87%E6%A1%A3%5Cdocker%E9%83%A8%E7%BD%B2LNMP%E7%8E%AF%E5%A2%83.assets%5Cimage-20191220113901886.png" alt="image-20191220113901886"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 html]# unzip phpMyAdmin-4.9.1-all-languages.zip <br>//解压phpmyadmin包<br>[root@docker01 html]# mv phpMyAdmin-4.9.1-all-languages phpmyadmin<br>//更改刚刚解压文件的名称<br>[root@docker01 html]#  cd  /docker/nginx/conf.d/<br>[root@docker01 conf.d]#  vim default.conf <br>//修改nginx配置文件<br>[root@docker01 conf.d]#  docker restart nginx <br>//重启nginx<br></code></pre></td></tr></table></figure><pre><code>        location /phpmyadmin {                root   /usr/share/nginx/html;                index   index.html index.htm index.php;    }</code></pre><p><img src="/posts/E:%5C%E8%BD%AF%E4%BB%B6%5Ctypora%5C%E6%96%87%E6%A1%A3%5Cdocker%E9%83%A8%E7%BD%B2LNMP%E7%8E%AF%E5%A2%83.assets%5Cimage-20191220121324472.png" alt="image-20191220121324472"></p><pre><code>    location ~ /phpmyadmin/(?&lt;after_ali&gt;(.*)\.(php|php5)?$) {        root           /usr/share/nginx/html;        fastcgi_pass   172.16.10.30:9000;        fastcgi_index  index.php;        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;        include        fastcgi_params;    }</code></pre><p><img src="/posts/E:%5C%E8%BD%AF%E4%BB%B6%5Ctypora%5C%E6%96%87%E6%A1%A3%5Cdocker%E9%83%A8%E7%BD%B2LNMP%E7%8E%AF%E5%A2%83.assets%5Cimage-20191220101300471.png" alt="image-20191220101300471"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 conf.d]# docker restart nginx <br>[root@docker01 conf.d]# docker ps<br></code></pre></td></tr></table></figure><p><img src="/posts/E:%5C%E8%BD%AF%E4%BB%B6%5Ctypora%5C%E6%96%87%E6%A1%A3%5Cdocker%E9%83%A8%E7%BD%B2LNMP%E7%8E%AF%E5%A2%83.assets%5Cimage-20191220105419384.png" alt="image-20191220105419384"></p><p><strong>浏览器访问 <a href="http://192.168.1.11/phpmyadmin/index.php" target="_blank" rel="noopener">http://192.168.1.11/phpmyadmin/index.php</a></strong></p><p><img src="/posts/E:%5C%E8%BD%AF%E4%BB%B6%5Ctypora%5C%E6%96%87%E6%A1%A3%5Cdocker%E9%83%A8%E7%BD%B2LNMP%E7%8E%AF%E5%A2%83.assets%5Cimage-20191220134345698.png" alt="image-20191220134345698"></p><p><em>报红框属于正常现象，不要惊慌，接下来就解决它</em></p><p><strong>需要我们对php镜像做出更改，添加php和MySQL连接模块</strong></p><p><strong>编写一个Dockerfile</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 conf.d]# cd <br>[root@docker01 ~]# vim Dockerfile<br>FROM php:7.2-fpm<br>RUN apt-get update &amp;&amp; apt-get install -y \<br>        libfreetype6-dev \<br>        libjpeg62-turbo-dev \<br>        libpng-dev \<br>    &amp;&amp; docker-php-ext-install -j$(nproc) iconv \<br>    &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \<br>    &amp;&amp; docker-php-ext-install -j$(nproc) gd \<br>        &amp;&amp; docker-php-ext-install mysqli pdo pdo_mysql<br></code></pre></td></tr></table></figure><p><strong>基于dockerfile创建php镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker build -t phpmysql .<br>//基于Dockerfiler创建一个镜像<br></code></pre></td></tr></table></figure><p><strong>删除之前的php容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker stop phpfpm<br>[root@docker01 ~]# docker rm phpfpm <br>//关闭并删除php容器<br></code></pre></td></tr></table></figure><p><strong>用新的php镜像运行容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -itd --name phpfpm -p 9000:9000 -v /wwwroot/html:/usr/share/nginx/html --network lnmp --ip 172.16.10.30 phpmysql<br>//用新做的php镜像重新运行<br></code></pre></td></tr></table></figure><p><strong>//修改phpmyadmin的配置文件，指定连接的数据库的IP，然后重启php容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 html]# cd /wwwroot/html/phpmyadmin/<br>[root@docker01 phpmyadmin]# cp config.sample.inc.php  config.inc.php<br>[root@docker01 phpmyadmin]# vim config.inc.php<br><span class="hljs-meta">$</span><span class="bash">cfg[<span class="hljs-string">'Servers'</span>][<span class="hljs-variable">$i</span>][<span class="hljs-string">'auth_type'</span>] = <span class="hljs-string">'cookie'</span>;</span><br>/* Server parameters */<br><span class="hljs-meta">$</span><span class="bash">cfg[<span class="hljs-string">'Servers'</span>][<span class="hljs-variable">$i</span>][<span class="hljs-string">'host'</span>] = <span class="hljs-string">'172.16.10.20'</span>;   <span class="hljs-comment">#31写mysql数据库的IP地址</span></span><br><span class="hljs-meta">$</span><span class="bash">cfg[<span class="hljs-string">'Servers'</span>][<span class="hljs-variable">$i</span>][<span class="hljs-string">'compress'</span>] = <span class="hljs-literal">false</span>;</span><br><span class="hljs-meta">$</span><span class="bash">cfg[<span class="hljs-string">'Servers'</span>][<span class="hljs-variable">$i</span>][<span class="hljs-string">'AllowNoPassword'</span>] = <span class="hljs-literal">false</span>;</span><br></code></pre></td></tr></table></figure><p><img src="/posts/E:%5C%E8%BD%AF%E4%BB%B6%5Ctypora%5C%E6%96%87%E6%A1%A3%5Cdocker%E9%83%A8%E7%BD%B2LNMP%E7%8E%AF%E5%A2%83.assets%5Cimage-20191220104852352.png" alt="image-20191220104852352"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 phpmyadmin]# docker restart phpfpm <br>//重启phpfpm容器<br></code></pre></td></tr></table></figure><p>浏览器测试访问http://192.168.1.11/phpmyadmin/index.php</p><p>用户名：root 密码：<a href="http://123.com" target="_blank" rel="noopener">123.com</a></p><p><img src="/posts/E:%5C%E8%BD%AF%E4%BB%B6%5Ctypora%5C%E6%96%87%E6%A1%A3%5Cdocker%E9%83%A8%E7%BD%B2LNMP%E7%8E%AF%E5%A2%83.assets%5Cimage-20191220135242858.png" alt="image-20191220135242858"></p><p><img src="/posts/E:%5C%E8%BD%AF%E4%BB%B6%5Ctypora%5C%E6%96%87%E6%A1%A3%5Cdocker%E9%83%A8%E7%BD%B2LNMP%E7%8E%AF%E5%A2%83.assets%5Cimage-20191220135332412.png" alt="image-20191220135332412"></p><p>登陆成功之后可以看到之前mysql创建的数据库</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>docker-compose</title>
    <link href="https://wsdlxgp.top/posts/713b.html"/>
    <id>https://wsdlxgp.top/posts/713b.html</id>
    <published>2020-06-06T15:29:15.684Z</published>
    <updated>2020-06-06T15:24:41.444Z</updated>
    
    <content type="html"><![CDATA[<h1><strong>docker三剑客之docker-compose</strong></h1><p><em><strong>docker容器的编排工具: 解决相互有依赖关系的多个容器的管理。</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker-compose -v<br>//验证已有docker-compose命令<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223084424676.png" alt="image-20191223084424676"></p><h2 id="docker-compose的配置文件实例"><strong>docker-compose的配置文件实例</strong></h2><p><em><strong>通过识别一个docker-compose.yml的配置文件，去管理容器。</strong></em></p><h3 id="设置tab键的空格数量"><strong>设置tab键的空格数量</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# vim .vimrc<br>set tabstop=2<br>//设置tab键的空格数量<br>[root@docker01 ~]# source .vimrc <br>//刷新一下<br></code></pre></td></tr></table></figure><h3 id="创建一个docker-compose-yml测试文件"><strong>创建一个docker-compose.yml测试文件</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# mkdir compose_test<br>//创建测试目录<br>[root@docker01 ~]# cd compose_test/<br>[root@docker01 compose_test]# vim docker-compose.yml<br>//创建测试文件docker-compose.yml<br>version: "3"<br>services:<br>  nginx:<br>    container_name: web-nginx<br>    image: nginx<br>    restart: always<br>    ports:<br>      - 90:80<br>    volumes:<br>      - ./webserver:/usr/share/nginx/html<br></code></pre></td></tr></table></figure><h4 id="docker-compose-yml文件的解释"><strong>docker-compose.yml文件的解释</strong></h4><p><strong>第一部分: version: 指定语法格式的版本。</strong></p><p><strong>第二部分: service: 定义服务,(想要运行什么样的容器)</strong></p><h3 id="通过docker-compose-yml文件运行容器"><strong>通过docker-compose.yml文件<a href>运行</a>容器</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# docker-compose up -d<br>//后台运行docker-compose规定的容器。（在执行这条命令的当前目录下，也需要一个docker-compose.yml的配置文件，并且通常只有一个。）<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223091336129.png" alt="image-20191223091336129"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# docker ps<br>//查看容器信息<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223091432734.png" alt="image-20191223091432734"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# curl 127.0.0.1:90<br>//访问nginx会失败，因为挂载目录没有页面内容<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223091542832.png" alt="image-20191223091542832"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# vim webserver/index.html<br>//创建测试网页<br>xgp666<br>[root@docker01 compose_test]# curl 127.0.0.1:90<br>//再次访问，是成功的<br>xgp666<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223091825697.png" alt="image-20191223091825697"></p><h3 id="通过docker-compose-yml文件停止运行容器"><strong>通过docker-compose.yml文件<a href>停止运行</a>容器</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# docker-compose stop<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223092133334.png" alt="image-20191223092133334"></p><h3 id="通过docker-compose-yml文件重启容器"><strong>通过docker-compose.yml文件<a href>重启</a>容器</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# docker-compose restart<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223092201539.png" alt="image-20191223092201539"></p><h3 id="不在docker-compose-yml文件所在目录，要使用-f指定目录"><strong>不在docker-compose.yml文件所在目录，要使用<a href>-f</a>指定目录</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker-compose -f compose_test/docker-compose.yml  stop<br></code></pre></td></tr></table></figure><h3 id="并且，在运行container（docker-compose-yml）的过程中，还支持Dockerfile"><strong>并且，在运行container（docker-compose.yml）的过程中，还支持Dockerfile</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# vim Dockerfile<br>//编写dockerfile<br>FROM nginx<br>ADD webserver /usr/share/nginx/html<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# vim docker-compose.yml <br>//修改docker-compose.yml文件<br>version: "3"<br>services:<br>  nginx:<br>    build: .     #添加<br>    container_name: web-nginx<br>    image: new-nginx:v1.0   #修改镜像名称<br>    restart: always<br>    ports:<br>      - 90:80<br></code></pre></td></tr></table></figure><h4 id="通过docker-compose-yml文件停止并删除容器"><strong>通过docker-compose.yml文件<a href>停止并删除</a>容器</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# docker-compose stop<br>Stopping web-nginx ... done<br>[root@docker01 compose_test]# docker-compose rm<br></code></pre></td></tr></table></figure><h4 id="通过docker-compose-yml文件运行容器-2"><strong>通过docker-compose.yml文件<a href>运行</a>容器</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# docker-compose up -d<br>//通过docker-compose.yml文件[运行]()容器<br>[root@docker01 compose_test]# docker ps<br>//查看容器信息<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223094155625.png" alt="image-20191223094155625"></p><h4 id="测试nginx访问页面">测试nginx访问页面</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# curl 127.0.0.1:90<br>//测试访问nginx页面，成功<br>xgp666<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223094318146.png" alt="image-20191223094318146"></p><h1><strong>搭建wordpress的博客</strong></h1><h2 id="下载wordpress和mysql-5-7容器"><strong>下载wordpress和mysql:5.7容器</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker pull wordpress<br>//下载wordpress容器<br>[root@docker01 ~]# docker pull mysql：5.7<br>//下载mysql：5.7容器<br></code></pre></td></tr></table></figure><h2 id="编写一个docker-ccompose-yml">编写一个docker-ccompose.yml</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# mkdir wordpress<br>//创建wordpress测试文件<br>[root@docker01 ~]# cd wordpress/<br><br>[root@docker01 wordpress]# vim docker-compose.yml<br>//编写docker-compose.yml<br>version: "3.1"<br>services:<br>  wordpress:<br>    image: wordpress<br>    restart: always<br>    ports:<br>      - 8080:80<br>    environment:<br>      WORDPRESS_DB_HOST: db<br>      WORDPRESS_DB_USER: wordpress<br>      WORDPRESS_DB_PASSWORD: 123.com<br>      WORDPRESS_DB_NAME: wordpress<br>  db:<br>    image: mysql:5.7<br>    restart: always<br>    environment:<br>      MYSQL_DATABASE: wordpress<br>      MYSQL_USER: wordpress<br>      MYSQL_PASSWORD: 123.com<br>      MYSQL_ROOT_PASSWORD: 123.com<br></code></pre></td></tr></table></figure><h3 id="通过docker-compose-yml文件运行容器-3"><strong>通过docker-compose.yml文件<a href>运行</a>容器</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 wordpress]# docker-compose up -d<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223100139125.png" alt="image-20191223100139125"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 wordpress]# docker ps<br>//查看容器信息<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223100236380.png" alt="image-20191223100236380"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 wordpress]# docker logs  容器名称<br>//查看容器日志<br></code></pre></td></tr></table></figure><h3 id="浏览器访问一下-http-192-168-1-11-8080"><strong>浏览器访问一下</strong> <a href="http://192.168.1.11:8080/" target="_blank" rel="noopener">http://192.168.1.11:8080/</a></h3><p><strong>选择语言</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223104436304.png" alt="image-20191223104436304"></p><p><strong>安装wordpress</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223104604591.png" alt="image-20191223104604591"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223104630540.png" alt="image-20191223104630540"></p><p><strong>登陆wordpress</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223104649709.png" alt="image-20191223104649709"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223105646408.png" alt="image-20191223105646408"></p><p><strong>登陆成功后，自己就可以进行设置了</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;strong&gt;docker三剑客之docker-compose&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;docker容器的编排工具: 解决相互有依赖关系的多个容器的管理。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Docker swarm集群</title>
    <link href="https://wsdlxgp.top/posts/ca45.html"/>
    <id>https://wsdlxgp.top/posts/ca45.html</id>
    <published>2020-06-06T15:29:15.682Z</published>
    <updated>2020-06-06T15:25:28.476Z</updated>
    
    <content type="html"><![CDATA[<h1>Docker swarm</h1><blockquote><p><strong>docker swarm集群：三剑客之一</strong></p></blockquote><h2 id="一-实验环境">一. 实验环境</h2><table><thead><tr><th>主机</th><th>IP地址</th><th>服务</th></tr></thead><tbody><tr><td>docker01</td><td>192.168.1.11</td><td>swarm+overlay+webUI</td></tr><tr><td>docker02</td><td>192.168.1.13</td><td>docker</td></tr><tr><td>docker03</td><td>192.168.1.20</td><td>docker</td></tr></tbody></table><p><em><strong>三台主机都关闭防火墙，禁用selinux，修改主机名，时间同步，并添加域名解析。</strong></em></p><p><em><strong>docker版本必须是：v1.12版本开始（可使用docker version查看版本）</strong></em></p><h3 id="1-关闭防火墙，禁用selinux"><strong>1.关闭防火墙，禁用selinux</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# systemctl stop firewalld<br>[root@localhost ~]# hostnamectl set-hostname docker03<br>[root@localhost ~]# su -<br></code></pre></td></tr></table></figure><h3 id="2-时间同步"><strong>2.时间同步</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /etc/localtime /etc/localtime.bk<br>cp /usr/share/zoneinfo/Asia/Shanghai/etc/localtime<br></code></pre></td></tr></table></figure><h2 id="3-修改主机名（三台都要）">3.修改主机名（三台都要）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# hostnamectl set-hostname docker01<br>[root@localhost ~]# su -<br></code></pre></td></tr></table></figure><h3 id="4-添加域名解析"><strong>4.添加域名解析</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# vim  /etc/hosts<br><br>127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4<br>::1         localhost localhost.localdomain localhost6 localhost6.localdomain6<br>192.168.1.11 docker01<br>192.168.1.13 docker02<br>192.168.1.20 docker03<br></code></pre></td></tr></table></figure><h2 id="二-swarm原理">二. swarm原理</h2><blockquote><p>**swarm：**作用运行docker engin的多个主机组成的集群</p><p>**node：**每一个docker engin都是一个node（节点），分为manager和worker。</p><p>**manager node：**负责执行容器的编排和集群的管理工作，保持并维护swarm处于期望的状态。swarm可以有多个manager node，他们会自动协调并选举一个leader执行编排任务。但相反，不能没有manager node。</p><p>**worker node：**接受并执行由manager node派发的任务，并且默认manager node也是一个worker node，不过可以将它设置为manager-only node，让他只负责编排和管理工作。</p><p>**service：**用来定义worker上执行的命令。</p></blockquote><h3 id="基本命令操作">基本命令操作</h3><blockquote><p>**docker swarm leave：**申请离开一个集群，之后查看节点状态会变成down，然后可通过manager node 将其删除<br>**docker node rm xxx：**删除某个节点</p><p><strong>docker swarm join-token [manager|worker]</strong>：生成令牌，可以是manager或worker身份。</p><p><strong>docker node demote（降级）</strong>：将swarm节点的为manager降级为worker</p><p><strong>docker node  promote（升级）</strong>：将swarm节点的work升级为manager</p><p>**docker node ls:**查看群集的信息（只可以在manager角色的主机上查看）</p><p><strong>docker service scale web05=6</strong>:容器的动态扩容及缩容</p><p><strong>docker service ps web01</strong>: 查看创建的容器运行在哪些节点</p><p><strong>docker service ls</strong>: 查看创建的服务</p><p><strong>docker swarm leave</strong>: 脱离这个群集</p><p><strong>docker node rm docker03</strong>: 在manager角色的服务器上移除docker03</p><p><strong>docker node update --availability drain docker01</strong>: 设置主机docker01以后不运行容器，但已经运行的容器并不会停止</p><p><strong>docker node update --label-add mem=max docker03</strong>: 更改docker03主机的标签为mem=max</p><p><strong>docker service update --replicas 8 --image 192.168.20.6:5000/lvjianzhao:v2.0 --container-label-add ‘node.labels.mem==max’ lvjianzhao05</strong>: 将服务升级为8个容器，并且指定在mem=max标签的主机上运行</p></blockquote><h2 id="三-docker01-初始化集群">三. docker01 初始化集群</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker swarm init --advertise-addr 192.168.1.11<br></code></pre></td></tr></table></figure><blockquote><p>**–advertise-addr：**指定与其它docker通信的地址。</p></blockquote><p><strong>上边返回的结果告诉我们：初始化成功，并且，如果想要添加work节点运行下面的命令：</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227100031387.png" alt="image-20191227100031387"></p><p><em><strong>注意：token令牌只有24小时的有效期</strong></em></p><p><strong>如果想要添加manager节点：运行下面命令</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227100101785.png" alt="image-20191227100101785"></p><h2 id="四-swarm集群的简单操作">四.swarm集群的简单操作</h2><h3 id="1-docker02和docker03以worker加入集群">1.docker02和docker03以worker加入集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker03 ~]# docker swarm join --token SWMTKN-1-5kxn9wloh7npnytklwbfciesr9di7uvu521gwnqm9h1n0pbokj-1e60wt0yr5583e4mzwbxnn3a8 192.168.1.11:2377<br></code></pre></td></tr></table></figure><h4 id="docker01查看集群">docker01查看集群</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227095739033.png" alt="image-20191227095739033"></p><p><em>注意：这里的”*****“代表的是当前所属的节点</em></p><h3 id="2-删除集群中节点">2.删除集群中节点</h3><h5 id="docker02和docker03申请离开一个集群"><strong>docker02和docker03申请离开一个集群</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker swarm leave<br></code></pre></td></tr></table></figure><h5 id="docker删除docker02和docker03节点"><strong>docker删除docker02和docker03节点</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node rm docker02 <br>[root@docker01 ~]# docker node rm docker03<br></code></pre></td></tr></table></figure><h5 id="docker01查看集群-2">docker01查看集群</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227101116537.png" alt="image-20191227101116537"></p><h3 id="3-docker02和docker03以manager加入集群">3.docker02和docker03以manager加入集群</h3><h4 id="docker01生成manager令牌">docker01生成manager令牌</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker swarm join-token manager<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227101524317.png" alt="image-20191227101524317"></p><h4 id="docker02和docker03加入集群">docker02和docker03加入集群</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker swarm join --token SWMTKN-1-5kxn9wloh7npnytklwbfciesr9di7uvu521gwnqm9h1n0pbokj-cz6hbyv9r5htyqwj5tfol65aa 192.168.1.11:2377<br></code></pre></td></tr></table></figure><h4 id="docker01查看集群-3">docker01查看集群</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227101645916.png" alt="image-20191227101645916"></p><h3 id="4-docker02和docker03降级">4.docker02和docker03降级</h3><h4 id="docker01（manager）把docker02和docker03降级成worker">docker01（manager）把docker02和docker03降级成worker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node  demote docker02<br>[root@docker01 ~]# docker node  demote docker03<br></code></pre></td></tr></table></figure><h4 id="查看集群">查看集群</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227102107194.png" alt="image-20191227102107194"></p><h2 id="五-部署docker-swarm集群网络">五.部署docker swarm集群网络</h2><h4 id="overlay-覆盖型网络">overlay:覆盖型网络</h4><p>overlay networks 管理Swarm中docker守护进程间的通信。可以将容器附加到一个或多个已存在的overlay网络上，使容器与容器之间能够通信；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker network create -d overlay --attachable docker<br>//attachable：这个参数必须要加，否则不能用于容器。<br></code></pre></td></tr></table></figure><p><strong>在创建网络的时候，我们并没有部署一个存储服务，比如consul，那是因为docker swarm自带存储。</strong></p><h5 id="docker01查看网络">docker01查看网络</h5><p><em><strong>但是会发现其他两台并不会发现此网络，需等基于此网络创建service服务就可以看到了</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker network ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227105017950.png" alt="image-20191227105017950"></p><h2 id="六-docker01部署一个图形化webUI界面">六. docker01部署一个图形化webUI界面</h2><h3 id="1-docker01-导入镜像">1.docker01 导入镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01~]# docker pull dockersamples/visualizer<br></code></pre></td></tr></table></figure><h3 id="2-基于镜像启动一台容器">2.基于镜像启动一台容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -d -p 8080:8080 -e HOST=192.168.1.100 -e PORT=8080 -v /var/run/docker.sock:/var/run/docker.sock --name visualiaer  dockersamples/visualizer<br></code></pre></td></tr></table></figure><h3 id="3-通过浏览器访问验证http-192-168-1-11-8080">3.通过浏览器访问验证http://192.168.1.11:8080/</h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227105857150.png" alt="image-20191227105857150"></p><p><em><strong>如果访问不到网页，需开启路由转发</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# echo net.ipv4.ip_forward = 1 &gt;&gt; /etc/sysctl.conf <br>[root@docker01 ~]# sysctl -p<br></code></pre></td></tr></table></figure><h2 id="七-创建service（服务）">七. 创建service（服务）</h2><h4 id="1-基于nginx容器创建一个service服务">1. 基于nginx容器创建一个service服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]#docker pull nginx<br>//下载nginx镜像（三台都要）<br>[root@docker01 ~]# docker service create --replicas 1 --network  docker --name web1 -p 80:80 nginx:latest <br>[root@docker01 ~]# docker service create --replicas 1 --network  docker --name web2 -p 80 nginx:latest<br></code></pre></td></tr></table></figure><p>//–replicas：副本数量</p><p>大概可以理解为一个副本等于一个容器</p><h4 id="2-查看创建的service服务">2. 查看创建的service服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227110938144.png" alt="image-20191227110938144"></p><h5 id="单独查看一个servicefuw">单独查看一个servicefuw</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service  ps web1<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227111603547.png" alt="image-20191227111603547"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service  ps web2<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227111617335.png" alt="image-20191227111617335"></p><h4 id="3-web界面查看">3. web界面查看</h4><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227111400323.png" alt="image-20191227111400323"></p><h4 id="4-基于nginx容器创建五个service服务">4. 基于nginx容器创建五个service服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service create --replicas 5 --network  docker --name web -p 80 nginx:latest<br></code></pre></td></tr></table></figure><h5 id="web界面查看">web界面查看</h5><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227111721046.png" alt="image-20191227111721046"></p><h4 id="5-挂起docker02">5. 挂起docker02</h4><h5 id="web查看（发现服务都分配到其他服务器了）">web查看（发现服务都分配到其他服务器了）</h5><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227112406099.png" alt="image-20191227112406099"></p><h4 id="6-恢复docker02">6. 恢复docker02</h4><h5 id="web查看（发现服务没有回到docker02）">web查看（发现服务没有回到docker02）</h5><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227112714567.png" alt="image-20191227112714567"></p><h2 id="八、实现docker容器的扩容及缩容">八、实现docker容器的扩容及缩容</h2><h3 id="1-删除web1和web2服务">1. 删除web1和web2服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service rm web1 web2<br></code></pre></td></tr></table></figure><h3 id="2-容器的扩容和缩减">2. 容器的扩容和缩减</h3><p>（1）扩容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service scale web=8<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227114842044.png" alt="image-20191227114842044"></p><p>（2）缩减</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service scale web=3<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227114821286.png" alt="image-20191227114821286"></p><h3 id="3-设置manager-node不参加工作">3.设置manager node不参加工作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node update docker01 --availability drain<br></code></pre></td></tr></table></figure><blockquote><p>设置主机docker01以后不运行容器，但已经运行的容器并不会停止<br>“–availability”选项后面共有三个选项可配置，如下：<br>“active”：工作；“pause”：暂时不工作；“drain”：永久性的不工作</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227115018372.png" alt="image-20191227115018372"></p><h4 id="web界面查看-2">web界面查看</h4><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227115142868.png" alt="image-20191227115142868"></p><h2 id="九、docker-Swarm总结">九、docker Swarm总结</h2><blockquote><p>在我对docker Swarm群集进行一定了解后，得出的结论如下：</p><ul><li>参与群集的主机名一定不能冲突，并且可以互相解析对方的主机名；</li><li>集群内的所有节点可以都是manager角色，但是不可以都是worker角色；</li><li>当指定运行的镜像时，如果群集中的节点本地没有该镜像，那么它将会自动下载对应的镜像；</li><li>当群集正常工作时，若一个运行着容器的docker服务器发生宕机，那么，其所运行的所有容器，都将转移到其他正常运行的节点之上，而且，就算发生宕机的服务器恢复正常运行，也不会再接管之前运行的容器；</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Docker swarm&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;docker swarm集群：三剑客之一&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一-实验环境&quot;&gt;一. 实验环境&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>docker swarm版本回滚</title>
    <link href="https://wsdlxgp.top/posts/4890.html"/>
    <id>https://wsdlxgp.top/posts/4890.html</id>
    <published>2020-06-06T15:29:15.680Z</published>
    <updated>2020-06-06T15:26:44.597Z</updated>
    
    <content type="html"><![CDATA[<h1>Docker swarm</h1><blockquote><p><strong>docker swarm集群：三剑客之一</strong></p></blockquote><h2 id="一-实验环境">一. 实验环境</h2><table><thead><tr><th>主机</th><th>IP地址</th><th>服务</th></tr></thead><tbody><tr><td>docker01</td><td>192.168.1.11</td><td>swarm+service+webUI+registry</td></tr><tr><td>docker02</td><td>192.168.1.13</td><td>docker</td></tr><tr><td>docker03</td><td>192.168.1.20</td><td>docker</td></tr></tbody></table><p><em><strong>三台主机都关闭防火墙，禁用selinux，修改主机名，时间同步，并添加域名解析。</strong></em></p><p><em><strong>docker版本必须是：v1.12版本开始（可使用docker version查看版本）</strong></em></p><h3 id="1-关闭防火墙，禁用selinux"><strong>1.关闭防火墙，禁用selinux</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# systemctl stop firewalld<br>[root@localhost ~]# hostnamectl set-hostname docker03<br>[root@localhost ~]# su -<br></code></pre></td></tr></table></figure><h3 id="2-时间同步"><strong>2.时间同步</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /etc/localtime /etc/localtime.bk<br>cp /usr/share/zoneinfo/Asia/Shanghai/etc/localtime<br></code></pre></td></tr></table></figure><h2 id="3-修改主机名（三台都要）">3.修改主机名（三台都要）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# hostnamectl set-hostname docker01<br>[root@localhost ~]# su -<br></code></pre></td></tr></table></figure><h3 id="4-添加域名解析"><strong>4.添加域名解析</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# echo 192.168.1.11 docker01 &gt;&gt; /etc/hosts<br>[root@docker01 ~]# echo 192.168.1.13 docker02 &gt;&gt; /etc/hosts<br>[root@docker01 ~]# echo 192.168.1.20 docker03 &gt;&gt; /etc/hosts<br></code></pre></td></tr></table></figure><h2 id="三-docker01-初始化集群">三. docker01 初始化集群</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker swarm init --advertise-addr 192.168.1.11<br></code></pre></td></tr></table></figure><blockquote><p>**–advertise-addr：**指定与其它docker通信的地址。</p></blockquote><p><strong>上边返回的结果告诉我们：初始化成功，并且，如果想要添加work节点运行下面的命令：</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227100031387.png" alt="image-20191227100031387"></p><p><em><strong>注意：token令牌只有24小时的有效期</strong></em></p><p><strong>如果想要添加manager节点：运行下面命令</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227100101785.png" alt="image-20191227100101785"></p><h2 id="四，docker02和docker03以worker加入集群">四，docker02和docker03以worker加入集群</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker03 ~]# docker swarm join --token SWMTKN-1-5kxn9wloh7npnytklwbfciesr9di7uvu521gwnqm9h1n0pbokj-1e60wt0yr5583e4mzwbxnn3a8 192.168.1.11:2377<br></code></pre></td></tr></table></figure><h4 id="docker01查看集群">docker01查看集群</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227095739033.png" alt="image-20191227095739033"></p><p><em>注意：这里的”*****“代表的是当前所属的节点</em></p><h2 id="五-设置manager-node（docker01）不参加工作">五.设置manager node（docker01）不参加工作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node update docker01 --availability drain<br></code></pre></td></tr></table></figure><blockquote><p>设置主机docker01以后不运行容器，但已经运行的容器并不会停止<br>“–availability”选项后面共有三个选项可配置，如下：<br>“active”：工作；“pause”：暂时不工作；“drain”：永久性的不工作</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227115018372.png" alt="image-20191227115018372"></p><h2 id="六-docker01部署一个图形化webUI界面">六. docker01部署一个图形化webUI界面</h2><h3 id="1-docker01-导入镜像">1.docker01 导入镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01~]# docker pull dockersamples/visualizer<br></code></pre></td></tr></table></figure><h3 id="2-基于镜像启动一台容器">2.基于镜像启动一台容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -d -p 8080:8080 -e HOST=192.168.1.100 -e PORT=8080 -v /var/run/docker.sock:/var/run/docker.sock --name visualiaer  dockersamples/visualizer<br></code></pre></td></tr></table></figure><h3 id="3-通过浏览器访问验证http-192-168-1-11-8080">3.通过浏览器访问验证http://192.168.1.11:8080/</h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227105857150.png" alt="image-20191227105857150"></p><p><em><strong>如果访问不到网页，需开启路由转发</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# echo net.ipv4.ip_forward = 1 &gt;&gt; /etc/sysctl.conf <br>[root@docker01 ~]# sysctl -p<br></code></pre></td></tr></table></figure><h2 id="一-Docker01部署一个私有仓库">一. Docker01部署一个私有仓库</h2><h3 id="Docker01部署"><strong>Docker01部署</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">72 docker pull registry<br>//下载registry镜像<br><br>73 docker run -itd --name registry -p 5000:5000 --restart=always registry:latest<br>//基于registry镜像，启动一台容器<br><br>78 vim /usr/lib/systemd/system/docker.service #13行修改<br>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.1.11:5000 <br><br>80 systemctl daemon-reload<br>81 systemctl restart docker.service<br>//重启docker<br><br>76 docker tag busybox:latest 192.168.1.11:5000/busybox:v1 <br>//把容器重命名一个标签<br><br>77 docker ps<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/clip_image002.jpg" alt="img"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">78 vim /usr/lib/systemd/system/docker.service #13行修改<br>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.1.11:5000 <br><br><br>80 systemctl daemon-reload<br>81 systemctl restart docker.service<br>//重启docker<br><br>100 docker push 192.168.1.11:5000/busybox:v1<br>//上传容器到私有仓库<br></code></pre></td></tr></table></figure><h3 id="Docker02和docker03加入私有仓库"><strong>Docker02和docker03加入私有仓库</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">78 vim /usr/lib/systemd/system/docker.service #13行修改<br>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.1.11:5000  <br><br>80 systemctl daemon-reload<br>81 systemctl restart docker.service<br>//重启docker<br><br>99 docker pull 192.168.1.11/busybox:v1<br>//测试下载<br></code></pre></td></tr></table></figure><h2 id="2-自定义镜像">2. 自定义镜像</h2><h3 id="要求：基于httpd镜像，更改访问界面内容。镜像tag版本为v1，v2，v3，对应主机面内容为v1，xgp666、v2，xgp666、v2，xgp666">要求：基于httpd镜像，更改访问界面内容。镜像tag版本为v1，v2，v3，对应主机面内容为v1，xgp666、v2，xgp666、v2，xgp666</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker pull httpd<br>//下载httpd镜像<br></code></pre></td></tr></table></figure><p><strong>创建三个测试目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# mkdir &#123;v1,v2,v3&#125;<br>//创建测试目录<br></code></pre></td></tr></table></figure><p><strong>docker01，v1目录操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# cd v1<br>[root@docker01 v1]# echo v1,xgp666 &gt; index.html<br>//创建测试网页<br><br>[root@docker01 v1]# vim Dockerfile<br>//编写Dockerfile<br>FROM httpd<br>ADD index.html /c<br><br>[root@docker01 v1]# docker build -t 192.168.1.11:5000/httpd:v1 .<br>//基于dockerfile创建镜像<br><br>[root@docker01 v1]# docker push  192.168.1.11:5000/httpd:v1<br>//上传刚刚创建镜像到私有仓库<br></code></pre></td></tr></table></figure><p><strong>docker01，v2目录操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v1]# cd ../v2<br>[root@docker01 v2]# echo v2,xgp666 &gt; index.html<br><br>[root@docker01 v2]# vim Dockerfile <br>//编写Dockerfile<br>FROM httpd<br>ADD index.html /usr/local/apache2/htdocs/index.html<br><br>[root@docker01 v2]# docker build -t 192.168.1.11:5000/httpd:v2 .<br>//基于dockerfile创建镜像<br><br>[root@docker01 v2]# docker push  192.168.1.11:5000/httpd:v2<br>//上传刚刚创建镜像到私有仓库<br></code></pre></td></tr></table></figure><p><strong>docker01，v3目录操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v1]# cd ../v3<br>[root@docker01 v2]# echo v3,xgp666 &gt; index.html<br><br>[root@docker01 v2]# vim Dockerfile <br>//编写Dockerfile<br>FROM httpd<br>ADD index.html /usr/local/apache2/htdocs/index.html<br><br>[root@docker01 v2]# docker build -t 192.168.1.11:5000/httpd:v3 .<br>//基于dockerfile创建镜像<br><br>[root@docker01 v2]# docker push  192.168.1.11:5000/httpd:v3<br>//上传刚刚创建镜像到私有仓库<br></code></pre></td></tr></table></figure><h2 id="3-发布一个服务，基于上述镜像">3. 发布一个服务，基于上述镜像</h2><h3 id="要求-副本数量为3个。服务的名称为-bdqn">要求:副本数量为3个。服务的名称为: bdqn</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v3]# docker service create --replicas 3 --name bdqn  -p 80:80 192.168.1.11:5000/httpd:v1<br></code></pre></td></tr></table></figure><p><strong>查看一下网络</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker03 ~]# docker network ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191228101822794.png" alt="image-20191228101822794"></p><p><strong>默认的Ingress网络，包括创建的自定义overlay网络, 为后端真正为用户提供服务的container,提供了一个统一的入口。</strong></p><h3 id="查看一下创建的副本">查看一下创建的副本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v3]# docker service ps bdqn<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191228095854330.png" alt="image-20191228095854330"></p><h3 id="浏览器测试访问http-192-168-1-11-80-http-192-168-1-13-80-http-192-168-1-20-80">浏览器测试访问http://192.168.1.11:80,<a href="http://192.168.1.13:80" target="_blank" rel="noopener">http://192.168.1.13:80</a>,<a href="http://192.168.1.20:80" target="_blank" rel="noopener">http://192.168.1.20:80</a></h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191228100217751.png" alt="image-20191228100217751"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191228100237712.png" alt="image-20191228100237712"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191228100254812.png" alt="image-20191228100254812"></p><h3 id="修改docker02和docker03测试网页内容">修改docker02和docker03测试网页内容</h3><h3 id="docker02">docker02</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker exec -it 388f3bd9dd33 /bin/bash<br>root@388f3bd9dd33:/usr/local/apache2# cd htdocs/<br>root@388f3bd9dd33:/usr/local/apache2/htdocs# echo 123 &gt; index.html<br></code></pre></td></tr></table></figure><h3 id="docker03">docker03</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker03 ~]# docker exec -it 281454867fac /bin/bash<br>root@281454867fac:/usr/local/apache2# echo 321 &gt; htdocs/index.html<br></code></pre></td></tr></table></figure><h3 id="测试访问（每一台都会显示，会负载均衡）">测试访问（每一台都会显示，会负载均衡）</h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191228101141172.png" alt="image-20191228101141172"></p><h2 id="要求-副本数量为3个。服务的名称为-test">要求:副本数量为3个。服务的名称为:test</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v3]# docker service create --replicas 3 --name test  -p 80  192.168.1.11:5000/httpd:v1<br></code></pre></td></tr></table></figure><h3 id="查看创建的服务映射端口">查看创建的服务映射端口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v3]# docker service ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191228102155589.png" alt></p><p><strong>默认映射端口30000-32767</strong></p><h2 id="4-服务的扩容与缩容">4. 服务的扩容与缩容</h2><h3 id="扩容">扩容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v3]# docker service scale bdqn=6<br></code></pre></td></tr></table></figure><h3 id="缩容">缩容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v3]# docker service scale bdqn=4<br></code></pre></td></tr></table></figure><p><em><strong>扩容与缩容直接直接通过scale进行设置副本数量。</strong></em></p><h2 id="5-服务的升级与回滚">5.服务的升级与回滚</h2><h3 id="（1）升级">（1）升级</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service update --image 192.168.1.11:5000/httpd:v2 bdqn<br>//把bdqn服务升级成v2的版本<br></code></pre></td></tr></table></figure><h4 id="测试访问一下">测试访问一下</h4><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191228105637593.png" alt="image-20191228105637593"></p><h3 id="（2）平滑的更新">（2）平滑的更新</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service update --image 192.168.1.11:5000/httpd:v3  --update-parallelism 2 --update-delay 1m bdqn <br>//两个服务一起更新，然后，隔一分钟，继续更新<br></code></pre></td></tr></table></figure><blockquote><p>默认情况下, swarm-次只更新-个副本,并且两个副本之间没有等待时间，我们可以通过<br>–update-parallelism;设置并行更新的副本数量。<br>–update-delay：指定滚动更新的时间间隔。</p></blockquote><h4 id="测试访问一下-2">测试访问一下</h4><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191228110448144.png" alt="image-20191228110448144"></p><h3 id="3-回滚操作">(3) 回滚操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service  rollback bdqn<br></code></pre></td></tr></table></figure><p><strong>注意，docker swarm的回滚操作，默认只能回滚到上一-次操作的状态，并不能连续回滚到指定操作。</strong></p><h4 id="测试访问一下-3">测试访问一下</h4><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191228110849914.png" alt="image-20191228110849914"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Docker swarm&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;docker swarm集群：三剑客之一&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一-实验环境&quot;&gt;一. 实验环境&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>AlertManager自定义邮件模板</title>
    <link href="https://wsdlxgp.top/posts/e914.html"/>
    <id>https://wsdlxgp.top/posts/e914.html</id>
    <published>2020-06-06T15:29:15.677Z</published>
    <updated>2020-06-06T15:27:34.171Z</updated>
    
    <content type="html"><![CDATA[<h1><strong>AlertManager自定义邮件模板</strong></h1><h2 id="创建模板目录"><strong>创建模板目录</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# cd prometheus<br>//进入之前创建的prometheus目录<br>[root@docker01 prometheus]# mkdir alertmanager-tmpl<br>//创建AlertManager模板目录<br></code></pre></td></tr></table></figure><h2 id="编写模板规则">编写模板规则</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 prometheus]# vim email.tmpl <br>&#123;&#123; define "email.from" &#125;&#125;2877364346@qq.com&#123;&#123; end &#125;&#125;<br>&#123;&#123; define "email.to" &#125;&#125;2877364346@qq.com&#123;&#123; end &#125;&#125;<br>&#123;&#123; define "email.to.html" &#125;&#125;<br>&#123;&#123; range .Alerts &#125;&#125;<br>=========start==========&lt;br&gt;<br>告警程序: prometheus_alert&lt;br&gt;<br>告警级别: &#123;&#123; .Labels.severity &#125;&#125; 级&lt;br&gt;<br>告警类型: &#123;&#123; .Labels.alertname &#125;&#125;&lt;br&gt;<br>故障主机: &#123;&#123; .Labels.instance &#125;&#125;&lt;br&gt;<br>告警主题: &#123;&#123; .Annotations.summary &#125;&#125;&lt;br&gt;<br>触发时间: &#123;&#123; .StartsAt.Format "2019-08-04 16:58:15" &#125;&#125; &lt;br&gt;<br>=========end==========&lt;br&gt;<br>&#123;&#123; end &#125;&#125;<br>&#123;&#123; end &#125;&#125;<br></code></pre></td></tr></table></figure><h2 id="修改alertmanager的配置文件"><strong>修改alertmanager的配置文件</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# vim alertmanager.yml <br>global:<br>  resolve_timeout: 5m<br>  smtp_from: '2877364346@qq.com'<br>  smtp_smarthost: 'smtp.qq.com:465'<br>  smtp_auth_username: '2877364346@qq.com'<br>  smtp_auth_password: 'evjmqipqezlbdfij'<br>  smtp_require_tls: false<br>  smtp_hello: 'qq.com'<br>templates:                        #添加模板<br>  - '/etc/alertmanager-tmpl/*.tmpl'   #添加路径<br>    route:<br>      group_by: ['alertname']<br>      group_wait: 5s<br>      group_interval: 5s<br>      repeat_interval: 5m<br>      receiver: 'email'<br>    receivers:<br>- name: 'email'<br>  email_configs: <br>  - to: '&#123;&#123; template "email to" &#125;&#125;'   #修改<br>    html: '&#123;&#123; template "email.to.html" .&#125;&#125;'  #添加<br>    send_resolved: true  #删除<br>    inhibit_rules:<br>  - source_match:<br>    severity: 'critical'<br>    target_match:<br>      severity: 'warning'<br>    equal: ['alertname', 'dev', 'instance']<br></code></pre></td></tr></table></figure><h3 id="重新运行-alertmanager-容器"><strong>重新运行 alertmanager 容器</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker rm -f alertmanager<br>//删除alertmanager容器<br>[root@docker01 ~]# docker run -itd  --name alertmanager  -p 9093:9093 -v /root/alertmanager.yml:/etc/alertmanager/alertmanager.yml -v /root/prometheus/alertmanager-tmpl:/etc/alertmanager-tmpl  prom/alertmanager:latest<br>//运行一台新的alertmanager容器，记得挂载配置文件<br></code></pre></td></tr></table></figure><h4 id="挂起docker02">挂起docker02</h4><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191225110848591.png" alt="image-20191225110848591"></p><h4 id="收到邮件">收到邮件</h4><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191225114011561.png" alt="image-20191225114011561"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;strong&gt;AlertManager自定义邮件模板&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&quot;创建模板目录&quot;&gt;&lt;strong&gt;创建模板目录&lt;/strong&gt;&lt;/h2&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
