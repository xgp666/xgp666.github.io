<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xgp &amp; Blog</title>
  
  <subtitle>Today is still beautiful</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wsdlxgp.top/"/>
  <updated>2020-06-28T11:08:13.593Z</updated>
  <id>https://wsdlxgp.top/</id>
  
  <author>
    <name>Wu Shao Dong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nnobackupex全库备份+innobackupex增量备份</title>
    <link href="https://wsdlxgp.top/posts/49er.html"/>
    <id>https://wsdlxgp.top/posts/49er.html</id>
    <published>2020-06-25T16:02:00.000Z</published>
    <updated>2020-06-28T11:08:13.593Z</updated>
    
    <content type="html"><![CDATA[<h1>nnobackupex全库备份+innobackupex增量备份</h1><p><strong>测试环境准备 创建一个测试数据库，并创建一张表输入几行数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create database test2;<br>mysql&gt; use test2;<br>mysql&gt; create table yy(id int,name varchar(20));<br>mysql&gt; insert into yy values(1,&#39;kim1&#39;);<br>mysql&gt; insert into yy values(2,&#39;kim2&#39;);<br></code></pre></td></tr></table></figure><h2 id="1、innobackupex先做完全备份-命令如下：">1、innobackupex先做完全备份 命令如下：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">\# innobackupex --defaults-file=/etc/my.cnf --user=root --password="123456" /opt/mysqlbackup/full/full_incre_$(date +%Y%m%d_%H%M%S) --no-timestamp<br></code></pre></td></tr></table></figure><h4 id="查看完全备份文件">查看完全备份文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> ll /opt/mysqlbackup/full/</span><br>drwxr-x---. 10 root root 4096 Sep 12 23:52 full_incre_20160912_235237<br>innobackupex做增量备份<br></code></pre></td></tr></table></figure><h3 id="（1）做第一次增量备份-先录入增量数据">（1）做第一次增量备份 先录入增量数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; use test2;<br>mysql&gt; insert into yy values(3,&#39;kim3&#39;);<br></code></pre></td></tr></table></figure><h3 id="（2）再进行增量备份，命令如下：">（2）再进行增量备份，命令如下：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> innobackupex --incremental /opt/mysqlbackup/inc/incre_$(date +%Y%m%d_%H%M%S) --incremental-basedir=/opt/mysqlbackup/full/full_incre_20160912_235237/ --user=root --password=<span class="hljs-string">"123456"</span> --no-timestamp</span><br></code></pre></td></tr></table></figure><p><strong>查看增量备份文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> ll /opt/mysqlbackup/inc/</span><br>drwxr-x---. 10 root root 4096 Sep 12 23:56 incre_20160912_235636<br></code></pre></td></tr></table></figure><h4 id="基于全备和第一个增量备份来做第二次增量备份-先录入增量数据录入">基于全备和第一个增量备份来做第二次增量备份 先录入增量数据录入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; use test2;<br>mysql&gt; insert into yy values(4,&#39;kim4&#39;);<br></code></pre></td></tr></table></figure><p><strong>查看增量备份文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> ll /opt/mysqlbackup/inc/</span><br>drwxr-x---. 10 root root 4096 Sep 12 23:56 incre_20160912_235636<br>drwxr-x---. 10 root root 4096 Sep 12 23:59 incre_20160912_235942<br>2、innobackupex做增量恢复<br></code></pre></td></tr></table></figure><h3 id="（3）先删除两次增量数据，用来查看验证恢复结果">（3）先删除两次增量数据，用来查看验证恢复结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; use test2;<br>mysql&gt; delete from yy where id&#x3D;3;<br></code></pre></td></tr></table></figure><h3 id="（4）开始做恢复，恢复全备份-命令如下">（4）开始做恢复，恢复全备份 命令如下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> innobackupex --apply-log --redo-only</span><br>/opt/mysqlbackup/full/full_incre_20160912_235237/<br></code></pre></td></tr></table></figure><p><strong>–redo-only 用于准备增量备份内容把数据合并到全备份目录，配合incremental-dir 增量备份目录使用 基于全备份进行第一次增量备份的恢复 命令如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> innobackupex --apply-log --redo-only /opt/mysqlbackup/full/full_incre_20160912_235237/ --incrementaldir=/opt/mysqlbackup/inc/incre_20160912_235636/</span><br></code></pre></td></tr></table></figure><h4 id="基于全备份和第一次增量备份，恢复第二次增量备份-命令如下："><strong>基于全备份和第一次增量备份，恢复第二次增量备份 命令如下：</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> innobackupex --apply-log --redo-only /opt/mysqlbackup/full/full_incre_20160912_235237/ --incrementaldir=/opt/mysqlbackup/inc/incre_20160912_235942/</span><br></code></pre></td></tr></table></figure><h3 id="（5）恢复整个数据库-停止数据库">（5）恢复整个数据库 停止数据库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> systemctl stop mysqld</span><br></code></pre></td></tr></table></figure><h3 id="（6）清空数据目录下所有文件">（6）清空数据目录下所有文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> mkdir -p /tmp/mysqldatabak</span><br><span class="hljs-meta">#</span><span class="bash"> mv /usr/<span class="hljs-built_in">local</span>/mysql/data/* /tmp/mysqldatabak/</span><br></code></pre></td></tr></table></figure><h3 id="（7）将恢复好的数据按照配置文件的需求拷贝到相应目录">（7）将恢复好的数据按照配置文件的需求拷贝到相应目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> innobackupex --defaults-file=/etc/my.cnf --user=root --password=<span class="hljs-string">"123456"</span> --copyback /opt/mysqlbackup/full/full_incre_20160912_235237/</span><br></code></pre></td></tr></table></figure><p><strong>当数据恢复至DATADIR目录以后，还需要确保所有数据文件的属主和属组均为正确的用户，如mysql，否则，在启动mysqld之前还需要事先修改数据文件的属主和属组。 赋予mysql账号权限</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> chown -R mysql:mysql /usr/<span class="hljs-built_in">local</span>/mysql/data/</span><br></code></pre></td></tr></table></figure><h3 id="（8）启动mysql服务">（8）启动mysql服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">\# systemctl start mysqld<br></code></pre></td></tr></table></figure><h3 id="（9）登录mysql界面，查看数据是否已经恢复，如下所示：">（9）登录mysql界面，查看数据是否已经恢复，如下所示：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; use test2;<br>mysql&gt; select * from yy;<br>+------+------+<br>| id | name |<br>+------+------+<br>| 1 | kim1 |<br>| 2 | kim2 |<br>| 3 | kim3 |<br>| 4 | kim4 |<br>+------+------+<br></code></pre></td></tr></table></figure><p><strong>附：Xtrabackup的“流”及“备份压缩”功能 Xtrabackup对备份的数据文件支持“流”功能，即可以将备份的数据通过STDOUT传输给tar程序进行归档，而不是默认的直接保存至某备份目录中。要使用此功能，仅需要使用–stream选项即可。如：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> innobackupex --user=root --password=<span class="hljs-string">"123456"</span> --stream=tar /opt/mysqlbackup/full/ | gzip &gt;/opt/mysqlbackup/full/full_`date +%F_%H%M%S`.tar.gz</span><br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;nnobackupex全库备份+innobackupex增量备份&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;测试环境准备 创建一个测试数据库，并创建一张表输入几行数据&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://wsdlxgp.top/categories/mysql/"/>
    
    
      <category term="MySQL优化" scheme="https://wsdlxgp.top/tags/MySQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Xtrabackup备份还原</title>
    <link href="https://wsdlxgp.top/posts/49lt.html"/>
    <id>https://wsdlxgp.top/posts/49lt.html</id>
    <published>2020-06-24T16:02:00.000Z</published>
    <updated>2020-06-28T11:06:13.920Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Xtrabackup介绍</h1><p><strong>MySQL冷备、mysqldump、MySQL热拷贝都无法实现对数据库进行增量备份。在实际生产环境中增量备份是非常实用的，如果数据大于50G或100G，存储空间足够的情况下，可以每天进行完整备份，如果每天产生的数据量较大，需要定制数据备份策略。例如每周实用完整备份，周一到周六实用增量备份。而Percona-Xtrabackup就是为了实现增量备份而出现的一款主流备份工具，xtrabakackup有2个工具，分别是xtrabakup、innobakupe。</strong></p><p><strong>Percona-xtrabackup是 Percona公司开发的一个用于MySQL数据库物理热备的备份工具，支持MySQL、Percona server和MariaDB，开源免费，是目前较为受欢迎的主流备份工具。xtrabackup只能备份innoDB和xtraDB两种数据引擎的表，而不能备份MyISAM数据表。</strong></p><h2 id="1、Xtrabackup优点">1、Xtrabackup优点</h2><p><strong>（1）备份速度快，物理备份可靠</strong></p><p><strong>（2）备份过程不会打断正在执行的事务（无需锁表）</strong></p><p><strong>（3）能够基于压缩等功能节约磁盘空间和流量</strong></p><p><strong>（4）自动备份校验</strong></p><p><strong>（5）还原速度快</strong></p><p><strong>（6）可以流传将备份传输到另外一台机器上</strong></p><p><strong>（7）在不增加服务器负载的情况备份数据</strong></p><h2 id="2、Xtrabackup备份原理">2、Xtrabackup备份原理</h2><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200627212311123.png" alt="image-20200627212311123"></p><p><strong>（1）innobackupex启动后，会先fork一个进程，用于启动xtrabackup，然后等待xtrabackup备份ibd数据文件；</strong></p><p><strong>（2）xtrabackup在备份innoDB数据是，有2种线程：redo拷贝线程和ibd数据拷贝线程。xtrabackup进程开始执行后，会启动一个redo拷贝的线程，用于从最新的checkpoint点开始顺序拷贝redo.log；再启动ibd数据拷贝线程，进行拷贝ibd数据。这里是先启动redo拷贝线程的。在此阶段，innobackupex进行处于等待状态（等待文件被创建）</strong></p><p><strong>（4）xtrabackup拷贝完成ibd数据文件后，会通知innobackupex（通过创建文件），同时xtrabackup进入等待状态（redo线程依旧在拷贝redo.log）</strong></p><p><strong>（5）innobackupex收到xtrabackup通知后哦，执行FLUSH TABLES WITH READ LOCK（FTWRL），取得一致性位点，然后开始备份非InnoDB文件（如frm、MYD、MYI、CSV、opt、par等格式的文件），在拷贝非InnoDB文件的过程当中，数据库处于全局只读状态。</strong></p><p><strong>（6）当innobackup拷贝完所有的非InnoDB文件后，会通知xtrabackup，通知完成后，进入等待状态；</strong></p><p><strong>（7）xtrabackup收到innobackupex备份完成的通知后，会停止redo拷贝线程，然后通知innobackupex，redo.log文件拷贝完成；</strong></p><p><strong>（8）innobackupex收到redo.log备份完成后，就进行解锁操作，执行：UNLOCK TABLES；</strong></p><p><strong>（9）最后innbackupex和xtrabackup进程各自释放资源，写备份元数据信息等，innobackupex等xtrabackup子进程结束后退出。</strong></p><h2 id="3、xtrabackup的安装部署以及备份恢复实现">3、xtrabackup的安装部署以及备份恢复实现</h2><h3 id="（1）下载xtrabackup">（1）下载xtrabackup</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.4.4/binary/tarball/percona-xtrabackup-2.4.4-Linux-x86_64.tar.gz<br></code></pre></td></tr></table></figure><h3 id="（2）解压">（2）解压</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar zxf percona-xtrabackup-2.4.4-Linux-x86_64.tar.gz<br></code></pre></td></tr></table></figure><h3 id="（3）进入解压目录">（3）进入解压目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd percona-xtrabackup-2.4.4-Linux-x86_64/<br></code></pre></td></tr></table></figure><h3 id="（4）复制bin下的所有程序到-usr-bin">（4）复制bin下的所有程序到/usr/bin</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost percona-xtrabackup-2.4.4-Linux-x86_64]# cp bin/* /usr/bin/<br></code></pre></td></tr></table></figure><h3 id="Xtrabackup中主要包含两个工具：">Xtrabackup中主要包含两个工具：</h3><ul><li><strong><code>xtrabackup</code>：是用于热备份innodb, xtradb表中数据的工具，支持在线热备份，可以在不加锁的情况下备份Innodb数据表，不过此工具不能操作Myisam引擎表；</strong></li><li><strong><code>innobackupex</code>：是将xtrabackup进行封装的perl脚本，能同时处理Innodb和Myisam，但在处理Myisam时需要加一个读锁。 由于操作Myisam时需要加读锁，这会堵塞线上服务的写操作，而Innodb没有这样的限制，所以数据库中Innodb表类型所占的比例越大，则越有利。</strong></li></ul><h4 id="安装相关插件">安装相关插件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">yum install perl-DBI perl-DBD-MySQL perl-Time-HiRes perl-IO-Socket-SSL perl-TermReadKey.x86_64 perl-Digest-MD5 –y</span><br></code></pre></td></tr></table></figure><h4 id="常用选项">常用选项:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">--host     指定主机<br>--user     指定用户名<br>--password    指定密码<br>--port     指定端口<br>--databases     指定数据库<br><br>--incremental    创建增量备份<br>--incremental-basedir   指定包含完全备份的目录<br>--incremental-dir      指定包含增量备份的目录  <br><br>--apply-log        对备份进行预处理操作             <br>  一般情况下，在备份完成后，数据尚且不能用于恢复操作，因为备份的数据中可能会包含尚未提交的事务或已经提交但尚未同步至数据文件中的事务。因此，此时数据文件仍处理不一致状态。“准备”的主要作用正是通过回滚未提交的事务及同步已经提交的事务至数据文件也使得数据文件处于一致性状态。<br>--redo-only      不回滚未提交事务<br>--copy-back     恢复备份目录<br></code></pre></td></tr></table></figure><p><strong>使用innobackupex备份时，其会调用xtrabackup备份所有的InnoDB表，复制所有关于表结构定义的相关文件(.frm)、以及MyISAM、MERGE、CSV和ARCHIVE表的相关文件，同时还会备份触发器和数据库配置信息相关的文件，这些文件会被保存到一个以时间命名的目录当中。在备份的同时，innobackupex还会在备份目录中创建如下文件：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">(1)xtrabackup_checkpoints -- 备份类型(如完全或增量)、备份状态(如是否已经为prepared状态)和LSN(日志序列号)范围信息：<br><br>每个InnoDB页(通常为16k大小)<br>都会包含一个日志序列号，即LSN，LSN是整个数据库系统的系统版本号，每个页面相关的LSN能够表明此页面最近是如何发生改变的。<br><br>(2)xtrabackup_binlog_info  --  mysql服务器当前正在使用的二进制日志文件及备份这一刻位置二进制日志时间的位置。<br><br>(3)xtrabackup_binlog_pos_innodb  --  二进制日志文件及用于InnoDB或XtraDB表的二进制日志文件的当前position。<br><br>(4)xtrabackup_binary  --  备份中用到的xtrabackup的可执行文件；<br><br>(5)backup-my.cnf  --  备份命令用到的配置选项信息：<br><br>在使用innobackupex进行备份时，还可以使用--no-timestamp选项来阻止命令自动创建一个以时间命名的目录：如此一来，innobackupex命令将会创建一个BACKUP-DIR目录来存储备份数据。<br></code></pre></td></tr></table></figure><h4 id="如果要使用一个最小权限的用户进行备份，则可基于如下命令创建此类用户：">如果要使用一个最小权限的用户进行备份，则可基于如下命令创建此类用户：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">mysql&gt;</span><span class="bash"> CREATE USER <span class="hljs-string">'bkpuser'</span>@<span class="hljs-string">'localhost'</span> IDENTIFIED BY <span class="hljs-string">'123456'</span>;　　</span><br><span class="hljs-meta">#</span><span class="bash">创建用户</span><br><br><span class="hljs-meta">mysql&gt;</span><span class="bash"> REVOKE ALL PRIVILEGES,GRANT OPTION FROM <span class="hljs-string">'bkpuser'</span>;　　</span><br><span class="hljs-meta">#</span><span class="bash">回收此用户所有权限</span><br><br><span class="hljs-meta">mysql&gt;</span><span class="bash"> GRANT RELOAD,LOCK TABLES,RELICATION CLIENT ON *.* TO <span class="hljs-string">'bkpuser'</span>@<span class="hljs-string">'localhost'</span>;　　</span><br><span class="hljs-meta">#</span><span class="bash">授权刷新、锁定表、用户查看服务器状态</span><br><br><span class="hljs-meta">mysql&gt;</span><span class="bash"> FLUSH PRIVILEGES;　　</span><br><span class="hljs-meta">#</span><span class="bash">刷新授权表</span><br></code></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">注意：备份时需启动MySQL,恢复时需关闭MySQL,清空mysql数据目录且不能重新初始化,恢复数据后应该立即进行一次完全备份<br></code></pre></td></tr></table></figure></blockquote><h3 id="（5）下载percona-toolkit并安装">（5）下载percona-toolkit并安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">wget https://www.percona.com/downloads/percona-toolkit/2.2.19/RPM/perconatoolkit-2.2.19-1.noarch.rpm</span><br><span class="hljs-meta">#</span><span class="bash"> rpm -vih percona-toolkit-2.2.19-1.noarch.rpm</span><br></code></pre></td></tr></table></figure><p><strong>下面就可以启动备份了</strong></p><h1>二、xtrabackup全量备份与恢复</h1><h5 id="命令语法格式">命令语法格式</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">备份：<br>innobackupex --user=DBUSER --password=DBUSERPASS --defaults-file=/etc/my.cnf /path/to/BACKUP-DIR/<br><br>恢复：<br>innobackupex --apply-log /backups/2018-07-30_11-04-55/<br>innobackupex --copy-back --defaults-file=/etc/my.cnf  /backups/2018-07-30_11-04-55/<br></code></pre></td></tr></table></figure><h2 id="1、准备-prepare-一个完全备份">1、准备(prepare)一个完全备份</h2><p><strong>一般情况下，在备份完成后，数据尚且不能用于恢复操作，因为备份的数据中可能会包含尚未提交的事务或者已经提交但尚未同步至数据文件中的事务。因此，此时数据文件仍处于不一致状态。&quot;准备&quot;的主要作用正是通过回滚未提交的事务及同步已经提交的事务至数据文件也使用得数据文件处于一致性状态。</strong></p><p><strong>innobackupex命令的–apply-log选项可用于实现上述功能，如下面的命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> innobackupex --apply-log /path/to/BACKUP-DIR</span><br>如果执行正确，其最后输出的几行信息通常如下：<br><br>120407 09:01:04 innobackupex: completed OK!<br></code></pre></td></tr></table></figure><p><strong>在实现&quot;准备&quot;的过程中，innobackupex通常还可以使用–user-memory选项来指定其可以使用的内存的大小，默认为100M.如果有足够的内存空间可用，可以多划分一些内存给prepare的过程，以提高其完成备份的速度。</strong></p><h2 id="2、从一个完全备份中恢复数据">2、从一个完全备份中恢复数据</h2><p><em><strong>注意：恢复不用启动MySQL</strong></em></p><p><strong>innobackupex命令的–copy-back选项用于恢复操作，其通过复制所有数据相关的文件至mysql服务器DATADIR目录中来执行恢复过程。innobackupex通过backup-my.cnf来获取DATADIR目录的相关信息。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> innobackupex --copy-back /path/to/BACKUP-DIR</span><br></code></pre></td></tr></table></figure><p><strong>当数据恢复至DATADIR目录以后，还需要确保所有的数据文件的属主和属组均为正确的用户，如mysql，否则，在启动mysqld之前还需要事先修改数据文件的属主和属组。如：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> chown -R mysql.mysql /mydata/data/</span><br></code></pre></td></tr></table></figure><h2 id="3、实战练习">3、实战练习</h2><h3 id="（1）全量备份">（1）全量备份</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master backups]# innobackupex --user=root --password=123 --host=127.0.0.1 /backups/　　<br><span class="hljs-meta">#</span><span class="bash">在master上进行全库备份<span class="hljs-comment">#语法解释说明：</span></span><br><span class="hljs-meta">#</span><span class="bash">--user=root 指定备份用户</span><br><span class="hljs-meta">#</span><span class="bash">--password=123456  指定备份用户密码</span><br><span class="hljs-meta">#</span><span class="bash">--host　　指定主机</span><br><span class="hljs-meta">#</span><span class="bash">/backups　　指定备份目录</span><br><br>[root@master backups]# ll<br>total 0<br>drwxr-x--- 7 root root 232 Jul 30 11:01 2018-07-30_11-01-37<br>[root@master backups]# ll 2018-07-30_11-01-37/　　<br><span class="hljs-meta">#</span><span class="bash">查看备份数据</span><br>total 77856<br>-rw-r----- 1 root root      418 Jul 30 11:01 backup-my.cnf　　<br><span class="hljs-meta">#</span><span class="bash">备份用到的配置选项信息文件</span><br>-rw-r----- 1 root root 79691776 Jul 30 11:01 ibdata1　　<br><span class="hljs-meta">#</span><span class="bash">数据文件</span><br>drwxr-x--- 2 root root       20 Jul 30 11:01 kim<br>drwxr-x--- 2 root root     4096 Jul 30 11:01 mysql<br>drwxr-x--- 2 root root     4096 Jul 30 11:01 performance_schema<br>drwxr-x--- 2 root root       20 Jul 30 11:01 repppp<br>drwxr-x--- 2 root root     4096 Jul 30 11:01 wordpress<br>-rw-r----- 1 root root       21 Jul 30 11:01 xtrabackup_binlog_info　　<br><span class="hljs-meta">#</span><span class="bash">mysql服务器当前正在使用的二进制日志文件和此时二进制日志时间的位置信息文件</span><br>-rw-r----- 1 root root      113 Jul 30 11:01 xtrabackup_checkpoints　　<br><span class="hljs-meta">#</span><span class="bash">备份的类型、状态和LSN状态信息文件</span><br>-rw-r----- 1 root root      482 Jul 30 11:01 xtrabackup_info<br>-rw-r----- 1 root root     2560 Jul 30 11:01 xtrabackup_logfile　　　　<br><span class="hljs-meta">#</span><span class="bash">备份的日志文件</span><br></code></pre></td></tr></table></figure><h3 id="（2）恢复">（2）恢复</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@slave ~]# /etc/init.d/mysqld stop　　#停止slave上的mysql<br>Shutting down MySQL.. SUCCESS! <br><br>[root@slave tools]# yum install -y percona-xtrabackup-24-2.4.9-1.el7.x86_64.rpm 　　#安装xtrabackup<br>[root@master backups]# scp -r 2018-07-30_11-01-37/ root@192.168.56.12:/backups/　　 #从master上拷贝备份数据<br>[root@slave tools]# innobackupex --apply-log /backups/2018-07-30_11-01-37/　　　　　 #合并数据，使数据文件处于一致性的状态<br>180729 23:18:23 innobackupex: Starting the apply-log operation<br><br>IMPORTANT: Please check that the apply-log run completes successfully.<br>           At the end of a successful apply-log run innobackupex<br>           prints "completed OK!".<br><br>innobackupex version 2.4.9 based on MySQL server 5.7.13 Linux (x86_64) (revision id: a467167cdd4)<br>xtrabackup: cd to /backups/2018-07-30_11-01-37/<br>xtrabackup: This target seems to be not prepared yet.<br>InnoDB: Number of pools: 1<br>xtrabackup: xtrabackup_logfile detected: size=8388608, start_lsn=(3127097)<br>......<br>InnoDB: FTS optimize thread exiting.<br>InnoDB: Starting shutdown...<br>InnoDB: Shutdown completed; log sequence number 3129915<br>180729 23:18:30 completed OK!<br>[root@slave ~]# rm -rf /usr/local/mysql/data/　　#在slave上删除原有的数据<br>[root@slave ~]# vim /etc/my.cnf　　#配置my.cnf的数据目录路径，否则会报错，要和master一致<br>datadir=/usr/local/mysql/data<br>[root@slave ~]# innobackupex --copy-back /backups/2018-07-30_11-01-37/　　#在slave上数据恢复<br>180729 23:32:03 innobackupex: Starting the copy-back operation<br><br>IMPORTANT: Please check that the copy-back run completes successfully.<br>           At the end of a successful copy-back run innobackupex<br>           prints "completed OK!".<br>......<br>180729 23:32:08 completed OK!　　#看到completed OK就是恢复正常了<br>[root@slave ~]# ll /usr/local/mysql/data/　　#slave上查看数据目录，可以看到数据已经恢复，但是属主会有问题，需要进行修改，所以一般使用mysql的运行用户进行恢复，否则需要进行修改属主和属组信息<br>total 188432<br>-rw-r----- 1 root root 79691776 Jul 29 23:32 ibdata1<br>-rw-r----- 1 root root 50331648 Jul 29 23:32 ib_logfile0<br>-rw-r----- 1 root root 50331648 Jul 29 23:32 ib_logfile1<br>-rw-r----- 1 root root 12582912 Jul 29 23:32 ibtmp1<br>drwxr-x--- 2 root root       20 Jul 29 23:32 kim<br>drwxr-x--- 2 root root     4096 Jul 29 23:32 mysql<br>drwxr-x--- 2 root root     4096 Jul 29 23:32 performance_schema<br>drwxr-x--- 2 root root       20 Jul 29 23:32 repppp<br>drwxr-x--- 2 root root     4096 Jul 29 23:32 wordpress<br>-rw-r----- 1 root root      482 Jul 29 23:32 xtrabackup_info<br>[root@slave ~]# chown -R mysql.mysql /usr/local/mysql/data/　　#修改属主属组<br>[root@slave ~]# /etc/init.d/mysqld start　　#启动mysql<br>Starting MySQL. SUCCESS! <br>[root@slave ~]# mysql -uroot -p -e "show databases;"　　#查看数据，是否恢复<br>Enter password: <br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| kim                |<br>| mysql              |<br>| performance_schema |<br>| repppp             |<br>| wordpress          |<br>+--------------------+<br></code></pre></td></tr></table></figure><h4 id="总结全库备份与恢复三步曲：">总结全库备份与恢复三步曲：</h4><ul><li><strong>innobackupex全量备份，并指定备份目录路径；</strong></li><li><strong>在恢复前，需要使用–apply-log参数先进行合并数据文件，确保数据的一致性要求；</strong></li><li><strong>恢复时，直接使用–copy-back参数进行恢复，需要注意的是，在my.cnf中要指定数据文件目录的路径。</strong></li></ul><h1>三、xtrabackup增量备份与恢复</h1><p><strong>使用innobackupex进行增量备份，每个InnoDB的页面都会包含一个LSN信息，每当相关的数据发生改变，相关的页面的LSN就会自动增长。这正是InnoDB表可以进行增量备份的基础，即innobackupex通过备份上次完全备份之后发生改变的页面来实现。在进行增量备份时，首先要进行一次全量备份，第一次增量备份是基于全备的，之后的增量备份都是基于上一次的增量备份的，以此类推。</strong></p><p><strong>要实现第一次增量备份，可以使用下面的命令进行：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">基于全量备份的增量备份与恢复<br>做一次增量备份（基于当前最新的全量备份）<br>innobackupex --user&#x3D;root --password&#x3D;root --defaults-file&#x3D;&#x2F;etc&#x2F;my.cnf --incremental &#x2F;backups&#x2F; --incremental-basedir&#x3D;&#x2F;backups&#x2F;2018-07-30_11-01-37<br>1. 准备基于全量<br>innobackupex --user&#x3D;root --password&#x3D;root --defaults-file&#x3D;&#x2F;etc&#x2F;my.cnf --apply-log --redo-only &#x2F;backups&#x2F;2018-07-30_11-01-37<br>2. 准备基于增量<br>innobackupex --user&#x3D;root --password&#x3D;root --defaults-file&#x3D;&#x2F;etc&#x2F;my.cnf --apply-log --redo-only &#x2F;backups&#x2F;2018-07-30_11-01-37 --incremental-dir&#x3D;&#x2F;backups&#x2F;2018-07-30_13-51-47&#x2F;3. 恢复<br>innobackupex --copy-back --defaults-file&#x3D;&#x2F;etc&#x2F;my.cnf &#x2F;opt&#x2F;2017-01-05_11-04-55&#x2F;<br>解释：<br>1. 2018-07-30_11-01-37指的是完全备份所在的目录。2. 2018-07-30_13-51-47指定是第一次基于2018-07-30_11-01-37增量备份的目录，其他类似以此类推，即如果有多次增量备份。每一次都要执行如上操作。<br></code></pre></td></tr></table></figure><p><strong>需要注意的是，增量备份仅能应用于InnoDB或XtraDB表，对于MyISAM表而言，执行增量备份时其实进行的是完全备份。</strong></p><p><strong>&quot;准备&quot;(prepare)增量备份与整理完全备份有着一些不同，尤其要注意的是：</strong></p><ul><li><strong>需要在每个备份 (包括完全和各个增量备份)上，将已经提交的事务进行&quot;重放&quot;。&quot;重放&quot;之后，所有的备份数据将合并到完全备份上。</strong></li><li><strong>基于所有的备份将未提交的事务进行&quot;回滚&quot;</strong></li></ul><h2 id="1、增量备份演示"><strong>1、增量备份演示</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master backups]# innobackupex --user=root --password=123456 --host=127.0.0.1 /backups/   #全备数据[root@master ~]# mysql -uroot -p　　#在master上创建student库并创建testtb表插入若干数据Enter password: <br><span class="hljs-meta">mysql&gt;</span><span class="bash"> create database student;</span><br>Query OK, 1 row affected (0.03 sec)<br><br><span class="hljs-meta">mysql&gt;</span><span class="bash"> use student;</span><br>Database changed<br><span class="hljs-meta">mysql&gt;</span><span class="bash"> create table testtb(id int);</span><br>Query OK, 0 rows affected (0.07 sec)<br><br><span class="hljs-meta">mysql&gt;</span><span class="bash"> insert into testtb values(1),(10),(99);</span><br>Query OK, 3 rows affected (0.04 sec)<br>Records: 3  Duplicates: 0  Warnings: 0<br><br><span class="hljs-meta">mysql&gt;</span><span class="bash"> select * from testtb;</span><br>+------+<br>| id   |<br>+------+<br>|    1 |<br>|   10 |<br>|   99 |<br>+------+<br>3 rows in set (0.00 sec)<br><br><span class="hljs-meta">mysql&gt;</span><span class="bash"> quit;</span><br>Bye<br></code></pre></td></tr></table></figure><h2 id="2、使用innobackupex进行增量备份">2、使用innobackupex进行增量备份</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>[root@master backups]# innobackupex --user=root --password=123456 --host=127.0.0.1 --incremental /backups/ --incremental-basedir=/backups/2018-07-30_11-01-37/<br>......<br>180730 13:51:50 Executing UNLOCK TABLES<br>180730 13:51:50 All tables unlocked<br>180730 13:51:50 Backup created in directory '/backups/2018-07-30_13-51-47/'<br>MySQL binlog position: filename 'mysql-bin.000005', position '664'<br>180730 13:51:50 [00] Writing /backups/2018-07-30_13-51-47/backup-my.cnf<br>180730 13:51:50 [00]        ...done<br>180730 13:51:50 [00] Writing /backups/2018-07-30_13-51-47/xtrabackup_info<br>180730 13:51:50 [00]        ...done<br>xtrabackup: Transaction log of lsn (3158741) to (3158741) was copied.<br>180730 13:51:50 completed OK!<br>[root@master backups]# ll　　#查看备份数据<br>total 0<br>drwxr-x--- 7 root root 232 Jul 30 11:01 2018-07-30_11-01-37　　#全量备份数据目录<br>drwxr-x--- 8 root root 273 Jul 30 13:51 2018-07-30_13-51-47　　#增量备份数据目录<br>[root@master 2018-07-30_11-01-37]# cat xtrabackup_checkpoints #查看全量备份的xtrabackup_checkpoints<br>backup_type = full-backuped　　#备份类型为全量备份<br>from_lsn = 0　　#lsn从0开始<br>to_lsn = 3127097　　#lsn到3127097结束<br>last_lsn = 3127097<br>compact = 0<br>recover_binlog_info = 0<br><br>[root@master 2018-07-30_13-51-47]# cat xtrabackup_checkpoints 　　#查看增量备份的xtrabackup_checkpoints<br>backup_type = incremental　　#备份类型为增量备份<br>from_lsn = 3127097　　#lsn从3127097开始<br>to_lsn = 3158741　　  #lsn到啊3158741结束<br>last_lsn = 3158741　　<br>compact = 0<br>recover_binlog_info = 0<br></code></pre></td></tr></table></figure><h2 id="3、增量备份后数据恢复演示"><strong>3、增量备份后数据恢复演示</strong></h2><h3 id="（1）模拟mysql故障，删除数据目录所有数据">（1）模拟mysql故障，删除数据目录所有数据</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# /etc/init.d/mysqld stop　　#模拟mysql故障，停止mysql<br>Shutting down MySQL.. SUCCESS! <br>[root@master ~]# rm -rf /usr/local/mysql/data/*　　#删除数据目录中的所有数据<br></code></pre></td></tr></table></figure><h3 id="（2）合并全备数据目录，确保数据的一致性">（2）合并全备数据目录，确保数据的一致性</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# innobackupex --apply-log --redo-only /backups/2018-07-30_11-01-37/<br>180730 14:05:27 innobackupex: Starting the apply-log operation<br><br>IMPORTANT: Please check that the apply-log run completes successfully.<br>           At the end of a successful apply-log run innobackupex<br>           prints "completed OK!".<br><br>innobackupex version 2.4.9 based on MySQL server 5.7.13 Linux (x86_64) (revision id: a467167cdd4)<br>xtrabackup: cd to /backups/2018-07-30_11-01-37/<br>......<br>......<br>xtrabackup: starting shutdown with innodb_fast_shutdown = 1<br>InnoDB: Starting shutdown...<br>InnoDB: Shutdown completed; log sequence number 3127106<br>InnoDB: Number of pools: 1<br>180730 14:05:29 completed OK!<br></code></pre></td></tr></table></figure><h3 id="（3）将增量备份数据合并到全备数据目录当中">（3）将增量备份数据合并到全备数据目录当中</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# innobackupex --apply-log --redo-only /backups/2018-07-30_11-01-37/ --incremental-dir=/backups/2018-07-30_13-51-47/<br>180730 14:06:42 innobackupex: Starting the apply-log operation<br><br>IMPORTANT: Please check that the apply-log run completes successfully.<br>           At the end of a successful apply-log run innobackupex<br>           prints "completed OK!".<br>......<br>......<br>180730 14:06:44 [00]        ...done<br>180730 14:06:44 completed OK!<br>[root@master ~]# cat /backups/2018-07-30_11-01-37/xtrabackup_checkpoints <br>backup_type = log-applied　　#查看到数据备份类型是增加<br>from_lsn = 0　　#lsn从0开始<br>to_lsn = 3158741　　#lsn结束号为最新的lsn<br>last_lsn = 3158741<br>compact = 0<br>recover_binlog_info = 0<br></code></pre></td></tr></table></figure><h3 id="（4）恢复数据">（4）恢复数据</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# innobackupex --copy-back /backups/2018-07-30_11-01-37/<br>180730 14:07:51 innobackupex: Starting the copy-back operation<br><br>IMPORTANT: Please check that the copy-back run completes successfully.<br>           At the end of a successful copy-back run innobackupex<br>           prints "completed OK!".<br>.......<br>.......<br>180730 14:08:17 [01]        ...done<br>180730 14:08:17 completed OK!<br>[root@master ~]# ll /usr/local/mysql/data/<br>total 77844<br>-rw-r----- 1 root root 79691776 Jul 30 14:08 ibdata1<br>drwxr-x--- 2 root root       20 Jul 30 14:08 kim<br>drwxr-x--- 2 root root     4096 Jul 30 14:08 mysql<br>drwxr-x--- 2 root root     4096 Jul 30 14:08 performance_schema<br>drwxr-x--- 2 root root       20 Jul 30 14:08 repppp<br>drwxr-x--- 2 root root       56 Jul 30 14:08 student<br>drwxr-x--- 2 root root     4096 Jul 30 14:08 wordpress<br>-rw-r----- 1 root root       21 Jul 30 14:08 xtrabackup_binlog_pos_innodb<br>-rw-r----- 1 root root      554 Jul 30 14:08 xtrabackup_info<br>[root@master ~]# chown -R mysql.mysql /usr/local/mysql/data　　#更改数据的属主属组<br>[root@master ~]# /etc/init.d/mysqld start　　#启动mysql<br>Starting MySQL.Logging to '/usr/local/mysql/data/master.err'.<br>.. SUCCESS! <br>[root@master ~]# mysql -uroot -p -e "show databases;"　　#查看数据是否恢复<br>Enter password: <br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| kim                |<br>| mysql              |<br>| performance_schema |<br>| repppp             |<br>| student            |<br>| wordpress          |<br>+--------------------+<br></code></pre></td></tr></table></figure><h3 id="总结：">总结：</h3><ul><li><strong>增量备份需要使用参数–incremental指定需要备份到哪个目录，使用incremental-dir指定全备目录；</strong></li><li><strong>进行数据备份时，需要使用参数–apply-log redo-only先合并全备数据目录数据，确保全备数据目录数据的一致性；</strong></li><li><strong>再将增量备份数据使用参数–incremental-dir合并到全备数据当中；</strong></li><li><strong>最后通过最后的全备数据进行恢复数据，注意，如果有多个增量备份，需要逐一合并到全备数据当中，再进行恢复。</strong></li></ul><h2 id="方案一：xtrabackup完全备份-binlog增量备份">方案一：xtrabackup完全备份+binlog增量备份</h2><h2 id="1、备份-创建备份目录">1、备份 创建备份目录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /opt/mysqlbackup/&#123;full,inc&#125;<br></code></pre></td></tr></table></figure><p>**full：全备存放的目录；inc：增量备份存放的目录 **</p><h3 id="（1）完全备份">（1）完全备份</h3><p><a href="https://wsdlxgp.top/posts/af18.html"><em><strong>需要开启和设置二进制日志</strong></em></a></p><p><strong>基本语法：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">innobackupex --user=DBUSER --password=DBUSERPASS /path/to/BACKUP-DIR/<br></code></pre></td></tr></table></figure><p><strong>执行下面的命令进行完全备份：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> innobackupex --user=root --password=123 /opt/mysqlbackup/full</span><br></code></pre></td></tr></table></figure><p><strong>注： --defaults-file=/etc/my.cnf 指定mysql的配置文件my.cfg，如果指定则必须是第一个参数。</strong></p><p><strong>/path/to/BACKUP-DIR/指定备份所存放的目标目录，备份过程会创建一个以当时备份时间命名的目录存放备份文件。 出现如下提示。表示成功</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">200113 09:49:37 Backup created in directory '/opt/mysqlbackup/full/2020-01-13_09-<br>49-22'<br>200113 09:49:37 [00] Writing backup-my.cnf<br>200113 09:49:37 [00] ...done<br>200113 09:49:37 [00] Writing xtrabackup_info<br>200113 09:49:37 [00] ...done<br>xtrabackup: Transaction log of lsn (67343410) to (67343419) was copied.<br>200113 09:49:37 completed OK!<br></code></pre></td></tr></table></figure><p><strong>备份后的文件： 在备份的同时，备份数据会在备份目录下创建一个以当前日期时间为名字的目录存放备份文件：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# cd /opt/mysqlbackup/full/<br>[root@localhost full]#<br>[root@localhost full]# ll<br>total 4<br>drwxr-x---. 12 root root 4096 Jan 13 09:49 2020-01-13_09-49-22<br>[root@localhost full]# ll 2020-01-13_09-49-22/<br>total 77892<br>-rw-r-----. 1 root root 425 Jan 13 09:49 backup-my.cnf<br>-rw-r-----. 1 root root 115 Jan 13 09:49 xtrabackup_checkpoints<br>-rw-r-----. 1 root root 431 Jan 13 09:49 xtrabackup_info<br>-rw-r-----. 1 root root 2560 Jan 13 09:49 xtrabackup_logfile<br></code></pre></td></tr></table></figure><h4 id="各文件说明：">各文件说明：</h4><ul><li><strong>xtrabackup_checkpoints ——备份类型（如完全或增量）、备份状态（如是否已经为prepared状态）和LSN(日志序列号)范围信息； 每个InnoDB页(通常为16k大小)都会包含一个日志序列号，即LSN。LSN是整个数据库系统的系统版本号，每个页面相关的LSN能够表明此页面最近是如何发生改变的。</strong></li><li><strong>xtrabackup_binlog_info —— mysql服务器当前正在使用的二进制日志文件及至备份这一刻为止二进制日志事件的位置。</strong></li><li><strong>xtrabackup_binlog_pos_innodb ——二进制日志文件及用于InnoDB或XtraDB表的二进制日志文件的当前position。</strong></li><li><strong>xtrabackup_binary ——备份中用到的xtrabackup的可执行文件；</strong></li><li><strong>backup-my.cnf ——备份命令用到的配置选项信息；</strong></li><li><ul><li><strong>在使用innobackupex进行备份时，还可以使用–no-timestamp选项来阻止命令自动创建一个以时间命名的目录；如此一来，innobackupex命令将会创建一个BACKUP-DIR目录来存储备份数据</strong></li></ul></li></ul><blockquote><p><strong>注意：相关选项说明： 其中，</strong></p><p><strong>–user指定连接数据库的用户名，</strong></p><p><strong>–password指定连接数据库的密码，</strong></p><p><strong>–defaults-file指定数据库的配置文件，innobackupex要从其中获取datadir等信息；</strong></p><p><strong>–database指定要备份的数据库，这里指定的数据库只对MyISAM表有效，对于InnoDB 数据来说都是全备（所有数据库中的InnoDB数据都进行了备份，不是只备份指定的数据库，恢复时也一样）；</strong></p><p><strong>/opt/mysqlbackup/full是备份文件的存放位置。</strong></p></blockquote><p><strong>注意：备份数据库的用户需要具有相应权限，如果要使用一个最小权限的用户进行备份，则可基于如下命令创建此类用户：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE USER &#39;bkpuser&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;　　#创建用户<br>mysql&gt; REVOKE ALL PRIVILEGES ON *.*  FROM &#39;bkpuser&#39;@&#39;localhost&#39;;　　#回收此用户所有权限<br>mysql&gt; GRANT RELOAD,LOCK TABLES,RELICATION CLIENT ON *.* TO &#39;bkpuser&#39;@&#39;localhost&#39;;　　#授权刷新、锁定表、用户查看服务器状态<br>mysql&gt; FLUSH PRIVILEGES;　　#刷新授权表<br></code></pre></td></tr></table></figure><p><strong>至此全备完全成功，然后向mysql某个库插入几条数据，然后进行增量备份 对完全备份的后数据库更改进行二进制日志增量备份：</strong></p><h4 id="模拟数据库修改：">模拟数据库修改：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create database tb1;<br>Query OK, 1 row affected (0.00 sec)<br><br>mysql&gt; use tb1;<br>Database changed<br><br>mysql&gt; create table tom1(qq int(10));<br>Query OK, 0 rows affected (0.01 sec)<br><br>mysql&gt; create table tom2(qq int(10));<br>Query OK, 0 rows affected (0.01 sec)<br><br>mysql&gt; insert into tb1.tom1 values (3);<br>Query OK, 1 row affected (0.00 sec)<br><br>mysql&gt; insert into tb1.tom2 values (4);<br>Query OK, 1 row affected (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（2）增量备份二进制文件：">（2）增量备份二进制文件：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# mysqlbinlog --start-position=2378 /usr/local/mysql/data/mysql_bin_log.000001 &gt; /opt/mysqlbackup/inc/`date +%F`.sql<br></code></pre></td></tr></table></figure><h2 id="2、还原数据库：-模拟数据库损坏：-我这里直接使用删除数据目录文件来模拟损坏">2、还原数据库： 模拟数据库损坏： 我这里直接使用删除数据目录文件来模拟损坏</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# rm -fr /usr/local/mysql/data/*<br></code></pre></td></tr></table></figure><h3 id="还原完全备份：">还原完全备份：</h3><h3 id="（1）准备-prepare-一个完全备份">（1）准备(prepare)一个完全备份</h3><p><strong>一般情况下，在备份完成后，数据尚且不能用于恢复操作，</strong><br><strong>因为备份的数据中可能会包含尚未提交的事务或已经提交但尚未同步至数据文件中的事务。因此，此时数据文件仍处理不一致状态。“准备”的主要作用正是通过回滚未提交的事务及同步已经提交的事务至数据文件也使得数据文件处于一致性状态。 在准备（prepare）过程结束后，InnoDB表数据已经前滚到整个备份结束的点，而不是回滚到xtrabackup刚开始时的点。 innobakupex命令的–apply-log选项可用于实现上述功能。</strong></p><p><strong>如下面的命令： --apply-log指明是将日志应用到数据文件上，完成之后将备份文件中的数据恢复到数据库中：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# innobackupex --apply-log /opt/mysqlbackup/full/2020-06-28_17-55-31/<br></code></pre></td></tr></table></figure><p><strong>注：/opt/mysqlbackup/full/2020-06-28_17-55-31/备份文件所在目录名称 如果执行正确，其最后输出的几行信息通常如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">InnoDB: FTS optimize thread exiting.<br>InnoDB: Starting shutdown...<br>InnoDB: Shutdown completed; log sequence number 2598952<br>200628 18:01:23 completed OK!<br></code></pre></td></tr></table></figure><p><strong>在实现“准备”的过程中，innobackupex通常还可以使用–use-memory选项来指定其可以使用的内存的大小，默认通常为100M。如果有足够的内存可用，可以多划分一些内存给prepare的过程，以提高其完成速度。</strong></p><p><strong>innobackupex命令的–copy-back选项用于执行恢复操作，其通过复制所有数据相关的文件至mysql服务器DATADIR目录中来执行恢复过程。innobackupex通过backup-my.cnf来获取DATADIR目录的相关信息。</strong></p><h3 id="（2）还原数据库语法：">（2）还原数据库语法：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> innobackupex --copy-back /opt/mysqlbackup/full/2020-06-28_17-55-31/</span><br></code></pre></td></tr></table></figure><p><strong>这里的–copy-back指明是进行数据恢复。数据恢复完成之后，需要修改相关文件的权限mysql数据库才能正常启动。 如果执行正确，其输出信息的最后几行通常如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">200628 18:04:29 [01] Copying ./ibtmp1 to /usr/local/mysql/data/ibtmp1<br>200628 18:04:29 [01]        ...done<br>200628 18:04:29 completed OK!<br></code></pre></td></tr></table></figure><p><strong>请确保如上信息的最行一行出现“completed OK!”。</strong></p><h4 id="修改还原后的数据目录权限">修改还原后的数据目录权限:</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# ll /usr/local/mysql/data/<br>总用量 122916<br>-rw-r----- 1 root root      258 Jun 28 18:04 ib_buffer_pool<br>-rw-r----- 1 root root 12582912 Jun 28 18:04 ibdata1<br>-rw-r----- 1 root root 50331648 Jun 28 18:04 ib_logfile0<br>-rw-r----- 1 root root 50331648 Jun 28 18:04 ib_logfile1<br>-rw-r----- 1 root root 12582912 Jun 28 18:04 ibtmp1<br>drwxr-x--- 2 root root     4096 Jun 28 18:04 mysql<br>drwxr-x--- 2 root root     8192 Jun 28 18:04 performance_schema<br>drwxr-x--- 2 root root     8192 Jun 28 18:04 sys<br>drwxr-x--- 2 root root       84 Jun 28 18:04 tb1<br>drwxr-x--- 2 root root       20 Jun 28 18:04 test2<br>drwxr-x--- 2 root root      248 Jun 28 18:04 testdb<br>drwxr-x--- 2 root root       20 Jun 28 18:04 testqq<br>drwxr-x--- 2 root root       20 Jun 28 18:04 xgp<br>-rw-r----- 1 root root      481 Jun 28 18:04 xtrabackup_info<br></code></pre></td></tr></table></figure><p><strong>当数据恢复至DATADIR目录以后，还需要确保所有数据文件的属主和属组均为正确的用户，如mysql，否则，在启动mysqld之前还需要事先修改数据文件的属主和属组。如：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# chown -R mysql:mysql /usr/local/mysql/data/<br></code></pre></td></tr></table></figure><p><strong>必须重启MySQL：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# systemctl restart mysqld<br></code></pre></td></tr></table></figure><p><strong>验证还原后的数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; use tb1<br>Database changed<br><br>mysql&gt; show tables;<br>+---------------+<br>| Tables_in_tb1 |<br>+---------------+<br>| tom1          |<br>| tom2          |<br>+---------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（3）还原增量备份：-为了防止还原时产生大量的二进制日志，在还原时可临时关闭二进制日志后再还原：">（3）还原增量备份： 为了防止还原时产生大量的二进制日志，在还原时可临时关闭二进制日志后再还原：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; set sql_log_bin&#x3D;0;<br>mysql&gt; source &#x2F;opt&#x2F;mysqlbackup&#x2F;inc&#x2F;2020-06-28.sql<br></code></pre></td></tr></table></figure><p><strong>或者在命令行：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql –uroot –p &lt; &#x2F;opt&#x2F;mysqlbackup&#x2F;inc&#x2F;2016-09-12.sql<br>mysqlbinlog &#x2F;opt&#x2F;mysqlbackup&#x2F;inc&#x2F;2016-09-12.sql | mysql –uroot -p<br></code></pre></td></tr></table></figure><p><strong>重新启动二进制日志并验证还原数据：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">mysql&gt; <span class="hljs-builtin-name">set</span> <span class="hljs-attribute">sql_log_bin</span>=1;<br></code></pre></td></tr></table></figure><p><strong>验证数据是否恢复回来</strong></p><h1>方案二、xtrabackup完全备份+xtrabacup增量备份</h1><p><strong>前面我们进行增量备份时，使用的还是老方法：备份二进制日志。其实xtrabackup还支持进行增量备份。 先介绍下xtrabackup的备份原理 在InnoDB内部会维护一个redo日志文件，我们也可以叫做事务日志文件（transaction log，事务日志）。事务日志会存储每一个InnoDB表数据的记录修改。当InnoDB启动时，InnoDB会检查数据文件和事务日志，并执行两个步骤：它应用已经提交的事务日志到数据文件，并将修改过但没有提交的数据进行回滚操作。 xtrabackup在启动时会记住log sequence number（LSN），并且复制所有的数据文件。复制过程需要一些时间，所以这期间如果数据文件有改动，那么将会使数据库处于一个不同的时间点。这时，xtrabackup会运行一个后台进程，用于监视事务日志，并从事务日志复制最新的修改。xtrabackup必须持续的做这个操作，是因为事务日志是会轮转重复的写入，并且事务日志可以被重用。所以xtrabackup自启动开始，就不停的将事务日志中每个数据文件的修改都记录下来。这就是xtrabackup的备份过程</strong></p><p><strong>所以每个InnoDB的页面都会包含一个LSN信息，每当相关的数据发生改变，相关的页面的LSN就会自动增长。这正是InnoDB表可以进行增量备份的基础。 xtraBackup基于InnoDB的crash-recovery功能。它会复制innodb的data file，由于不锁表，复制出来的数据是不一致的，在恢复的时候使用crash-recovery，使得数据恢复一致。当InnoDB启动的时候，它会先去检查data file和transaction log，并且会做二步操作： <a href="http://1.It" target="_blank" rel="noopener">1.It</a> applies committed transaction logentries to the data files <a href="http://2.it" target="_blank" rel="noopener">2.it</a> performs an undo operation on anytransactions that modified data but did not commit. 所以在prepare过程中，XtraBackup使用复制到的transactions log对备份出来的innodb data file进行crash recovery。 测试环境准备 创建一个测试数据库，并创建一张表输入几行数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create database test;<br>mysql&gt; use test;<br>mysql&gt; create table xx(id int,name varchar(20));<br>mysql&gt; insert into xx values(1,&#39;tom1&#39;);<br>mysql&gt; insert into xx values(2,&#39;tom2&#39;);<br></code></pre></td></tr></table></figure><h2 id="1、-xtrabacup进行备份-执行完全备份：-备份命令：">1、 xtrabacup进行备份 执行完全备份： 备份命令：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># xtrabackup --defaults-file&#x3D;&#x2F;etc&#x2F;my.cnf --user&#x3D;root --password&#x3D;&quot;123456&quot; --port&#x3D;3306 --backup --target-dir&#x3D;&#x2F;opt&#x2F;mysqlbackup&#x2F;full&#x2F;full_incre_$(date+%Y%m%d_%H%M%S)<br></code></pre></td></tr></table></figure><h4 id="部分显示信息如下所示：">部分显示信息如下所示：</h4><ul><li><p><strong>–defaults-file指定数据库的配置文件，如果使用该参数必须做为第一个参数；</strong></p></li><li><p><strong>–user指定连接数据库的用户名；</strong></p></li><li><p><strong>–password指定连接数据库的密码；</strong></p></li><li><p><strong>–port指定连接数据库的端口号；</strong></p></li><li><p><strong>–backup 实施备份到target-dir;</strong></p></li><li><p><strong>–target-dir=name 备份文件的存放目录路径。innobackupex要从其中获取datadir等信息；</strong></p></li><li><p><strong>–database指定要备份的数据库，这里指定的数据库只对MyISAM表和InnoDB表的表结构有效，对于InnoDB 数据来说都是全备（所有数据库中的InnoDB数据都进行了备份，不是只备份指定的数据库，恢复时也一样）；</strong></p></li><li><p><strong>/opt/mysqlbackup/full/是备份文件的存放位置。 查看完全备份文件</strong></p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# ls /opt/mysqlbackup/full/ -l<br>drwxr-x---. 8 root root 4096 Sep 12 22:11 full_incre_20160912_221111<br></code></pre></td></tr></table></figure><p><strong>xtrabackup进行增量备份 先录入些数据，实现第一次增量数据：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; use test;<br>mysql&gt; insert into xx values(3,&#39;tom3&#39;);<br>再进行增量备份1<br>备份命令：<br># xtrabackup --defaults-file&#x3D;&#x2F;etc&#x2F;my.cnf --user&#x3D;root --password&#x3D;&quot;123456&quot; --port&#x3D;3306 --backup --target-dir&#x3D;&#x2F;opt&#x2F;mysqlbackup&#x2F;inc&#x2F;incre_$(date +%Y%m%d_%H%M%S) --incremental-basedir&#x3D;&#x2F;opt&#x2F;mysqlbackup&#x2F;full&#x2F;full_incre_20160912_221111&#x2F;<br></code></pre></td></tr></table></figure><p><strong>其中，–incremental-basedir指定上次完整备份或者增量备份文件的位置(即如果是第一次增量备份则指向完全备份所在目录，在执行过增量备份之后再一次进行增量备份时，其–incremental-basedir应该指向上一次的增量备份所在的目录)。 查看增量备份文件：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@localhost ~]# ls -l &#x2F;opt&#x2F;mysqlbackup&#x2F;inc&#x2F;<br>drwxr-x---. 8 root root 4096 Sep 12 22:15 incre_20160912_221510<br>注：<br>这里的增量备份其实只针对的是InnoDB，对于MyISAM来说，还是完整备份。<br>向表中再插入几行数据，继续第二次增量备份<br>mysql&gt; use test;<br>mysql&gt; insert into xx values(4,&#39;tom4&#39;);<br>mysql&gt; commit;<br>进行第二次增量备份<br>备份命令：<br># xtrabackup --defaults-file&#x3D;&#x2F;etc&#x2F;my.cnf --user&#x3D;root --password&#x3D;&quot;123456&quot; --<br>port&#x3D;3306 --backup --target-dir&#x3D;&#x2F;opt&#x2F;mysqlbackup&#x2F;inc&#x2F;incre_$(date +%Y%m%d_%H%M%S)<br>--incremental-basedir&#x3D;&#x2F;opt&#x2F;mysqlbackup&#x2F;inc&#x2F;incre_20160912_221510&#x2F;<br></code></pre></td></tr></table></figure><p><strong>注：第二次增量备份–incremental-basedir指向上一次增量备份文件的位置。 查看增量备份文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@localhost ~]# ls -l &#x2F;opt&#x2F;mysqlbackup&#x2F;inc&#x2F;<br>drwxr-x---. 8 root root 4096 Sep 12 22:15 incre_20160912_221510<br>drwxr-x---. 8 root root 4096 Sep 12 22:19 incre_20160912_221916<br></code></pre></td></tr></table></figure><h2 id="2、-xtrabacup进行增量恢复-为了验证比对，先删除两个增量备份前表里面的数据">2、 xtrabacup进行增量恢复 为了验证比对，先删除两个增量备份前表里面的数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; use test;<br>mysql&gt; delete from xx where id&#x3D;3;<br></code></pre></td></tr></table></figure><h4 id="完整备份恢复：">**完整备份恢复： **</h4><p><strong>在进行恢复前，如果完整备份在远程主机上，首先将完整备份复制到本地主机上，如果是tar包，则需要先解包，解包命令为：tar –izxf xxx.tar，这里必须使用-i参数（忽略存档中的 0 字节块（通常意味着文件结束））。 开始全备份恢复 命令如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> xtrabackup --defaults-file=/etc/my.cnf --prepare --user=root --password=<span class="hljs-string">"123456"</span> --apply-log-only --target-dir=/opt/mysqlbackup/full/full_incre_20160912_221111/</span><br></code></pre></td></tr></table></figure><h4 id="恢复到第一次增量的时刻">**恢复到第一次增量的时刻 **</h4><p>**增量备份恢复的步骤和完整备份恢复的步骤基本一致，只是应用日志的过程稍有不同。增量备份恢复时，是先将所有的增量备份挨个应用到完整备份的数据文件中，然后再将完整备份中的数据恢复到数据库中。 恢复命令：  **</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> xtrabackup --defaults-file=/etc/my.cnf --prepare --user=root --password=<span class="hljs-string">"123456"</span> --apply-log-only --target-dir=/opt/mysqlbackup/full/full_incre_20160912_221111/ --incremental-dir=/opt/mysqlbackup/inc/incre_20160912_221510/</span><br></code></pre></td></tr></table></figure><h4 id="恢复到第二次增量备份前面：-恢复命令"><strong>恢复到第二次增量备份前面： 恢复命令</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># xtrabackup --defaults-file&#x3D;&#x2F;etc&#x2F;my.cnf --prepare --user&#x3D;root --password&#x3D;&quot;123456&quot; --apply-log-only --target-dir&#x3D;&#x2F;opt&#x2F;mysqlbackup&#x2F;full&#x2F;full_incre_20160912_221111&#x2F; --incremental-dir&#x3D;&#x2F;opt&#x2F;mysqlbackup&#x2F;inc&#x2F;incre_20160912_221916&#x2F;<br></code></pre></td></tr></table></figure><h4 id="恢复整个库-恢复命令：">恢复整个库 恢复命令：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> xtrabackup --defaults-file=/etc/my.cnf --prepare --user=root --password=<span class="hljs-string">"123456"</span> --target-dir=/opt/mysqlbackup/full/full_incre_20160912_221111/</span><br></code></pre></td></tr></table></figure><h4 id="然后停止mysql数据库：">然后停止mysql数据库：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# systemctl stop mysqld<br></code></pre></td></tr></table></figure><h4 id="开始rsync数据文件：">开始rsync数据文件：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># cd &#x2F;opt&#x2F;mysqlbackup&#x2F;full&#x2F;full_incre_20160912_221111&#x2F;<br>#rsync -rvt --exclude &#39;xtrabackup_checkpoints&#39; --exclude &#39;xtrabackup_logfile&#39; .&#x2F; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;<br></code></pre></td></tr></table></figure><p><strong>当数据恢复至DATADIR目录以后，还需要确保所有数据文件的属主和属组均为正确的用户，如mysql，否则，在启动mysqld之前还需要事先修改数据文件的属主和属组。 授予mysql访问权限：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> chown -R mysql:mysql /usr/<span class="hljs-built_in">local</span>/mysql/data/</span><br></code></pre></td></tr></table></figure><h4 id="启动mysql服务：">启动mysql服务：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># systemctl start mysqld<br></code></pre></td></tr></table></figure><p><strong>验证 登录mysql，看到以前在备份之后删除的数据已经通过2次增量备份恢复过来了，如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# mysql -uroot -p123456 -e "select * from test.xx"<br>+------+------+<br>| id | name |<br>+------+------+<br>| 1 | tom1 |<br>| 2 | tom2 |<br>| 3 | tom3 |<br>| 4 | tom4 |<br>+------+------+<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#备份：<br>innobackupex --user&#x3D;DBUSER --password&#x3D;DBUSERPASS --defaults-file&#x3D;&#x2F;etc&#x2F;my.cnf &#x2F;path&#x2F;to&#x2F;BACKUP-DIR&#x2F;<br><br>#恢复：<br>innobackupex --apply-log &#x2F;backups&#x2F;2018-07-30_11-04-55&#x2F;<br>innobackupex --copy-back --defaults-file&#x3D;&#x2F;etc&#x2F;my.cnf  &#x2F;backups&#x2F;2018-07-30_11-04-55&#x2F;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 预处理全量备份<br>innobackupex --apply-log --redo-only &#x2F;backups&#x2F;2020-06-28_17-24-29&#x2F;<br># 把增量备份合并到全量备份<br>innobackupex --apply-log --redo-only &#x2F;backups&#x2F;2020-06-28_17-24-29&#x2F; --incremental-dir&#x3D;&#x2F;backups&#x2F;2020-06-28_17-29-29&#x2F;<br># 用全量备份恢复<br>innobackupex --user&#x3D;root --password&#x3D;1234 --copyback &#x2F;backups&#x2F;2020-06-28_17-24-29&#x2F;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;一、Xtrabackup介绍&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;MySQL冷备、mysqldump、MySQL热拷贝都无法实现对数据库进行增量备份。在实际生产环境中增量备份是非常实用的，如果数据大于50G或100G，存储空间足够的情况下，可以每天进行完整备份，如果每天产生的
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://wsdlxgp.top/categories/mysql/"/>
    
    
      <category term="MySQL优化" scheme="https://wsdlxgp.top/tags/MySQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>mysqldump备份还原</title>
    <link href="https://wsdlxgp.top/posts/49et.html"/>
    <id>https://wsdlxgp.top/posts/49et.html</id>
    <published>2020-06-23T16:02:00.000Z</published>
    <updated>2020-06-28T11:05:30.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mysqldump备份结合binlog日志恢复">mysqldump备份结合binlog日志恢复</h2><p><strong>MySQL备份一般采取全库备份加日志备份的方式，例如每天执行一次全备份，每小时执行一次二进制日志备份。这样在MySQL故障后可以使用全备份和日志备份将数据恢复到最后一个二进制日志备份前的任意位置或时间。</strong></p><h1>一、binlog介绍</h1><p><strong>mysql的二进制日志记录着该数据库的所有增删改的操作日志(前提是要在自己的服务器上开启binlog)，还包括了这些操作的执行时间。为了显示这些二进制内容，我们可以使用mysqlbinlog命令来查看。 Binlog的用途</strong></p><ul><li><strong>主从同步</strong></li><li><strong>恢复数据库</strong></li></ul><p><strong>开启binary log功能 通过编辑my.cnf中的log-bin选项可以开启二进制日志；形式如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">log-bin[=DIR/[filename]]<br></code></pre></td></tr></table></figure><p>**（配置文件中只写log_bin不写后面的文件名和路径时，默认存放在/usr/local/mysql/data目录下，文件名为主机名-bin.000001…命名）其中，DIR参数指定二进制文件的存储路径；filename参数指定二级制文件的文件名，其形式为filename.number，number的形式为000001、000002等。每次重启mysql服务或运行mysql&gt; flush logs;都会生成一个新的二进制日志文件，这些日志文件的number会不断地递增。除了生成上述的文件外还会生成一个名为filename.index的文件。这个文件中存储所有二进制日志文件的清单又称为二进制文件的索引 配置保存以后重启mysql的服务器，用mysql&gt; show variables like ‘log_bin’;查看bin-log是否开启，如图： **</p><p><strong>查看产生的binary log 注：查看binlog内容是为了恢复数据 bin-log因为是二进制文件，不能通过文件内容查看命令直接打开查看，mysql提供两种方式查看方式，在介绍之前，我们先对数据库进行一下增删改的操作，否则log里边数据有点空。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#mysql -uroot -p -e &quot;reset master&quot;&#x2F;&#x2F; 清空所有的二进制文件，从00001开始<br>#mysql -uroot -p -e &quot;create database test&quot;<br>#mysql -uroot -p -e &quot;use test;create table tb1(id int primary key<br>auto_increment,name varchar(20))&quot;<br>#mysql -uroot -p -e &quot;insert into test.tb1(name) values(&#39;lisi&#39;)&quot;<br>#mysql -uroot -p -e &quot;insert into test.tb1(name) values(&#39;zhangsan&#39;)&quot;<br></code></pre></td></tr></table></figure><h4 id="重新开始一个新的日志文件"><strong>重新开始一个新的日志文件</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#mysql -uroot -p -e &quot;flush logs&quot;<br>#mysql -uroot -p -e &quot;delete from test.tb1 where id&#x3D;2&quot;<br>#mysql -uroot -p -e &quot;insert into test.tb1(name) values(&#39;tom&#39;)&quot;<br># mysql -uroot -p -e &quot;select * from test.tb1&quot;<br>Enter password:<br>+----+------+<br>| id | name |<br>+----+------+<br>| 1 | lisi |<br>| 3 | tom |<br>+----+------+<br></code></pre></td></tr></table></figure><p><strong>查看MySQL Server上的二进制日志</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show binary logs;<br>+------------------+-----------+<br>| Log_name | File_size |<br>+------------------+-----------+<br>| mysql-bin.000001 | 1087 |<br>| mysql-bin.000002 | 673 |<br>+------------------+-----------+<br></code></pre></td></tr></table></figure><h4 id="查看二进制日志信息的命令：">查看二进制日志信息的命令：</h4><h5 id="语法格式："><strong>语法格式：</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW BINLOG EVENTS[IN &#39;log_name&#39;] [FROM pos] [LIMIT [offset,] row_count]<br></code></pre></td></tr></table></figure><h5 id="查看二进制日志中的事件"><strong>查看二进制日志中的事件</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show binlog events;<br></code></pre></td></tr></table></figure><p><strong>默认显示可找到的第一个二进制日志文件中的事件，包含了日志文件名、事件的开始位置、事件类型、结束位置、信息等内容</strong></p><h4 id="具体操作请查看该网址">具体操作请查看<a href="https://wsdlxgp.top/posts/af18.html">该网址</a></h4><h1>二、mysqldump介绍</h1><p><strong>mysqldump是mysql用于备份和数据转移的一个工具。它主要产生一系列的SQL语句，可以封装到文件，该文件包含有所有重建你的数据库所需要的 SQL命令如CREATE DATABASE，CREATE TABLE，INSERT等等。可以用来实现轻量级的快速迁移或恢复数据库。 mysqldump 是将数据表导成 SQL 脚本文件，在不同的 MySQL 版本之间升级时相对比较合适，这也是最常用的备份方法。 mysqldump一般在数据量很小的时候（几个G）可以用于备份。当数据量比较大的情况下，就不建议用mysqldump工具进行备份了。 数据库的导出 导出对象说明：mysqldump可以针对单个表、多个表、单个数据库、多个数据库、所有数据库进行导出的操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># mysqldump [options] db_name [tbl_name ...] <br>&#x2F;&#x2F;导出指定数据库或单个表 <br># mysqldump [options] --databases db_name ... <br>&#x2F;&#x2F;导出多个数据库 <br>#mysqldump [options] --all-databases <br>&#x2F;&#x2F;导出所有 导出数据库test <br># mysqldump -uroot -p --flush-logs test &gt; &#x2F;opt&#x2F;test.sql <br>&#x2F;&#x2F;--flush-logs这个选项就会完整备份的时候<br>重新开启一个新binlog<br></code></pre></td></tr></table></figure><h1>实例一</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">----------------------------------------------------------------<br>truetrueMySQL数据库备份<br>----------------------------------------------------------------<br># 备份指定数据库<br>[root@192 ~]# mysqldump -uroot -p --databases ttt &gt;&#x2F;opt&#x2F;ttt_all.sql<br># 备份数据库并且压缩<br>[root@192 ~]# mysqldump -uroot -p --databases ttt|gzip &gt;&#x2F;opt&#x2F;ttt_all.sql.gz<br># 备份同个库多个表<br>[root@192 ~]# mysqldump -uroot -p ttt demo student &gt;&#x2F;opt&#x2F;ttt_demo_student.sql<br># 同时备份多个库<br>[root@192 ~]# mysqldump -uroot -p --databases ttt myschool &gt;&#x2F;opt&#x2F;db_ttt_myschool.sql<br># 备份实例上所有的数据库<br>[root@192 ~]# mysqldump -uroot -p --opt --all-databases &gt;&#x2F;opt&#x2F;db_all.sql<br># 备份数据库结构，不备份数据<br>[root@192 ~]# mysqldump --no-data -uroot -p --databases ttt &gt;&#x2F;opt&#x2F;no_data_ttt.sql<br><br>----------------------------------------------------------------<br>truetrueMySQL数据库还原<br>----------------------------------------------------------------<br># 恢复到指定数据库(数据库必须事先存在)<br>[root@192 ~]# mysql -uroot -p ttt &lt;&#x2F;opt&#x2F;ttt_all.sql<br># 还原压缩的MySQL数据备份文件<br>[root@192 ~]# gunzip &lt;&#x2F;opt&#x2F;new_ttt_all.sql |mysql -uroot -p ttt<br># 使用source导入sql文件<br>source &#x2F;data&#x2F;cmdb_backup.sql<br></code></pre></td></tr></table></figure><h1>实例二</h1><p><strong>在前面我们介绍了mysql的binlog和mysqldump工具，下面我们来学习如何实现mysqldump全库备份+binlog的数据恢复 环境准备与备份还原：检查开启binlog 先创建一些原始数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; reset master;<br>mysql&gt; create database test_db;<br>mysql&gt; use test_db;<br>mysql&gt; create table tb1(id int primary key auto_increment,name varchar(20));<br>mysql&gt; insert into tb1(name) values(&#39;tom1&#39;);<br>mysql&gt; insert into tb1(name) values(&#39;tom2&#39;);<br>mysql&gt; commit;<br>mysql&gt; select * from tb1;<br>+----+------+<br>| id | name |<br>+----+------+<br>| 1 | tom1 |<br>| 2 | tom2 |<br>+----+------+<br></code></pre></td></tr></table></figure><h2 id="方案：mysqldump全库备份-binlog还原">方案：mysqldump全库备份+binlog还原</h2><h3 id="1、mysqldump备份方案：">1、mysqldump备份方案：</h3><p><strong>每周一凌晨1点全库备份</strong></p><h3 id="2、备份步骤">2、备份步骤</h3><h4 id="（1）-创建备份目录">（1） 创建备份目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># mkdir &#x2F;opt&#x2F;mysqlbackup<br># mkdir &#x2F;opt&#x2F;mysqlbackup&#x2F;daily<br></code></pre></td></tr></table></figure><h4 id="（2）全库备份-这里我们模拟周一的完整备份数据库任务">（2）全库备份 这里我们模拟周一的完整备份数据库任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#mysqldump -uroot -p --flush-logs test_db &gt; &#x2F;opt&#x2F;mysqlbackup&#x2F;test_db_2016_09_12.sql（test_db_&#96;date +%Y%m%d_%H%M%S&#96;）<br>[root@localhost data]# ls -l &#x2F;opt&#x2F;mysqlbackup&#x2F;<br>-rw-r--r--. 1 root root 1871 Sep 13 21:06 test_db_2016_09_12.sql<br></code></pre></td></tr></table></figure><p><strong>备份mysqldump全库备份之前的binlog日志文（注：生产环境中可能不只一个binlog文件）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># cp &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;mysql-bin.000001 &#x2F;opt&#x2F;mysqlbackup&#x2F;daily&#x2F;<br># mysql -uroot -p -e &quot;purge binary logs to &#39;mysql-bin.000002&#39;&quot;<br></code></pre></td></tr></table></figure><h3 id="3、模拟下操作失误-将数据修改错误了。">3、模拟下操作失误,将数据修改错误了。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; use test_db;<br>mysql&gt; delete from tb1 where id&#x3D;1;<br>mysql&gt; commit;<br>mysql&gt; insert into tb1(name) values(&#39;tom3&#39;);<br>mysql&gt; commit;<br></code></pre></td></tr></table></figure><p><strong>备份自mysqldump之后的binlog日志文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">cp &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;mysql-bin.000002 &#x2F;opt&#x2F;mysqlbackup&#x2F;daily&#x2F;<br></code></pre></td></tr></table></figure><p><strong>上面的模拟的误操作是删除了id=1的记录</strong></p><h3 id="4、现在我们使用mysqldump的全库备份和binlog来恢复数据。-使用mysqldump的备份进行全库恢复">4、现在我们使用mysqldump的全库备份和binlog来恢复数据。 使用mysqldump的备份进行全库恢复</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># mysql -uroot -p test_db &lt; &#x2F;opt&#x2F;mysqlbackup&#x2F;test_db_2016_09_12.sql<br></code></pre></td></tr></table></figure><p><strong>查询一下数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@localhost ~]# mysql -uroot -p -e &quot;select * from test_db.tb1&quot;<br>Enter password:<br>+----+------+<br>| id | name |<br>+----+------+<br>| 1 | tom1 |<br>| 2 | tom2 |<br>+----+------+<br></code></pre></td></tr></table></figure><p><strong>从显示结果可以看到使用mysqldump备份将数据还原到了备份时的状态，刚才删除的数据（id=2）恢复回来了，但备份后产生的数据却丢失了所以还得利用binlog进一步还原 因为删除是在全库备份后发生的，而mysqldump全库备份时使用–flush-logs选项，所以只需要分析全库备份后的binlog即mysql-bin.000002。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show binary logs;<br>+------------------+-----------+<br>| Log_name | File_size |<br>+------------------+-----------+<br>| mysql-bin.000002 | 1853 |<br>+------------------+-----------+<br></code></pre></td></tr></table></figure><p><strong>查看mysql-bin.000002中的事件，可以看到有删除事件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show binlog events in &#39;mysql-bin.000002&#39;;<br>| mysql-bin.000002 | 219 | Query | 1 | 294 | BEGIN<br>|<br>| mysql-bin.000002 | 294 | Table_map | 1 | 346 | table_id:<br>118 (test_db.tb1)<br>|<br>| mysql-bin.000002 | 346 | Delete_rows | 1 | 391 | table_id:<br>118 flags: STMT_END_F<br>|<br>| mysql-bin.000002 | 391 | Xid | 1 | 422 | COMMIT &#x2F;*<br>xid&#x3D;2739 *&#x2F;<br></code></pre></td></tr></table></figure><p><strong>使用mysqlbinlog 命令可以查看备份的binlog文件的详细事件。 恢复流程：我们直接用bin-log日志将数据库恢复到删除位置前,然后跳过故障点,再进行恢复删除后的所有操作。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># mysqlbinlog -v &#x2F;opt&#x2F;mysqlbackup&#x2F;daily&#x2F;mysql-bin.000002<br></code></pre></td></tr></table></figure><p><strong>我们先用mysqlbinlog命令找到delete那条语句的位置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># at 219<br>#160911 17:19:55 server id 1 end_log_pos 294 CRC32 0x84590493 Query<br>thread_id&#x3D;66 exec_time&#x3D;0 error_code&#x3D;0<br>SET TIMESTAMP&#x3D;1473585595&#x2F;*!*&#x2F;;<br>SET @@session.pseudo_thread_id&#x3D;66&#x2F;*!*&#x2F;;<br>SET @@session.foreign_key_checks&#x3D;1, @@session.sql_auto_is_null&#x3D;0,<br>@@session.unique_checks&#x3D;1, @@session.autocommit&#x3D;1&#x2F;*!*&#x2F;;<br>SET @@session.sql_mode&#x3D;1075838976&#x2F;*!*&#x2F;;<br>SET @@session.auto_increment_increment&#x3D;1, @@session.auto_increment_offset&#x3D;1&#x2F;*!*&#x2F;;<br>&#x2F;*!\C utf8 *&#x2F;&#x2F;*!*&#x2F;;<br>。。。 。。。 。。。<br></code></pre></td></tr></table></figure><p><strong>通过mysqlbinlog命令所显示的结果可以看到误操作delete的开始postion为219，结束position是422。 从二进制日志中读取指定position=219事件位置作为截至，即把数据恢复到delete删除前</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#mysqlbinlog --start-position&#x3D;422 &#x2F;opt&#x2F;mysqlbackup&#x2F;daily&#x2F;mysql-bin.000002 | mysql -u root -p<br></code></pre></td></tr></table></figure><p><strong>查看恢复结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># mysql -uroot -p -e &quot;select * from test_db.tb1&quot;<br>Enter password:<br>+----+------+<br>| id | name |<br>+----+------+<br>| 1 | tom1 |<br>| 2 | tom2 |<br>| 3 | tom3 |<br>+----+------+<br></code></pre></td></tr></table></figure><p><strong>从上面显示可以看出数据恢复到正常状态 生产环境中Mysql数据库的备份是周期性重复的操作，所以通常是要编写脚本实现，通过crond计划任务周期性执行备份脚本 mysqldump备份方案： 周日凌晨1点全库备份 周一到周六凌晨每隔4个小时增量备份一次 设置crontab任务，每天执行备份脚本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># crontab –e<br>#每个星期日凌晨1:00执行完全备份脚本<br>0 1 * * 0 &#x2F;root&#x2F;mysqlfullbackup.sh &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1<br>#周一到周六每隔4个小时增量备份一次<br>0 *&#x2F;4 * * 1-6 &#x2F;root&#x2F;mysqldailybackup.sh &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1<br></code></pre></td></tr></table></figure><p><strong>mysqlfullbackup.sh脚本内容：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# cat mysqlfullbackup.sh<br><span class="hljs-meta">#</span><span class="bash">!/bin/sh</span><br><span class="hljs-meta">#</span><span class="bash"> Name:mysqlFullBackup.sh</span><br><span class="hljs-meta">#</span><span class="bash"> 定义数据库目录</span><br>mysqlDir=/usr/local/mysql<br><span class="hljs-meta">#</span><span class="bash"> 定义用于备份数据库的用户名和密码</span><br>user=root<br>userpwd=123456<br>dbname=test_db<br><span class="hljs-meta">#</span><span class="bash"> 定义备份目录</span><br>databackupdir=/opt/mysqlbackup<br>[ ! -d $databackupdir ] &amp;&amp; mkdir $databackupdir<br><span class="hljs-meta">#</span><span class="bash"> 定义邮件正文文件</span><br>emailfile=$databackupdir/email.txt<br><span class="hljs-meta">#</span><span class="bash"> 定义邮件地址</span><br>email=root@localhost.localdomain<br><span class="hljs-meta">#</span><span class="bash"> 定义备份日志文件</span><br>logfile=$databackupdir/mysqlbackup.log<br>DATE=`date -I`<br>echo "" &gt; $emailfile<br>echo $(date +"%y-%m-%d %H:%M:%S") &gt;&gt; $emailfile<br>cd $databackupdir<br><span class="hljs-meta">#</span><span class="bash"> 定义备份文件名</span><br>dumpfile=mysql_$DATE.sql<br>gzdumpfile=mysql_$DATE.sql.tar.gz<br><span class="hljs-meta">#</span><span class="bash"> 使用mysqldump备份数据库，请根据具体情况设置参数</span><br><span class="hljs-meta">$</span><span class="bash">mysqlDir/bin/mysqldump -u<span class="hljs-variable">$user</span> -p<span class="hljs-variable">$userpwd</span> --flush-logs -x <span class="hljs-variable">$dbname</span> &gt; <span class="hljs-variable">$dumpfile</span></span><br>//-x--lock-all-tables<br><span class="hljs-meta">#</span><span class="bash"> 压缩备份文件</span><br>if [ $? -eq 0 ]; then<br>truetar czf $gzdumpfile $dumpfile &gt;&gt; $emailfile 2&gt;&amp;1<br>trueecho "BackupFileName:$gzdumpfile" &gt;&gt; $emailfile<br>trueecho "DataBase Backup Success!" &gt;&gt; $emailfile<br>truerm -f $dumpfile<br>else<br>trueecho "DataBase Backup Fail!" &gt;&gt; $emailfile<br>fi<br><span class="hljs-meta">#</span><span class="bash"> 写日志文件</span><br>echo "--------------------------------------------------------" &gt;&gt; $logfile<br>cat $emailfile &gt;&gt; $logfile<br><span class="hljs-meta">#</span><span class="bash"> 发送邮件通知</span><br>cat $emailfile | mail -s "MySQL Backup" $email<br></code></pre></td></tr></table></figure><p><strong>mysqldailybackup.sh脚本内容：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# cat mysqldailybackup.sh<br><span class="hljs-meta">#</span><span class="bash">!/bin/sh</span><br><span class="hljs-meta">#</span><span class="bash"> Name:mysqlDailyBackup.sh</span><br><span class="hljs-meta">#</span><span class="bash"> 定义数据库目录和数据目录</span><br>mysqldir=/usr/local/mysql<br>datadir=$mysqldir/data<br><span class="hljs-meta">#</span><span class="bash"> 定义用于备份数据库的用户名和密码</span><br>user=root<br>userpwd=123456<br><span class="hljs-meta">#</span><span class="bash"> 定义备份目录，每日备份文件备份到<span class="hljs-variable">$dataBackupDir</span>/daily</span><br>databackupdir=/opt/mysqlbackup<br>dailybackupdir=$databackupdir/daily<br>[ ! -d $dailybackupdir ] &amp;&amp; mkdir -p $databackupdir/daily<br><span class="hljs-meta">#</span><span class="bash"> 定义邮件正文文件</span><br>emailfile=$databackupdir/email.txt<br><span class="hljs-meta">#</span><span class="bash"> 定义邮件地址</span><br>email=root@localhost.localdomain<br><span class="hljs-meta">#</span><span class="bash"> 定义日志文件</span><br>logfile=$databackupdir/mysqlbackup.log<br>echo "" &gt; $emailfile<br>echo $(date +"%y-%m-%d %H:%M:%S") &gt;&gt; $emailfile<br><span class="hljs-meta">#</span><br><span class="hljs-meta">#</span><span class="bash"> 刷新日志，使数据库使用新的二进制日志文件</span><br><span class="hljs-meta">$</span><span class="bash">mysqldir/bin/mysqladmin -u<span class="hljs-variable">$user</span> -p<span class="hljs-variable">$userpwd</span> flush-logs</span><br>cd $datadir<br><span class="hljs-meta">#</span><span class="bash"> 得到二进制日志列表</span><br>filelist=`cat mysql-bin.index`<br>icounter=0<br>for file in $filelist<br>do<br>trueicounter=`expr $icounter + 1` // = let icounter++<br>done<br>nextnum=0<br>ifile=0<br>for file in $filelist<br>do<br>truebinlogname=`basename $file`<br>truenextnum=`expr $nextnum + 1`<br><span class="hljs-meta">#</span><span class="bash"> 跳过最后一个二进制日志（数据库当前使用的二进制日志文件）</span><br>trueif [ $nextnum -eq $icounter ]; then<br>truetrueecho "Skip lastest!" &gt; /dev/null<br>trueelse<br>truetruedest=$dailybackupdir/$binlogname<br><span class="hljs-meta">#</span><span class="bash"> 跳过已经备份的二进制日志文件</span><br>truetrueif [ -e $dest ]; then<br>truetruetrueecho "Skip exist $binlogname!" &gt; /dev/null<br>truetrueelse<br><span class="hljs-meta">#</span><span class="bash"> 备份日志文件到备份目录</span><br>truetruetruecp $binlogname $dailybackupdir<br>truetruetrueif [ $? -eq 0 ]; then<br>truetruetruetrueifile=`expr $ifile + 1`<br>truetruetruetrueecho "$binlogname backup success!" &gt;&gt; $emailfile<br>truetruetruefi<br>truetruefi<br>truefi<br>done<br>if [ $ifile -eq 0 ];then<br>trueecho "No Binlog Backup!" &gt;&gt; $emailfile<br>else<br>trueecho "Backup $ifile File(s)." &gt;&gt; $emailfile<br>trueecho "Backup MySQL Binlog OK!" &gt;&gt; $emailfile<br>fi<br><span class="hljs-meta">#</span><span class="bash"> 发送邮件通知</span><br>cat $emailfile | mail -s "MySQL Backup" $email<br><span class="hljs-meta">#</span><span class="bash"> 写日志文件</span><br>echo "--------------------------------------------------------" &gt;&gt; $logfile<br>cat $emailfile &gt;&gt; $logfile<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mysqldump备份结合binlog日志恢复&quot;&gt;mysqldump备份结合binlog日志恢复&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MySQL备份一般采取全库备份加日志备份的方式，例如每天执行一次全备份，每小时执行一次二进制日志备份。这样在MySQL故障后可以使用全
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://wsdlxgp.top/categories/mysql/"/>
    
    
      <category term="MySQL优化" scheme="https://wsdlxgp.top/tags/MySQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL配置参数优化</title>
    <link href="https://wsdlxgp.top/posts/49wn.html"/>
    <id>https://wsdlxgp.top/posts/49wn.html</id>
    <published>2020-06-22T16:02:00.000Z</published>
    <updated>2020-06-28T11:05:20.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要分表和分区？">为什么要分表和分区？</h2><p><strong>我们的数据库数据越来越大，随之而来的是单个表中数据太多。以至于查询速度变慢，而且由于表的锁机制导致应用操作也搜到严重影响，出现了数据库性能瓶颈。</strong><br><strong>mysql中有一种机制是表锁定和行锁定，是为了保证数据的完整性。表锁定表示你们都不能对这张表进行操作，必须等我对表操作完才行。行锁定也一样，别的sql必须等我对这条数据操作完了，才能对这条数据进行操作。当出现这种情况时，我们可以考虑分表或分区。</strong></p><h1>一、分表</h1><h3 id="什么是分表？">什么是分表？</h3><p><strong>分表是将一个大表按照一定的规则分解成多张具有独立存储空间的实体表，每个表都对应三个文件，MYD数据文件，.MYI索引文件，.frm表结构文件。这些表可以分布在同一块磁盘上，也可以在不同的机器上。app读写的时候根据事先定义好的规则得到对应的表名，然后去操作它。</strong><br><strong>将单个数据库表进行拆分，拆分成多个数据表，然后用户访问的时候，根据一定的算法（如用hash的方式，也可以用求余（取模）的方式），让用户访问不同的表，这样数据分散到多个数据表中，减少了单个数据表的访问压力。提升了数据库访问性能。分表的目的就在于此，减小数据库的负担，缩短查询时间。</strong></p><h3 id="Mysql分表分为垂直切分和水平切分">Mysql分表分为垂直切分和水平切分</h3><p><strong>垂直切分是指数据表列的拆分，把一张列比较多的表拆分为多张表 通常我们按以下原则进行垂直拆分: 把不常用的字段单独放在一张表; 把text，blob（binary large object，二进制大对象）等大字段拆分出来放在附表中;</strong></p><p><strong>经常组合查询的列放在一张表中; 垂直拆分更多时候就应该在数据表设计之初就执行的步骤，然后查询的时候用join关键起来即可。</strong></p><p><strong>水平拆分是指数据表行的拆分，把一张的表的数据拆成多张表来存放。 水平拆分原则 通常情况下，我们使用hash、取模等方式来进行表的拆分 比如一张有400W的用户表users，为提高其查询效率我们把其分成4张表users1，users2，users3，users4 通过用ID取模的方法把数据分散到四张表内Id%4= [0,1,2,3] 然后查询,更新,删除也是通过取模的方法来查询 部分业务逻辑也可以通过地区，年份等字段来进行归档拆分; 进行拆分后的表，这时我们就要约束用户查询行为。比如我们是按年来进行拆分的,这个时候在页面设计上就约束用户必须要先选择年,然后才能进行查询。</strong></p><h2 id="1、分表的几种方式：">1、分表的几种方式：</h2><h3 id="1）mysql集群">1）mysql集群</h3><p><strong>它并不是分表，但起到了和分表相同的作用。集群可分担数据库的操作次数，将任务分担到多台数据库上。集群可以读写分离，减少读写压力。从而提升数据库性能。</strong></p><h3 id="2）预先估计会出现大数据量并且访问频繁的表，将其分为若干个表">2）预先估计会出现大数据量并且访问频繁的表，将其分为若干个表</h3><p><strong>根据一定的算法（如用hash的方式，也可以用求余（取模）的方式）让用户访问不同的表。 例如论坛里面发表帖子的表，时间长了这张表肯定很大，几十万，几百万都有可能。聊天室里面信息表，几十个人在一起一聊一个晚上，时间长了，这张表的数据肯定很大。像这样的情况很多。所以这种能预估出来的大数据量表，我们就事先分出个N个表，这个N是多少，根据实际情况而定。以聊天信息表为例：我们事先建100个这样的表，message_00,message_01,message_02…message_98,message_99.然后根据用户的ID来判断这个用户的聊天信息放到哪张表里面，可以用hash的方式来获得，也可以用求余的方式来获得，方法很多。 或者可以设计每张表容纳的数据量是N条，那么如何判断某张表的数据是否容量已满呢？可以在程序段对于要新增数据的表，在插入前先做统计表记录数量的操作，当&lt;N条数据，就直接插入，当已经到达阀值，可以在程序段新创建数据库表（或者已经事先创建好），再执行插入操作）。</strong></p><h3 id="3）利用merge存储引擎来实现分表">3）利用merge存储引擎来实现分表</h3><p><strong>如果要把已有的大数据量表分开比较痛苦，最痛苦的事就是改代码，因为程序里面的sql语句已经写好了，用merge存储引擎来实现分表, 这种方法比较适合。 merge分表，分为主表和子表，主表类似于一个壳子，逻辑上封装了子表，实际上数据都是存储在子表中的。 我们可以通过主表插入和查询数据，如果清楚分表规律，也可以直接操作子表。 下面我们来实现一个简单的利用merge存储引擎来实现分表的演示： 创建一个完整表存储着所有的成员信息（表名为member)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建库<br>drop database IF EXISTS testdb;<br>create database testdb;<br>use testdb;<br><br>create table member(<br>id bigint auto_increment primary key,<br>name varchar(20),<br>sex tinyint not null default &#39;0&#39;<br>)engine&#x3D;myisam default charset&#x3D;utf8 auto_increment&#x3D;1;<br></code></pre></td></tr></table></figure><h4 id="加入点数据："><strong>加入点数据：</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into member(name,sex) values(&#39;tom1&#39;,1);<br>insert into member(name,sex) select name,sex from member;<br></code></pre></td></tr></table></figure><p><strong>第二条语句多执行几次就有了很多数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from member;<br>+----+------+-----+<br>| id | name | sex |<br>+----+------+-----+<br>| 1 | tom1 | 1 |<br>| 2 | tom1 | 1 |<br>| 3 | tom1 | 1 |<br>| 4 | tom1 | 1 |<br>| 5 | tom1 | 1 |<br>| 6 | tom1 | 1 |<br>| 7 | tom1 | 1 |<br>| 8 | tom1 | 1 |<br>| 9 | tom1 | 1 |<br>| 10 | tom1 | 1 |<br>| 11 | tom1 | 1 |<br>| 12 | tom1 | 1 |<br>| 13 | tom1 | 1 |<br>| 14 | tom1 | 1 |<br>| 15 | tom1 | 1 |<br>| 16 | tom1 | 1 |<br>+----+------+-----+<br></code></pre></td></tr></table></figure><h4 id="下面我们进行分表，这里我们把member分两个表tb-member1-tb-member2"><strong>下面我们进行分表，这里我们把member分两个表tb_member1,tb_member2</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建两个分表<br>use testdb;<br>DROP table IF EXISTS tb_member1;<br>create table tb_member1(<br>id bigint primary key ,<br>name varchar(20),<br>sex tinyint not null default &#39;0&#39;<br>)ENGINE&#x3D;MyISAM DEFAULT CHARSET&#x3D;utf8 ;<br><br>DROP table IF EXISTS tb_member2;<br>create table tb_member2(<br>id bigint primary key,<br>name varchar(20),<br>sex tinyint not null default &#39;0&#39;<br>)ENGINE&#x3D;MyISAM DEFAULT CHARSET&#x3D;utf8;<br></code></pre></td></tr></table></figure><h4 id="创建主表tb-member">创建主表tb_member</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建主表tb_member<br>DROP table IF EXISTS tb_member;<br>create table tb_member(<br>id bigint primary key ,<br>name varchar(20),<br>sex tinyint not null default &#39;0&#39;<br>) ENGINE&#x3D;MERGE UNION&#x3D;(tb_member1,tb_member2) INSERT_METHOD&#x3D;LAST CHARSET&#x3D;utf8 ;<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into member(name,sex) values(&#39;tom2&#39;,2);<br>insert into member(name,sex) select name,sex from member;<br><br>insert into member(name,sex) values(&#39;tom3&#39;,3);<br>insert into member(name,sex) select name,sex from member;<br><br>insert into member(name,sex) values(&#39;tom4&#39;,4);<br>insert into member(name,sex) select name,sex from member;<br></code></pre></td></tr></table></figure><p>**注：INSERT_METHOD,此参数INSERT_METHOD = NO 表示该表不能做任何写入操作只作为查询使用,INSERT_METHOD = LAST表示插入到最后的一张表里面。INSERT_METHOD = first表示插入到第一张表里面。 **</p></blockquote><h4 id="查看一下tb-member表的结构">查看一下tb_member表的结构:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; desc tb_member;<br>mysql&gt; desc tb_member;<br>+-------+-------------+------+-----+---------+------------------------------------<br>-----+<br>| Field | Type | Null | Key | Default | Extra |<br>+-------+-------------+------+-----+---------+------------------------------------<br>-----+<br>| id | bigint(20) | NO | PRI | NULL | auto_increment |<br>| name | varchar(20) | YES | | NULL | |<br>| sex | tinyint(4) | NO | | 0 | |<br>+-------+-------------+------+-----+---------+------------------------------------<br>------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="接下来，我们把数据分到两个分表中去：">接下来，我们把数据分到两个分表中去：</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 按照已经有行插入<br>insert into tb_member1(id,name,sex) select id,name,sex from member where<br>id%2&#x3D;0;<br>insert into tb_member2(id,name,sex) select id,name,sex from member where<br>id%2&#x3D;1;<br></code></pre></td></tr></table></figure><h4 id="查看两个子表的数据：">查看两个子表的数据：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from tb_member1;<br>+----+------+-----+<br>| id | name | sex |<br>+----+------+-----+<br>| 16 | tom1 | 1 |<br>| 14 | tom1 | 1 |<br>| 12 | tom1 | 1 |<br>| 10 | tom1 | 1 |<br>| 8 | tom1 | 1 |<br>| 6 | tom1 | 1 |<br>| 4 | tom1 | 1 |<br>| 2 | tom1 | 1 |<br>+----+------+-----+<br>8 rows in set (0.00 sec)<br>mysql&gt; select * from tb_member2;<br>+----+------+-----+<br>| id | name | sex |<br>+----+------+-----+<br>| 3 | tom1 | 1 |<br>| 1 | tom1 | 1 |<br>| 5 | tom1 | 1 |<br>| 7 | tom1 | 1 |<br>| 9 | tom1 | 1 |<br>| 11 | tom1 | 1 |<br>| 13 | tom1 | 1 |<br>| 15 | tom1 | 1 |<br>+----+------+-----+<br>8 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="查看一下主表的数据：">查看一下主表的数据：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from tb_member;<br>+----+------+-----+<br>| id | name | sex |<br>+----+------+-----+<br>| 16 | tom1 | 1 |<br>| 14 | tom1 | 1 |<br>| 12 | tom1 | 1 |<br>| 10 | tom1 | 1 |<br>| 8 | tom1 | 1 |<br>| 6 | tom1 | 1 |<br>| 4 | tom1 | 1 |<br>| 2 | tom1 | 1 |<br>| 15 | tom1 | 1 |<br>| 13 | tom1 | 1 |<br>| 11 | tom1 | 1 |<br>| 9 | tom1 | 1 |<br>| 7 | tom1 | 1 |<br>| 5 | tom1 | 1 |<br>| 3 | tom1 | 1 |<br>| 1 | tom1 | 1 |<br>+----+------+-----+<br>16 rows in set (0.00 sec)<br>mysql&gt; select * from tb_member where id&#x3D;3;<br>+----+------+-----+<br>| id | name | sex |<br>+----+------+-----+<br>| 3 | tom1 | 1 |<br>+----+------+-----+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><em><strong>注意：总表只是一个外壳，存取数据发生在一个一个的子表里面。</strong></em></p><p><em><strong>注意：每个子表都有自已独立的相关表文件，而主表只是一个壳，并没有完整的相关表文件</strong></em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@localhost ~]# ls -l &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;test&#x2F;tb_member*<br>-rw-r-----. 1 mysql mysql 8614 Sep 15 21:49<br>&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;test&#x2F;tb_member1.frm<br>-rw-r-----. 1 mysql mysql 320 Sep 16 00:02<br>&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;test&#x2F;tb_member1.MYD<br>-rw-r-----. 1 mysql mysql 2048 Sep 16 00:43<br>&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;test&#x2F;tb_member1.MYI<br>-rw-r-----. 1 mysql mysql 8614 Sep 15 21:50<br>&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;test&#x2F;tb_member.MRG<br></code></pre></td></tr></table></figure><h1>二、分区 什么是分区？</h1><p><strong>分区和分表相似，都是按照规则分解表。不同在于分表将大表分解为若干个独立的实体表，而分区是将数据分段划分在多个位置存放，分区后，表还是一张表，但数据散列到多个位置了。app读写的时候操作的还是表名字，db自动去组织分区的数据。</strong></p><h3 id="分区主要有两种形式：">分区主要有两种形式：</h3><p><strong>水平分区（Horizontal Partitioning）这种形式分区是对表的行进行分区，所有在表中定义的列在每个数据集中</strong><br><strong>都能找到，所以表的特性依然得以保持。</strong></p><p><strong>举个简单例子：一个包含十年发票记录的表可以被分区为十个不同的分区，每个分区包含的是其中一年的记录。</strong><br><strong>垂直分区（Vertical Partitioning）这种分区方式一般来说是通过对表的垂直划分来减少目标表的宽度，使某些特定的列被划分到特定的分区，每个分区都包含了其中的列所对应的行。</strong></p><p><strong>举个简单例子：一个包含了大text和BLOB列的表，这些text和BLOB列又不经常被访问，这时候就要把这些不经常使用的text和BLOB了划分到另一个分区，在保证它们数据相关性的同时还能提高访问速度。</strong></p><h2 id="1、mysql怎么查看是否支持分区">1、mysql怎么查看是否支持分区</h2><p><strong>mysql从5.1开始支持分区功能</strong></p><p><strong>查询命令如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#39;%partition%&#39;;<br>Empty set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>如果查询结果显示Empty，表示不支持分区。</strong></p><p><strong>但是上面的查询方法只是针对mysql5.6以下版本。</strong></p><p><strong>如果mysql5.6以及以上版本，需要使用下面的查询命令：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show plugins;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200623163451033.png" alt="image-20200623163451033"></p><h4 id="编写代码">编写代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop database IF EXISTS testdb;<br>create database testdb;<br>use testdb;<br><br>create table if not exists user (<br>  id int not null auto_increment,<br>  name varchar(30) not null default &#39;&#39;,<br>  sex int(1) not null default &#39;0&#39;,<br>  primary key(id)<br>)default charset&#x3D;utf8 auto_increment&#x3D;1<br>partition by range(id) (<br>  partition p0 values less than (3),<br>  partition p1 values less than (6),<br>  partition p2 values less than (9),<br>  partition p3 values less than (12),<br>  partition p4 values less than maxvalue<br>);<br></code></pre></td></tr></table></figure><p><strong>插入些数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into testdb.user(name,sex)values (&#39;tom1&#39;,&#39;0&#39;);<br>insert into testdb.user(name,sex)values (&#39;tom2&#39;,&#39;1&#39;);<br>insert into testdb.user(name,sex)values (&#39;tom3&#39;,&#39;1&#39;);<br>insert into testdb.user(name,sex)values (&#39;tom4&#39;,&#39;0&#39;);<br>insert into testdb.user(name,sex)values (&#39;tom5&#39;,&#39;0&#39;);<br>insert into testdb.user(name,sex)values (&#39;tom6&#39;,&#39;1&#39;);<br>insert into testdb.user(name,sex)values (&#39;tom7&#39;,&#39;1&#39;);<br>insert into testdb.user(name,sex)values (&#39;tom8&#39;,&#39;1&#39;);<br>insert into testdb.user(name,sex)values (&#39;tom9&#39;,&#39;1&#39;);<br>insert into testdb.user(name,sex)values (&#39;tom10&#39;,&#39;1&#39;);<br>insert into testdb.user(name,sex)values (&#39;tom11&#39;,&#39;1&#39;);<br>insert into testdb.user(name,sex)values (&#39;tom12&#39;,&#39;1&#39;);<br>insert into testdb.user(name,sex)values (&#39;tom13&#39;,&#39;1&#39;);<br>insert into testdb.user(name,sex)values (&#39;tom14&#39;,&#39;1&#39;);<br></code></pre></td></tr></table></figure><p><strong>到存放数据库表文件的地方看一下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from testdb.user partition(p4);<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200623164606421.png" alt="image-20200623164606421"></p><p><strong>从information_schema系统库中的partitions表中查看分区信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from information_schema.partitions where table_schema&#x3D;&#39;test2&#39; and table_name&#x3D;&#39;user&#39;\G;<br></code></pre></td></tr></table></figure><h4 id="测试在创建表之后分区是否可以">测试在创建表之后分区是否可以</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200623165711016.png" alt="image-20200623165711016"></p><h2 id="2、新增分区">2、新增分区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; alter table test2.user add partition (partition partionname values less<br>than (n));<br></code></pre></td></tr></table></figure><h3 id="（1）删除分区-当删除了一个分区，也同时删除了该分区中所有的数据。"><strong>（1）删除分区 当删除了一个分区，也同时删除了该分区中所有的数据。</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table testdb.user drop partition p4;<br><br>alter table testdb.user add partition(<br>  partition m5 values less than (13)<br>);<br><br>select * from testdb.user partition(m5);<br></code></pre></td></tr></table></figure><h4 id="查看分区">查看分区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from information_schema.&#96;PARTITIONS&#96;;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200623171600295.png" alt="image-20200623171600295"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select PARTITION_NAME,PARTITION_METHOD,PARTITION_DESCRIPTION,TABLE_ROWS<br>from information_schema.&#96;PARTITIONS&#96;<br>where TABLE_SCHEMA&#x3D;&#39;testdb&#39;<br>and table_name&#x3D; &#39;user&#39;;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200623171843472.png" alt="image-20200623171843472"></p><h2 id="3、分区的合并">3、分区的合并</h2><p><strong>下面的SQL，将p1 – p3合并为2个分区p01– p02</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table testdb.user<br>reorganize partition p1,p2,p3 into(<br>truepartition t1 values less than (8),<br>truepartition t2 values less than (12)<br>);<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200623172300138.png" alt="image-20200623172300138"></p><h2 id="4、未分区表和分区表性能测试-创建一个未分区的表">4、未分区表和分区表性能测试 创建一个未分区的表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table test2.tab1(c1 int,c2 varchar(30),c3 date);<br>创建分区表,按日期的年份拆分<br>mysql&gt; CREATE TABLE test2.tab2 ( c1 int, c2 varchar(30) , c3 date )<br>PARTITION BY RANGE (year(c3)) (PARTITION p0 VALUES LESS THAN (1995),<br>PARTITION p1 VALUES LESS THAN (1996) , PARTITION p2 VALUES LESS THAN (1997) ,<br>PARTITION p3 VALUES LESS THAN (1998) , PARTITION p4 VALUES LESS THAN (1999) ,<br>PARTITION p5 VALUES LESS THAN (2000) , PARTITION p6 VALUES LESS THAN (2001) ,<br>PARTITION p7 VALUES LESS THAN (2002) , PARTITION p8 VALUES LESS THAN (2003) ,<br>PARTITION p9 VALUES LESS THAN (2004) , PARTITION p10 VALUES LESS THAN (2010),<br>PARTITION p11 VALUES LESS THAN MAXVALUE );<br></code></pre></td></tr></table></figure><p><strong>注意:最后一行，考虑到可能的最大值 通过存储过程插入100万条测试数据 创建存储过程：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; delimiter $$&#x2F;&#x2F;指定存储过程结束符<br>mysql&gt;CREATE PROCEDURE load_part_tab()<br>truetruebegin<br>truedeclare v int default 0;<br>truewhile v &lt; 2000000<br>truedo<br>truetrueinsert into test2.tab1<br>truetruevalues (v,&#39;testing partitions&#39;,adddate(&#39;1995-01-01&#39;,<br>(rand(v)*36520) mod 3652));<br>trueset v &#x3D; v + 1;<br>trueend while;<br>trueend<br>true$$<br></code></pre></td></tr></table></figure><p><strong>注：RAND()函数在0和1之间产生一个随机数，如果一个整数参数N被指定，它被用作种子值。每个种子产生的随机数序列是不同的。</strong></p><p><strong>执行存储过程load_part_tab向test2.tab1表插入数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; delimiter ; &#x2F;&#x2F; 注意有空格<br>mysql&gt; call load_part_tab();<br>向test2.tab2表中插入数据<br>mysql&gt; insert into test2.tab2 select * from test2.tab1;<br>测试SQL性能<br>mysql&gt; select count(*) from test2.tab1 where c3 &gt; &#39;1995-01-01&#39; and c3 &lt; &#39;1995-12-31&#39;;<br>+----------+<br>| count(*) |<br>+----------+<br>| 219642 |<br>+----------+<br>1 row in set (0.84 sec)<br>mysql&gt; select count(*) from test2.tab2 where c3 &gt; &#39;1995-01-01&#39; and c3 &lt; &#39;1995-12-31&#39;;<br>+----------+<br>| count(*) |<br>+----------+<br>| 219642 |<br>+----------+<br>1 row in set (0.09 sec)<br></code></pre></td></tr></table></figure><p><strong>结果表明分区表比未分区表的执行时间少很多。 通过explain语句来分析执行情况</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; flush tables;<br>mysql&gt; explain select count(*) from test2.tab1 where c3 &gt; &#39;1995-01-01&#39; and c3 &lt;<br>&#39;1995-12-31&#39;\G;<br>*************************** 1. row ***************************<br>id: 1<br>select_type: SIMPLE<br>table: tab1<br>partitions: NULL<br>type: ALL<br>possible_keys: NULL<br>key: NULL<br>key_len: NULL<br>ref: NULL<br>rows: 2001552<br>filtered: 11.11<br>Extra: Using where<br>1 row in set, 1 warning (0.00 sec)<br>mysql&gt; explain select count(*) from test2.tab2 where c3 &gt; &#39;1995-01-01&#39; and c3 &lt;<br>&#39;1995-12-31&#39;\G;<br>*************************** 1. row ***************************<br>id: 1<br>select_type: SIMPLE<br>table: tab2<br>partitions: p1<br>type: ALL<br>possible_keys: NULL<br>key: NULL<br>key_len: NULL<br>ref: NULL<br>rows: 220206<br>filtered: 11.11<br>Extra: Using where<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>explain语句显示了SQL查询要处理的记录数目可以看出分区表比未分区表的明显扫描的记录要少很多。 创建索引后情况测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create index idx_of_c3 on test2.tab1(c3);<br>Query OK, 0 rows affected (5.07 sec)<br>Records: 0 Duplicates: 0 Warnings: 0<br>mysql&gt; create index idx_of_c3 on test2.tab2(c3);<br>Query OK, 0 rows affected (4.87 sec)<br>Records: 0 Duplicates: 0 Warnings: 0<br>mysql&gt; flush tables;<br>mysql&gt; select count(*) from test2.tab1 where c3 &gt; &#39;1996-01-01&#39; and c3 &lt; &#39;1996-12-31&#39;;<br>+----------+<br>| count(*) |<br>+----------+<br>| 220264 |<br>+----------+<br>1 row in set (0.12 sec)<br></code></pre></td></tr></table></figure><p><strong>重启mysqld服务</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select count(*) from test2.tab2 where c3 &gt; &#39;1996-01-01&#39; and c3 &lt; &#39;1996-12-<br>31&#39;;<br>+----------+<br>| count(*) |<br>+----------+<br>| 220264 |<br>+----------+<br>1 row in set (0.11 sec)<br></code></pre></td></tr></table></figure><p><strong>创建索引后分区表比未分区表相差不大（数据量越大差别会明显些）</strong></p><h2 id="5、分区时，将不同分区放到不同存储位置">5、分区时，将不同分区放到不同存储位置</h2><h3 id="（1）建表时，提前创建好存储目录，并授权给mysql">（1）建表时，提前创建好存储目录，并授权给mysql:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# cd /opt/<br>[root@mysql opt]# mkdir -p data/ares&#123;1..3&#125;<br>[root@mysql opt]# ll data/<br>总用量 0<br>drwxr-xr-x 2 root root 6 Jun 23 17:27 ares1<br>drwxr-xr-x 2 root root 6 Jun 23 17:27 ares2<br>drwxr-xr-x 2 root root 6 Jun 23 17:27 ares3<br></code></pre></td></tr></table></figure><h3 id="（2）创建表格。">（2）创建表格。</h3><blockquote><p><strong>注：使用mysql默认的存储引擎inodb时候，只需要指定data directory 就可以，因为inodb的数据和索引在一个文件中。但是创建表格时指定engine=myisam时，修改分区的存储位置，需要同时指定data directory和index directory。</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table user(<br>  id int not null auto_increment,<br>  name varchar(30) not null default &#39;&#39;,<br>  primary key(id)<br>) engine&#x3D;innodb default charset&#x3D;utf8 auto_increment&#x3D;1 <br>partition by range(id)(<br>  partition p1 values less than (3) data directory &#39;&#x2F;opt&#x2F;data&#x2F;area1&#39;,<br>  partition p2 values less than (6) data directory &#39;&#x2F;opt&#x2F;data&#x2F;area2&#39;,<br>  partition p3 values less than (9) data directory &#39;&#x2F;opt&#x2F;data&#x2F;area3&#39;);<br></code></pre></td></tr></table></figure><h3 id="（3）查看分区情况">（3）查看分区情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@mysql ~]# ls -R &#x2F;data&#x2F;<br>&#x2F;data&#x2F;:<br>area1 area2 area3<br>&#x2F;data&#x2F;area1:<br>test<br>&#x2F;data&#x2F;area1&#x2F;test:<br>user#P#p1.ibd<br>&#x2F;data&#x2F;area2:<br>test<br>&#x2F;data&#x2F;area2&#x2F;test:<br>user#P#p2.ibd<br>&#x2F;data&#x2F;area3:<br>test<br>&#x2F;data&#x2F;area3&#x2F;test:<br>user#P#p3.ibd<br></code></pre></td></tr></table></figure><p><strong>查看默认数据存储位置的文件：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@mysql ~]# cd &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;test<br>[root@mysql test]# ls –l<br>-rw-r----- 1 mysql mysql 30 9月 22 17:55 user#P#p1.isl<br>-rw-r----- 1 mysql mysql 30 9月 22 17:55 user#P#p2.isl<br>-rw-r----- 1 mysql mysql 30 9月 22 17:55 user#P#p3.isl<br></code></pre></td></tr></table></figure><h2 id="6、mysql分区的类型">6、mysql分区的类型</h2><h3 id="（1）RANGE分区">（1）RANGE分区</h3><p><strong>基于属于一个给定连续区间的列值，把多行分配给分区。这些区间要连续且不能相互重叠，使用VALUES LESS THAN操作符来进行定义。以下是实例。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE employees (<br>id INT NOT NULL,<br>fname VARCHAR(30),<br>lname VARCHAR(30),<br>hired DATE NOT NULL DEFAULT &#39;1970-01-01&#39;,<br>separated DATE NOT NULL DEFAULT &#39;9999-12-31&#39;,<br>job_code INT NOT NULL,<br>store_id INT NOT NULL<br>)<br>partition BY RANGE (store_id) (<br>partition p0 VALUES LESS THAN (6),<br>partition p1 VALUES LESS THAN (11),<br>partition p2 VALUES LESS THAN (16),<br>partition p3 VALUES LESS THAN (21)<br>);<br></code></pre></td></tr></table></figure><p><strong>按照这种分区方案，在商店1到5工作的雇员相对应的所有行被保存在分区P0中，商店6到10的雇员保存在P1中，依次类推。注意，每个分区都是按顺序进行定义，从最低到最高。 对于包含数据(72, ‘Michael’, ‘Widenius’,‘1998-06-25’, NULL, 13)的一个新行，可以很容易地确定它将插入到p2分区中，但是如果增加了一个编号为第21的商店，将会发生什么呢？在这种方案下，由于没有规则把store_id大于20的商店包含在内，服务器将不知道把该行保存在何处，将会导致错误。要避免这种错误，可以创建maxvalue分区，所有不在指定范围内的记录都会被存储到maxvalue所在的分区中。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; alter table test2.user add partition (partition p4 values less than maxvalue);<br></code></pre></td></tr></table></figure><h3 id="（2）LIST分区">（2）LIST分区</h3><p><strong>类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择。LIST分区通过使用“PARTITION BY LIST(expr)”来实现，其中“expr” 是某列值或一个基于某个列值、并返回一个整数值的表达式，然后通过“VALUES IN (value_list)”的方式来定义每个分区，其中“value_list”是一个通过逗号分隔的整数列表。 要按照属于同一个地区商店的行保存在同一个分区中的方式来分割表，可以使用下面的“CREATE TABLE”语句：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE employees (<br>id INT NOT NULL,<br>fname VARCHAR(30),<br>lname VARCHAR(30),<br>hired DATE NOT NULL DEFAULT &#39;1970-01-01&#39;,<br>separated DATE NOT NULL DEFAULT &#39;9999-12-31&#39;,<br>job_code INT,<br>store_id INT<br>)<br>PARTITION BY LIST(store_id)(<br>PARTITION pNorth VALUES IN (3,5,6,9,17),<br>PARTITION pEast VALUES IN (1,2,10,11,19,20),<br>PARTITION pWest VALUES IN (4,12,13,14,18),<br>PARTITION pCentral VALUES IN (7,8,15,16)<br>);<br></code></pre></td></tr></table></figure><p><strong>这使得在表中增加或删除指定地区的雇员记录变得容易起来。例如，假定西区的所有音像店都卖给了其他公司。那么与在西区音像店工作雇员相关的所有记录（行）可以使用查询“<code>ALTER TABLE employees DROP PARTITION pWest;</code> ”来进行删除，它与具有同样作用的DELETE （删除）查询“<code>DELETE query DELETE FROM employees WHERE store_id IN (4,12,13,14,18);</code> ”比起来，要有效得多。 要点：如果试图插入列值不在分区值列表中的一行时，那么“INSERT”查询将失败并报错。例如，假定LIST分区的采用上面的方案，下面的插入将失败：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO employees VALUES(224, &#39;Linus&#39;, &#39;Torvalds&#39;, &#39;2002-05-01&#39;, &#39;2004-10-12&#39;, 42, 21);<br></code></pre></td></tr></table></figure><p><strong>这是因为“store_id”列值21不能在用于定义分区pNorth, pEast, pWest,或pCentral的值列表中找到。要重点注意的是，LIST分区没有类似如“VALUES LESS THAN MAXVALUE”这样的包含其他值在内的定义。将要匹配的任何值都必须在值列表中找到。 3.HASH分区 这种模式允许DBA通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。 hash分区的目的是将数据均匀的分布到预先定义的各个分区中，保证各分区的数据量大致一致。在RANGE和LIST分区中，必须明确指定一个给定的列值或列值集合应该保存在哪个分区中；而在HASH分区中，MYSQL自动完成这些工作，用户所要定一个列值或者表达式，以及指定被分区的表将要被分割成的分区数量。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table t_hash( a int(11), b datetime) partition by hash(year(b)) partitions 4;<br></code></pre></td></tr></table></figure><h4 id="hash的分区函数页需要返回一个整数值。partitions子句中的值是一个非负整数，不加的partitions子句的话，默认为分区数为1。"><strong>hash的分区函数页需要返回一个整数值。partitions子句中的值是一个非负整数，不加的partitions子句的话，默认为分区数为1。</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table t_hash( a int(11), b datetime) partition by hash(year(b)) partitions 4;<br>insert into t_hash values(1,&#39;2010-04-01&#39;);<br><br>select PARTITION_NAME,PARTITION_METHOD,PARTITION_DESCRIPTION,TABLE_ROWS<br>from information_schema.&#96;PARTITIONS&#96;<br>where TABLE_SCHEMA&#x3D;&#39;testdb&#39;<br>and table_name&#x3D; &#39;t_hash&#39;;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200623180147872.png" alt="image-20200623180147872"></p><p><strong>该记录会被放入分区p2中。因为插入2010-04-01进入表t_hash,那么</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">MOD(YEAR('2010-04-01'),4)=2</span><br><span class="hljs-string">mysql&gt;</span> <span class="hljs-string">select</span> <span class="hljs-string">*</span> <span class="hljs-string">from</span> <span class="hljs-string">information_schema.partitions</span> <span class="hljs-string">where</span> <span class="hljs-string">table_schema='test2'</span> <span class="hljs-string">and</span><br><span class="hljs-string">table_name='t_hash'\G;</span><br><span class="hljs-string">***************************</span> <span class="hljs-number">1</span><span class="hljs-string">.</span> <span class="hljs-string">row</span> <span class="hljs-string">***************************</span><br>                  <span class="hljs-attr">TABLE_CATALOG:</span> <span class="hljs-string">def</span><br>                  <span class="hljs-attr">TABLE_SCHEMA:</span> <span class="hljs-string">testdb</span><br>                  <span class="hljs-attr">TABLE_NAME:</span> <span class="hljs-string">t_hash</span><br>                  <span class="hljs-attr">PARTITION_NAME:</span> <span class="hljs-string">p0</span><br>                  <span class="hljs-attr">SUBPARTITION_NAME:</span> <span class="hljs-literal">NULL</span><br>                  <span class="hljs-attr">PARTITION_ORDINAL_POSITION:</span> <span class="hljs-number">1</span><br>                  <span class="hljs-attr">SUBPARTITION_ORDINAL_POSITION:</span> <span class="hljs-literal">NULL</span><br>                  <span class="hljs-attr">PARTITION_METHOD:</span> <span class="hljs-string">HASH</span><br>                  <span class="hljs-attr">SUBPARTITION_METHOD:</span> <span class="hljs-literal">NULL</span><br>                  <span class="hljs-attr">PARTITION_EXPRESSION:</span> <span class="hljs-string">year(b)</span><br>                  <span class="hljs-attr">SUBPARTITION_EXPRESSION:</span> <span class="hljs-literal">NULL</span><br>                  <span class="hljs-attr">PARTITION_DESCRIPTION:</span> <span class="hljs-literal">NULL</span><br>                  <span class="hljs-attr">TABLE_ROWS:</span> <span class="hljs-number">0</span><br>                  <span class="hljs-attr">AVG_ROW_LENGTH:</span> <span class="hljs-number">0</span><br>                  <span class="hljs-attr">DATA_LENGTH:</span> <span class="hljs-number">16384</span><br>                  <span class="hljs-attr">MAX_DATA_LENGTH:</span> <span class="hljs-literal">NULL</span><br>                  <span class="hljs-attr">INDEX_LENGTH:</span> <span class="hljs-number">0</span><br>                  <span class="hljs-attr">DATA_FREE:</span> <span class="hljs-number">0</span><br>                  <span class="hljs-attr">CREATE_TIME:</span> <span class="hljs-number">2016</span><span class="hljs-number">-09</span><span class="hljs-number">-16</span> <span class="hljs-number">22</span><span class="hljs-string">:48:59</span><br>                  <span class="hljs-attr">UPDATE_TIME:</span> <span class="hljs-number">2016</span><span class="hljs-number">-09</span><span class="hljs-number">-17</span> <span class="hljs-number">23</span><span class="hljs-string">:36:22</span><br>                  <span class="hljs-attr">CHECK_TIME:</span> <span class="hljs-literal">NULL</span><br>                  <span class="hljs-attr">CHECKSUM:</span> <span class="hljs-literal">NULL</span><br>                  <span class="hljs-attr">PARTITION_COMMENT:</span><br>                  <span class="hljs-attr">NODEGROUP:</span> <span class="hljs-string">default</span>                  <br>                  <span class="hljs-attr">TABLESPACE_NAME:</span> <span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><p><strong>可以看到P2分区有一条记录。当前这个例子并不能把数据均匀的分布到各个分区，因为按照YEAR函数进行的，该值本身是离散的。如果对连续的值进行HASH分区，如自增长的主键，则可以较好地将数据平均分布。 请思考：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; insert into t_hash values(1,&#39;2012-04-01&#39;)<br></code></pre></td></tr></table></figure><p><strong>记录会插入哪个分区？</strong></p><h2 id="7、key分区">7、key分区</h2><p><strong>key分区和hash分区相似，不同在于hash分区是用户自定义函数进行分区，key分区使用mysql数据库提供的函数进行分区，NDB cluster使用MD5函数来分区，对于其他存储引擎mysql使用内部的hash函数。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table t_key( a int(11), b datetime) partition by key(b) partitions<br>4;<br></code></pre></td></tr></table></figure><p>上面的RANGE、LIST、HASH、KEY四种分区中，分区的条件必须是整形，如果不是整形需要通过函数将其转换为整形。</p><h2 id="8、columns分区">8、columns分区</h2><p><strong>mysql-5.5开始支持COLUMNS分区，可视为RANGE和LIST分区的进化，COLUMNS分区可以直接使用非整形数据进行分区。</strong></p><h3 id="COLUMNS分区支持以下数据类型：">COLUMNS分区支持以下数据类型：</h3><ul><li><strong>所有整形，如INT SMALLINT TINYINT BIGINT。FLOAT和DECIMAL则不支持。</strong></li><li><strong>日期类型，如DATE和DATETIME。其余日期类型不支持。</strong></li><li><strong>字符串类型，如CHAR、VARCHAR、BINARY和VARBINARY。</strong></li><li><strong>BLOB和TEXT类型不支持。</strong></li><li><strong>COLUMNS可以使用多个列进行分区。</strong></li></ul><h3 id="mysql分表和分区有什么区别呢">mysql分表和分区有什么区别呢</h3><h4 id="实现方式上">实现方式上</h4><p><strong>a）mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完整的一张表，都对</strong><br><strong>应三个文件，一个.MYD数据文件，.MYI索引文件，.frm表结构文件。</strong></p><p><strong>b）分区不一样，一张大表进行分区后，他还是一张表，不会变成二张表，但是他存放数据的区块变多了</strong></p><h4 id="数据处理上">数据处理上</h4><p><strong>a）分表后，数据都是存放在分表里，总表只是一个外壳，存取数据发生在一个一个的分表里面。</strong></p><p><strong>b）分区呢，不存在分表的概念，分区只不过把存放数据的文件分成了许多小块，分区后的表呢，还是一张表，数据处理还是由自己来完成。</strong></p><h4 id="提高性能上">提高性能上</h4><p><strong>a）分表后，单表的并发能力提高了，磁盘I/O性能也提高了。并发能力为什么提高了呢，因为查寻一次所花的时间变短了，如果出现高并发的话，总表可以根据不同的查询，将并发压力分到不同的小表里面。</strong></p><p><strong>b）mysql提出了分区的概念，主要是想突破磁盘I/O瓶颈，想提高磁盘的读写能力，来增加mysql性能。在这一点上，分区和分表的测重点不同，分表重点是存取数据时，如何提高mysql并发能力上；而分区呢，如何突破磁盘的读写能力，从而达到提高mysql性能的目的。</strong></p><h4 id="实现的难易度上">实现的难易度上</h4><p><strong>a）分表的方法有很多，用merge来分表，是最简单的一种方式。这种方式跟分区难易度差不多，并且对</strong></p><p><strong>程序代码来说可以做到透明的。如果是用其他分表方式就比分区麻烦了。</strong><br><strong>b）分区实现是比较简单的，建立分区表，根建平常的表没什么区别，并且对开代码端来说是透明的。</strong></p><h3 id="mysql分表和分区有什么联系？">mysql分表和分区有什么联系？</h3><ul><li><strong>都能提高mysql的性高，在高并发状态下都有一个良好的表现。</strong></li><li><strong>分表和分区不矛盾，可以相互配合的，对于那些大访问量，并且表数据比较多的表，我们可以采取分表和分区结合的方式，访问量不大，但是表数据很多的表，我们可以采取分区的方式等。</strong></li><li><strong>分表技术是比较麻烦的，需要手动去创建子表，app服务端读写时候需要计算子表名。采用merge好一些，但也要创建子表和配置子表间的union关系。</strong></li><li><strong>表分区相对于分表，操作方便，不需要创建子表。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要分表和分区？&quot;&gt;为什么要分表和分区？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;我们的数据库数据越来越大，随之而来的是单个表中数据太多。以至于查询速度变慢，而且由于表的锁机制导致应用操作也搜到严重影响，出现了数据库性能瓶颈。&lt;/strong&gt;&lt;br&gt;
&lt;strong
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://wsdlxgp.top/categories/mysql/"/>
    
    
      <category term="MySQL优化" scheme="https://wsdlxgp.top/tags/MySQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL配置参数优化</title>
    <link href="https://wsdlxgp.top/posts/49an.html"/>
    <id>https://wsdlxgp.top/posts/49an.html</id>
    <published>2020-06-21T16:02:00.000Z</published>
    <updated>2020-06-28T11:05:05.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p><strong>很多人都将&lt;数据库设计范式&gt;作为数据库表结构设计“圣经”，认为只要按照这个范式需求设计，就能让设计出来的表结构足够优化，既能保证性能优异同时还能满足扩展性要求。殊不知，在N年前被奉为“圣经”的数据库设计3范式早就已经不完全适用了。这里我整理了一些比较常见的数据库表结构设计方面的优化技巧，希望对大家有用。</strong></p><p><strong>由于MySQL数据库是基于行(Row)存储的数据库，而数据库操作 IO 的时候是以 page(block)的方式，也就是说，如果我们每条记录所占用的空间量减小，就会使每个page中可存放的数据行数增大，那么每次 IO 可访问的行数也就增多了。反过来说，处理相同行数的数据，需要访问的 page 就会减少，也就是 IO 操作次数降低，直接提升性能。此外，由于我们的内存是有限的，增加每个page中存放的数据行数，就等于增加每个内存块的缓存数据量，同时还会提升内存换中数据命中的几率，也就是缓存命中率。</strong></p><h2 id="1、数据类型选择">1、数据类型选择</h2><p><strong>数据库操作中最为耗时的操作就是 IO 处理，大部分数据库操作 90% 以上的时间都花在了 IO 读写上面。所以尽可能减少 IO 读写量，可以在很大程度上提高数据库操作的性能。</strong></p><ul><li><strong>使用可以存下你的数据的最小的数据类型</strong></li><li><strong>使用简单的数据类型。int要比varchar类型在MySQL处理上简单</strong></li><li><strong>极可能的使用not null定义字段</strong></li><li><strong>尽量少用text类型，非用不可时最好考虑分表</strong></li></ul><p><strong>我们无法改变数据库中需要存储的数据，但是我们可以在这些数据的存储方式方面花一些心思。下面的这些关于字段类型的优化建议主要适用于记录条数较多，数据量较大的场景，因为精细化的数据类型设置可能带来维护成本的提高，过度优化也可能会带来其他的问题：</strong></p><ul><li><strong>数字类型：非万不得已不要使用DOUBLE，不仅仅只是存储长度的问题，同时还会存在精确性的问题。同样，固定精度的小数，也不建议使用DECIMAL，建议乘以固定倍数转换成整数存储，可以大大节省存储空间，且不会带来任何附加维护成本。对于整数的存储，在数据量较大的情况下，建议区分开 TINYINT / INT / BIGINT 的选择，因为三者所占用的存储空间也有很大的差别，能确定不会使用负数的字段，建议添加unsigned定义。当然，如果数据量较小的数据库，也可以不用严格区分三个整数类型。</strong></li><li><strong>字符类型：非万不得已不要使用 TEXT 数据类型，其处理方式决定了他的性能要低于char或者是varchar类型的处理。定长字段，建议使用 CHAR 类型，不定长字段尽量使用 VARCHAR，且仅仅设定适当的最大长度，而不是非常随意的给一个很大的最大长度限定，因为不同的长度范围，MySQL也会有不一样的存储处理。</strong></li><li><strong>时间类型：尽量使用TIMESTAMP类型，因为其存储空间只需要 DATETIME 类型的一半。对于只需要精确到某一天的数据类型，建议使用DATE类型，因为他的存储空间只需要3个字节，比TIMESTAMP还少。不建议通过INT类型类存储一个unix timestamp 的值，因为这太不直观，会给维护带来不必要的麻烦，同时还不会带来任何好处。</strong></li><li><strong>ENUM &amp; SET：对于状态字段，可以尝试使用 ENUM 来存放，因为可以极大的降低存储空间，而且即使需要增加新的类型，只要增加于末尾，修改结构也不需要重建表数据。如果是存放可预先定义的属性数据呢?可以尝试使用SET类型，即使存在多种属性，同样可以游刃有余，同时还可以节省不小的存储空间。</strong></li><li><strong>LOB类型：强烈反对在数据库中存放 LOB 类型数据，虽然数据库提供了这样的功能，但这不是他所擅长的，我们更应该让合适的工具做他擅长的事情，才能将其发挥到极致。在数据库中存储 LOB 数据就像让一个多年前在学校学过一点Java的营销专业人员来写 Java 代码一样。</strong></li></ul><h2 id="2、字符编码">2、字符编码</h2><p><strong>字符集直接决定了数据在MySQL中的存储编码方式，由于同样的内容使用不同字符集表示所占用的空间大小会有较大的差异，所以通过使用合适的字符集，可以帮助我们尽可能减少数据量，进而减少IO操作次数。</strong></p><ul><li><strong>纯拉丁字符能表示的内容，没必要选择 latin1 之外的其他字符编码，因为这会节省大量的存储空间。</strong></li><li><strong>如果我们可以确定不需要存放多种语言，就没必要非得使用UTF8或者其他UNICODE字符类型，这回造成大量的存储空间浪费。</strong></li><li><strong>MySQL的数据类型可以精确到字段，所以当我们需要大型数据库中存放多字节数据的时候，可以通过对不同表不同字段使用不同的数据类型来较大程度减小数据存储量，进而降低 IO 操作次数并提高缓存命中率。</strong></li></ul><h2 id="3、适当拆分">3、适当拆分</h2><p><strong>有些时候，我们可能会希望将一个完整的对象对应于一张数据库表，这对于应用程序开发来说是很有好的，但是有些时候可能会在性能上带来较大的问题。</strong></p><p><strong>当我们的表中存在类似于 TEXT 或者是很大的 VARCHAR类型的大字段的时候，如果我们大部分访问这张表的时候都不需要这个字段，我们就该义无反顾的将其拆分到另外的独立表中，以减少常用数据所占用的存储空间。这样做的一个明显好处就是每个数据块中可以存储的数据条数可以大大增加，既减少物理 IO 次数，也能大大提高内存中的缓存命中率。</strong></p><p><strong>上面几点的优化都是为了减少每条记录的存储空间大小，让每个数据库中能够存储更多的记录条数，以达到减少 IO 操作次数，提高缓存命中率。下面这个优化建议可能很多开发人员都会觉得不太理解，因为这是典型的反范式设计，而且也和上面的几点优化建议的目标相违背。</strong></p><h2 id="4、适度冗余">4、适度冗余</h2><p><strong>为什么我们要冗余?这不是增加了每条数据的大小，减少了每个数据块可存放记录条数吗?</strong></p><p><strong>确实，这样做是会增大每条记录的大小，降低每条记录中可存放数据的条数，但是在有些场景下我们仍然还是不得不这样做：</strong></p><ul><li><strong>被频繁引用且只能通过 Join 2张(或者更多)大表的方式才能得到的独立小字段。</strong></li><li><strong>这样的场景由于每次Join仅仅只是为了取得某个小字段的值，Join到的记录又大，会造成大量不必要的 IO，完全可以通过空间换取时间的方式来优化。不过，冗余的同时需要确保数据的一致性不会遭到破坏，确保更新的同时冗余字段也被更新。</strong></li></ul><h2 id="5、表的范式化和反范式化">5、表的范式化和反范式化</h2><p><strong>范式化是指数据库设计的规范，目前说到的范式化一般是指第三设计范式，也就是要求数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式。</strong></p><p><strong>反范式化是指为了查询效率的考虑把原本符合第三范式的表适当的增加冗余，以达到优化查询效率的目的，反范式化是一种空间来换取时间的操作。</strong></p><h2 id="6、规范的对象名称">6、规范的对象名称</h2><ul><li><strong>数据库和表名尽可能和所服务的业务模块名一致</strong></li><li><strong>服务于同意子模块的一类表尽量以子模块为前缀或者后缀</strong></li><li><strong>字段名称尽量保持和实际数据响应</strong></li><li><strong>索引名称尽量包含所有的检索字段名或者缩写</strong></li><li><strong>约束其他对象也应该尽可能包含所属表或者其他对象，以表名各自关系</strong></li></ul><h2 id="7、表的垂直拆分">7、表的垂直拆分</h2><p><strong>所谓的垂直拆分，就是把原来一个有很多列的表拆分成多个表，这解决了表的宽度问题。通常垂直拆分可以按依稀原则进行：</strong></p><ul><li><strong>把不常用的字段单独存放到一个表中</strong></li><li><strong>把大字段独立存放到一个表中</strong></li><li><strong>把经常一起使用的字段放到一起</strong></li></ul><h2 id="8、表的水平拆分">8、表的水平拆分</h2><p><strong>表的水平拆分是为了解决单表的数据量过大的问题（单表达到上亿条），水平拆分的表每个表的结构都是一致的。</strong></p><p><strong>常用的水平拆分方法为：</strong></p><ul><li><strong>对customer_id进行hash运算，如果要拆分成5个表则使用mode(customer_id, 5)取出0-4个值</strong></li><li><strong>针对不同的hashID把数据存到不同的表中</strong></li></ul><h2 id="9、尽量使用-NOT-NULL">9、尽量使用 NOT NULL</h2><p><strong>NULL 类型比较特殊，SQL 难优化。虽然 MySQL NULL类型和 Oracle 的NULL 有差异，会进入索引中，但如果是一个组合索引，那么这个NULL 类型的字段会极大影响整个索引的效率。此外，NULL 在索引中的处理也是特殊的，也会占用额外的存放空间。</strong></p><p><strong>很多人觉得 NULL 会节省一些空间，所以尽量让NULL来达到节省IO的目的，但是大部分时候这会适得其反，虽然空间上可能确实有一定节省，倒是带来了很多其他的优化问题，不但没有将IO量省下来，反而加大了SQL的IO量。所以尽量确保 DEFAULT 值不是 NULL，也是一个很好的表结构设计优化习惯。</strong></p><h2 id="10、优化数据库表结构-将字段很多的表分解成多个表-查看表的表结构">10、优化数据库表结构 将字段很多的表分解成多个表 查看表的表结构</h2><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200622151838867.png" alt="image-20200622151838867"></p><p><strong>优化表结构 1 将字段很多的表分解成多个表 2 增加中间表 3 合理增加冗余字段 4 优化插入记录的速度</strong></p><p><strong>禁用索引(在插入数据之前禁用索引，会让创建索引不会生效，命令：alter table 表名 disable keys ，注意表的创建表后加引擎 engine=myisam，可以禁用成功)</strong></p><p>![image-20200627201918154](E:\软件\博客\Blog\blog\source_posts\119 mysql优化表结构.assets\image-20200627201918154.png)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;很多人都将&amp;lt;数据库设计范式&amp;gt;作为数据库表结构设计“圣经”，认为只要按照这个范式需求设计，就能让设计出来的表结构足够优化，既能保证性能优异同时还能满足扩展性要求。殊不知，在N年前被奉为“圣经”的数据库设计3范
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://wsdlxgp.top/categories/mysql/"/>
    
    
      <category term="MySQL优化" scheme="https://wsdlxgp.top/tags/MySQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL软件优化</title>
    <link href="https://wsdlxgp.top/posts/49c6.html"/>
    <id>https://wsdlxgp.top/posts/49c6.html</id>
    <published>2020-06-20T16:02:00.000Z</published>
    <updated>2020-06-28T11:04:50.727Z</updated>
    
    <content type="html"><![CDATA[<h1>一、软件优化</h1><p>**MySQL瓶颈优化（业务从小到大的转变） 假设一个网站从最开始访问量很小做到日PV千万，我们来推测一下它的mysql服务器架构演变过程。 **</p><ul><li>**第一阶段： 网站访问量日pv量级在1w以下。单台机器跑web和db，不需要做架构层调优（比如，不需要增加memcached缓存）。此时，数据往往都是每日冷备份的，但是有时候如果考虑数据安全性，会搭建一个mysql主从。 **</li><li>**第二阶段： 网站访问量日pv达到几万。此时单台机器已经有点负载，需要我们把web和db分开，需要搭建memcached服务作为缓存。也就是说，在这个阶段，我们还可以使用单台机器跑mysql去承担整个网站的数据存储和查询。如果做mysql主从目的也是为了数据安全性。 **</li><li>**第三阶段： 网站访问量日pv达到几十万。单台机器虽然也可以支撑，但是需要的机器配置要比之前的机器多好多。如果经费允许，可以购买配置很高的机器来跑mysql服务，但是并不是说，配置翻倍，到了一定阶段配置增加已经不能带来性能的增加。所以，此阶段，我们会想到做mysql服务的集群，也就是说我们可以拿多台机器跑mysql。但mysql的集群和web集群是不一样的，我们需要考虑数据的一致性，所以不能简单套用做web集群的方式。可以做的架构是，mysql主从，一主多从。为了保证架构的强壮和数据完整，主只能是一个，从可以是多个。还有一个问题，我们需要想到，就是在前端web层，我们程序里面指定了mysql机器的ip，那么当mysql机器有多台时，程序里面如何去配置？我们可以拿多台机器跑mysql，其中一台写，其他多台是读，我们只需要把读写的ip分别配置到程序中，程序自动会去区分机器。 **</li><li><strong>第四阶段： 网站访问量日pv到几百万。之前的一主多从模式已经遇到瓶颈，因为当网站访问量变大，读数据库的量也会越来越大，我们需要多加一些从进来，但是从的数量增加到数十台时，由于主需要把bin-log全部分到所以从上，那么这个过程本身就是一件很繁琐读取，势必会造成从上同步过来的数据有很大延迟。所以，我们可以做一个优化，把mysql原来的一主多从为一主一从，然后作为其他从的主，而前面的主，只负责网站业务的写入，而后面的从不负责网站任何业务，只负责给其他从同步bin-log。这样还可以继续多叠加几个从库。 第五阶段： 网站访问量日pv到1千万的时候，我们发现，网站的写入量非常大，我们之前架构中只有一个主，这里的主已经成为瓶颈了。所以，需要再进一步作出调整</strong></li></ul><h3 id="解决瓶颈：做索引-查询一些MySQL数据库的性能参数用show-status">解决瓶颈：做索引 查询一些MySQL数据库的性能参数用show status</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW STATUS LIKE &#39;Connections&#39;; &#x2F;&#x2F;连接mysql服务器的次数<br>+---------------+-------+<br>| Variable_name | Value |<br>+---------------+-------+<br>| Connections | 4 |<br>+---------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="Uptime：mysql服务器的上线时间">Uptime：mysql服务器的上线时间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW STATUS LIKE &#39;uptime&#39;;<br>+---------------+----------+<br>| Variable_name | Value |<br>+---------------+----------+<br>| Uptime | 14159453 |<br>+---------------+----------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="Com-select-查询操作的次数">Com_select:查询操作的次数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW STATUS LIKE &#39;com_select&#39;;<br>+---------------+-------+<br>| Variable_name | Value |<br>+---------------+-------+<br>| Com_select | 7 |<br>+---------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="Com-insert：插入操作的次数">Com_insert：插入操作的次数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW STATUS LIKE &#39;com_insert&#39;;<br>+---------------+-------+<br>| Variable_name | Value |<br>+---------------+-------+<br>| Com_insert | 3 |<br>+---------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="Com-update：更新操作的次数">Com_update：更新操作的次数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW STATUS LIKE &#39;com_update&#39;;<br>+---------------+-------+<br>| Variable_name | Value |<br>+---------------+-------+<br>| Com_update | 0 |<br>+---------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="Com-delete：删除操作的次数">Com_delete：删除操作的次数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW STATUS LIKE &#39;com_delete&#39;;<br>+---------------+-------+<br>| Variable_name | Value |<br>+---------------+-------+<br>| Com_delete | 0 |<br>+---------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="Slow-queries：查询mysql服务器的慢查询次数">Slow_queries：查询mysql服务器的慢查询次数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW STATUS LIKE &#39;slow_queries&#39;;<br>+---------------+-------+<br>| Variable_name | Value |<br>+---------------+-------+<br>| Slow_queries | 0 |<br>+---------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="1、分析查询语句">1、分析查询语句</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Explain [extended] select select_option;<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; explain select * from student\G<br>*************************** 1. row ***************************<br>           id: 1<br>  select_type: SIMPLE<br>        table: student<br>   partitions: NULL<br>         type: ALL<br>possible_keys: NULL<br>          key: NULL<br>      key_len: NULL<br>          ref: NULL &#x2F;&#x2F;使用哪个列或常数与索引一起使用来查询记录<br>         rows: 13<br>     filtered: 100.00<br>        Extra: NULL<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>Select_type:表示select语句的类型 其中simple 是简单查询(不包括连接查询和子查询) Primary 主查询 Union 连接查询</strong></p><p><strong>Type:表的连接类型 System仅有系统表一行 Const 数据表中最多只有一行匹配，将在查询开始时被读取，并在余下的查询优化中，作为常量 Eq_ref 用于使用 = 操作符比较带索引的列 ref 对于来自前面的表的任意行的组合，从该表中读取所有匹配的行 ref_or_null 同上，添加可以专门搜索包含null值的行 index_merge 将连接类型表示使用了索引并优化方法 range 只检索给定范围的行 index 与all的连接类型相同，除了只扫描索引树 all 前面的表的任意行的组合，进行完整的表的扫描</strong></p><p><strong>possible_keys: NULL //指出mysql使用哪个索引在表中找到行 NULL表示没有创建索引</strong></p><p><strong>describe select 语句和分析查询语句</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; DESC select * from student\G<br>*************************** 1. row ***************************<br>           id: 1<br>  select_type: SIMPLE<br>        table: student<br>   partitions: NULL<br>         type: ALL<br>possible_keys: NULL<br>          key: NULL<br>      key_len: NULL<br>          ref: NULL<br>         rows: 13<br>     filtered: 100.00<br>        Extra: NULL<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>索引提高了查询效率 Create index 索引名 on 表名(字段)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#创建索引，在一定程度.上能够提升sQL的执行效率<br>create index index_student on student (studentNo);<br>mysql&gt; create index index_student on student (studentNo);<br>Query OK, 0 rows affected (0.02 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br><br>mysql&gt; select * from student;<br>+-----------+----------+-------------+-----+---------+-------------+----------------+---------------------+-------+--------------+<br>| studentNo | loginPwd | studentName | sex | gradeId | phone       | address        | bornDate            | email | identityCard |<br>+-----------+----------+-------------+-----+---------+-------------+----------------+---------------------+-------+--------------+<br>|     10000 | 123      | 郭靖        | 男  |       1 | 13645667783 | 天津市河西区   | 1990-09-08 00:00:00 | NULL  | NULL         |<br>|     10001 | 123      | 李文才      | 男  |       1 | 13645667890 | 地址不详       | 1994-04-12 00:00:00 | NULL  | NULL         |<br>|     10002 | 123      | 李斯文      | 男  |       1 | 13645556793 | 河南洛阳       | 1993-07-23 00:00:00 | NULL  | NULL         |<br>|     10003 | 123      | 张萍        | 女  |       1 | 13642345112 | 地址不详       | 1995-06-10 00:00:00 | NULL  | NULL         |<br>|     10004 | 123      | 韩秋洁      | 女  |       1 | 13812344566 | 北京市海淀区   | 1995-07-15 00:00:00 | NULL  | NULL         |<br>|     10005 | 123      | 张秋丽      | 女  |       1 | 13567893246 | 北京市东城区   | 1994-01-17 00:00:00 | NULL  | NULL         |<br>|     10006 | 123      | 肖梅        | 女  |       1 | 13563456721 | 河北省石家庄市 | 1991-02-17 00:00:00 | NULL  | NULL         |<br>|     10007 | 123      | 秦洋        | 男  |       1 | 13056434411 | 上海市卢湾区   | 1992-04-18 00:00:00 | NULL  | NULL         |<br>|     10008 | 123      | 何睛睛      | 女  |       1 | 13053445221 | 广州市天河区   | 1997-07-23 00:00:00 | NULL  | NULL         |<br>|     20000 | 123      | 王宝宝      | 男  |       2 | 15076552323 | 地址不详       | 1996-06-05 00:00:00 | NULL  | NULL         |<br>|     20010 | 123      | 何小华      | 女  |       2 | 13318877954 | 地址不详       | 1995-09-10 00:00:00 | NULL  | NULL         |<br>|     30011 | 123      | 陈志强      | 男  |       3 | 13689965430 | 地址不详       | 1994-09-27 00:00:00 | NULL  | NULL         |<br>|     30012 | 123      | 李露露      | 女  |       3 | 13685678854 | 地址不详       | 1992-09-27 00:00:00 | NULL  | NULL         |<br>+-----------+----------+-------------+-----+---------+-------------+----------------+---------------------+-------+--------------+<br>13 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>优化查询速度 注意： 1做索引了之后，用 like ‘xx%’ %不在第一位查询效率最高</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from student where studentName&#x3D;&#39;李文才&#39;;<br>select * from student where studentName like &#39;%文&#39;;<br>select * from student where studentName like &#39;文%&#39;;<br>select * from student where studentName like &#39;%文%&#39;;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200622141703271.png" alt="image-20200622141703271"></p><h2 id="2、多字段索引，除了第一字段查询最快，其余不按索引来，索引不生效"><strong>2、多字段索引，除了第一字段查询最快，其余不按索引来，索引不生效</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE INDEX index_id_price ON student(sex);<br>Query OK, 0 rows affected (0.03 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br><br>mysql&gt; explain select * from student where sex&#x3D;&#39;2&#39;\G;<br>*************************** 1. row ***************************<br>           id: 1<br>  select_type: SIMPLE<br>        table: student<br>   partitions: NULL<br>         type: ref<br>possible_keys: index_id_price<br>          key: index_id_price<br>      key_len: 6<br>          ref: const<br>         rows: 1<br>     filtered: 100.00<br>        Extra: NULL<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="3、若创建索引所设置的字段，查询索引组合-or-左右边的值都是属于索引设置字段下的值"><strong>3、若创建索引所设置的字段，查询索引组合 or 左右边的值都是属于索引设置字段下的值</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; EXPLAIN SELECT * FROM student where studentName&#x3D;&#39;何小华&#39; or sex&#x3D;2\G<br>*************************** 1. row ***************************<br>           id: 1<br>  select_type: SIMPLE<br>        table: student<br>   partitions: NULL<br>         type: ALL<br>possible_keys: index_id_price<br>          key: NULL<br>      key_len: NULL<br>          ref: NULL<br>         rows: 13<br>     filtered: 19.00<br>        Extra: Using where<br>1 row in set, 2 warnings (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>profiling分析查询 通过慢日志查询可以知道哪些SQL语句执行效率低下，通过explain我们可以得知SQL语句的具体执行情况，索引使用等，还可以结合show命令查看执行状态。如果觉得explain的信息不够详细，可以同通过profiling命令得到更准确的SQL执行消耗系统资源的信息。 profiling默认是关闭的。可以通过以下语句查看</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#39;%profiling%&#39;; &#x2F;&#x2F;off表示未开启<br>+------------------------+-------+<br>| Variable_name          | Value |<br>+------------------------+-------+<br>| have_profiling         | YES   |<br>| profiling              | OFF   |<br>| profiling_history_size | 15    |<br>+------------------------+-------+<br>3 rows in set, 1 warning (0.00 sec)<br>mysql&gt; select @@profiling; &#x2F;&#x2F;0表示未开启<br>+-------------+<br>| @@profiling |<br>+-------------+<br>|           0 |<br>+-------------+<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>打开profiling功能： <code>mysql&gt;set profiling=1</code>; 执行需要测试的sql 语句：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; set profiling&#x3D;1;<br>Query OK, 0 rows affected, 1 warning (0.00 sec)<br><br>mysql&gt; select @@profiling;<br>+-------------+<br>| @@profiling |<br>+-------------+<br>|           1 |<br>+-------------+<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>执行要测试的sql语句</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt;  select * from student where studentName&#x3D;&#39;郭靖&#39;;<br>+-----------+----------+-------------+-----+---------+-------------+--------------+---------------------+-------+--------------+<br>| studentNo | loginPwd | studentName | sex | gradeId | phone       | address      | bornDate            | email | identityCard |<br>+-----------+----------+-------------+-----+---------+-------------+--------------+---------------------+-------+--------------+<br>|     10000 | 123      | 郭靖        | 男  |       1 | 13645667783 | 天津市河西区 | 1990-09-08 00:00:00 | NULL  | NULL         |<br>+-----------+----------+-------------+-----+---------+-------------+--------------+---------------------+-------+--------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; show profiles;<br>+----------+------------+--------------------------------------------------+<br>| Query_ID | Duration   | Query                                            |<br>+----------+------------+--------------------------------------------------+<br>|        1 | 0.00011150 | select @@profiling                               |<br>|        2 | 0.00015925 | select * from student where f_name&#x3D;&#39;studentName&#39; |<br>|        3 | 0.00013125 | select * from student where f_name&#x3D;&#39;studentName&#39; |<br>|        4 | 0.00033975 | select * from student where studentName&#x3D;&#39;&#39;       |<br>|        5 | 0.00027950 | select * from student where studentName&#x3D;&#39;????&#39;   |<br>+----------+------------+--------------------------------------------------+<br>5 rows in set, 1 warning (0.00 sec)<br><br>mysql&gt; show profile for query 2;<br>+----------------------+----------+<br>| Status               | Duration |<br>+----------------------+----------+<br>| starting             | 0.000050 |<br>| checking permissions | 0.000005 |<br>| Opening tables       | 0.000011 |<br>| init                 | 0.000034 |<br>| end                  | 0.000003 |<br>| query end            | 0.000003 |<br>| closing tables       | 0.000005 |<br>| freeing items        | 0.000037 |<br>| cleaning up          | 0.000012 |<br>+----------------------+----------+<br>9 rows in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>status:是profile里的状态，duration：是status状态下的耗时。因此我们关注的就是那个状态最耗时，这些状态中那些可以优化。 当然也可以查看更多的信息如CPU等等</strong></p><blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex">SHOW PROFILE [type [, type] ... ][FOR QUERY n] <br><br>type: ALL:显示所有的开销信息 <br>BLOCK IO:显示块IO相关开销 <br>CPU:显示用户CPU时间、系统CPU时间 <br>IPC:显示发送和接收相关开销信息<br>PAGE FAULTS:显示页面错误相关开销信息 <br>SWAPS:显示交换次数相关开销的信息 测试完成之以后，记得要关闭调试功能，以免影响数据库的正常使用：<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; set profiling&#x3D;0;<br></code></pre></td></tr></table></figure><p><strong>优化数据库表结构 将字段很多的表分解成多个表 查看表的表结构</strong></p><p>**优化表结构 1 将字段很多的表分解成多个表 2 增加中间表 3 合理增加冗余字段 4 优化插入记录的速度 **</p><h4 id="（1），禁用索引-在插入数据之前禁用索引，会让创建索引不会生效，命令：alter-table-表名-disable-keys-，注意表的创建表后加引擎-engine-myisam，可以禁用成功"><strong>（1），禁用索引(在插入数据之前禁用索引，会让创建索引不会生效，命令：alter table 表名 disable keys ，注意表的创建表后加引擎 engine=myisam，可以禁用成功)</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; ALTER TABLE fruits DISABLE KEYS;<br>Query OK, 0 rows affected, 1 warning (0.05 sec)<br></code></pre></td></tr></table></figure><h4 id="2-，禁用唯一性检查-插入记录之前禁用唯一性检查，命令：set-unique-checks-0-关闭set-unique-checks-1">(2)，禁用唯一性检查(插入记录之前禁用唯一性检查，命令：set unique_checks=0 关闭set unique_checks=1)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; set unique_checks&#x3D;0;<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="（3）使用批量插入-多条插入命令整合成一条命令">（3）使用批量插入(多条插入命令整合成一条命令)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; INSERT INTO fruits values(&#39;x1&#39;,&#39;101&#39;,&#39;mongo2&#39;,&#39;5.5&#39;);<br>Query OK, 1 row affected (0.00 sec)<br><br>mysql&gt; INSERT INTO fruits values(&#39;x2&#39;,&#39;101&#39;,&#39;mongo2&#39;,&#39;5.5&#39;);<br>Query OK, 1 row affected (0.08 sec)<br><br>mysql&gt; INSERT INTO fruits values(&#39;x3&#39;,&#39;101&#39;,&#39;mongo2&#39;,&#39;5.5&#39;);<br>Query OK, 1 row affected (0.01 sec)<br><br>mysql&gt; INSERT INTO fruits values(&#39;x4&#39;,&#39;101&#39;,&#39;mongo2&#39;,&#39;5.5&#39;);<br>Query OK, 1 row affected (0.01 sec)<br><br>mysql&gt; insert into fruits values (&#39;x8&#39;,&#39;101&#39;,&#39;mongo2&#39;,&#39;5.5&#39;),<br>(&#39;x7&#39;,&#39;101&#39;,&#39;mongo2&#39;,&#39;5.5&#39;), (&#39;x6&#39;,&#39;101&#39;,&#39;mongo2&#39;,&#39;5.5&#39;),<br>(&#39;x5&#39;,&#39;101&#39;,&#39;mongo2&#39;,&#39;5.5&#39;);<br>Query OK, 4 rows affected (0.07 sec)<br>Records: 4 Duplicates: 0 Warnings: 0<br></code></pre></td></tr></table></figure><h4 id="4-使用load-data-infile批量插入-对于innnodb表来说-1-禁用唯一性检查">(4)使用load data infile批量插入 对于innnodb表来说 (1) 禁用唯一性检查</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SET unique_checks&#x3D;0;<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="5-禁用外键检查-命令-set-foreign-key-checks-0，开启-1">(5) 禁用外键检查(命令: set foreign_key_checks=0，开启=1)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SET foreign_key_checks&#x3D;0;<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="6-禁用自动提交-命令-set-autocommit-0，开启-1">(6) 禁用自动提交(命令: set autocommit=0，开启=1)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; set autocommit&#x3D;0;<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="4、分析表，检查表和优化表-分析表：分析关键字的分布-检查表：检查是否存在错误-优化表：消除删除或更新造成的空间浪费">4、分析表，检查表和优化表 分析表：分析关键字的分布 检查表：检查是否存在错误 优化表：消除删除或更新造成的空间浪费</h2><p><strong>分析表语句：<code>analyze [local |no_wirte_to_binlog] table tb1_name[tb2_name]….. Local</code>的关键字不写入二进制日志 后跟1个表或多个表 在分析期间只能读，不能进行插入和更新的操作。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; ANALYZE TABLE fruits;<br>+-------------+---------+----------+----------+<br>| Table | Op | Msg_type | Msg_text |<br>+-------------+---------+----------+----------+<br>| test.fruits | analyze | status | OK |<br>+-------------+---------+----------+----------+<br>1 row in set (0.07 sec)<br></code></pre></td></tr></table></figure><p><strong>Table是表名 op执行的操作是什么 msg_type 信息级别（status是正常状态，info是信息，note注意，warning警告，error错误） msg_text 是显示信息</strong></p><p><strong>检查表：检查是否存在错误,关键字统计，检查视图是否有错误 Check table 表名 <code>option ={quick |fast | medium|extended |changed} Quick</code> 不扫描行，不检查错误连接 Fast 只检查没有被正确关闭的表 Medium 扫描行验证被删除的连接是有效的，也可以计算各行的关键字校验和。 Extended 对每行所有关键字进行全面的关键字查找Changed 只检查上次检查后被更改的表和没有被正确关闭的表 Option只对myisam 有效 对innodb表无效 在执行时会给表加上只读锁</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CHECK TABLE fruits ;<br>+-------------+-------+----------+----------+<br>| Table | Op | Msg_type | Msg_text |<br>+-------------+-------+----------+----------+<br>| test.fruits | check | status | OK |<br>+-------------+-------+----------+----------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>优化表：消除删除或更新造成的空间浪费 Optimize [local |no_write_to_binlog] table tb1_name …. 只能优化myisam的表和innodb的表都有效 但是只能优化表中的varchar\text\blob 执行过程中上只读锁</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; optimize table fruits\G<br>*************************** 1. row ***************************<br>Table: test.fruits<br>Op: optimize<br>Msg_type: note<br>Msg_text: Table does not support optimize, doing recreate + analyze instead<br>*************************** 2. row ***************************<br>Table: test.fruits<br>Op: optimize<br>Msg_type: status<br>Msg_text: OK<br>2 rows in set (0.12 sec)<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;一、软件优化&lt;/h1&gt;
&lt;p&gt;**MySQL瓶颈优化（业务从小到大的转变） 假设一个网站从最开始访问量很小做到日PV千万，我们来推测一下它的mysql服务器架构演变过程。 **&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**第一阶段： 网站访问量日pv量级在1w以下。单台机器跑web和d
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://wsdlxgp.top/categories/mysql/"/>
    
    
      <category term="MySQL优化" scheme="https://wsdlxgp.top/tags/MySQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL之my.cnf配置文件优化</title>
    <link href="https://wsdlxgp.top/posts/49ca.html"/>
    <id>https://wsdlxgp.top/posts/49ca.html</id>
    <published>2020-06-19T16:01:10.000Z</published>
    <updated>2020-06-28T10:57:30.950Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[client]<br>port &#x3D; 3306<br>socket &#x3D; &#x2F;tmp&#x2F;mysql.sock<br>default-character-set &#x3D; utf8<br>[mysql]<br>no-auto-rehash                                            #仅允许使用键值的updates和deletes<br>[mysqld]<br>port &#x3D; 3306                                                #msyql服务器端口号<br>basedir &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql                                 #mysql安装目录<br>datadir &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data                            #mysql数据存放目录<br>#datadir &#x3D; &#x2F;data&#x2F;mysql&#x2F;data                                #同上<br>socket &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;mysql.sock                  #sock文件<br> <br>#字符集与校对规则<br>character-set-server &#x3D; utf8                                #默认字符集<br>collation-server &#x3D; utf8_general_ci                         #设置校对规则<br> <br>external-locking &#x3D; FALSE                                   #避免外部锁定(减少出错几率，增加稳定性)<br>skip-name-resolv                                           #禁止外部连接进行DNS解析<br>skip-slave-start                                           # 复制进程就不会随着数据库的启动而启动 http:&#x2F;&#x2F;blog.csdn.net&#x2F;aeolus_pu&#x2F;article&#x2F;details&#x2F;9419965 <br>#master库binlog参数相关<br>server-id &#x3D; 1                                              #主从复制时，ID不能相同<br>#binlog_format &#x3D; mixed                                     #二进制日志格式（mixed、row、statement）<br>binlog-cache-size &#x3D; 32M                                    #设置二进制日志缓存大小<br>sync-binlog &#x3D; 1                                            #每隔N秒将缓存中的二进制日志记录写回硬盘<br>max_binlog_cache_size &#x3D; 8M                                 #最大的二进制Cache日志缓冲尺寸<br>max_binlog_size &#x3D; 1G                                       #单个二进制日志文件的最大值，默认1G，最大1G<br>log-bin-index &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;mysql-bin.index      #binlog索引文件位置<br>log-bin &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;mysql-bin                  #binlog日志存放目录<br>expire_logs_days &#x3D; 90                                      #二进制日志文件过期时间<br>#slave数据库binlog参数<br>server-id &#x3D; 10                                             #各数据库id不能相同<br>log_slave_updates &#x3D; 1                                      #级联也使用<br>relay-log &#x3D; &#x2F;usr&#x2F;lcoal&#x2F;mysql&#x2F;data&#x2F;relay-bin                #relady目录<br>relay-log-info-file &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;relay-log.info #info目录<br>slave-skip-errors &#x3D; 1007,1008,1032,1062                    #跳过主从复制时的错误<br>read-only &#x3D; 1                                              #从服务器只读,SQL线程不影响，具有super，root用户不限制<br>master-connect-retry &#x3D; 60                                  #主从复制丢失，重连间隔时间，默认60s<br>#replicate-ignore-db &#x3D; mysql                               #忽略mysql库不同步<br>replicate-wild-do-table&#x3D;testdb1.%<br>replicate-wild-do-table&#x3D;testdb2.%<br>replicate-wild-do-table&#x3D;testdb3.%<br>#master半同步开启参数<br>rpl_semi_sync_master_enabled &#x3D; ON<br>rpl_semi_sync_master_timeout &#x3D; 10000<br>#rpl_semi_sync_master_wait_no_slave &#x3D; ON<br>#rpl_semi_sync_master_trace_level &#x3D; 32<br>#slave半同步开启参数<br>rpl_semi_sync_slave_enabled &#x3D; ON<br>#rpl_semi_sync_slave_trace_level &#x3D; 32<br> <br>back_log &#x3D; 1000                                          #指出在MySQL暂时停止响应新请求之前，短时间内的多少个请求<br>open_files_limit &#x3D; 1024                                  #打开文件的最大个数，如果出现too mantopen files之类的就需要调整该值了<br> <br>#连接相关<br>max_connections &#x3D; 2000                                   #指定MySQL允许的最大连接进程数，show global variables like &#39;%connections%&#39;; http:&#x2F;&#x2F;elf8848.iteye.com&#x2F;blog&#x2F;1847445 <br>max_user_connections &#x3D; 2000                              #单用户最大的连接数，max_user_connections &lt; 实例 max_user_connections &lt; max_connections<br>max_connect_errors &#x3D; 100000                              #默认为10，设置每个主机的连接请求异常中断的最大次数，超过后会blocked，连接成功后初始0，出现错误后需要flush hosts<br> <br>max_allowed_packet &#x3D; 8M                                  #服务器一次能处理的最大的查询包的值<br>wait_timeout &#x3D; 360                                       #指定一个请求的最大连接时间<br>interactive_timeout &#x3D; 360                                #连接保持活动的时间<br>#访问日志<br>#general_log &#x3D; on<br>#general_log_file &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;mysql_access.log<br> <br>#错误日志<br>log_error &#x3D; &#x2F;data&#x2F;mysql&#x2F;data&#x2F;mysql_error.log<br>#慢查询相关参数<br>slow_query_log &#x3D; on                                    #开启慢查询<br>log-queries-not-using-indexes                          #记录所有没有使用到索引的查询语句<br>long_query_time &#x3D; 2                                    #指定多少秒未返回结果的查询属于慢查询<br>min_examined_row_limit &#x3D; 5                             #记录那些由于查找了多余5次而引发的慢查询<br>log-slow-admin-statements                              #记录那些慢的OPTIMIZE TABLE,ANALYZE TABLE和ALTER TABLE语句<br>log-slow-slave-statements                              #记录由slave所产生的慢查询<br>slow_query_log_file &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;slow.log   #指定慢查询日志文件路径<br>table_cache &#x3D; 614                                      #表分配的内存，物理内存越大，设置就越大<br>table_open_cache &#x3D; 512                                 #设置高速缓存表的数目<br>thread_cache_size &#x3D; 64                                 #服务器线程缓存数，与内存大小有关(建议大于3G设置为64)<br>thread_concurrency &#x3D; 32                                #CPU核数的两倍<br>query_cache_size &#x3D; 32M                                 #指定MySQL查询缓冲区的大小<br>query_cache_limit &#x3D; 2M                                 #只有小于此设置值的结果才会被缓存<br>query_cache_min_res_unit &#x3D; 2k                          #设置查询缓存分配内存的最小单位<br>key_buffer_size &#x3D; 512M                                #指定用于索引的缓冲区大小，增加它可得到更好的索引处理性能<br>sort_buffer_size &#x3D; 2M                                 #设置查询排序时所能使用的缓冲区大小，系统默认大小为2MB<br>join_buffer_size &#x3D; 1M                                 #联合查询操作所能使用的缓冲区大小<br>read_buffer_size &#x3D; 4M                                 #读查询操作所能使用的缓冲区大小<br>read_rnd_buffer_size &#x3D; 16M                            #设置进行随机读的时候所使用的缓冲区<br>thread_stack &#x3D; 192K                                   #设置Mysql每个线程的堆栈大小，默认值足够大，可满足普通操作<br>bulk_insert_buffer_size &#x3D; 8M                          #可以适当调整参数至16MB~32MB，建议8MB<br>#myisam参数引擎相关<br>myisam_sort_buffer_size &#x3D; 128M<br>myisam_max_sort_file_size &#x3D; 10G<br>myisam_repair_threads &#x3D; 1<br>myisam_recover                                       #自动检查和修复没有适当关闭的MyISAM表<br>key_buffer_size &#x3D; 16M                                #myisam索引buffer，只有key没有data<br> <br>transaction_isolation &#x3D; READ-COMMITTED              #事务隔离级别<br>tmp_table_size &#x3D; 64M                                #设置内存临时表最大值<br>max_heap_table_size &#x3D; 64M                           #独立的内存表所允许的最大容量<br>#innodb引擎参数相关<br>default-storage-engine&#x3D;InnoDB                      #默认表的类型为InnoDB<br>innodb_old_blocks_time &#x3D;1000                       #减小单次的大批量数据查询,默认为0，调整后性能提升80%                     http:&#x2F;&#x2F;www.cnblogs.com&#x2F;cenalulu&#x2F;archive&#x2F;2012&#x2F;10&#x2F;10&#x2F;2718585.html <br>innodb_flush_method &#x3D; O_DIRECT                     #从innode刷新到磁盘，不经过系统write,fdatasync(默认)，O_DSYNC，O_DIRECT http:&#x2F;&#x2F;blog.csdn.net&#x2F;jiao_fuyou&#x2F;article&#x2F;details&#x2F;16113403 <br>innodb_additional_mem_pool_size &#x3D; 16M              #设置InnoDB存储的数据目录信息和其他内部数据结构的内存池大小<br>innodb_buffer_pool_size &#x3D; 51G                      #InnoDB使用一个缓冲池来保存索引和原始数据，官方建议物理内存的80%<br>innodb_data_file_path &#x3D; ibdata1:128M:autoextend    #表空间<br>innodb_file_io_threads &#x3D; 4                         #InnoDB中的文件I&#x2F;O线程，通常设置为4，innodb除master线程外，还有insert buffer, log, read, write这4种线程，默认各有一个<br>innodb_read_io_threads &#x3D; 8<br>innodb_write_io_threads &#x3D; 8<br>innodb_thread_concurrency &#x3D; 8                      #服务器有几个CPU就设置为几，建议用默认设置，一般设为8<br>innodb_flush_log_at_trx_commit &#x3D; 2                 #设置为0就等于innodb_log_buffer_size队列满后再统一存储，默认为1<br>innodb_log_buffer_size &#x3D; 16M                       #默认为1MB，通常设置为6-8MB就足够<br>innodb_log_file_size &#x3D; 512M                        #确定日志文件的大小，更大的设置可以提高性能，但也会增加恢复数据库的时间<br>innodb_log_files_in_group &#x3D; 3                      #为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3<br>innodb_max_dirty_pages_pct &#x3D; 90                    #InnoDB主线程刷新缓存池中的数据<br>innodb_lock_wait_timeout &#x3D; 120                     #InnoDB事务被回滚之前可以等待一个锁定的超时秒数<br>innodb_file_per_table &#x3D; 1                          #InnoDB为独立表空间模式，每个数据库的每个表都会生成一个数据空间,0关闭,1开启<br>innodb_autoextend_increment &#x3D; 256                  #这个参数的作用是控制innodb 共享表空间文件自动扩展的大小<br>[mysqldump]<br>quick<br>max_allowed_packet &#x3D; 64M<br>[mysqld_safe]<br>log-error &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;mysql.err<br>pid-file &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;mysqld.pid<br> <br>查询innodb分配资源<br>mysql&gt; show engine innodb status;<br>----------------------<br>BUFFER POOL AND MEMORY<br>----------------------<br>Total memory allocated 137363456; in additional pool allocated 0<br>Dictionary memory allocated 59957<br>Buffer pool size   8191<br>Free buffers       8028<br>Database pages     163<br>Old database pages 0<br>Modified db pages  0<br>Pending reads 0<br>Pending writes: LRU 0, flush list 0, single page 0<br>Pages made young 0, not young 0<br>0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s<br>Pages read 163, created 0, written 1<br>0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.00 writes&#x2F;s<br>No buffer pool page gets since the last printout<br>Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s<br>LRU len: 163, unzip_LRU len: 0<br>I&#x2F;O sum[0]:cur[0], unzip sum[0]:cur[0]<br> <br> <br> <br>我们使用的是专用于MySQL的（5.5 Percona的）上运行CentOS的（不同口味），主要128GB的服务器。我们innodb_buffer_pool_size设置为104GB这些和他们也有&#x2F; tmp目录8GB的内存磁盘。他们被大量使用，但从未使用过任何的交换。当然vm.swappiness设置为1，<br>下面就是我们用较低层的服务器（包括128GB为简洁起见），他们又从来没有使用过任何掉期和运行大型数据库（2-3TB）：<br>128GB RAM：innodb_buffer_pool_size &#x3D; 104GB<br>64GB RAM：innodb_buffer_pool_size &#x3D; 56G<br>32GB RAM：innodb_buffer_pool_size &#x3D; 28G<br> <br>在大多数情况下，我们分配（N - 7G）* 0.9。所以对于一个64G的节点，我们最终分配给缓冲池内存〜51G<br>64GB RAM：innodb_buffer_pool_size &#x3D; 51G<br> <br>https:&#x2F;&#x2F;www.percona.com&#x2F;blog&#x2F;2015&#x2F;06&#x2F;02&#x2F;80-ram-tune-innodb_buffer_pool_size&#x2F; <br>http:&#x2F;&#x2F;osxr.org:8080&#x2F;mysql&#x2F;ident?_i&#x3D;back_log&amp;_remember&#x3D;1 <br> <br> <br>王导DBA MySQL优化<br>log_error &#x3D; localhost3306.err<br>sync_binlog&#x3D;1<br>innodb_old_blocks_time &#x3D;1000<br>innodb_flush_method &#x3D; O_DIRECT<br>back_log&#x3D;1000<br>max_connections &#x3D; 2000<br>max_user_connections&#x3D;2000<br>min_examined_row_limit &#x3D;5<br>skip-slave-start<br>skip-name-resolve<br>max_connect_errors &#x3D; 100000<br>character-set-server&#x3D;utf8<br>collation-server&#x3D;utf8_bin<br>binlog_cache_size&#x3D;32M<br>query_cache_limit &#x3D; 2M<br>tmp_table_size&#x3D;256M<br>max_heap_table_size&#x3D;256M<br>interactive_timeout&#x3D;360<br>wait_timeout&#x3D;360<br>log_slave_updates&#x3D;1<br>expire_logs_days&#x3D;60<br>binlog_format&#x3D;mixed<br>tmpdir&#x3D;&#x2F;dev&#x2F;shm<br>innodb_autoextend_increment &#x3D; 256<br>innodb_buffer_pool_instances&#x3D;8<br>innodb_additional_mem_pool_size&#x3D;128M<br>innodb_max_dirty_pages_pct&#x3D;80<br>innodb_read_io_threads &#x3D; 8<br>innodb_write_io_threads &#x3D; 8<br>innodb_log_file_size &#x3D; 1G<br>innodb_log_files_in_group &#x3D; 2<br>innodb_flush_log_at_trx_commit &#x3D; 2<br>innodb_file_per_table&#x3D;1<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://wsdlxgp.top/categories/mysql/"/>
    
    
      <category term="MySQL优化" scheme="https://wsdlxgp.top/tags/MySQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL配置参数优化</title>
    <link href="https://wsdlxgp.top/posts/49c4.html"/>
    <id>https://wsdlxgp.top/posts/49c4.html</id>
    <published>2020-06-19T16:01:00.000Z</published>
    <updated>2020-06-28T11:00:14.775Z</updated>
    
    <content type="html"><![CDATA[<h1>一、配置参数优化</h1><p><strong>MySQL参数优化对于不同的网站，与其在线量、访问量、帖子数量、网络情况,以及机器硬件配置都有关系,优化不可能一-次性完成， 需要不断的观察以及调试，才有可能得到最佳效果。下面列出了 对性能优化影响较大的主要变量，主要分为连接请求的变星和缓冲区变星。</strong></p><h2 id="1、连接请求的变量">1、连接请求的变量</h2><h3 id="（1）max-connections">（1）max_connections</h3><p><strong>MySQL的最大连接数，如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当<br>然这建立在机器能支撑的情况下，因为如果连接数越多，MySQL会 为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。数值过 小会经常出现ERROR 1040: Too many connections错误，可以通过<code>mysql&gt; show status like 'connections';</code>通配符查看当前状态的连接数量(试图连接到MySQL(不管是否连接成功)的连接数)，以定夺该值的大小。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt;show variables like &#39;max_connections&#39;; #最大连接数<br>+-----------------+-------+<br>| Variable_name   | Value |<br>+-----------------+-------+<br>| max_connections | 151   |<br>+-----------------+-------+<br>1 row in set (0.00 sec)<br><br>mysql&gt;show status like &#39;max_used_connections&#39;; #响应的连接数<br>+----------------------+-------+<br>| Variable_name        | Value |<br>+----------------------+-------+<br>| Max_used_connections | 1     |<br>+----------------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>rnax_used_connections / max_connections * 100% (理想值≈85%)如果max_used_connections跟max_connections相同那么就是max_connections设 置过低或者超过服务器负载上限了，低于10%则设置过大。如何设置max_connections? 修改/etc/my.cnf文件，在[mysqld]下面添加如下内容， 如设置最大连接数为1024</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">max_connections &#x3D; 1024<br></code></pre></td></tr></table></figure><p><strong>重启mysq|服务</strong></p><h2 id="2、back-log-MySQL能暂存的连接数量。">2、back _log MySQL能暂存的连接数量。</h2><p><strong>当主要MySQL线程在一个很短时间内得到非常多的连接请求，它就会起作用。如果MySQL的连接数据达到max. connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back Jlog, 如果等待连接的数量超过back _log,将不被授予连接资源。back_log值指出在MySQL暂时停止回答新请求之前的短时间内有多少个请求可以被存在堆栈中。只有如果期望在一个短时间内有很多连接，你需要增加它。当观察你主机进程列表(<code>mysql&gt; show full processlist</code>)，发现大量<code>xxxxx | unauthenticated user | x | xxx.xxx.xxx.xxx I NULL I Connect | NULL I login | NULL</code>的待连接进程时，就要加大back. log的值了或加大max_connections的值。通过</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show full processlist;<br>+----+------+-----------+------+---------+------+----------+----<br>| Id | User | Host      | db   | Command | Time | State    | Inf<br>+----+------+-----------+------+---------+------+----------+----<br>|  2 | root | localhost | NULL | Query   |    0 | starting | sho<br>+----+------+-----------+------+---------+------+----------+----<br>1 row in set (0.00 sec)<br><br>mysql&gt; show variables like &#39;back_log&#39;; #查看back_log的设置<br>+---------------+-------+<br>| Variable_name | Value |<br>+---------------+-------+<br>| back_log      | 80    |<br>+---------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>如何设置back_log? 修改/etc/my.cnf文件，在[mysqld]下面添加如下内容，如设置最大连接数为1024</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">back_log &#x3D; 数值<br></code></pre></td></tr></table></figure><p><strong>重启mysql服务，查看一下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#39;back_log&#39;;<br>+---------------+-------+<br>| Variable_name | Value |<br>+---------------+-------+<br>| back_log      | 1024  |<br>+---------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="3、wait-timeout和interactive-timeout-wait-ftimeout">3、wait_timeout和interactive_timeout wait_ftimeout</h2><p><strong>wait_timeout和interactive_timeout wait_ftimeout –  指的是MySQL在关闭一个非交互的连接之前所要等待的秒数interactive. time – 指的是mysq|在关闭一个交互的连接之前所要等待的秒数，比如我们在终端上进入mysq|管理，使用的即使交互的连接，这时候，如果没有操作的时间超过了interactive_timne设置的时间就会自动断开。默认数值是28800，可调优为7200。对性能的影响: wait_timeout:</strong></p><p><strong>(1) 如果设置大小，那么连接关闭的很快，从而使一些持久的连接不起作用</strong></p><p><strong>(2) 如果设置太大，容易造成连接打开时间过长，在show processlist时，能看到太多的sleep状态的连接，从而造成too many connections错误</strong></p><p><strong>(3)一般希望wait_timeout尽可能地低interactive_timeout的设置将要对你的web application没有多大</strong><br><strong>的影响查看wait_timeout和interactive_timeout</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#39;%wait_timeout%&#39;;<br>+--------------------------+----------+<br>| Variable_name            | Value    |<br>+--------------------------+----------+<br>| innodb_lock_wait_timeout | 50       |<br>| lock_wait_timeout        | 31536000 |<br>| wait_timeout             | 28800    |<br>+--------------------------+----------+<br>3 rows in set (0.01 sec)<br><br>mysql&gt; show variables like &#39;%interactive_timeout%&#39;;<br>+---------------------+-------+<br>| Variable_name       | Value |<br>+---------------------+-------+<br>| interactive_timeout | 28800 |<br>+---------------------+-------+<br>1 row in set (0.01 sec)<br><br>set global interactive_timeout&#x3D;7200;<br></code></pre></td></tr></table></figure><p><strong>如何设置wait_timeout和linteractive_timeout?修改/etc/my.cnf文件，在[mysqld]下 面添加如下内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">wait_timeout&#x3D;100<br>interactive_timeout&#x3D;100<br></code></pre></td></tr></table></figure><p><strong>重启一下mysql，查看一下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#39;%wait_timeout%&#39;;<br>+--------------------------+----------+<br>| Variable_name            | Value    |<br>+--------------------------+----------+<br>| innodb_lock_wait_timeout | 50       |<br>| lock_wait_timeout        | 31536000 |<br>| wait_timeout             | 100      |<br>+--------------------------+----------+<br>3 rows in set (0.00 sec)<br><br>mysql&gt; show variables like &#39;%interactive_timeout%&#39;;<br>+---------------------+-------+<br>| Variable_name       | Value |<br>+---------------------+-------+<br>| interactive_timeout | 100   |<br>+---------------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（2）缓冲区变量">（2）缓冲区变量</h3><h3 id="全局缓冲："><strong>全局缓冲：</strong></h3><h3 id="4、key-buffer-size">4、key_buffer_size</h3><p><strong>key_buffer_size指定索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度。通过检查状态值Key_read_requests和Key_reads，可以知道key_buffer_size设置是否合理。比例key_reads/ key_read_requests应该尽可能的低，至少是1:100，1:1000更好（上述状态值可以使用SHOW STATUS LIKE ‘key_read%’获得）。</strong></p><p><strong>一共有6个索引读取请求，有3个请求在内存中没有找到直接从硬盘读取索引，计算索引未命中缓存的概率：<br>key_cache_miss_rate ＝ Key_reads / Key_read_requests * 100% =50% key_buffer_size只对MyISAM表起作用。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值。可以使用检查状态值created_tmp_disk_tables得知详情。</strong></p><p><strong>如何调整key_buffer_size 默认配置数值是8388608(8M)，主机有4GB内存，可以调优值为268435456(256MB) 修改/etc/my.cnf文件，在[mysqld]下面添加如下内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">key_buffer_size&#x3D;268435456或key_buffer_size&#x3D;256M<br></code></pre></td></tr></table></figure><p><strong>重启MySQL Server进入后，查看设置已经生效。</strong></p><h3 id="5、query-cache-size-查询缓存简称QC">5、query_cache_size(查询缓存简称QC)</h3><p><strong>query_cache_size(查询缓存简称QC) 使用查询缓冲，MySQL将查询结果存放在缓冲区中，今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。 一个SQL查询如果以select开头，那么MySQL服务器将尝试对其使用查询缓存。</strong></p><blockquote><p><strong>注：两个SQL语句，只要相差哪怕是一个字符（例如大小写不一样；多一个空格等），那么这两个SQL<br>将使用不同的一个CACHE。</strong></p></blockquote><p><strong>通过检查状态值’Qcache%’，可以知道query_cache_size设置是否合理（上述状态值可以使用SHOW STATUS LIKE ‘Qcache%’获得）。</strong></p><p>**Qcache_free_blocks：缓存中相邻内存块的个数。如果该值显示较大，则说明Query Cache 中的内存碎片较多了，FLUSH QUERY CACHE会对缓存中的碎片进行整理，从而得到一个空闲块。 **</p><p>**注：当一个表被更新之后，和它相关的cache blocks将被free。但是这个block依然可能存在队列中，除非是在队列的尾部。可以用FLUSH QUERY CACHE语句来清空free blocks Qcache_free_memory：Query Cache 中目前剩余的内存大小。通过这个参数我们可以较为准确的观察出当前系统中的Query Cache 内存大小是否足够，是需要增加还是过多了。 **</p><p>**Qcache_hits：表示有多少次命中缓存。我们主要可以通过该值来验证我们的查询缓存的效果。数字越大，<br>缓存效果越理想。 **</p><p><strong>Qcache_inserts：表示多少次未命中然后插入，意思是新来的SQL请求在缓存中未找到，不<br>得不执行查询处理，执行查询处理后把结果insert到查询缓存中。这样的情况的次数越多，表示查询缓存应用到的比较少，效果也就不理想。当然系统刚启动后，查询缓存是空的，这很正常。</strong></p><p>**Qcache_lowmem_prunes：多少条Query 因为内存不足而被清除出Query Cache过“Qcache_lowmem_prunes”和“Qcache_free_memory”相互结合，能够更清楚的了解到我们系统中Query Cache 的内存大小是否真的足够，是否非常频繁的出现因为内存不足而有Query 被换出。这个数字最好长时间来看；如果这个数字在不断增长，就表示可能碎片非常严重，或者内存很少。（上面的free_blocks和free_memory可以告诉您属于哪种情况） **</p><p><strong>Qcache_not_cached：不适合进行缓存的查询的数量，通常是由于这些查询不是 SELECT 语句或者用了now()之类的函数。</strong><br><strong>Qcache_queries_in_cache：当前Query Cache 中cache 的Query 数量；</strong></p><p><strong>Qcache_total_blocks：当前QueryCache 中的block 数量；我们再查询一下服务器关于query_cache的配置：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show status like &#39;%Qcache%&#39;;<br>+-------------------------+---------+<br>| Variable_name           | Value   |<br>+-------------------------+---------+<br>| Qcache_free_blocks      | 1       |<br>| Qcache_free_memory      | 1031832 |<br>| Qcache_hits             | 0       |<br>| Qcache_inserts          | 0       |<br>| Qcache_lowmem_prunes    | 0       |<br>| Qcache_not_cached       | 0       |<br>| Qcache_queries_in_cache | 0       |<br>| Qcache_total_blocks     | 1       |<br>+-------------------------+---------+<br>8 rows in set (0.00 sec)<br><br>mysql&gt; show variables like &#39;%query_cache%&#39;;<br>+------------------------------+---------+<br>| Variable_name                | Value   |<br>+------------------------------+---------+<br>| have_query_cache             | YES     |<br>| query_cache_limit            | 1048576 |<br>| query_cache_min_res_unit     | 4096    |<br>| query_cache_size             | 1048576 |<br>| query_cache_type             | OFF     |<br>| query_cache_wlock_invalidate | OFF     |<br>+------------------------------+---------+<br>6 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="上图可以看出query-cache-type为off表示不缓存任何查询-各字段的解释：">上图可以看出query_cache_type为off表示不缓存任何查询 各字段的解释：</h4><ul><li><strong>query_cache_limit：超过此大小的查询将不缓存</strong></li><li>**query_cache_min_res_unit：缓存块的最小大小 ，query_cache_min_res_unit的配置是一柄”双刃剑”，默认是4KB，设置值大对大数据查询有好处，但如果你的查询都是小数据查询，就容易造成内存碎片和浪费。 **</li><li>**query_cache_size：查询缓存大小 (注：QC存储的最小单位是1024 byte，所以如果你设定了一个不是1024的倍数的值，这个值会被四舍五入到最接近当前值的等于1024的倍数的值。) **</li><li><strong>query_cache_type：缓存类型，决定缓存什么样的查询，注意这个值不能随便设置，必须设置为数字，可选项目以及说明如下：</strong></li></ul><h4 id="query-cache-type三个参数的含义">query_cache_type三个参数的含义:</h4><ul><li><strong>query_cache_type=0（OFF）关闭</strong></li><li><strong>query_cache_type=1（ON）缓存所有结果，除非select语句使用SQL_NO_CACHE禁用查询缓存</strong></li><li><strong>query_cache_type=2(DEMAND)，只缓存select语句中通过SQL_CACHE指定需要缓存的查询</strong></li></ul><p><strong>如果设置为0，那么可以说，你的缓存根本就没有用，相当于禁用了。 如果设置为1，将会缓存所有的结果，除非你的select语句使用SQL_NO_CACHE禁用了查询缓存。 如果设置为2，则只缓存在select语句中通过<br>SQL_CACHE指定需要缓存的查询。 query_cache_wlock_invalidate：当有其他客户端正在对MyISAM表进行写操作时，如果查询在query cache中，是否返回cache结果还是等写操作完成再读表获取结果。 修改/etc/my.cnf,配置完后的部分文件如下： query_cache_size=256M query_cache_type=1 保存文件，重新启动MYSQL服务，然后通过如下查询来验证是否真正开启了：</strong></p><p><strong>查询缓存碎片率 = Qcache_free_blocks / Qcache_total_blocks * 100% 如果查询缓存碎片率超过20%，可以用FLUSH QUERY CACHE整理缓存碎片，或者试试减小query_cache_min_res_unit，如果你的查询都是小数据量的话。 查询缓存利用率 = (query_cache_size – Qcache_free_memory) / query_cache_size * 100% 查询缓存利用率在25%以下的话说明query_cache_size设置的过大，可适当减小；查询缓存利用率在80％以上而且<br>Qcache_lowmem_prunes &gt; 50的话说明query_cache_size可能有点小，要不就是碎片太多。 查询缓存命中率 =Qcache_hits/(Qcache_hits +Qcache_inserts) * 100%</strong></p><p><strong>Query Cache 的限制 a) 所有子查询中的外部查询SQL 不能被Cache； b) 在Procedure，Function 以及Trigger 中的Query 不能被Cache； c) 包含其他很多每次执行可能得到不一样结果的函数的Query不能被Cache。 鉴于上面的这些限制，在使用Query Cache 的过程中，建议通过精确设置的方式来使用，仅仅让合适的表的数据可以进入Query Cache，仅仅让某些Query的查询结果被Cache。</strong></p><p><strong>如何设置query_cache_size？ 修改/etc/my.cnf文件，在[mysqld]下面添加如下内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">query_cache_size&#x3D;256M<br>query_cache_type&#x3D;1<br></code></pre></td></tr></table></figure><p><strong>重启MySQL Server进入后，查看设置已经生效。</strong></p><h3 id="6、max-connect-errors">6、max_connect_errors</h3><p><strong>max_connect_errors是一个MySQL中与安全有关的计数器值，它负责阻止过多尝试失败的客户端以防止暴力破解密码的情况,当超过指定次数，MYSQL服务器将禁止host的连接请求，直到mysql服务器重启或<br>通过flush hosts命令清空此host的相关信息。max_connect_errors的值与性能并无太大关系。 修改/etc/my.cnf文件，在[mysqld]下面添加如下内容 max_connect_errors=20 重启MySQL Server进入后，查看设置已经生效。</strong></p><h3 id="7、sort-buffer-size">7、sort_buffer_size</h3><p>**sort_buffer_size 每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUPBY操作。 Sort_Buffer_Size 是一个connection级参数，在每个connection（session）第一次需要使用这个buffer的时候，一次性分配设置的内存。 Sort_Buffer_Size 并不是越大越好，由于是connection级的参数，过大的设置+高并发可能会耗尽系统内存资源。例如：500个连接将会消<br>耗 500*sort_buffer_size(2M)=1G内存 例如设置sort_buffer_size 修改/etc/my.cnf文件，在[mysqld]下面添加如下内容 sort_buffer_size = 2M 重启MySQL Server进入后，查看设置已经生效。 **</p><h3 id="8、max-allowed-packet-32M">8、max_allowed_packet = 32M</h3><p><strong>max_allowed_packet = 32M MySQL根据配置文件会限制Server接受的数据包大小。有时候大的插入和更新会受 max_allowed_packet 参数限制，导致写入或者更新失败。最大值是1GB，必须设置1024的倍数。</strong></p><h3 id="9、join-buffer-size-2M">9、join_buffer_size = 2M</h3><p><strong>join_buffer_size = 2M 用于表间关联缓存的大小，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。</strong></p><h3 id="10、thread-cache-size-300">10、thread_cache_size = 300</h3><p><strong>thread_cache_size = 300服务器线程缓存，这个值表示可以重新利用保存在缓存中线程的数量,当断开连接时,那么客户端的线程将被放到缓存中以响应下一个客户而不是销毁(前提是缓存数未达上限),如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程，增加这个值可以改善系统性能.通过比较 Connections 和 Threads_created 状态的变量，可以看到这个变量的作用。设置规则如下：1GB 内存配置为8，2GB配置为16，3GB配置为32，4GB或更高内存，可配置更大。服务器处理此客户的线程将会缓存起来以响应下一个客户而不是销毁(前提是缓存数未达上限)</strong></p><h4 id="试图连接到MySQL-不管是否连接成功-的连接数">试图连接到MySQL(不管是否连接成功)的连接数</h4><p><strong>Threads_cached :代表当前此时此刻线程缓存中有多少空闲线程。 Threads_connected :代表当前已建立连接的数量，因为一个连接就需要一个线程，所以也可以看成当前被使用的线程数。 Threads_created :代表从最近一次服务启动，已创建线程的数量，如果发现Threads_created值过大的话，表明MySQL服务器一直在创建线程，这也是比较耗资源，可以适当增加配置文件中thread_cache_size值。 Threads_running :代表当前激活的（非睡眠状态）线程数。并不是代表正在使用的线程数，有时候连接已建立，但是连接处于sleep状态。</strong></p><h2 id="3）配置InnoDB的几个变量">3）配置InnoDB的几个变量</h2><h3 id="（1）innodb-buffer-pool-size">（1）innodb_buffer_pool_size</h3><p><strong>对于InnoDB表来说，innodb_buffer_pool_size的作用就相当于key_buffer_size对于MyISAM表的作用一样。InnoDB使用该参数指定大小的内存来缓冲数据和索引。对于单独的MySQL数据库服务器，最大可以把该值设置成物理内存的80%。根据MySQL手册，对于2G内存的机器，推荐值是1G（50%）。 如果你的数据量不大，并且不会暴增，那么无需把 innodb_buffer_pool_size 设置的太大了。 mysql&gt; show variables like ‘innodb_buffer_pool_size’; 设置innodb_buffer_pool_size 修</strong><br><strong>改/etc/my.cnf文件，在[mysqld]下面添加如下内容 innodb_buffer_pool_size = 2048M 重启MySQL Server进入后，查看设置已经生效。</strong></p><h3 id="2、innodb-flush-log-at-trx-commit">2、innodb_flush_log_at_trx_commit</h3><p><strong>innodb_flush_log_at_trx_commit 主要控制了innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，取值分别为0、1、2三个。0，表示当事务提交时，不做日志写入操作，而是每秒钟将log buffer中的数据写入日志文件并flush磁盘一次；1，则在每秒钟或是每次事物的提交都会引起日志文件写入、flush磁盘的操作，确保了事务的ACID；设置为2，每次事务提交引起写入日志文件的动作，但每秒钟完成一次flush磁盘操作。 实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。 根据MySQL手册，在允许丢失最近部分事务的危险的前提下，可以把该值设为0或2。</strong></p><h3 id="3、innodb-thread-concurrency-0">3、innodb_thread_concurrency = 0</h3><p><strong>innodb_thread_concurrency = 0 此参数用来设置innodb线程的并发数量，默认值为0表示不限制，若要设置则与服务器的CPU核数相同或是cpu的核数的2倍，建议用默认设置，一般为8.</strong></p><h3 id="4、innodb-log-buffer-size">4、innodb_log_buffer_size</h3><p><strong>innodb_log_buffer_size 此参数确定些日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，对于较大的事务，可以增大缓存大小。 innodb_log_buffer_size=32M</strong></p><h3 id="5、innodb-log-file-size-50M">5、innodb_log_file_size = 50M</h3><p><strong>innodb_log_file_size = 50M此参数确定数据日志文件的大小，以M为单位，更大的设置可以提高性能.</strong></p><h3 id="6、innodb-log-files-in-group-3">6、innodb_log_files_in_group = 3</h3><p><strong>innodb_log_files_in_group = 3为提高性能，MySQL可以以循环方式将日志文件写到多个文件。<a href="http://xn--3-br6aw4nnneb2ud16aepag5zu5iu2v.md" target="_blank" rel="noopener">推荐设置为3第十四章.md</a> 1/6/20206 / 7</strong></p><h3 id="7、read-buffer-size-1M">7、read_buffer_size = 1M</h3><p><strong>read_buffer_size = 1M MySql 读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区。如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能。和 sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。</strong></p><h3 id="8、read-rnd-buffer-size-16M">8、read_rnd_buffer_size = 16M</h3><p><strong>read_rnd_buffer_size = 16M MySql 的随机读（查询操作）缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。 注：顺序读是指根据索引的叶节点数据就能顺序地读取所需要的行数据。随机读是指一般需要根据辅助索引叶节点中的主键寻找实际行数据，而辅助索引和主键所在的数据段不同，因此访问方式是随机的。</strong></p><h3 id="9、bulk-insert-buffer-size-64M">9、bulk_insert_buffer_size = 64M</h3><p><strong>bulk_insert_buffer_size = 64M 批量插入数据缓存大小，可以有效提高插入效率，默认为8M</strong></p><h3 id="10、binary-log-log-bin-usr-local-mysql-data-mysql-bin-binlog-cache-size-2M">10、binary log log-bin=/usr/local/mysql/data/mysql-bin binlog_cache_size = 2M</h3><p><strong>binary log log-bin=/usr/local/mysql/data/mysql-bin binlog_cache_size = 2M //为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存,提高记录bin-log的效率。没有什么大事务，dml也不是很频繁的情况下可以设置小一点，如果事务大而且多，dml操作也频繁，则可以适当的调大一点。前者建议是–1M，后者建议是：即 2–4M max_binlog_cache_size = 8M //表示的是binlog 能够使用的最大cache内存大小 max_binlog_size = 512M //指定binlog日志文件的大小，如果当前的日志大小达到max_binlog_size，还会自动创建新的二进制日志。你不能将该变量设置为大于1GB或小于4096字节。默认值是1GB。在导入大容量的sql文件时，建议关闭sql_log_bin，否则硬盘扛不住，而且建议定期做删除。 expire_logs_days = 7 //定义了mysql清除过期日志的时间。 二进制日志自动删除的天数。默认值为0,表示“没有自动删除”。 mysqladmin flush-logs 也可以重新开始新的binary log</strong></p><h3 id="11、log-queries-not-using-indexes">11、log_queries_not_using_indexes</h3><p><strong>log_queries_not_using_indexes 开启这个选项真实地记录了返回所有行的查询。</strong></p><h3 id="在优化之前执行mysqlslap工具进行测试">在优化之前执行mysqlslap工具进行测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]#mysqlslap --defaults-file=/etc/my.cnf --concurrency=10 --<br>iterations=1 --create-schema='test1' --query='select * from test1.tb1' --<br>engine=innodb --number-of-queries=2000 -uroot -p123456 –verbose<br>显示结果：<br>Benchmark<br>Running for engine innodb<br>Average number of seconds to run all queries: 13.837 seconds<br>Minimum number of seconds to run all queries: 13.837 seconds<br>Maximum number of seconds to run all queries: 13.837 seconds<br>Number of clients running queries: 10<br>Average number of queries per client: 200<br>优化之后执行mysqlslap工具进行测试<br>[root@localhost ~]#mysqlslap --defaults-file=/etc/my.cnf --concurrency=10 --<br>iterations=1 --create-schema='test1' --query='select * from test1.tb1' --<br>engine=innodb --number-of-queries=2000 -uroot -p123456 –verbose<br>显示结果：<br>Benchmark<br>Running for engine innodb<br>Average number of seconds to run all queries: 4.199 seconds<br>Minimum number of seconds to run all queries: 4.199 seconds<br>Maximum number of seconds to run all queries: 4.199 seconds<br>Number of clients running queries: 10<br>Average number of queries per client: 200<br>相关优化参数总结：<br>[mysqld]<br>slow_query_log = 1<br>slow_query_log_file = /usr/local/mysql/data/slow-query.log<br>long_query_time = 1<br>log-queries-not-using-indexes<br>max_connections = 1024<br>back_log = 128<br>wait_timeout = 60<br>interactive_timeout = 7200<br>key_buffer_size=256M<br>query_cache_size = 256M<br>query_cache_type=1<br>query_cache_limit=50M<br>max_connect_errors=20<br>sort_buffer_size = 2M<br>max_allowed_packet=32M<br>join_buffer_size=2M<br>thread_cache_size=200<br>innodb_buffer_pool_size = 2048M<br>innodb_flush_log_at_trx_commit = 1<br>innodb_log_buffer_size=32M<br>innodb_log_file_size=128M<br>innodb_log_files_in_group=3<br>log-bin=mysql-bin<br>binlog_cache_size=2M<br>max_binlog_cache_size=8M<br>max_binlog_size=512M<br>expire_logs_days=7<br>read_buffer_size=1M<br>read_rnd_buffer_size=16M<br>bulk_insert_buffer_size=64M<br>log-error = /usr/local/mysql/data/mysqld.err<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;一、配置参数优化&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;MySQL参数优化对于不同的网站，与其在线量、访问量、帖子数量、网络情况,以及机器硬件配置都有关系,优化不可能一-次性完成， 需要不断的观察以及调试，才有可能得到最佳效果。下面列出了 对性能优化影响较大的主要变量，主要分为
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://wsdlxgp.top/categories/mysql/"/>
    
    
      <category term="MySQL优化" scheme="https://wsdlxgp.top/tags/MySQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL自带工具使用介绍</title>
    <link href="https://wsdlxgp.top/posts/f96f.html"/>
    <id>https://wsdlxgp.top/posts/f96f.html</id>
    <published>2020-06-17T16:01:00.000Z</published>
    <updated>2020-06-19T05:19:48.231Z</updated>
    
    <content type="html"><![CDATA[<h1>一、MySQL自带工具使用介绍</h1><p><strong>MySQL数据库不仅提供了数据库的服务器端应用程序，同时还提供了大量的客户端工具程序，如mysql，mysqladmin，mysqldump等等 。</strong></p><p>语法格式：</p><blockquote><p><strong>Usage: mysql [OPTIONS] [database] 例如：</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># mysql -e &quot;select user,host from user&quot; mysql<br></code></pre></td></tr></table></figure><p><strong>大家只要运行一下“mysql --help”就会得到如下相应的基本使用帮助信息：</strong></p><p><strong>这里主要介绍一些在运维过程中会用到的相关选项： 首先看看“-e, --execute=name”参数，这个参数是告诉</strong><br><strong>mysql，我要执行“-e”后面的某个命令，而不是要通过mysql连接登录到MySQL Server 上面。此参数在我们写一些基本的MySQL 检查和监控的脚本中非常有用，运维mysql时经常在脚本中使用到它。</strong></p><blockquote><p><strong>#mysql -hhostname -Pport -uusername -ppassword -e 相关mysql的sql语句</strong></p></blockquote><h2 id="1、mysql命令">1、mysql命令</h2><p><strong>Mysql命令是用的最多的一个命令工具了，为用户提供一个命令行接口来操作管理MySQL 服务器。可以通过mysql --help来查看其详细使用方法。</strong></p><table><thead><tr><th>mysql命令选项</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>-u</td><td>指定连接数据库时使用的用户</td><td></td></tr><tr><td>-p</td><td>指定用户的密码</td><td>可以-p后面直接写密码，也可以不写，进行交互式输入密码，推荐后者</td></tr><tr><td>-h</td><td>指定要登录的主机</td><td>可选，如果为空，则登录本机</td></tr><tr><td>-P</td><td>指定要连接的端口</td><td>可选，默认是3306</td></tr><tr><td>-e</td><td>可以通过-e命令直接执行SQL语句，而不用进入数据库</td><td>免交互登录数据库执行SQL语句，通常在脚本中使用</td></tr><tr><td>-D</td><td>指定要登录到哪个库</td><td>默认不会登录到库，可以省略此选项，直接写库名</td></tr><tr><td>-E</td><td>查询到的结果以行来显示</td><td>类似于每条SQL语句后面加“\G”</td></tr><tr><td>-f</td><td>即使出现SQL错误，也强制继续</td><td>比如在不登陆数据库执行删除库的操作会有一个交互式的确认操作，可以使用此选项来避免交互式</td></tr><tr><td>-X</td><td>将查询到的数据导出位xml文件</td><td>导出的文件在windows系统中可以使用excel表格打开</td></tr><tr><td>-H</td><td>将查询到的数据导出位html文件</td><td>导出的文件在windows系统中可以使用浏览器打开</td></tr><tr><td>–prompt</td><td>定制自己的MySQL提示符显示的内容</td><td>默认登登录到MySQL后的提示符是“mysql &gt;”，可以使用该选项定制提示符</td></tr><tr><td>–tee</td><td>将操作数据库所有输入和输出的内容都记录进文件中</td><td>在一些较大维护变更的时候，为了方便被查，可以将整个操作过程中的输出信息保存到某个文件中</td></tr></tbody></table><p><strong>这里主要介绍一些在运维过程中会用到的相关选项。</strong></p><h3 id="1）-e、-u、-p、-h、-P、-等选项的使用语法">1）-e、-u、-p、-h、-P、 等选项的使用语法</h3><p><strong>首先看看“-e, --execute=name”参数，这个参数是告诉mysql，我要执行“-e”后面的某个命令，而不是要通过mysql连接登录到MySQL Server 上面。此参数在我们写一些基本的MySQL 检查和监控的脚本中非常有用，运维mysql时经常在脚本中使用到它。</strong></p><h5 id="语法格式：">语法格式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@mysql ~]# mysql  -hhostname -Pport -uusername -ppassword  -e  相关mysql的sql语句<br></code></pre></td></tr></table></figure><h4 id="示例1：免登录执行sql语句">示例1：免登录执行sql语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@mysql ~]# mysql -hlocalhost -P3306 -uroot -p mysql -e &quot;select user,host from user;&quot;<br>Enter password: <br>+---------------+-----------+<br>| user          | host      |<br>+---------------+-----------+<br>| bankMaster    | %         |<br>| bankMaster    | 127.0.0.1 |<br>| epetadmin     | localhost |<br>| mysql.session | localhost |<br>| mysql.sys     | localhost |<br>| root          | localhost |<br>+---------------+-----------+<br></code></pre></td></tr></table></figure><h4 id="示例2：">示例2：</h4><p><strong>通过binlog_cache_use 以及 binlog_cache_disk_use来分析设置的binlog_cache_size是否足够</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">[root@mysql ~]#  mysql -uroot -p -e &quot;show status like &#39;binlog_cache%&#39;&quot;<br>Enter password: <br>+-----------------------+-------+<br>| Variable_name         | Value |<br>+-----------------------+-------+<br>| Binlog_cache_disk_use | 0     |<br>| Binlog_cache_use      | 0     |<br>+-----------------------+-------+<br></code></pre></td></tr></table></figure><h4 id="示例3：">示例3：</h4><p><strong>通过脚本创建数据库、表及对表进行增、改、删、查操作.脚本内容如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># cat mysql1.sh<br><br>#!&#x2F;bin&#x2F;bash<br>HOSTNAME&#x3D;&quot;localhost&quot;<br>PORT&#x3D;&quot;3306&quot;<br>USERNAME&#x3D;&quot;root&quot;<br>PASSWORD&#x3D;&quot;123&quot;<br>DBNAME&#x3D;&quot;test_db&quot;<br>TABLENAME&#x3D;&quot;tb1&quot;<br><br>#create database<br>create_db_sql&#x3D;&quot;create database if not exists $&#123;DBNAME&#125;&quot;<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; -e &quot;$&#123;create_db_sql&#125;&quot;<br><br>#create table<br>create_table_sql&#x3D;&quot;create table if not exists $&#123;TABLENAME&#125; (name varchar(20),id int default 0)&quot;<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e &quot;$&#123;create_table_sql&#125;&quot;<br><br>#insert data to table<br>insert_sql&#x3D;&quot;insert into $&#123;TABLENAME&#125; values (&#39;tom&#39;,1)&quot;<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e &quot;$&#123;insert_sql&#125;&quot;<br><br>#select data<br>select_sql&#x3D;&quot;select * from $&#123;TABLENAME&#125;&quot;<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e &quot;$&#123;select_sql&#125;&quot;<br><br>#update data<br>update_sql&#x3D;&quot;update $&#123;TABLENAME&#125; set id&#x3D;3&quot;<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e &quot;$&#123;update_sql&#125;&quot;<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e &quot;$&#123;select_sql&#125;&quot;<br><br>#delete data<br>delete_sql&#x3D;&quot;delete from $&#123;TABLENAME&#125;&quot;<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e &quot;$&#123;delete_sql&#125;&quot;<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e &quot;$&#123;select_sql&#125;&quot;<br></code></pre></td></tr></table></figure><h4 id="执行一下">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# sh mysql1.sh <br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>+------+------+<br>| name | id   |<br>+------+------+<br>| tom  |    1 |<br>+------+------+<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>+------+------+<br>| name | id   |<br>+------+------+<br>| tom  |    3 |<br>+------+------+<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br></code></pre></td></tr></table></figure><h2 id="2、-E">2、-E</h2><p><strong>如果在连接时候使用了“-E, --vertical”参数，登入之后的所有查询结果都将以纵列显示，效果和我们在一条query 之后以“\G”结尾一样。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># mysql -uroot -p123 -E<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>Welcome to the MySQL monitor. Commands end with ; or \g.<br>Your MySQL connection id is 27<br>Server version: 5.7.22 Source distribution<br>Copyright (c) 2000, 2018, Oracle and&#x2F;or its affiliates. All rights reserved.<br>Oracle is a registered trademark of Oracle Corporation and&#x2F;or its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br>Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.<br>mysql&gt; show databases;<br>*************************** 1. row ***************************<br>Database: information_schema<br>*************************** 2. row ***************************<br>Database: mysql<br>*************************** 3. row ***************************<br>Database: test_db<br>10 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>“-H, --html”与“-X, --xml”，在启用这两个参数之后，select出来的所有结果都会按照“Html”与“Xml”格式来输出，在有些场合之下，比如希望Xml或者Html 文件格式导出某些报表文件的时候，是非常方便的。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@192 ~]# mysql -utest -p -X<br>Enter password: <br>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 40<br>Server version: 5.7.30 MySQL Community Server (GPL)<br><br>Copyright (c) 2000, 2020, Oracle and&#x2F;or its affiliates. All rights reserved.<br><br>Oracle is a registered trademark of Oracle Corporation and&#x2F;or its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br><br>Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.<br><br>mysql&gt; use test_db;<br>Reading table information for completion of table and column names<br>You can turn off this feature to get a quicker startup with -A<br><br>Database changed<br>mysql&gt; select * from tb1;<br>&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;<br><br>&lt;resultset statement&#x3D;&quot;select * from tb1;&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;&gt;<br>  &lt;row&gt;<br>        &lt;field name&#x3D;&quot;name&quot;&gt;tom&lt;&#x2F;field&gt;<br>        &lt;field name&#x3D;&quot;id&quot;&gt;1&lt;&#x2F;field&gt;<br>  &lt;&#x2F;row&gt;<br><br>  &lt;row&gt;<br>        &lt;field name&#x3D;&quot;name&quot;&gt;tom&lt;&#x2F;field&gt;<br>        &lt;field name&#x3D;&quot;id&quot;&gt;2&lt;&#x2F;field&gt;<br>  &lt;&#x2F;row&gt;<br><br>  &lt;row&gt;<br>        &lt;field name&#x3D;&quot;name&quot;&gt;tom&lt;&#x2F;field&gt;<br>        &lt;field name&#x3D;&quot;id&quot;&gt;3&lt;&#x2F;field&gt;<br>  &lt;&#x2F;row&gt;<br>&lt;&#x2F;resultset&gt;<br>3 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><h2 id="3、-H选项的使用方式">3、-H选项的使用方式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# mysql -H -uroot -p123.com -e "select * from mysql.user" &gt; a.html<br><span class="hljs-meta">#</span><span class="bash">将查询的结果重定向输出到a.html文件中</span><br>[root@mysql ~]# sz a.html    #下载这个文件到本地windows系统<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200618184838389.png" alt="image-20200618184838389"></p><h2 id="4、创建授予test用户可以在指定的源登录">4、创建授予test用户可以在指定的源登录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># mysql -uroot -p -e &quot;grant all on test_db.* to root@&#39;192.168.1.10&#39; identified by<br>&#39;123&#39;&quot;<br>Enter password:<br></code></pre></td></tr></table></figure><h4 id="测试test用户连接mysql服务器">测试test用户连接mysql服务器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@mysql ~]# mysql -u root -p -e &quot;grant all on test_db.* to test@&#39;192.168.1.%&#39; identified by &#39;123&#39;&quot;<br>Enter password: <br>[root@mysql ~]#  mysql -utest -p123 -h 192.168.1.10<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 18<br>Server version: 5.7.22 MySQL Community Server (GPL)<br><br>Copyright (c) 2000, 2018, Oracle and&#x2F;or its affiliates. All rights reserved.<br><br>Oracle is a registered trademark of Oracle Corporation and&#x2F;or its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br><br>Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.<br><br>mysql&gt;<br></code></pre></td></tr></table></figure><h1>二、–prompt使用方法</h1><p><strong>“–prompt=name”参数对于做运维的人来说是一个非常重要的参数选项，其主要功能是<code>定制自己的mysql提示符的显示内容。</code></strong></p><p><strong>在默认情况下，我们通过mysql登入到数据库之后，mysql的提示符只是一个很简单的内容”mysql&gt;“，没有其他任何附加信息。非常幸运的是mysql通过“<code>--prompt=name</code>”参数给我们提供了自定义提示信息的办法，可以通过配置显示登入的主机地址，登录用户名，当前时间，当前数据库schema，MySQL Server 的一些信息等等。</strong></p><p><strong>个人强烈建议将登录主机名，登录用户名和所在的schema 这三项加入提示内容，因为当大家手边管理的MySQL 越来越多，操作越来越频繁的时候，非常容易因为操作的时候没有太在意自己当前所处的环境而造成在错误的环境执行了错误的命令并造成严重后果的情况。如果我们在提示内容中加入了这几项之后，至少可以更方便的提醒自己当前所处环境，以尽量减少犯错误的概率.</strong></p><p><strong>个人强烈建议提示符定义：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&quot;\\u@\\h : \\d \\r:\\m:\\s&gt; &quot;<br></code></pre></td></tr></table></figure><h4 id="提示符解释：">提示符解释：</h4><ul><li><strong>\u ：表示用户名,</strong></li><li><strong>\h ：表示主机名，</strong></li><li><strong>\d ：表示当前数据库，</strong></li><li><strong>\r小时：（12小时制），</strong></li><li><strong>\R小时（24小时制），</strong></li><li><strong>\m：分种，</strong></li><li><strong>\s秒，</strong></li></ul><h4 id="显示效果">显示效果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@mysql ~]# mysql -uroot -p --prompt&#x3D;&quot;\\u@\\h: \\d \\r:\\m:\\s&quot;<br>Enter password: <br>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 26<br>Server version: 5.7.22 MySQL Community Server (GPL)<br><br>Copyright (c) 2000, 2018, Oracle and&#x2F;or its affiliates. All rights reserved.<br><br>Oracle is a registered trademark of Oracle Corporation and&#x2F;or its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br><br>Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.<br><br>root@localhost: (none) 04:54:56&gt; use test_db<br>Reading table information for completion of table and column names<br>You can turn off this feature to get a quicker startup with -A<br><br>Database changed<br>root@localhost: (none) 04:54:56&gt;<br></code></pre></td></tr></table></figure><h1>三、–tee的使用方法</h1><p><strong>“–tee=name”参数也是对运维人员非常有用的参数选项，用来告诉mysql，将所有输入和输出内容都记录进文件。在我们一些较大维护变更的时候，为了方便被查，最好是将整个操作过程的所有输入和输出内容都保存下来.假如mysql命令行状态下，要进行大量的交互操作，其实可以把这些操作记录在log中进行审计，很简单 <code>mysql -u root -p --tee=/path/xxxx.log</code></strong></p><p><strong>也可以在服务器上的/etc/my.cnf中的[client]加入 tee =/tmp/client_mysql.log即可. 注：若没有[client]就添加即可 或者在mysql&gt;提示符下执行下面的命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; tee &#x2F;opt&#x2F;xgp.log<br>Logging to file &#39;&#x2F;opt&#x2F;xgp.log&#39;<br>mysql&gt; show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>| test_db            |<br>+--------------------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="查看一下">查看一下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@mysql ~]# cat &#x2F;opt&#x2F;xgp.log <br>mysql&gt; tee &#x2F;opt&#x2F;xgp.log<br>Logging to file &#39;&#x2F;opt&#x2F;xgp.log&#39;<br>mysql&gt; show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>| test_db            |<br>+--------------------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>同样，“–tee”这个配置项也可以写入my.cnf这个主配置文件中的client字段下，如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# vim /etc/my.cnf <br><br>[client]<br>socket=/usr/local/mysql/mysql.sock<br>[mysqld]<br>basedir=/usr/local/mysql<br>datadir=/usr/local/mysql/data<br>pid-file=/usr/local/mysql/data/mysql.pid<br>socket=/usr/local/mysql/mysql.sock<br>log-error=/usr/local/mysql/data/mysql.err<br>tee=/opt/xgp.log<br></code></pre></td></tr></table></figure><h1>四、mysqladmin命令</h1><p><strong>mysqladmin,顾名思义,提供的功能都是与MySQL管理相关的各种功能。如MySQL Server状态检查,各种统计信息的flush,创建/删除数据库，关闭MySQL Server等等。mysqladmin所能做的事情，虽然大部分都可以通过mysql连接登录上MySQL Server之后来完成，但是大部分通过mysqladmin来完成操作会更简单更方便。</strong><br><strong>mysqladmin后面可以接选项，也可以接命令,这里就不说选项了，主要说一下命令</strong></p><table><thead><tr><th>命令字</th><th>作用</th></tr></thead><tbody><tr><td>create databasename</td><td>创建一个库</td></tr><tr><td>drop databasename</td><td>删除一个库</td></tr><tr><td>status</td><td>查询MySQL的基本状态（显示的信息有限 ）</td></tr><tr><td>extended-status</td><td>查询服务器的详细状态信息（类似于在数据库中执行show status;）</td></tr><tr><td>flush-hosts</td><td>刷新服务器缓存</td></tr><tr><td>flush-logs</td><td>刷新二进制日志文件（如果二进制日志功能开启，那么执行这个操作会生成新的二进制日志文件）</td></tr><tr><td>flush-status</td><td>刷新状态变量</td></tr><tr><td>flush-tables</td><td>刷新所有表</td></tr><tr><td>flush-threads</td><td>刷新所有线程缓存</td></tr><tr><td>flush-privileges</td><td>重新加载授权表</td></tr><tr><td>processlist</td><td>查看当前连接数据库的所有ID详细信息</td></tr><tr><td>kill id</td><td>杀掉某个或多个连接ID（一般需要先使用processlist查看出ID列表，然后根据ID将其kill掉 ）</td></tr><tr><td>ping</td><td>检测某个MySQL服务是否处于启动状态</td></tr><tr><td>password</td><td>修改用户密码</td></tr><tr><td>shutdown</td><td>关闭MySQL服务</td></tr><tr><td>start-slave</td><td>开启主从复制</td></tr><tr><td>stop-slave</td><td>关闭主从复制</td></tr><tr><td>variables</td><td>查询MySQL服务中的所有变量</td></tr><tr><td>version</td><td>查询MySQL的版本详细信息</td></tr></tbody></table><h3 id="（1）ping">（1）ping</h3><p><strong>监测服务是否正常</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# mysqladmin -uroot -p  ping<br>Enter password: <br>mysqld is alive<br></code></pre></td></tr></table></figure><h3 id="（2）status">（2）status</h3><p><strong>获取mysql当前状态值</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# mysqladmin -uroot -p  status<br>Enter password: <br>Uptime: 3413  Threads: 2  Questions: 102  Slow queries: 0  Opens: 118  Flush tables: 1  Open tables: 111  Queries per second avg: 0.029<br></code></pre></td></tr></table></figure><h4 id="状态值：">状态值：</h4><ul><li>**mysqladmin status命令结果有下述列 **</li><li><strong>Uptime:是mysql服务器运行的秒数.</strong></li><li><strong>Threads:活跃线程的数量即开启的会话数.</strong></li><li><strong>Questions： 服务器启动以来客户的问题(查询)数目 （只要跟mysql作交互，不管查询表，还是查询服务器状态都记一次）.</strong></li><li><strong>Slow queries：是慢查询的数量.</strong></li><li>**Opens：mysql已经打开的数据库表的数量 **</li><li>**Flush tables: mysql已经执行的flush tables，refresh和reload命令的数量.注：flush tables //刷新表（清除缓存）reload 重载授权表 refresh 洗掉所有表并关闭和打开日志文件 **</li><li><strong>open：打开数据库的表的数量，以服务器启动开始.</strong></li><li><strong>Queries per second avg：select语句平均查询时间 Memory in use分配的内存(只有在MySQL用–withdebug编译时可用) Max memory used分配的最大内存(只有在MySQL用–with-debug编译时可用)</strong></li></ul><h3 id="（3）processlist">（3）processlist</h3><p><strong>获取数据库当前连接信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# mysqladmin -uroot -p  processlist<br>Enter password: <br>+----+------+-----------+---------+---------+------+----------+------------------+<br>| Id | User | Host      | db      | Command | Time | State    | Info             |<br>+----+------+-----------+---------+---------+------+----------+------------------+<br>| 32 | root | localhost | test_db | Sleep   | 877  |          |                  |<br>| 40 | root | localhost |         | Query   | 0    | starting | show processlist |<br>+----+------+-----------+---------+---------+------+----------+------------------+<br></code></pre></td></tr></table></figure><h3 id="（4）获取数据库当前的连接数">（4）获取数据库当前的连接数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# mysql -uroot -p -BNe "select host,count(host) from processlist group by host" information_schema<br>Enter password: <br>localhost2<br></code></pre></td></tr></table></figure><h3 id="（5）显示mysql的启动时长">（5）显示mysql的启动时长</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# mysql -uroot -p123 -e "SHOW STATUS LIKE '%uptime%'" | awk '/ptime/&#123; calc = $NF/3600;print $(NF-1), calc"Hour"&#125;'<br><br>Uptime 1.005Hour<br>Uptime_since_flush_status 1.005Hour<br></code></pre></td></tr></table></figure><h3 id="（6）查看数据库所有库大小">（6）查看数据库所有库大小</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# mysql -uroot -p123 -e 'select table_schema,round(sum(data_length+index_length)/1024/1024,4) from information_schema.tables group by table_schema'<br><br>+--------------------+--------------------------------------------------+<br>| table_schema       | round(sum(data_length+index_length)/1024/1024,4) |<br>+--------------------+--------------------------------------------------+<br>| information_schema |                                           0.1563 |<br>| mysql              |                                           2.4425 |<br>| performance_schema |                                           0.0000 |<br>| sys                |                                           0.0156 |<br>| test_db            |                                           0.0156 |<br>+--------------------+--------------------------------------------------+<br></code></pre></td></tr></table></figure><h3 id="（7）processlist获取当前数据库的连接线程信息：-监控mysql进程运行状态："><strong>（7）processlist获取当前数据库的连接线程信息： 监控mysql进程运行状态：</strong></h3><p><strong>上面的这三个功能在一些简单监控脚本中经常使用到的.mysqladmin其他参数选项可以通过执行“mysqladmin–help”或man mysqladmin得到帮助信息.编写一个简单的mysql监控脚本，内容如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta">#</span><span class="bash">监测服务是否正常</span><br>mysqladmin -uroot -p123 -h localhost ping<br><span class="hljs-meta">#</span><span class="bash">获取mysql当前状态值</span><br>mysqladmin -uroot -p123 -h localhost status<br><span class="hljs-meta">#</span><span class="bash">获取数据库当前连接信息</span><br>mysqladmin -uroot -p123 -h localhost processlist<br><span class="hljs-meta">#</span><span class="bash">获取数据库当前的连接数</span><br>mysql -uroot -p123 -BNe "select host,count(host) from processlist group by host" information_schema<br><span class="hljs-meta">#</span><span class="bash">显示mysql的启动时长</span><br>mysql -uroot -p123 -e "SHOW STATUS LIKE '%uptime%'" | awk '/ptime/&#123; calc = $NF/3600;print $(NF-1), calc"Hour"&#125;'<br><span class="hljs-meta">#</span><span class="bash">查看数据库所有库大小</span><br>mysql -uroot -p123 -e 'select table_schema,round(sum(data_length+index_length)/1024/1024,4) from information_schema.tables group by table_schema'<br></code></pre></td></tr></table></figure><h1>五、mysqldump</h1><p><strong>这个工具其功能就是将MySQL Server中的数据以SQL 语句的形式从数据库中dump 成文本文件。mysqldump是做为MySQL 的一种逻辑备份工具，在我之前的博文中有这个工具的使用方法：<a href="https://blog.51cto.com/14154700/2395340" target="_blank" rel="noopener">MySQL的备份与恢复详解</a></strong></p><h1>六、mysqlbinlog</h1><p><strong>mysqlbinlog程序的主要功能就是分析MySQL Server 所产生的二进制日志（也就是binlog）。</strong><br><strong>通过mysqlbinlog，我们可以解析出binlog中指定时间段或者指定日志起始和结束位置的内容解析成SQL 语句。</strong></p><h1>七、Mysqlslap性能测试</h1><p><strong>MySQL二种存储引擎 mysqlslap是mysql自带的基准测试工具,优点:查询数据,语法简单,灵活容易使用.该工具可以模拟多个客户端同时并发的向服务器发出查询更新,给出了性能测试数据而且提供了多种引擎的性能比较.mysqlslap为mysql性能优化前后提供了直观的验证依据,建议系统运维和DBA人员应该掌握一些常见的压力测试工具,才能准确的掌握线上数据库支撑的用户流量上限及其抗压性等问题.现在看一下这个压力测试工具mysqlslap，关于他的选项手册上以及–help介绍的很详细。</strong></p><h4 id="这里解释一下一些常用的选项">这里解释一下一些常用的选项</h4><ul><li><strong>–concurrency代表并发数量，多个可以用逗号隔开。例如：concurrency=50,100,200 --engines代表要测试的引</strong><br><strong>擎，可以有多个，用分隔符隔开。</strong></li><li><strong>–iterations代表要运行这些测试多少次，即运行多少次后，得到结果。</strong></li><li><strong>–auto-generate-sql 代表用系统自己生成的SQL脚本来测试。</strong></li><li><strong>–auto-generate-sql-load-type 代表要测试的是读 还是写还是两者混合的（read,write,update,mixed）</strong></li><li><strong>–number-of-queries 代表总共要运行多少次查询。每个客户运行的查询数量可以用查询总数/并发数来计算。比如倒数第二个结果2=200/100。</strong></li><li><strong>–debug-info 代表要额外输出CPU以及内存的相关信息（注：只有在MySQL用–with-debug编译时可）。</strong></li><li><strong>–number-int-cols 代表测试表中的INTEGER类型的属性有几个。</strong></li><li><strong>–number-char-cols代表测试表的char类型字段的数量。</strong></li><li><strong>–create-schema 代表自己定义的模式（在MySQL中也就是库即创建测试的数据库）。</strong></li><li><strong>–query 代表自己的SQL脚本。</strong></li><li><strong>–only-print如果只想打印看看SQL语句是什么，可以用这个选项。</strong></li><li><strong>–csv=name 生产CSV格式数据文件 查看Mysql数据库默认最大连接数</strong></li></ul><h2 id="（1）查看Mysql数据库默认最大连接数">（1）查看Mysql数据库默认最大连接数</h2><p><strong>可以看到mysql5.7.13默认是151。注：不同版本默认最大连接数不差别。一般生产环境是不够的。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#39;%max_connections%&#39;;<br>+-----------------+-------+<br>| Variable_name   | Value |<br>+-----------------+-------+<br>| max_connections | 151   |<br>+-----------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>注：不同版本默认最大连接数不差别。一般生产环境是不够的</strong></p><h2 id="2、修改MySQL数据库默认最大连接数">2、修改MySQL数据库默认最大连接数</h2><h4 id="方法一">方法一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; set GLOBAL max_connections &#x3D; 1024;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; show variables like &#39;%max_connections%&#39;;<br>+-----------------+-------+<br>| Variable_name   | Value |<br>+-----------------+-------+<br>| max_connections | 1024  |<br>+-----------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="方法二">方法二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">在my.cnf[mysqld]下添加 <br>max_connections&#x3D;1024 #增加到1024<br>重启Mysql.<br><br>总结：修改my.cnf文件并重启mysqld服务<br></code></pre></td></tr></table></figure><h2 id="3、查看Mysql默认使用存储引擎，">3、查看Mysql默认使用存储引擎，</h2><p><strong>如下查看： <code>mysql&gt; show engines;</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show engines;<br>+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+<br>| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |<br>+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+<br>| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |<br>| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |<br>| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |<br>| BLACKHOLE          | YES     | &#x2F;dev&#x2F;null storage engine (anything you write to it disappears) | NO           | NO   | NO         |<br>| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |<br>| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |<br>| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |<br>| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |<br>| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |<br>+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+<br>9 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="4、测试">4、测试</h2><p><strong>现在我们来看一下具体测试的例子。</strong></p><h3 id="1）用自带的SQL脚本来测试">1）用自带的SQL脚本来测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@mysql ~]# mysqlslap --defaults-file&#x3D;&#x2F;etc&#x2F;my.cnf --concurrency&#x3D;100,200 --iterations&#x3D;1 --number-int-cols&#x3D;20 --number-char-cols&#x3D;30 --auto-generate-sql --auto-generate-sql-add-autoincrement --auto-generate-sql-load-type&#x3D;mixed --engine&#x3D;myisam,innodb --number-of-queries&#x3D;2000 -uroot -p123 --verbose<br><br>Benchmark<br>trueRunning for engine myisam<br>trueAverage number of seconds to run all queries: 0.330 seconds<br>trueMinimum number of seconds to run all queries: 0.330 seconds<br>trueMaximum number of seconds to run all queries: 0.330 seconds<br>trueNumber of clients running queries: 100<br>trueAverage number of queries per client: 20<br><br>Benchmark<br>trueRunning for engine myisam<br>trueAverage number of seconds to run all queries: 0.341 seconds<br>trueMinimum number of seconds to run all queries: 0.341 seconds<br>trueMaximum number of seconds to run all queries: 0.341 seconds<br>trueNumber of clients running queries: 200<br>trueAverage number of queries per client: 10<br><br>Benchmark<br>trueRunning for engine innodb<br>trueAverage number of seconds to run all queries: 0.610 seconds<br>trueMinimum number of seconds to run all queries: 0.610 seconds<br>trueMaximum number of seconds to run all queries: 0.610 seconds<br>trueNumber of clients running queries: 100<br>trueAverage number of queries per client: 20<br><br>Benchmark<br>trueRunning for engine innodb<br>trueAverage number of seconds to run all queries: 0.457 seconds<br>trueMinimum number of seconds to run all queries: 0.457 seconds<br>trueMaximum number of seconds to run all queries: 0.457 seconds<br>trueNumber of clients running queries: 200<br>trueAverage number of queries per client: 10<br></code></pre></td></tr></table></figure><h6 id="测试说明">测试说明</h6><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">模拟测试两次读写并发，第一次100，第二次200，自动生成SQL脚本，测试表包含20个init字段，30个char字段，每次执行2000查询请求。测试引擎分别是myisam，innodb。<br></code></pre></td></tr></table></figure><h6 id="测试结果说明">测试结果说明</h6><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">Myisam第一次100客户端同时发起增查用1.459/s,第二次200客户端同时发起增查用1.420/s<br>Innodb第一次100客户端同时发起增查用1.352/s,第二次200客户端同时发起增查用2.330/s<br></code></pre></td></tr></table></figure><h6 id="测试结论">测试结论</h6><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">由此可见MyISAM存储引擎处理性能是最好的，也是最常用的，但不支持事务。<br>InonDB存储引擎提供了事务型数据引擎（ACID），在事务型引擎里使用最多的。具有事务回滚，系统修复等特点。<br></code></pre></td></tr></table></figure><h3 id="2）测试结果保存为csv文件">2）测试结果保存为csv文件</h3><p><strong>Mysqlslap测试工具生产CSV格式数据文件并转换成图表形式：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# mysqlslap --defaults-file=/etc/my.cnf --concurrency=100,200 --iterations=1 --number-int-cols=20 --number-char-cols=30 --auto-generate-sql --auto-generate-sql-add-autoincrement --auto-generate-sql-load-type=mixed --engine=myisam,innodb --number-of-queries=2000 -uroot -p123 --csv=/root/a.csv<br></code></pre></td></tr></table></figure><p><strong>将/root/a.csv拷贝到windows主机上，打开并生成图表</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200618175243042.png" alt="image-20200618175243042"></p><h3 id="3）使用自定义sql脚本测试">3）使用自定义sql脚本测试</h3><p><strong>用我们自己定义的SQL 脚本或语句来测试 首先准备好要测试的数据库表，这里我们编写一个生成表的脚本去完成 脚本内容如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# cat /root/mysql3.sh<br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>HOSTNAME="localhost"<br>PORT="3306"<br>USERNAME="root"<br>PASSWORD="123"<br>DBNAME="test1"<br>TABLENAME="tb1"<br><span class="hljs-meta">#</span><span class="bash">create database</span><br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; -e "drop database if exists $&#123;DBNAME&#125;" create_db_sql="create database if not exists $&#123;DBNAME&#125;"<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; -e "$&#123;create_db_sql&#125;"<br><span class="hljs-meta">#</span><span class="bash">create table</span><br>create_table_sql="create table if not exists $&#123;TABLENAME&#125;(stuid int not null primary key,stuname varchar(20) not null,stusex char(1) not null,cardid varchar(20) not null,birthday datetime,entertime datetime,address varchar(100) default null)"<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e "$&#123;create_table_sql&#125;"<br><span class="hljs-meta">#</span><span class="bash">insert data to table</span><br>i=1<br>while [ $i -le 20000 ]<br>do<br>insert_sql="insert into $&#123;TABLENAME&#125; values($i,'zhangsan','1','1234567890123456','1999-10-10','2016-9-3','zhongguo beijingshi changpinqu')"<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e "$&#123;insert_sql&#125;"<br>let i++<br>done<br><span class="hljs-meta">#</span><span class="bash">select data</span><br>select_sql="select count(*) from $&#123;TABLENAME&#125;"<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e "$&#123;select_sql&#125;"<br></code></pre></td></tr></table></figure><p><strong>授权脚本x执行权限</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@192 opt]# chmod +x mysql_test.sh<br></code></pre></td></tr></table></figure><h4 id="执行脚本mysql3-sh生成mysqlslap工具需要的测试表">执行脚本mysql3.sh生成mysqlslap工具需要的测试表</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# /root/mysql3.sh<br><br>执行mysqlslap工具进行测试<br>[root@mysql ~]# mysqlslap --defaults-file=/etc/my.cnf --concurrency=10,20 --iterations=1 --create-schema='test1' --query='select * from test1.tb1' --engine=myisam,innodb --number-of-queries=2000 -uroot -p123 –verbose<br></code></pre></td></tr></table></figure><h5 id="显示结果：">显示结果：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@192 opt]# mysqlslap --defaults-file&#x3D;&#x2F;etc&#x2F;my.cnf --concurrency&#x3D;10,20 --iterations&#x3D;1 --create-schema&#x3D;&#39;test1&#39; --query&#x3D;&#39;select * from test1.tb1&#39; --engine&#x3D;myisam,innodb --number-of-queries&#x3D;2000 -uroot -p1234 –verbose<br>mysqlslap: [Warning] Using a password on the command line interface can be insecure.<br>Benchmark<br>        Running for engine myisam<br>        Average number of seconds to run all queries: 3.261 seconds<br>        Minimum number of seconds to run all queries: 3.261 seconds<br>        Maximum number of seconds to run all queries: 3.261 seconds<br>        Number of clients running queries: 10<br>        Average number of queries per client: 200<br><br>Benchmark<br>        Running for engine myisam<br>        Average number of seconds to run all queries: 3.010 seconds<br>        Minimum number of seconds to run all queries: 3.010 seconds<br>        Maximum number of seconds to run all queries: 3.010 seconds<br>        Number of clients running queries: 20<br>        Average number of queries per client: 100<br><br>Benchmark<br>        Running for engine innodb<br>        Average number of seconds to run all queries: 3.421 seconds<br>        Minimum number of seconds to run all queries: 3.421 seconds<br>        Maximum number of seconds to run all queries: 3.421 seconds<br>        Number of clients running queries: 10<br>        Average number of queries per client: 200<br><br>Benchmark<br>        Running for engine innodb<br>        Average number of seconds to run all queries: 3.252 seconds<br>        Minimum number of seconds to run all queries: 3.252 seconds<br>        Maximum number of seconds to run all queries: 3.252 seconds<br>        Number of clients running queries: 20<br>        Average number of queries per client: 100<br></code></pre></td></tr></table></figure><p><strong>注：通过mysqlslap工具对mysql server进行压力测试，可以通过–concurrency、–number-of-queries等选项的值查看每次测试的结果，通过反复测试、优化得出mysql server的最大并发数.如果mysqlslap工具输出结果为Segmentation fault (core dumped)基本表示走超出mysql server的负载。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;一、MySQL自带工具使用介绍&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;MySQL数据库不仅提供了数据库的服务器端应用程序，同时还提供了大量的客户端工具程序，如mysql，mysqladmin，mysqldump等等 。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;bl
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://wsdlxgp.top/categories/mysql/"/>
    
    
      <category term="mysqladmin" scheme="https://wsdlxgp.top/tags/mysqladmin/"/>
    
      <category term="--tee" scheme="https://wsdlxgp.top/tags/tee/"/>
    
      <category term="--prompt" scheme="https://wsdlxgp.top/tags/prompt/"/>
    
      <category term="mysqldump" scheme="https://wsdlxgp.top/tags/mysqldump/"/>
    
      <category term="mysqlslap" scheme="https://wsdlxgp.top/tags/mysqlslap/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据文件介绍及存放位置</title>
    <link href="https://wsdlxgp.top/posts/80a7.html"/>
    <id>https://wsdlxgp.top/posts/80a7.html</id>
    <published>2020-06-17T16:00:00.000Z</published>
    <updated>2020-06-19T05:16:36.710Z</updated>
    
    <content type="html"><![CDATA[<h1>一、MySQL数据库文件介绍</h1><p><strong>MySQL的每个数据库都对应存放在一个与数据库同名的文件夹中，MySQL数据库文件包括MySQL所建数据库文件和MySQL所用存储引擎创建的数据库文件。</strong></p><h2 id="1、MySQL创建并管理的数据库文件：">1、MySQL创建并管理的数据库文件：</h2><p><strong>.frm文件：存储数据表的框架结构，文件名与表名相同，每个表对应一个同名frm文件，与操作系统和存储引擎无关，即不管MySQL运行在何种操作系统上，使用何种存储引擎，都有这个文件。</strong></p><p><strong>除了必有的.frm文件，根据MySQL所使用的存储引擎的不同（MySQL常用的两个存储引擎是MyISAM和InnoDB），存储引擎会创建各自不同的数据库文件。</strong></p><h2 id="2、MyISAM数据库表文件：">2、MyISAM数据库表文件：</h2><ul><li><strong>.MYD文件：即MY Data，表数据文件</strong></li><li><strong>.MYI文件：即MY Index，索引文件</strong></li><li><strong>.log文件：日志文件</strong></li></ul><h2 id="3、InnoDB采用表空间（tablespace）来管理数据，存储表数据和索引，">3、InnoDB采用表空间（tablespace）来管理数据，存储表数据和索引，</h2><p><strong>InnoDB数据库文件（即InnoDB文件集，ib-file set）：</strong></p><p><strong>ibdata1、ibdata2等：系统表空间文件，存储InnoDB系统信息和用户数据库表数据和索引，所有表共用</strong></p><p><strong>.ibd文件：单表表空间文件，每个表使用一个表空间文件（file per table），存放用户数据库表数据和索引</strong></p><p><strong>日志文件： ib_logfile1、ib_logfile2</strong></p><h1>二、MySQL数据库存放位置：</h1><p><strong>1、MySQL如果使用MyISAM存储引擎，数据库文件类型就包括.frm、.MYD、.MYI，默认存放位置是C:\Documentsand Settings\All Users\Application Data\MySQL\MySQL Server 5.1\data</strong></p><p><strong>2、MySQL如果使用InnoDB存储引擎，数据库文件类型就包括.frm、ibdata1、.ibd，存放位置有两个，</strong></p><p><strong>.frm文件默认存放位置是C:\Documents and Settings\All Users\ApplicationData\MySQL\MySQL Server 5.1\data，ibdata1、.ibd文件默认存放位置是MySQL安装目录下的data文件夹</strong></p><h1>三、操作</h1><p><strong>看看我的数据库文件的存放位置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@pacteralinux ~]<span class="hljs-comment"># cd /mnt/resource/mysqldate/</span><br>[root@pacteralinux mysqldate]<span class="hljs-comment"># ll -h</span><br>total 173M<br>-rw-rw----. 1 mysql mysql   56 Nov 25 17:17 auto.cnf<br>-rw-rw----. 1 mysql mysql  76M Dec 24 17:02 ibdata1<br>-rw-rw----. 1 mysql mysql  48M Dec 24 17:02 ib_logfile0<br>-rw-rw----. 1 mysql mysql  48M Nov 26 13:39 ib_logfile1<br>drwx------. 2 mysql mysql 4.0K Nov 26 13:41 mysql<br>drwx------. 2 mysql mysql  20K Nov 26 17:00 mysqldb<br>srwxrwxrwx. 1 mysql mysql    0 Dec 24 17:02 mysql.sock<br>-rw-rw----. 1 mysql root  499K Dec 25 14:42 pacteralinux.err<br>-rw-rw----. 1 mysql mysql    6 Dec 24 17:02 pacteralinux.pid<br>drwx------. 2 mysql mysql 4.0K Nov 26 13:41 performance_schema<br>drwx------. 2 mysql mysql 4.0K Nov 26 13:41 <span class="hljs-built_in">test</span><br>drwx------. 2 mysql mysql 4.0K Dec  9 16:49 weixindemo<br>[root@pacteralinux mysqldate]<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p><strong>其中这三个文件我一直很迷惑</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">-rw-rw----. 1 mysql mysql  76M Dec 24 17:02 ibdata1<br>-rw-rw----. 1 mysql mysql  48M Dec 24 17:02 ib_logfile0<br>-rw-rw----. 1 mysql mysql  48M Nov 26 13:39 ib_logfile1<br></code></pre></td></tr></table></figure><p><strong>再看这些文件（部分）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@pacteralinux mysqldb]<span class="hljs-comment"># ll -h</span><br>total 3.6G<br>-rw-rw----. 1 mysql mysql  11K Nov 26 16:47 chen_fundnetvalue_bak.frm<br>-rw-rw----. 1 mysql mysql  62K Nov 26 16:47 chen_fundnetvalue_bak.MYD<br>-rw-rw----. 1 mysql mysql 4.0K Nov 26 16:47 chen_fundnetvalue_bak.MYI<br>-rw-rw----. 1 mysql mysql  11K Nov 26 16:47 chen_fundnetvalue.frm<br>-rw-rw----. 1 mysql mysql 834K Nov 26 16:47 chen_fundnetvalue.MYD<br>-rw-rw----. 1 mysql mysql  18K Nov 26 16:47 chen_fundnetvalue.MYI<br>-rw-rw----. 1 mysql mysql 8.4K Nov 26 16:47 codelist_bak.frm<br>-rw-rw----. 1 mysql mysql  162 Nov 26 16:47 codelist_bak.MYD<br>-rw-rw----. 1 mysql mysql 1.0K Nov 26 16:47 codelist_bak.MYI<br>-rw-rw----. 1 mysql mysql 8.4K Nov 26 16:47 codelist.frm<br>-rw-rw----. 1 mysql mysql  162 Nov 26 16:47 codelist.MYD<br>-rw-rw----. 1 mysql mysql 1.0K Nov 26 16:47 codelist.MYI<br></code></pre></td></tr></table></figure><p><strong>. 前面是表名，每个表由frm  MYD MYI三个后缀名组成，所有表都是！</strong></p><p><strong>在MySQL 中每一个数据库都会在定义好（或者默认）的数据目录下存在一个以数据库名字命名的文件夹，用来存放该数据库中各种表数据文件。不同的MySQL 存储引擎有各自不同的数据文件，存放位置也有区别。</strong></p><p><strong>多数存储引擎的数据文件都存放在和MyISAM 数据文件位置相同的目录下，但是每个数据文件的扩展名却各不一样。如MyISAM 用“.MYD”作为扩展名，Innodb 用“.ibd”，Archive 用“.arc”，CSV 用“.csv”，等等。</strong></p><h2 id="1、下面就来详细分析一下这些是什么文件！！！！！">1、下面就来详细分析一下这些是什么文件！！！！！</h2><h2 id="（1）“-frm”文件">（1）“.frm”文件</h2><p><strong>与表相关的元数据（meta）信息都存放在“.frm”文件中，包括表结构的定义信息等。不论是什么存储引擎，每一个表都会有一个以表名命名的“.frm”文件。所有的“.frm”文件都存放在所属数据库的文件夹下面。（innodb，myisam）</strong></p><h2 id="（2）“-MYD”文件">（2）“.MYD”文件</h2><p><strong>“.MYD”文件是MyISAM 存储引擎专用，存放MyISAM 表的数据。每一个MyISAM 表都会有一个“.MYD”文件与之对应，同样存放于所属数据库的文件夹下，和“.frm”文件在一起。</strong></p><h2 id="（3）“-MYI”文件">（3）“.MYI”文件</h2><p><strong>“.MYI”文件也是专属于MyISAM存储引擎的，主要存放MyISAM表的索引相关信息。对于MyISAM存储来说，可以被cache 的内容主要就是来源于“.MYI”文件中。每一个MyISAM表对应一个“.MYI”文件，存放于位置和“.frm”以及“.MYD”一样。</strong></p><h2 id="（4）小结一下：">（4）小结一下：</h2><p><strong>MyISAM 存储引擎的表在数据库中，每一个表都被存放为三个以表名命名的物理文件（frm,myd,myi）。 每个表都有且仅有这样三个文件做为MyISAM 存储类型的表的存储，也就是说不管这个表有多少个索引，都是存放在同一个.MYI 文件中。</strong></p><p><strong>这个在开始里看的比较清楚。</strong></p><h2 id="2、“-ibd”文件和ibdata-文件">2、“.ibd”文件和ibdata 文件</h2><p><strong>这两种文件都是存放Innodb 数据的文件，之所以有两种文件来存放Innodb 的数据（包括索引），是因为Innodb 的数据存储方式能够通过配置来决定是使用<code>共享表空间存放存储数据，还是独享表空间存放存储数据</code>。独享表空间存储方式使用“.ibd”文件来存放数据，且每个表一个“.ibd”文件，文件存放在和MyISAM数据相同的位置。</strong></p><p><strong>如果选用共享存储表空间来存放数据，则会使用ibdata 文件来存放，所有表<code>共同使用一个（或者多个，可自行配置）ibdata 文件</code>。ibdata 文件可以通过innodb_data_home_dir 和innodb_data_file_path两个参数共同配置组成， innodb_data_home_dir 配置数据存放的总目录， 而innodb_data_file_path 配置每一个文件的名称。当然，也可以不配innodb_data_home_dir而直接在innodb_data_file_path参数配置的时候使用绝对路径来完成配置。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">mysql&gt;</span><span class="bash"> showvariables like <span class="hljs-string">'innodb_data%'</span>;</span><br><br>+-----------------------+------------------------+<br>|Variable_name     | Value          |<br>+-----------------------+------------------------+<br>|innodb_data_file_path | ibdata1:10M:autoextend |<br>| innodb_data_home_dir  |             |<br>+-----------------------+------------------------+<br>2 rows in set(0.01 sec)<br></code></pre></td></tr></table></figure><p><strong>innodb_data_file_path中可以一次配置多个ibdata文件。文件可以是指定大小，也可以是自动扩展的，但是Innodb 限制了仅仅只有最后一个ibdata 文件能够配置成自动扩展类型。当我们需要添加新的ibdata 文件的时候，只能添加在innodb_data_file_path配置的最后，而且必须重启MySQL 才能完成ibdata 的添加工作。</strong></p><h2 id="3、ibdata文件瘦身法">3、ibdata文件瘦身法</h2><p><strong>MySql innodb如果是共享表空间，ibdata1文件越来越大，达到了30多个G，对一些没用的表进行清空：</strong><br><strong>truncate table xxx;</strong><br><strong>然后optimize table xxx; 没有效果</strong><br><strong>因为对共享表空间不起作用。</strong><br><strong>mysql ibdata1存放数据，索引等，是MYSQL的最主要的数据。</strong></p><p><strong>如果不把数据分开存放的话，这个文件的大小很容易就上了G，甚至几十G。对于某些应用来说，并不是太合适。因此要把此文件缩小。</strong><br><strong>无法自动收缩，必须数据导出，删除ibdata1，然后数据导入，比较麻烦，因此需要改为每个表单独的文件。</strong></p><p><strong>解决方法：数据文件单独存放(共享表空间如何改为每个表独立的表空间文件)。</strong></p><h3 id="步骤如下："><strong>步骤如下：</strong></h3><h4 id="1）备份数据库"><strong>1）备份数据库</strong></h4><p><strong>从命令行进入MySQL Server 5.0\bin</strong><br><strong>备份全部数据库，执行命令</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">D:\&gt;<span class="hljs-title">mysqldump</span> -<span class="hljs-title">q</span> -<span class="hljs-title">umysql</span> -<span class="hljs-title">ppassword</span> --<span class="hljs-title">add</span>-<span class="hljs-title">drop</span>-<span class="hljs-title">table</span> --<span class="hljs-title">all</span>-<span class="hljs-title">databases</span> &gt; <span class="hljs-title">c</span>:/<span class="hljs-title">all.sql</span></span><br></code></pre></td></tr></table></figure><p><strong>做完此步后，停止数据库服务。</strong></p><h4 id="2）找到my-ini或my-cnf文件"><strong>2）找到my.ini或my.cnf文件</strong></h4><p><strong>linux下执行 <code>./mysqld --verbose --help | grep -A 1 'Default options'</code></strong><br><strong>会有类似显示：</strong><br><strong>Default options are read from the following files in the given order:</strong><br><strong>/etc/my.cnf ~/.my.cnf /usr/local/service/mysql3306/etc/my.cnf</strong></p><p><strong>windows环境下可以：</strong><br><strong><code>mysqld --verbose --help &gt; mysqlhelp.txt</code></strong><br><strong><code>notepad mysqlhelp.txt</code></strong><br><strong>在里面查找Default options，可以看到查找my.ini的顺序，以找到真实目录</strong></p><h4 id="3）修改mysql配置文件"><strong>3）修改mysql配置文件</strong></h4><p><strong>打开my.ini或my.cnf文件</strong><br><strong><code>[mysqld]</code>下增加下面配置</strong><br><strong><code>innodb_file_per_table=1</code></strong></p><p><strong>验证配置是否生效，可以重启mysql后,执行</strong><br><strong><code>show variables like '%per_table%'</code></strong><br><strong>看看<code>innodb_file_per_table</code>变量是否为ON</strong></p><h4 id="4）删除原数据文件"><strong>4）删除原数据文件</strong></h4><p><strong>删除原来的ibdata1文件及日志文件<code>ib_logfile*</code>，删除data目录下的应用数据库文件夹(mysql文件夹不要删)</strong></p><h4 id="5）还原数据库"><strong>5）还原数据库</strong></h4><p><strong>启动数据库服务</strong></p><p><strong>从命令行进入MySQL Server 5.0\bin</strong><br><strong>还原全部数据库，执行命令<code>mysql -uusername -pyourpassword &lt; c:/all.sql</code></strong></p><p><strong>经过以上几步后，可以看到新的ibdata1文件就只有几十M了，数据及索引都变成了针对单个表的小ibd文件了，它们在相应数据库的文件夹下面。</strong></p><h1>四、mysql data文件夹下的ibdata1 文件作用</h1><p><strong>这个文件超级大， 查了一下， 大概的作用如下</strong><br><strong>是储存的格式</strong><br><strong>INNODB类型数据状态下，</strong><br><strong>ibdata用来储存文件的数据</strong><br><strong>而库名的文件夹里面的那些表文件只是结构而已</strong><br><strong>由于mysql4.1默认试innodb，所以这个文件默认就存在了https://wsdlxgp.top/ 这个链接试innodb的中文参考， innodb的东西可以在my.ini中设置</strong></p><p><strong>使用过MySQL的同学，刚开始接触最多的莫过于MyISAM表引擎了，这种引擎的数据库会分别创建三个文件：表结构、表索引、表数据空间。我们可以将某个数据库目录直接迁移到其他数据库也可以正常工作。</strong><br><strong>然而当你使用InnoDB的时候，一切都变了。InnoDB 默认会将所有的数据库InnoDB引擎的表数据存储在一个共享空间中：ibdata1，这样就感觉不爽，增删数据库的时候，ibdata1文件不会自动收缩，单个数据库的备份也将成为问题。通常只能将数据使用mysqldump 导出，然后再导入解决这个问题。</strong><br><strong>在MySQL的配置文件[mysqld]部分，增加innodb_file_per_table参数，可以修改InnoDB为独立表空间模式，每个数据库的每个表都会生成一个数据空间。</strong></p><h3 id="独立表空间"><strong>独立表空间</strong></h3><h4 id="优点：">优点：</h4><p><strong>1.每个表都有自已独立的表空间。</strong><br><strong>2.每个表的数据和索引都会存在自已的表空间中。</strong><br><strong>3.可以实现单表在不同的数据库中移动。</strong><br><strong>4.空间可以回收（drop/truncate table方式操作表空间不能自动回收）</strong><br><strong>5.对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。</strong></p><h4 id="缺点："><strong>缺点：</strong></h4><p><strong>单表增加比共享空间方式更大。</strong></p><h4 id="结论："><strong>结论：</strong></h4><p><strong>共享表空间在Insert操作上有一些优势，但在其它都没独立表空间表现好。</strong><br><strong>当启用独立表空间时，请合理调整一下 innodb_open_files 参数。</strong></p><h4 id="两个重要参数：">两个重要参数：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">innodb_data_file_path<br>innodb_data_home_dir<br></code></pre></td></tr></table></figure><p><strong>这两个参数看参考文献的时候一直没有理解，先说明如下</strong></p><p><strong>我的my.cnf</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#innodb_data_home_dir = /var/lib/mysql/</span><br><span class="hljs-comment">#innodb_data_file_path = ibdata1:10M:autoextend</span><br></code></pre></td></tr></table></figure><p><strong>为了在 MySQL-Max-3.23 中使用 InnoDB 表，你必须在配置文件<code>‘my.cnf’</code>中的 <code>[mysqld]</code> 区中详细指定配置参数。</strong></p><p><strong>作为最小设置，在 3.23 中你必须在 <code>innodb_data_file_path</code> 上指定数据文件名能及大小。</strong></p><p><strong>如果在<code>‘my.cnf’</code>中没有指定<code>innodb_data_home_dir</code>，系统将在 MySQL 的 <code>datadir</code> 目录下创建数据文件。</strong></p><p><strong>如果将<code> innodb_data_home_dir</code> 设为一个空串，那可以在 <code>innodb_data_file_path</code> 中给定一个绝对路径。</strong></p><p><strong>在 MySQL-4.0 中可以不设定 <code>innodb_data_file_path</code> ：MySQL-4.0 将默认地在 <code>datadir</code> 目录下建立一个 10 MB 大小自扩充(auto-extending)的文件<code>‘ibdata1’</code>(在MySQL-4.0.0 与 4.0.1 中数据文件的大小为 64 MB 并且是非自扩充的(not auto-extending))。</strong></p><p><strong>为了得到更好的性能你必须所示的例子明确地设定 InnoDB 启动参数。</strong></p><p><strong>从 3.23.50 版和 4.0.2 版开始，InnoDB 允许在 <code>innodb_data_file_path</code> 中设置的最一个数据文件描述为 auto-extending。 <code>innodb_data_file_path</code> 语法如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs as3">pathtodatafile:sizespecification;pathtodatafile:sizespec;...<br>    ...;pathtodatafile:sizespec[:autoextend[:max:sizespecification]]<br></code></pre></td></tr></table></figure><p><strong>如果用 autoextend 选项描述最后一个数据文件，当 InnoDB 用尽所有表自由空间后将会自动扩充最后一个数据文件，每次增量为 8 MB。示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs as3">innodb_data_home_dir &#x3D;<br>innodb_data_file_path &#x3D; &#x2F;ibdata&#x2F;ibdata1:100M:autoextend<br></code></pre></td></tr></table></figure><p><strong>指定 InnoDB 只建立一个最初大小为 100 MB 并且当表空间被用尽时以 8MB 每块增加的数据文件。如果硬盘空间不足，可以再添加一个数据文件并将其放在其它的硬盘中。 举例来说：先检查硬盘空间的大小，设定<code>ibdata1</code>文件使它接近于硬盘空余空间大小并为 1024 * 1024 bytes (= 1 MB)的倍数， 将<code> ibdata1</code> 明确地指定在<code> innodb_data_file_path</code> 中。在此之后可以添加另一个数据文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">innodb_data_home_dir =<br>innodb_data_file_path = /ibdata/ibdata1:988M;/disk2/ibdata2:50M:autoextend<br></code></pre></td></tr></table></figure><p><strong>注意：设定文件大小时一定要注意你的OS是否有最大文件尺寸为2GB的限制！InnoDB是不会注意你的OS文件尺寸限制的， 在一些文件系统中你可能要设定最大容量限制：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs as3">innodb_data_home_dir &#x3D;<br>innodb_data_file_path &#x3D; &#x2F;ibdata&#x2F;ibdata1:100M:autoextend:max:2000M<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;一、MySQL数据库文件介绍&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;MySQL的每个数据库都对应存放在一个与数据库同名的文件夹中，MySQL数据库文件包括MySQL所建数据库文件和MySQL所用存储引擎创建的数据库文件。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1、MySQL
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://wsdlxgp.top/categories/mysql/"/>
    
    
      <category term="sql结构化查询语句" scheme="https://wsdlxgp.top/tags/sql%E7%BB%93%E6%9E%84%E5%8C%96%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"/>
    
      <category term="数值类型" scheme="https://wsdlxgp.top/tags/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务日志</title>
    <link href="https://wsdlxgp.top/posts/4c37.html"/>
    <id>https://wsdlxgp.top/posts/4c37.html</id>
    <published>2020-06-16T16:01:10.000Z</published>
    <updated>2020-06-19T05:16:26.737Z</updated>
    
    <content type="html"><![CDATA[<h1>事务日志(或称redo日志)</h1><p><strong>事务日志（InnoDB特有的日志）可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢的刷回到磁盘。目前大多数的存储引擎都是这样实现的。 如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。具有的恢复方式则视存储引擎而定。</strong></p><h4 id="查看事务日志的定义："><strong>查看事务日志的定义：</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show global variables like &#39;%log%&#39;;<br></code></pre></td></tr></table></figure><h5 id="显示结果">显示结果</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">| innodb_flush_log_at_timeout | 1 |<br>| innodb_flush_log_at_trx_commit | 1 #在事务提交时innodb是否同步日志从缓冲区到文件中，当这个值为1（默认值）之时，在每个事务提交时，日志缓冲被写到日志文件，对日志文件做到磁盘操作的刷新，性能会很差造成大量的磁盘I&#x2F;O但这种方式最安全；如果设为2,每次提交事务都会写日志，但并不会执行刷的操作。每秒定时会刷到日志文件。要注意的是，并不能保证100%每秒一定都会刷到磁盘，这要取决于进程的调度。每次事务提交的时候将数据写入事务日志，而这里的写入仅是调用了文件系统的写入操作，而文件系统是有 缓存的，所以这个写入并不能保证数据已经写入到物理磁盘。设置为0，日志缓冲每秒一次地被写到日志文件，并且对日志文件做到磁盘操作的刷新，但是在一个事务提交不做任何操作。<br>注：刷写的概念<br>刷写其实是两个操作，刷（flush）和写（write），区分这两个概念是很重要的。在大多数的操作系统中，把Innodb的log buffer（内存）写入日志（调用系统调用write），只是简单的把数据移到操作系统缓存中，操作系统缓存同样指的是内存。并没有实际的持久化数据。<br>所以，通常设为0和2的时候，在崩溃或断电的时候会丢失最后一秒的数据，因为这个时候数据只是存在于操作系统缓存。之所以说“通常”，可能会有丢失不只1秒的数据的情况，比如说执行flush操作的时候阻塞了。<br>总结<br>设为1当然是最安全的，但性能页是最差的（相对其他两个参数而言，但不是不能接受）。如果对数据一致性和完整性要求不高，完全可以设为2,如果只最求性能，例如高并发写的日志服务器，设为0来获得更高性能<br>|<br>| innodb_locks_unsafe_for_binlog | OFF |<br>| innodb_log_buffer_size | 16777216 |<br>| innodb_log_checksums | ON<br>|<br>| innodb_log_compressed_pages | ON |<br>| innodb_log_file_size | 50331648 #日志文件大小 |<br>| innodb_log_files_in_group | 2 # DB中设置几组事务日志，默认是2<br>|<br>| innodb_log_group_home_dir | .&#x2F; #定义innodb事务日志组的位置,此位置设置默认为<br>MySQL的datadir |<br></code></pre></td></tr></table></figure><p><strong>每个事务日志都是大小为50兆的文件（不同版本的<code>mysql</code>有差异）： 在<code>mysql</code>中默认以<code>ib_logfile0</code>,<code>ib_logfile1</code>名称存在</strong></p><h1>慢查询日志：slow query log</h1><p><strong>顾名思义，慢查询日志中记录的是执行时间较长的query，也就是我们常说的slow query。 慢查询日志采用的是简单的文本格式，可以通过各种文本编辑器查看其中的内容。其中 记录了语句执行的时刻，执行所消耗的时间，执行用户，连接主机等相关信息。 慢查询日志的作用： 慢查询日志是用来记录执行时间超过指定时间的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率很低，以便进行优化。一般建议开启，它对服务器性能的影响微乎其微，但是可以记录mysql服务器上执行了很长时间的查询语句。可以帮助我们定位性能问题的。MySQL 还提供了专门用来分析满查询日志的工具程序mysqldumpslow，用来帮助数据库管理人员解决可能存在的性能问题。 查看慢查询日志的定义：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show global variables like &#39;%slow_query_log%&#39;;<br>+---------------------+------------------------------------+<br>| Variable_name       | Value                              |<br>+---------------------+------------------------------------+<br>| slow_query_log      | OFF                                |<br>| slow_query_log_file | &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;192-slow.log |<br>+---------------------+------------------------------------+<br>2 rows in set (0.00 sec)<br><br>mysql&gt; show global variables like &#39;%long%&#39;;<br>+----------------------------------------------------------+-----------+<br>| Variable_name                                            | Value     |<br>+----------------------------------------------------------+-----------+<br>| long_query_time                                          | 10.000000 |<br>| performance_schema_events_stages_history_long_size       | 10000     |<br>| performance_schema_events_statements_history_long_size   | 10000     |<br>| performance_schema_events_transactions_history_long_size | 10000     |<br>| performance_schema_events_waits_history_long_size        | 10000     |<br>+----------------------------------------------------------+-----------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>**启动和设置慢查询日志： **</p><h3 id="方法1：通过配置文件my-cnf开启慢查询日志：">方法1：通过配置文件my.cnf开启慢查询日志：</h3><blockquote><p><strong>注：在不同的mysql版本中，开启慢查询日志参数不太一样，不过都可以通过 show variables like “%slow%” 和show variables like &quot;%long%&quot;查看出来。</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show global variables like &#39;%slow%&#39;;<br>+---------------------------+------------------------------------------+<br>| Variable_name | Value |<br>+---------------------------+------------------------------------------+<br>| log_slow_admin_statements | OFF |<br>| log_slow_slave_statements | OFF |<br>| slow_launch_time | 2 |<br>| slow_query_log | OFF |<br>| slow_query_log_file | &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;localhost-slow.log |<br>+---------------------------+------------------------------------------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>其中： slow_query_log： off关闭状态 on开启状态 slow_query_log_file 慢查询日志存放地点 long_query_time选项来设置一个时间值，时间以秒为单位，可以精确到微秒。如果查询时间超过了这个时间值（默认为10秒），这个查询语句将被记录到慢查询日志中, 设置为0的话表示记录所有的查询。 slow_launch_time 表示如果建立线程花费了比这个值更长的时间,slow_launch_threads 计数器将增加 注：如果不指定存储路径，慢查询日志默认存储到mysql数据库的数据文件下，如果不指定文件名，默认文件名为hostname-slow.log 修改my.cnf文件：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[mysqld]<br>slow_query_log=1<br>slow_query_log_file=/usr/local/mysql/data/mysql-slow.log<br>long_query_time=1<br>slow_launch_time=1<br></code></pre></td></tr></table></figure><p><strong>重启mysqld服务 再次查询慢查询日志定义</strong></p><h3 id="方法2：通过登录mysql服务器直接定义，方式如下："><strong>方法2：通过登录mysql服务器直接定义，方式如下：</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt;set global slow_query_log&#x3D;1; #开启慢查询日志<br>Query OK, 0 rowsaffected (0.35 sec)<br>mysql&gt;set session long_query_time&#x3D;0.0001; #更改时间（当前session中，退出则重置）<br>Query OK, 0 rowsaffected (0.00 sec)<br>mysql&gt;set global long_query_time&#x3D;0.0001; #更改时间（全局中，重启服务则重置）<br>mysql&gt; SHOW VARIABLES LIKE &#39;long%&#39;; #查询定义时间<br></code></pre></td></tr></table></figure><h4 id="查看慢查询日志">查看慢查询日志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; use mysql<br>mysql&gt; select user,host from user where user&#x3D;&quot;root&quot;;  <br>+------+-----------+<br>| user | host      |<br>+------+-----------+<br>| root | localhost |<br>+------+-----------+<br>1 row in set (0.02 sec)<br></code></pre></td></tr></table></figure><p><strong>或用系统查看文件内容命令如cat直接查看慢日志文件</strong></p><p><strong>第一行表示记录日志时的时间。其格式是 YYYY-MM-DD HH:MM:SS。我们可以看出上面的查询记录于 2016 年 8 月 29 日下午 15:47：24 - 注意：这个是服务器时间. MySql 用户、服务器以及主机名第三行表示总的查询时间、锁定时间、&quot;发送&quot;或者返回的行数 Query_time: 0.000304 表示用了0.000304秒 Lock_time: 0.000128 表示锁了0.000128秒 Rows_sent: 4 表示返回4行 Rows_examined: 4 表示一共查了4行 SETtimestamp=UNIXTIME; 这是查询实际发生的时间 何将其变成一个有用的时间，将 Unix 时间转成一个可读的时间，可以使用 date –d@日志中的时间戳可以看到查询进行的同时记录了该日志 ，但是对于一台超负载的服务器常常并非如此。因此记住：SETtimestamp= value 才是实际的查询的执行时间。</strong></p><p><strong>慢查询分析mysqldumpslow 们可以通过打开log文件查看得知哪些SQL执行效率低下。从日志中，可以发现查询时间超过long_query_time时间的query为慢查询，而小于long_query_time时间的没有出现在此日志中。 如果慢查询日志中记录内容很多，可以使用mysqldumpslow工具（MySQL客户端安装自带）来对慢查询日志进行分类汇总。mysqldumpslow对日志文件进行了分类汇总，显示汇总后摘要结果 进入log的存放目录，运行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@localhost data]# mysqldumpslow mysqld-slow.log<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">注： mysqldumpslow -s c -t 10 &#x2F;database&#x2F;mysql&#x2F;slow-query.log 这会输出记录次数最多<br>的10条SQL语句，其中： -s, 是表示按照何种方式排序，c、t、l、r分别是按照记录次数、时间、查询时<br>间、返回的记录数来排序，ac、at、al、ar，表示相应的倒序； -t, 是top n的意思，即为返回前面多少条<br>的数据； -g, 后边可以写一个正则匹配模式，大小写不敏感的； 例如： &#x2F;path&#x2F;mysqldumpslow -s r -t 10<br>&#x2F;database&#x2F;mysql&#x2F;slow-log 得到返回记录集最多的10个查询。<br>&#x2F;path&#x2F;mysqldumpslow -s t -t 10 -g “left join” &#x2F;database&#x2F;mysql&#x2F;slow-log 得到按照时间排序的前10条里面含有左连接的查询语句。<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;事务日志(或称redo日志)&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;事务日志（InnoDB特有的日志）可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://wsdlxgp.top/categories/mysql/"/>
    
    
      <category term="sql结构化查询语句" scheme="https://wsdlxgp.top/tags/sql%E7%BB%93%E6%9E%84%E5%8C%96%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"/>
    
      <category term="数值类型" scheme="https://wsdlxgp.top/tags/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>mysql二进制日志</title>
    <link href="https://wsdlxgp.top/posts/af18.html"/>
    <id>https://wsdlxgp.top/posts/af18.html</id>
    <published>2020-06-16T16:00:01.000Z</published>
    <updated>2020-06-19T05:16:18.614Z</updated>
    
    <content type="html"><![CDATA[<h1>一、什么是二进制日志</h1><p><strong>MySQL的二进制日志（binary log）是一个二进制文件，主要用于记录修改数据或有可能引起数据变更的MySQL语句。二进制日志（binary log）中记录了对MySQL数据库执行更改的所有操作，并且记录了语句发生时间、执行时长、操作数据等其它额外信息，但是它不记录SELECT、SHOW等那些不修改数据的SQL语句。二进制日志（binary log）主要用于数据库恢复和主从复制，以及审计（audit）操作。</strong></p><p><strong>开启二进制日志对性能的开销很小，带来的好处远大于坏处。</strong></p><h1>二、开启和设置二进制日志</h1><h2 id="1、查看二进制日志状态">1、查看二进制日志状态</h2><p><strong>默认情况下二进制日志是关闭的。</strong></p><p><strong>系统变量log_bin的值为<code>OFF</code>表示没有开启二进制日志，<code>ON</code>表示开启了二进制日志，如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#39;log_bin&#39;;<br>+---------------------------------+------------------------------------+<br>| Variable_name                   | Value                              |<br>+---------------------------------+------------------------------------+<br>| log_bin                         | OFF                                |<br>+---------------------------------+------------------------------------+<br>1 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="2、开启二进制日志">2、开启二进制日志</h2><h3 id="（1）修改配置文件并重启mysql服务">（1）修改配置文件并重启mysql服务</h3><p><strong>如果需要开启二进制日志，则必须在配置文件中[mysqld]下面添加log-bin [=DIR[filename]] 。</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">DIR参数指定二进制文件的存储路径；<br>filename参数指定二级制文件的文件名。 <br>其中filename可以任意指定，但最好有一定规范。<br>系统变量log_bin是静态参数，不能动态修改的（因为它不是Dynamic Variable）。<br></code></pre></td></tr></table></figure><p><strong>内容如下所示：</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">server-id</span> = <span class="hljs-number">1</span>              <span class="hljs-comment"># mysql5.7必须加，否则mysql服务启动报错</span><br><span class="hljs-attr">log-bin</span> = mysql_bin_log    <span class="hljs-comment"># 路径及命名，默认在data下</span><br><span class="hljs-attr">expire_logs_days</span> = <span class="hljs-number">10</span>      <span class="hljs-comment"># 过期时间,二进制文件自动删除的天数,0代表不删除</span><br><span class="hljs-attr">max_binlog_size</span> = <span class="hljs-number">100</span>M     <span class="hljs-comment"># 单个日志文件的大小限制，超出会新建一个</span><br></code></pre></td></tr></table></figure><h4 id="操作步骤：">操作步骤：</h4><blockquote><p><strong>Linux下的配置文件为/etc/my.cnf，Windows下的配置文件为my.ini。</strong></p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs powershell">[<span class="hljs-type">root</span>@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># vim /etc/my.cnf</span><br>[<span class="hljs-type">mysqld</span>]<br><br><span class="hljs-comment"># 省略部分内容</span><br>server<span class="hljs-literal">-id</span> = <span class="hljs-number">1</span>                     <span class="hljs-comment"># mysql5.7必须加，否则mysql服务启动报错</span><br>log<span class="hljs-literal">-bin</span> = mysql_bin_log           <span class="hljs-comment"># 路径及命名，默认在data下</span><br>expire_logs_days = <span class="hljs-number">10</span>             <span class="hljs-comment"># 过期时间,二进制文件自动删除的天数,0代表不删除</span><br>max_binlog_size = <span class="hljs-number">100</span>M            <span class="hljs-comment"># 单个日志文件大小</span><br><br>[<span class="hljs-type">root</span>@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># systemctl restart mysqld.service</span><br>[<span class="hljs-type">root</span>@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># systemctl status mysqld.service</span><br>● mysqld.service - MySQL Server<br>   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled)<br>   Active: active (running) since 二 <span class="hljs-number">2020</span><span class="hljs-literal">-06</span><span class="hljs-literal">-16</span> <span class="hljs-number">17</span>:<span class="hljs-number">47</span>:<span class="hljs-number">34</span> CST; <span class="hljs-number">35</span>s ago<br>     Docs: man:mysqld(<span class="hljs-number">8</span>)<br>           http://dev.mysql.com/doc/refman/en/using<span class="hljs-literal">-systemd</span>.html<br>  <span class="hljs-keyword">Process</span>: <span class="hljs-number">78724</span> ExecStart=/usr/sbin/mysqld -<span class="hljs-literal">-daemonize</span> -<span class="hljs-literal">-pid</span><span class="hljs-operator">-file</span>=/var/run/mysqld/mysqld.pid <span class="hljs-variable">$MYSQLD_OPTS</span> (code=exited, status=<span class="hljs-number">0</span>/SUCCESS)<br>  <span class="hljs-keyword">Process</span>: <span class="hljs-number">78701</span> ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=<span class="hljs-number">0</span>/SUCCESS)<br> Main PID: <span class="hljs-number">78726</span> (mysqld)<br>    Tasks: <span class="hljs-number">27</span><br>   CGroup: /system.slice/mysqld.service<br>           └─<span class="hljs-number">78726</span> /usr/sbin/mysqld -<span class="hljs-literal">-daemonize</span> -<span class="hljs-literal">-pid</span><span class="hljs-operator">-file</span>=/var/run/mysqld/mysqld.pid<br><br><span class="hljs-number">6</span>月 <span class="hljs-number">16</span> <span class="hljs-number">17</span>:<span class="hljs-number">47</span>:<span class="hljs-number">25</span> my_oracle systemd[<span class="hljs-number">1</span>]: Starting MySQL Server...<br><span class="hljs-number">6</span>月 <span class="hljs-number">16</span> <span class="hljs-number">17</span>:<span class="hljs-number">47</span>:<span class="hljs-number">34</span> my_oracle systemd[<span class="hljs-number">1</span>]: Started MySQL Server.<br></code></pre></td></tr></table></figure><h3 id="（2）查看二进制日志状态">（2）查看二进制日志状态</h3><p><strong>重启MySQL后，你就会发现log_bin变为了ON，二进制日志（binary log）默认放在数据目录下（系统变量datadir下）。</strong></p><blockquote><p><strong>show variables like ‘log_bin%’;</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#39;log_bin%&#39;;<br>+---------------------------------+------------------------------------+<br>| Variable_name                   | Value                              |<br>+---------------------------------+------------------------------------+<br>| log_bin                         | ON                                 |<br>| log_bin_basename                | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql_bin_log       |<br>| log_bin_index                   | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql_bin_log.index |<br>| log_bin_trust_function_creators | OFF                                |<br>| log_bin_use_v1_row_events       | OFF                                |<br>+---------------------------------+------------------------------------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（3）查看当前服务器所有的二进制日志文件">（3）查看当前服务器所有的二进制日志文件</h3><blockquote><p><strong>show binary logs;</strong></p></blockquote><p><strong>MySQL二进制日志存储了所有的变更信息，MySQL二进制日志经常使用。当MySQL创建二进制日志文件时，首先创建一个以’filename’为名称，以’.index’为后缀的文件；在创建一个以’filename’为名称，以’.000001’为后缀的文件。当MySQL服务重启一次，以’.000001’为后缀的文件会增加一个，并且后缀名加1递增。如果日志长度超过max_binlog_size的上限，也会创建一个新的日志。 Show binary logs;可以查看当前的*二进制日志文件个数及其文件名。二进制日志并不能直接查看，如果想要查看日志内容，可以通过mysqlbinlog命令查看。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show binary logs;<br>+----------------------+-----------+<br>| Log_name             | File_size |<br>+----------------------+-----------+<br>| mysql_bin_log.000001 |       120 |<br>+----------------------+-----------+<br>1 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>或者：</strong></p><blockquote><p><strong>show master logs;</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show master logs;<br>+----------------------+-----------+<br>| Log_name             | File_size |<br>+----------------------+-----------+<br>| mysql_bin_log.000001 |       120 |<br>+----------------------+-----------+<br>1 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（4）查看当前二进制日志文件状态">（4）查看当前二进制日志文件状态</h3><blockquote><p><strong>show master status;</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show master status;<br>+----------------------+----------+--------------+------------------+-------------------+<br>| File                 | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |<br>+----------------------+----------+--------------+------------------+-------------------+<br>| mysql_bin_log.000001 |      120 |              |                  |                   |<br>+----------------------+----------+--------------+------------------+-------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h1>三、切换二进制日志</h1><p><strong>执行 flush logs 可以刷新切换二进制文件。</strong></p><p><strong>每次重启MySQL服务也会生成一个新的二进制日志文件，相当于二进制日志切换。</strong></p><h2 id="1、重启MySQL服务切换日志">1、重启MySQL服务切换日志</h2><h3 id="（1）重启MySQL服务器前">（1）重启MySQL服务器前</h3><p><strong>查看二进制日志状态，如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show master status;<br>+----------------------+----------+--------------+------------------+-------------------+<br>| File                 | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |<br>+----------------------+----------+--------------+------------------+-------------------+<br>| mysql_bin_log.000001 |      120 |              |                  |                   |<br>+----------------------+----------+--------------+------------------+-------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（2）重启MySQL服务">（2）重启MySQL服务</h3><blockquote><p><strong>service mysql restart</strong></p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">[<span class="hljs-type">root</span>@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># service mysql restart</span><br>Shutting down MySQL.... SUCCESS! <br>Starting MySQL.. SUCCESS! <br>[<span class="hljs-type">root</span>@<span class="hljs-number">192</span> ~]<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h3 id="（3）查看日志">（3）查看日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show master status;<br>+----------------------+----------+--------------+------------------+-------------------+<br>| File                 | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |<br>+----------------------+----------+--------------+------------------+-------------------+<br>| mysql_bin_log.000002 |      120 |              |                  |                   |<br>+----------------------+----------+--------------+------------------+-------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="2、切换二进制日志并查看">2、切换二进制日志并查看</h2><p><strong>执行flush logs刷新，切换二进制文件，并查看二进制日志状态。如下所示：</strong></p><blockquote><p><strong>flush logs;</strong></p><p><strong>show master status;</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; flush logs;<br>Query OK, 0 rows affected (0.06 sec)<br><br>mysql&gt; show master status;<br>+----------------------+----------+--------------+------------------+-------------------+<br>| File                 | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |<br>+----------------------+----------+--------------+------------------+-------------------+<br>| mysql_bin_log.000003 |      120 |              |                  |                   |<br>+----------------------+----------+--------------+------------------+-------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>切换二进制日志时，你会看到这些number会不断递增。另外，除了这些二进制日志文件外，你会看到还生成了一个mysql-bin.index的文件，这个文件中存储所有二进制日志文件的清单又称为二进制文件的索引。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@192 ~]# ll /var/lib/mysql/<br><span class="hljs-meta">#</span><span class="bash">源码安装路径是：/usr/<span class="hljs-built_in">local</span>/mysql/data/</span><br>-rw-rw----. 1 mysql mysql      171 4月  10 11:25 mysql_bin_log.000001<br>-rw-rw----. 1 mysql mysql      143 4月  10 11:25 mysql_bin_log.000002<br>-rw-rw----. 1 mysql mysql      143 4月  10 11:25 mysql_bin_log.000003<br>-rw-rw----. 1 mysql mysql       92 4月  10 11:25 mysql_bin_log.index<br><br>[root@192 ~]# cat /var/lib/mysql/mysql_bin_log.index <br>./mysql_bin_log.000001<br>./mysql_bin_log.000002<br>./mysql_bin_log.000003<br></code></pre></td></tr></table></figure><h1>四、查看二进制日志</h1><h2 id="1、查看当前日志">1、查看当前日志</h2><blockquote><p><strong>show binlog events;</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show binlog events;<br>+----------------------+-----+-------------+-----------+-------------+---------------------------------------+<br>| Log_name             | Pos | Event_type  | Server_id | End_log_pos | Info                                  |<br>+----------------------+-----+-------------+-----------+-------------+---------------------------------------+<br>| mysql_bin_log.000001 |   4 | Format_desc |         1 |         120 | Server ver: 5.6.42-log, Binlog ver: 4 |<br>| mysql_bin_log.000001 | 120 | Rotate      |         1 |         171 | mysql_bin_log.000002;pos&#x3D;4            |<br>+----------------------+-----+-------------+-----------+-------------+---------------------------------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="2、查看指定日志">2、查看指定日志</h2><h3 id="（1）模拟产生二进制日志">（1）模拟产生二进制日志</h3><blockquote><p><strong>建库、建表、插入数据</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create database demo;<br>Query OK, 1 row affected (0.00 sec)<br><br>mysql&gt; use demo;<br>Database changed<br><br>mysql&gt; create table student(stuNo int, stuName varchar(25));<br>Query OK, 0 rows affected (0.01 sec)<br><br>mysql&gt; insert into student values(1001,&#39;John&#39;);<br>Query OK, 1 row affected (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（2）查看日志">（2）查看日志</h3><blockquote><p><strong>show binlog events in ‘mysql_bin_log.000002’;</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show binlog events in &#39;mysql_bin_log.000002&#39;;<br>+----------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------+<br>| Log_name             | Pos | Event_type  | Server_id | End_log_pos | Info                                                             |<br>+----------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------+<br>| mysql_bin_log.000002 |   4 | Format_desc |         1 |         120 | Server ver: 5.6.42-log, Binlog ver: 4                            |<br>| mysql_bin_log.000002 | 120 | Query       |         1 |         214 | create database demo                                             |<br>| mysql_bin_log.000002 | 214 | Query       |         1 |         340 | use &#96;demo&#96;; create table student(stuNo int, stuName varchar(25)) |<br>| mysql_bin_log.000002 | 340 | Query       |         1 |         419 | BEGIN                                                            |<br>| mysql_bin_log.000002 | 419 | Query       |         1 |         532 | use &#96;demo&#96;; insert into student values(1001,&#39;John&#39;)              |<br>| mysql_bin_log.000002 | 532 | Xid         |         1 |         563 | COMMIT &#x2F;* xid&#x3D;15 *&#x2F;                                              |<br>+----------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------+<br>6 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><blockquote><p><strong>show binlog events in ‘mysql_bin_log.000002’ from 419;</strong></p><p><strong>查看某个节点</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show binlog events in &#39;mysql_bin_log.000002&#39; from 419;<br>+----------------------+-----+------------+-----------+-------------+-----------------------------------------------------+<br>| Log_name             | Pos | Event_type | Server_id | End_log_pos | Info                                                |<br>+----------------------+-----+------------+-----------+-------------+-----------------------------------------------------+<br>| mysql_bin_log.000002 | 419 | Query      |         1 |         532 | use &#96;demo&#96;; insert into student values(1001,&#39;John&#39;) |<br>| mysql_bin_log.000002 | 532 | Xid        |         1 |         563 | COMMIT &#x2F;* xid&#x3D;15 *&#x2F;                                 |<br>+----------------------+-----+------------+-----------+-------------+-----------------------------------------------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><blockquote><p><strong>show binlog events in ‘mysql_bin_log.000002’ from 419 limit 1;</strong></p><p><strong>查看从419开始的一条数据</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show binlog events in &#39;mysql_bin_log.000002&#39; from 419 limit 1;<br>+----------------------+-----+------------+-----------+-------------+-----------------------------------------------------+<br>| Log_name             | Pos | Event_type | Server_id | End_log_pos | Info                                                |<br>+----------------------+-----+------------+-----------+-------------+-----------------------------------------------------+<br>| mysql_bin_log.000002 | 419 | Query      |         1 |         532 | use &#96;demo&#96;; insert into student values(1001,&#39;John&#39;) |<br>+----------------------+-----+------------+-----------+-------------+-----------------------------------------------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; show binlog events in &#39;mysql_bin_log.000002&#39; from 419 limit 2;<br>+----------------------+-----+------------+-----------+-------------+-----------------------------------------------------+<br>| Log_name             | Pos | Event_type | Server_id | End_log_pos | Info                                                |<br>+----------------------+-----+------------+-----------+-------------+-----------------------------------------------------+<br>| mysql_bin_log.000002 | 419 | Query      |         1 |         532 | use &#96;demo&#96;; insert into student values(1001,&#39;John&#39;) |<br>| mysql_bin_log.000002 | 532 | Xid        |         1 |         563 | COMMIT &#x2F;* xid&#x3D;15 *&#x2F;                                 |<br>+----------------------+-----+------------+-----------+-------------+-----------------------------------------------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h1>五、使用二进制日志恢复数据库</h1><p><strong>如果开启了二进制日志，出现了数据丢失，可以通过二进制日志恢复数据库，语法如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqlbinlog [option] filename | mysql -u user -p passwd<br></code></pre></td></tr></table></figure><p><strong>option的参数主要有两个 <code>--start-datetime</code> <code>--stop-datetime</code> 和 <code>start-position</code> <code>--stop-position</code> ,前者指定恢复的时间点，后者指定恢复的位置（位置指的是二进制文件中 # at 580 580就是位置），原理就是把记录的语句重新执行了一次。如果恢复了两次。会产生重复数据。</strong></p><h2 id="1、按时间点恢复数据">1、按时间点恢复数据</h2><h3 id="（1）从日志开头截止到某个时间点的恢复">（1）从日志开头截止到某个时间点的恢复</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqlbinlog [--no-defaults] --stop-datetime&#x3D;’年-月-日 小时:分钟:秒’ 二进制日志 | mysql -u 用户名 -p<br></code></pre></td></tr></table></figure><p><strong>例如：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqlbinlog [--no-defaults] --stop-datetime=’2020-03-18 10:30:26’ /var/lib/mysql/mysql_bin_log.000005 | mysql -uroot -p<br></code></pre></td></tr></table></figure><h3 id="（2）从某个时间点到日志结尾的恢复">（2）从某个时间点到日志结尾的恢复</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqlbinlog [--no-defaults] --start-datetime&#x3D;’年-月-日 小时:分钟:秒’ 二进制日志 | mysql -u 用户名 -p<br></code></pre></td></tr></table></figure><p><strong>例如：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqlbinlog [--no-defaults] --start-datetime=’2020-01-10 8:20:20’ /var/lib/mysql/mysql_bin_log.000005 | mysql -uroot -p<br></code></pre></td></tr></table></figure><h3 id="（3）从某个时间点到某个时间点的恢复">（3）从某个时间点到某个时间点的恢复</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqlbinlog [--no-defaults] --start-datetime&#x3D;’年-月-日 小时:分钟:秒’ --stop-datetime&#x3D;’年-月-日小时:分钟:秒’ 二进制日志 | mysql -u 用户名 -p<br></code></pre></td></tr></table></figure><p><strong>例如：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqlbinlog [--no-defaults] --start-datetime=’2010-11-10 8:20:20’ --stop-datetime=’2020-03-18 10:30:26’ /var/lib/mysql/mysql_bin_log.000005 | mysql -uroot -p<br></code></pre></td></tr></table></figure><h2 id="2、按位置恢复数据">2、按位置恢复数据</h2><h3 id="（1）从某个位置到日志结尾的恢复">（1）从某个位置到日志结尾的恢复</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/local/mysql/bin/mysqlbinlog --start-position='275' /var/lib/mysql/mysql_bin_log.000005 | mysql -uroot -p<br>Enter password: <br>[root@bogon ~]#<br></code></pre></td></tr></table></figure><h3 id="（2）从日志开头位置到日志结尾的恢复">（2）从日志开头位置到日志结尾的恢复</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/local/mysql/bin/mysqlbinlog --stop-position='465' /var/lib/mysql/mysql_bin_log.000005 | mysql -uroot -p<br>Enter password: <br>[root@bogon ~]#<br></code></pre></td></tr></table></figure><h3 id="（3）从某个位置到某个位置的恢复">（3）从某个位置到某个位置的恢复</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/local/mysql/bin/mysqlbinlog --start-position='4' --stop-position='120' /var/lib/mysql/mysql_bin_log.000005 | mysql -uroot -p<br>Enter password: <br>[root@bogon ~]#<br></code></pre></td></tr></table></figure><p><strong>例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; drop database demo;<br>Query OK, 1 row affected (0.00 sec)<br><br>mysql&gt; show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>+--------------------+<br>4 rows in set (0.00 sec)<br><br>[root@192 ~]# &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqlbinlog --start-position&#x3D;&#39;4&#39; --stop-position&#x3D;&#39;313&#39; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;mysql_bin_log.000002 | mysql -uroot -p<br><br>mysql&gt; show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| demo               |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>+--------------------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h1>六、删除二进制日志</h1><h2 id="1、删除某个日志之前的所有二进制日志文件">1、删除某个日志之前的所有二进制日志文件</h2><p><strong><code>purge binary logs to xxx;</code> 表示删除某个日志之前的所有二进制日志文件，这个命令会修改index中相关数据。</strong></p><p><strong>如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show master logs;<br>+----------------------+-----------+<br>| Log_name             | File_size |<br>+----------------------+-----------+<br>| mysql_bin_log.000001 |       143 |<br>| mysql_bin_log.000002 |       586 |<br>| mysql_bin_log.000003 |       171 |<br>| mysql_bin_log.000004 |       171 |<br>| mysql_bin_log.000005 |       120 |<br>+----------------------+-----------+<br>5 rows in set (0.00 sec)<br><br>mysql&gt; purge binary logs to &#39;mysql_bin_log.000002&#39;;<br>Query OK, 0 rows affected (0.03 sec)<br><br>mysql&gt; show master logs;<br>+----------------------+-----------+<br>| Log_name             | File_size |<br>+----------------------+-----------+<br>| mysql_bin_log.000002 |       586 |<br>| mysql_bin_log.000003 |       171 |<br>| mysql_bin_log.000004 |       171 |<br>| mysql_bin_log.000005 |       120 |<br>+----------------------+-----------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>查看日志清单：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@192 ~]# cat /var/lib/mysql/mysql_bin_log.index <br>./mysql_bin_log.000002<br>./mysql_bin_log.000003<br>./mysql_bin_log.000004<br>./mysql_bin_log.000005<br></code></pre></td></tr></table></figure><h2 id="2、清除某个时间点以前的二进制日志文件">2、清除某个时间点以前的二进制日志文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; purge binary logs before &#39;2020-03-10 10:10:00&#39;;<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="3、清除7天前的二进制日志文件">3、清除7天前的二进制日志文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; purge master logs before date_sub( now( ), interval 7 day);<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="4、清除所有的二进制日志文件（当前不存在主从复制关系）">4、清除所有的二进制日志文件（当前不存在主从复制关系）</h2><p><strong>reset之后，从000001开始生成全新空日志。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show master logs;<br>+----------------------+-----------+<br>| Log_name             | File_size |<br>+----------------------+-----------+<br>| mysql_bin_log.000002 |       586 |<br>| mysql_bin_log.000003 |       171 |<br>| mysql_bin_log.000004 |       171 |<br>| mysql_bin_log.000005 |       120 |<br>+----------------------+-----------+<br>4 rows in set (0.00 sec)<br><br>mysql&gt; reset master;<br>Query OK, 0 rows affected (0.01 sec)<br><br>mysql&gt; show master logs;<br>+----------------------+-----------+<br>| Log_name             | File_size |<br>+----------------------+-----------+<br>| mysql_bin_log.000001 |       120 |<br>+----------------------+-----------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="5、自动清理二进制日志文件">5、自动清理二进制日志文件</h2><p><strong>另外，我们也可以设置expire_logs_days参数，设置自动清理，其默认值为0,表示不启用过期自动删除功能，如果启用了自动清理功能，表示超出此天数的二进制日志文件将被自动删除，自动删除工作通常发生在MySQL启动时或flush日志时。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#39;expire_logs_days&#39;;<br>+------------------+-------+<br>| Variable_name    | Value |<br>+------------------+-------+<br>| expire_logs_days | 10    |<br>+------------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h1>七、停止二进制日志</h1><p><strong>可以通过修改配置文件停止二进制日志功能，但是需要重启数据库，mysql提供了语句可以在线停止二进制功能。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">set sql_log_bin &#x3D; 0       # 停止二进制日志功能<br>set sql_log_bin &#x3D; 1       # 开启二进制日志功能<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;一、什么是二进制日志&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;MySQL的二进制日志（binary log）是一个二进制文件，主要用于记录修改数据或有可能引起数据变更的MySQL语句。二进制日志（binary log）中记录了对MySQL数据库执行更改的所有操作，并且记录了语句发
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://wsdlxgp.top/categories/mysql/"/>
    
    
      <category term="sql结构化查询语句" scheme="https://wsdlxgp.top/tags/sql%E7%BB%93%E6%9E%84%E5%8C%96%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"/>
    
      <category term="数值类型" scheme="https://wsdlxgp.top/tags/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>mysql日志</title>
    <link href="https://wsdlxgp.top/posts/b6d.html"/>
    <id>https://wsdlxgp.top/posts/b6d.html</id>
    <published>2020-06-16T16:00:00.000Z</published>
    <updated>2020-06-19T05:16:11.919Z</updated>
    
    <content type="html"><![CDATA[<h1>mysql日志</h1><p><strong>MySQL日志记录了MySQL数据库日常操作和错误信息。MySQL有不同类型的日志文件（各自存储了不同类型的日志），从日志当中可以查询到MySQL数据库的运行情况、用户的操作、错误的信息等。</strong></p><h2 id="A：MySQL日志分为4大类">A：MySQL日志分为4大类</h2><ul><li><strong>错误日志：记录mysql服务的启动，运行或停止mysql服务时出现的问题</strong></li><li><strong>查询日志：记录建立的客户端的连接和执行的语句</strong></li><li><strong>二进制日志：记录所有更改数据的语句，可以用于数据的复制</strong></li><li><strong>慢查询日志：记录所有执行的时间超过long_query_time的所有查询或不使用索引的查询</strong></li></ul><p><strong>默认情况下，所有日志创建与MySQL数据目录中，通过刷新日志，可以强制MySQL关闭和重新打开日志文件，Flush logs刷新日志或者执行mysqladmin flush-logs 如果正使用MySQL复制功能，在复制服务器上可以维护更多日志文件，这种日志我们称为接替日志。启动日志功能会降低MySQL数据库的性能。</strong></p><h2 id="B：错误日志：Error-Log">B：错误日志：Error Log</h2><p><strong>在mysql数据库中，错误日志功能是默认开启的。默认情况下，错误日志存储在mysql数据库的数据目录中。错误日志文件通常的名称为hostname.err。其中，hostname表示服务器主机名。 错误日志信息可以自己进行配置的，错误日志所记录的信息是可以通过log-error和log-warnings来定义的，其中log-error是定义是否启用错误日志的功能和错误日志的存储位置，log-warnings是定义是否将警告信息也定义至错误日志中。默认情况下错误日志大概记录以下几个方面的信息：服务器启动和关闭过程中的信息（未必是错误信息，如mysql如何启动InnoDB的表空间文件的、如何初始化自己的存储引擎的等等）、服务器运行过程中的错误信息、事件调度器运行一个事件时产生的信息、在从服务器上启动服务器进程时产生的信息 注1：MySQL有很多系统变量可以设置，系统变量设置不同，会导致系统运行状态的不同。因此mysql提供两组命令，分别查看系统设置和运行状态。</strong></p><h2 id="C：MySQL日志缓存">C：MySQL日志缓存</h2><p><strong>一个高速、稳定、可靠的系统，缓存在其中必定起着至关重要的作用。MySQL日志处理也使用了缓存机制。MySQL日志最初存放在MySQL服务器的内存中，若超过指定的存储容量，内存中的日志则写（或者刷新flush）到外存中，以数据库表或者以文件的方式永远的保存在硬盘中。</strong></p><h3 id="1、查看系统设置：">1、查看系统设置：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW [GLOBAL | SESSION] VARIABLES [like_or_where] SHOW VARIABLES： shows the values of MySQL system variables.<br></code></pre></td></tr></table></figure><h3 id="2、运行状态：">2、运行状态：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW [GLOBAL | SESSION] STATUS [like_or_where] SHOW STATUS： provides server status information.<br></code></pre></td></tr></table></figure><h2 id="D：如何修改系统配置">D：如何修改系统配置</h2><h3 id="方法1：配置文件设置my-cnf-如：binlog-cache-size-1M">方法1：配置文件设置my.cnf 如：binlog_cache_size = 1M</h3><h3 id="方法2：set-global-binlog-cache-size-1048576-注">方法2：set global binlog_cache_size = 1048576; 注</h3><h3 id="2：查看mysql的版本">2：查看mysql的版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@localhost ~]# mysql -V<br>mysql Ver 14.14 Distrib 5.7.28, for Linux (x86_64) using EditLine wrapper<br></code></pre></td></tr></table></figure><p><strong>或</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; status;<br>--------------<br>mysql Ver 14.14 Distrib 5.7.28, for Linux (x86_64) using EditLine wrapper<br>Connection id: 5<br>Current database:<br>Current user: root@localhost<br>SSL: Not in use<br>Current pager: stdout<br>Using outfile: &#39;&#39;<br>Using delimiter: ;<br>Server version: 5.7.28 Source distribution<br>Protocol version: 10<br>Connection: Localhost via UNIX socket<br>Server characterset: utf8<br>Db characterset: utf8<br>Client characterset: utf8<br>Conn. characterset: utf8<br>UNIX socket: &#x2F;tmp&#x2F;mysql.sock<br>Uptime: 1 hour 12 min 8 sec<br>Threads: 1 Questions: 10 Slow queries: 0 Opens: 106 Flush tables: 1 Open<br>tables: 99 Queries per second avg: 0.002<br>--------------<br></code></pre></td></tr></table></figure><p><strong>或</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select version();<br>+-----------+<br>| version() |<br>+-----------+<br>| 5.7.28 |<br>+-----------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="E-一般而言，日志级别的定义没有会话变量都只是在全局级别下进行定义-错误日志的状态：">E: 一般而言，日志级别的定义没有会话变量都只是在全局级别下进行定义 错误日志的状态：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show global variables like &#39;%log_error%&#39;;<br>+---------------------+---------------------------------+<br>| Variable_name | Value |<br>+---------------------+---------------------------------+<br>| binlog_error_action | ABORT_SERVER |<br>| log_error | &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;mysql.err |<br>| log_error_verbosity | 3 |<br>+---------------------+---------------------------------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>其中 log_error定义为错误日志文件路径 log_error_verbosity:</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200616171633354.png" alt="image-20200616171633354"></p><p><strong>更改错误日志位置可以使用log-error来设置形式如下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">\#vi /etc/my.cnf<br>log-error = /usr/local/mysql/data/mysqld.err<br></code></pre></td></tr></table></figure><p><strong>查看mysql错误日志：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">tail /usr/<span class="hljs-built_in">local</span>/mysql/data/mysqld.err</span><br></code></pre></td></tr></table></figure><p><strong>为了方便维护需要，有时候会希望将错误日志中的内容做备份并重新开始记录，这时候就可以利用MySQL 的FLUSH LOGS 命令来告诉MySQL 备份旧日志文件并生成新的日志文件。备份文件名以“.old”结尾。 删除错误日志： 在mysql5.5.7之前：数据库管理员可以删除很长时间之前的错误日志，以保证mysql服务器上的硬盘空间。mysql数据库中，可以使用mysqladmin命令开启新的错误日志。mysqladmin命令的语法如下：mysqladmin –u root –p flush-logs也可以登录mysql数据库中使用FLUSH LOGS语句来开启新的错误日志。 在mysql5.5.7之后：服务器将关闭此项功能。只能使用重命名原来的错误日志文件，手动冲洗日志创建一个新的：方式如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">\# mv mysql.err mysql.old<br>\# mysqladmin -uroot -p flush-logs<br>Enter password:<br></code></pre></td></tr></table></figure><h2 id="F：-二进制日志">F： 二进制日志</h2><p><strong>主要记录MySQL数据库的变化，二进制日志以一种有效的格式，并且是事务安全的方式包含更新日志中可用的信息。二进制日志包含了所有更新了数据或者已经潜在更新了数据。二进制日志还包含关于每个更新数据库的语句的执行时间，它不包含没有修改任何数据的语句。使用二进制日志的主要目的是最大可能地恢复数据库。</strong></p><p><strong>启动二进制日志，默认情况下二进制日志是关闭的 编辑配置文件My.ini 或my.cnf</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@localhost ~]# vim &#x2F;etc&#x2F;my.cnf<br>【格式】：<br>[mysqld]<br>log-bin<br>expire_logs_days &#x3D; 10<br>max_binlog_size &#x3D; 100M<br>log-bin [&#x3D;path&#x2F;[filename]] &#x2F;&#x2F;二进制日志[路径[指定日志文件的名字<br>Expire_logs_days &#x3D; 10 &#x2F;&#x2F;清除日志的天数<br>Max_binlog_size &#x3D; 100M &#x2F;&#x2F;单个日志文件的大小限制，超出会新建一个<br>默认为1GB<br>【重启mysql】<br></code></pre></td></tr></table></figure><p><strong><code>Show variables</code> 或<code>show variables like 'log_%';</code> 语句来查询日志设置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br>mysql&gt; show variables like &#39;log_%&#39;;<br>+---------------------------------+-----------------------------------------------<br>--+<br>| Variable_name | Value<br>|<br>+---------------------------------+-----------------------------------------------<br>--+<br>| log_bin | ON<br>|<br>| log_bin_trust_function_creators | OFF<br>|<br>| log_error |<br>&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;localhost.localdomain.err |<br>| log_output | FILE<br>|<br>| log_queries_not_using_indexes | OFF<br>|<br>| log_slave_updates | OFF<br>|<br>| log_slow_queries | OFF<br>|<br>| log_warnings | 1<br>|<br>+---------------------------------+-----------------------------------------------<br>--+<br>8 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="【查看二进制日志】">【查看二进制日志】</h3><p><strong>MySQL二进制日志存储了所有的变更信息，MySQL二进制日志经常使用。当MySQL创建二进制日志文件时，首先创建一个以’filename’为名称，以’.index’为后缀的文件；在创建一个以’filename’为名称，以’.000001’为后缀的文件。当MySQL服务重启一次，以’.000001’为后缀的文件会增加一个，并且后缀名加1递增。如果日志长度超过max_binlog_size的上限，也会创建一个新的日志。 Show binary logs;可以查看当前的二进制日志文件个数及其文件名。二进制日志并不能直接查看，如果想要查看日志内容，可以通过mysqlbinlog命令查看</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW BINARY LOGS;<br>+------------------+-----------+<br>| Log_name | File_size |<br>+------------------+-----------+<br>| mysql-bin.000001 | 2189 |<br>| mysql-bin.000002 | 107 |<br>+------------------+-----------+<br>2 rows in set (0.06 sec)<br></code></pre></td></tr></table></figure><h3 id="【查看二进制日志的内容】-退出mysql在命令行">【查看二进制日志的内容】 退出mysql在命令行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@localhost data]# mysqlbinlog mysql-bin.000001<br>&#x2F;*!40019 SET @@session.max_insert_delayed_threads&#x3D;0*&#x2F;;<br>&#x2F;*!50003 SET @OLD_COMPLETION_TYPE&#x3D;@@COMPLETION_TYPE,COMPLETION_TYPE&#x3D;0*&#x2F;;<br>DELIMITER &#x2F;*!*&#x2F;;<br># at 4<br>#170826 11:40:02 server id 1 end_log_pos 107 Start: binlog v 4, server v<br>5.5.22-log created 170826 11:40:02 at startup<br>ROLLBACK&#x2F;*!*&#x2F;;<br>BINLOG &#39;<br>... ... 省略<br></code></pre></td></tr></table></figure><h3 id="【删除二进制日志】">【删除二进制日志】</h3><p><strong>MySQL的二进制文件可以配置自动删除，同时MySQL提供了手动删除二进制文件的方法RESET MASTER 删除所有的二进制日志文件；PURGE MASTER LOGS只删除部分二进制日志文件。 Reset master; 删除所有二进制日志 Purge master logs to ‘二进制名’ 删除单个二进制日志之前的</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; PURGE MASTER LOGS TO &quot;mysql-bin.000012&quot;;<br>Query OK, 0 rows affected (0.02 sec)<br>Purge binary logs before ‘date’ 删除指定日期之前的日志<br>mysql&gt; PURGE MASTER LOGS BEFORE &#39;20170101&#39;;<br>Query OK, 0 rows affected (0.07 sec)<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;mysql日志&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;MySQL日志记录了MySQL数据库日常操作和错误信息。MySQL有不同类型的日志文件（各自存储了不同类型的日志），从日志当中可以查询到MySQL数据库的运行情况、用户的操作、错误的信息等。&lt;/strong&gt;&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://wsdlxgp.top/categories/mysql/"/>
    
    
      <category term="sql结构化查询语句" scheme="https://wsdlxgp.top/tags/sql%E7%BB%93%E6%9E%84%E5%8C%96%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"/>
    
      <category term="数值类型" scheme="https://wsdlxgp.top/tags/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL创建触发器</title>
    <link href="https://wsdlxgp.top/posts/184.html"/>
    <id>https://wsdlxgp.top/posts/184.html</id>
    <published>2020-06-15T16:00:00.000Z</published>
    <updated>2020-06-19T05:16:02.473Z</updated>
    
    <content type="html"><![CDATA[<h1>一、MySQL创建触发器（CREATE TRIGGER）</h1><h2 id="基本语法">基本语法</h2><p><strong>在 MySQL 5.7 中，可以使用 CREATE TRIGGER 语句创建触发器。</strong></p><h4 id="语法格式如下：">语法格式如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE &lt;触发器名&gt; &lt; BEFORE | AFTER &gt;<br>&lt;INSERT | UPDATE | DELETE &gt;<br>ON &lt;表名&gt; FOR EACH Row&lt;触发器主体&gt;<br></code></pre></td></tr></table></figure><h2 id="语法说明如下。">语法说明如下。</h2><h3 id="1-触发器名">1) 触发器名</h3><p><strong>触发器的名称，触发器在当前数据库中必须具有唯一的名称。如果要在某个特定数据库中创建，名称前面应该加上数据库的名称。</strong></p><h3 id="2-INSERT-UPDATE-DELETE">2) INSERT | UPDATE | DELETE</h3><p><strong>触发事件，用于指定激活触发器的语句的种类。</strong></p><p><strong>注意：三种触发器的执行时间如下。</strong></p><ul><li><strong>INSERT：将新行插入表时激活触发器。例如，INSERT 的 BEFORE 触发器不仅能被 MySQL 的 INSERT 语句激活，也能被 LOAD DATA 语句激活。</strong></li><li><strong>DELETE： 从表中删除某一行数据时激活触发器，例如 DELETE 和 REPLACE 语句。</strong></li><li><strong>UPDATE：更改表中某一行数据时激活触发器，例如 UPDATE 语句。</strong></li></ul><h3 id="3-BEFORE-AFTER">3) BEFORE | AFTER</h3><p><strong>BEFORE 和 AFTER，触发器被触发的时刻，表示触发器是在激活它的语句之前或之后触发。若希望验证新数据是否满足条件，则使用 BEFORE 选项；若希望在激活触发器的语句执行之后完成几个或更多的改变，则通常使用 AFTER 选项。</strong></p><h3 id="4-表名">4) 表名</h3><p><strong>与触发器相关联的表名，此表必须是永久性表，不能将触发器与临时表或视图关联起来。在该表上触发事件发生时才会激活触发器。同一个表不能拥有两个具有相同触发时刻和事件的触发器。例如，对于一张数据表，不能同时有两个 BEFORE UPDATE 触发器，但可以有一个 BEFORE UPDATE 触发器和一个 BEFORE INSERT 触发器，或一个 BEFORE UPDATE 触发器和一个 AFTER UPDATE 触发器。</strong></p><h3 id="5-触发器主体">5) 触发器主体</h3><p><strong>触发器动作主体，包含触发器激活时将要执行的 MySQL 语句。如果要执行多个语句，可使用 BEGIN…END 复合语句结构。</strong></p><h3 id="6-FOR-EACH-ROW">6) FOR EACH ROW</h3><p><strong>一般是指行级触发，对于受触发事件影响的每一行都要激活触发器的动作。例如，使用 INSERT 语句向某个表中插入多行数据时，触发器会对每一行数据的插入都执行相应的触发器动作。</strong></p><blockquote><p><strong>注意：每个表都支持 INSERT、UPDATE 和 DELETE 的 BEFORE 与 AFTER，因此每个表最多支持 6 个触发器。每个表的每个事件每次只允许有一个触发器。单一触发器不能与多个事件或多个表关联。</strong></p></blockquote><p><strong>另外，在 MySQL 中，若需要查看数据库中已有的触发器，则可以使用 SHOW TRIGGERS 语句。</strong></p><h1>二、创建 BEFORE 类型触发器</h1><p><strong>在 test_db 数据库中，数据表 tb_emp8 为员工信息表，包含 id、name、deptId 和 salary 字段，数据表 tb_emp8 的表结构如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table tb_emp8(<br>    -&gt; id int(11) not null PRIMARY KEY,<br>    -&gt; name VARCHAR(22) UNIQUE,<br>    -&gt; deptId int(11) not null,<br>    -&gt; salary FLOAT DEFAULT 0<br>    -&gt; )charset &#x3D; &#39;utf8mb4&#39;;<br>Query OK, 0 rows affected (0.01 sec)<br><br>mysql&gt; SELECT * FROM tb_emp8;<br>Empty set (0.07 sec)<br>mysql&gt; DESC tb_emp8;<br>+--------+-------------+------+-----+---------+-------+<br>| Field  | Type        | Null | Key | Default | Extra |<br>+--------+-------------+------+-----+---------+-------+<br>| id     | int(11)     | NO   | PRI | NULL    |       |<br>| name   | varchar(22) | YES  | UNI | NULL    |       |<br>| deptId | int(11)     | NO   | MUL | NULL    |       |<br>| salary | float       | YES  |     | 0       |       |<br>+--------+-------------+------+-----+---------+-------+<br>4 rows in set (0.05 sec)<br></code></pre></td></tr></table></figure><h3 id="【实例-1】">【实例 1】</h3><p><strong>创建一个名为 SumOfSalary 的触发器，触发的条件是向数据表 tb_emp8 中插入数据之前，对新插入的 salary 字段值进行求和计算。输入的 SQL 语句和执行过程如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建触发器<br>create TRIGGER SumOfSalary<br>before insert on tb_emp8<br>for each ROW<br>set @sum&#x3D;@sum+NEW.salary;<br></code></pre></td></tr></table></figure><p><strong>触发器 SumOfSalary 创建完成之后，向表 tb_emp8 中插入记录时，定义的 sum 值由 0 变成了 1500，即插入值 1000 和 500 的和，如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET @sum&#x3D;0;<br>Query OK, 0 rows affected (0.05 sec)<br><br>#插入数据，会自动调用触发器会自动调用触发器<br>mysql&gt; INSERT INTO tb_emp8<br>    -&gt; VALUES(1,&#39;A&#39;,1,1000),(2,&#39;B&#39;,1,500);<br>Query OK, 2 rows affected (0.09 sec)<br>Records: 2  Duplicates: 0  Warnings: 0<br>mysql&gt; SELECT @sum;<br>+------+<br>| @sum |<br>+------+<br>| 1500 |<br>+------+<br>1 row in set (0.03 sec)<br></code></pre></td></tr></table></figure><h1>三、创建 AFTER 类型触发器</h1><p><strong>在 test_db 数据库中，数据表 tb_emp6 和 tb_emp7 都为员工信息表，包含 id、name、deptId 和 salary 字段，数据表 tb_emp6 和 tb_emp7 的表结构如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM tb_emp6;<br>Empty set (0.07 sec)<br>mysql&gt; SELECT * FROM tb_emp7;<br>Empty set (0.03 sec)<br>mysql&gt; DESC tb_emp6;<br>+--------+-------------+------+-----+---------+-------+<br>| Field  | Type        | Null | Key | Default | Extra |<br>+--------+-------------+------+-----+---------+-------+<br>| id     | int(11)     | NO   | PRI | NULL    |       |<br>| name   | varchar(25) | YES  |     | NULL    |       |<br>| deptId | int(11)     | YES  | MUL | NULL    |       |<br>| salary | float       | YES  |     | NULL    |       |<br>+--------+-------------+------+-----+---------+-------+<br>4 rows in set (0.00 sec)<br>mysql&gt; DESC tb_emp7;<br>+--------+-------------+------+-----+---------+-------+<br>| Field  | Type        | Null | Key | Default | Extra |<br>+--------+-------------+------+-----+---------+-------+<br>| id     | int(11)     | NO   | PRI | NULL    |       |<br>| name   | varchar(25) | YES  |     | NULL    |       |<br>| deptId | int(11)     | YES  |     | NULL    |       |<br>| salary | float       | YES  |     | 0       |       |<br>+--------+-------------+------+-----+---------+-------+<br>4 rows in set (0.04 sec)<br></code></pre></td></tr></table></figure><h3 id="【实例-2】">【实例 2】</h3><p><strong>创建一个名为 double_salary 的触发器，触发的条件是向数据表 tb_emp6 中插入数据之后，再向数据表 tb_emp7 中插入相同的数据，并且 salary 为 tb_emp6 中新插入的 salary 字段值的 2 倍。输入的 SQL 语句和执行过程如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE TRIGGER double_salary<br>    -&gt; AFTER INSERT ON tb_emp6<br>    -&gt; FOR EACH ROW<br>    -&gt; INSERT INTO tb_emp7<br>    -&gt; VALUES (NEW.id,NEW.name,deptId,2*NEW.salary);<br>Query OK, 0 rows affected (0.25 sec)<br></code></pre></td></tr></table></figure><p><strong>触发器 double_salary 创建完成之后，向表 tb_emp6 中插入记录时，同时向表 tb_emp7 中插入相同的记录，并且 salary 字段为 tb_emp6 中 salary 字段值的 2 倍，如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 插入后触发<br>mysql&gt; INSERT INTO tb_emp6<br>    -&gt; VALUES (1,&#39;A&#39;,1,1000),(2,&#39;B&#39;,1,500);<br>Query OK, 2 rows affected (0.09 sec)<br>Records: 2  Duplicates: 0  Warnings: 0<br><br>mysql&gt; SELECT * FROM tb_emp6;<br>+----+------+--------+--------+<br>| id | name | deptId | salary |<br>+----+------+--------+--------+<br>|  1 | A    |      1 |   1000 |<br>|  2 | B    |      1 |    500 |<br>+----+------+--------+--------+<br>3 rows in set (0.04 sec)<br><br>mysql&gt; SELECT * FROM tb_emp7;<br>+----+------+--------+--------+<br>| id | name | deptId | salary |<br>+----+------+--------+--------+<br>|  1 | A    |      1 |   2000 |<br>|  2 | B    |      1 |   1000 |<br>+----+------+--------+--------+<br>2 rows in set (0.06 sec)<br><br>#删除触发器<br>drop trigger double_salary;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;一、MySQL创建触发器（CREATE TRIGGER）&lt;/h1&gt;
&lt;h2 id=&quot;基本语法&quot;&gt;基本语法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;在 MySQL 5.7 中，可以使用 CREATE TRIGGER 语句创建触发器。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;语法格
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://wsdlxgp.top/categories/mysql/"/>
    
    
      <category term="sql结构化查询语句" scheme="https://wsdlxgp.top/tags/sql%E7%BB%93%E6%9E%84%E5%8C%96%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"/>
    
      <category term="数值类型" scheme="https://wsdlxgp.top/tags/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL触发器</title>
    <link href="https://wsdlxgp.top/posts/f9da.html"/>
    <id>https://wsdlxgp.top/posts/f9da.html</id>
    <published>2020-06-14T16:00:00.000Z</published>
    <updated>2020-06-19T05:15:55.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A：MySQL触发器到底是什么？">A：MySQL触发器到底是什么？</h2><p><strong>MySQL 的触发器和存储过程一样，都是嵌入到 MySQL 中的一段程序，是 MySQL 中管理数据的有力工具。不同的是执行存储过程要使用 CALL 语句来调用，而触发器的执行不需要使用 CALL 语句来调用，也不需要手工启动，而是通过对数据表的相关操作来触发、激活从而实现执行。比如当对 student 表进行操作（INSERT，DELETE 或 UPDATE）时就会激活它执行。</strong></p><p><strong>触发器与数据表关系密切，主要用于保护表中的数据。特别是当有多个表具有一定的相互联系的时候，触发器能够让不同的表保持数据的一致性。</strong></p><p><strong>在 MySQL 中，只有执行 INSERT、UPDATE 和 DELETE 操作时才能激活触发器，其它 SQL 语句则不会激活触发器。</strong></p><h4 id="那么为什么要使用触发器呢？比如，在实际开发项目时，我们经常会遇到以下情况：">那么为什么要使用触发器呢？比如，在实际开发项目时，我们经常会遇到以下情况：</h4><ul><li><strong>在学生表中添加一条关于学生的记录时，学生的总数就必须同时改变。</strong></li><li><strong>增加一条学生记录时，需要检查年龄是否符合范围要求。</strong></li><li><strong>删除一条学生信息时，需要删除其成绩表上的对应记录。</strong></li><li><strong>删除一条数据时，需要在数据库存档表中保留一个备份副本。</strong></li></ul><p><strong>虽然上述情况实现的业务逻辑不同，但是它们都需要在数据表发生更改时，自动进行一些处理。这时就可以使用触发器处理。例如，对于第一种情况，可以创建一个触发器对象，每当添加一条学生记录时，就执行一次计算学生总数的操作，这样就可以保证每次添加一条学生记录后，学生总数和学生记录数是一致的。</strong></p><h2 id="B-触发器的优缺点">B: 触发器的优缺点</h2><h3 id="触发器的优点如下：">触发器的优点如下：</h3><ul><li><strong>触发器的执行是自动的，当对触发器相关表的数据做出相应的修改后立即执行。</strong></li><li><strong>触发器可以实施比 FOREIGN KEY 约束、CHECK 约束更为复杂的检查和操作。</strong></li><li><strong>触发器可以实现表数据的级联更改，在一定程度上保证了数据的完整性。</strong></li></ul><h3 id="触发器的缺点如下：">触发器的缺点如下：</h3><ul><li><strong>使用触发器实现的业务逻辑在出现问题时很难进行定位，特别是涉及到多个触发器的情况下，会使后期维护变得困难。</strong></li><li><strong>大量使用触发器容易导致代码结构被打乱，增加了程序的复杂性，</strong></li><li><strong>如果需要变动的数据量较大时，触发器的执行效率会非常低。</strong></li></ul><h2 id="C：MySQL-支持的触发器">C：MySQL 支持的触发器</h2><p><strong>在实际使用中，MySQL 所支持的触发器有三种：INSERT 触发器、UPDATE 触发器和 DELETE 触发器。</strong></p><h3 id="1-INSERT-触发器">1) INSERT 触发器</h3><p><strong>在 INSERT 语句执行之前或之后响应的触发器。</strong></p><p><strong>使用 INSERT 触发器需要注意以下几点：</strong></p><ul><li><strong>在 INSERT 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问被插入的行。</strong></li><li><strong>在 BEFORE INSERT 触发器中，NEW 中的值也可以被更新，即允许更改被插入的值（只要具有对应的操作权限）。</strong></li><li><strong>对于 AUTO_INCREMENT 列，NEW 在 INSERT 执行之前包含的值是 0，在 INSERT 执行之后将包含新的自动生成值。</strong></li></ul><h4 id="2-UPDATE-触发器">2) UPDATE 触发器</h4><p><strong>在 UPDATE 语句执行之前或之后响应的触发器。</strong></p><p><strong>使用 UPDATE 触发器需要注意以下几点：</strong></p><ul><li><strong>在 UPDATE 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问更新的值。</strong></li><li><strong>在 UPDATE 触发器代码内，可引用一个名为 OLD（不区分大小写）的虚拟表来访问 UPDATE 语句执行前的值。</strong></li><li><strong>在 BEFORE UPDATE 触发器中，NEW 中的值可能也被更新，即允许更改将要用于 UPDATE 语句中的值（只要具有对应的操作权限）。</strong></li><li><strong>OLD 中的值全部是只读的，不能被更新。</strong></li></ul><p><em><strong>注意：当触发器设计对触发表自身的更新操作时，只能使用 BEFORE 类型的触发器，AFTER 类型的触发器将不被允许。</strong></em></p><h4 id="3-DELETE-触发器">3) DELETE 触发器</h4><p><strong>在 DELETE 语句执行之前或之后响应的触发器。</strong></p><p><strong>使用 DELETE 触发器需要注意以下几点：</strong></p><ul><li><strong>在 DELETE 触发器代码内，可以引用一个名为 OLD（不区分大小写）的虚拟表来访问被删除的行。</strong></li><li><strong>OLD 中的值全部是只读的，不能被更新。</strong></li></ul><p><strong>总体来说，触发器使用的过程中，MySQL 会按照以下方式来处理错误。</strong></p><p><strong>对于事务性表，如果触发程序失败，以及由此导致的整个语句失败，那么该语句所执行的所有更改将回滚；对于非事务性表，则不能执行此类回滚，即使语句失败，失败之前所做的任何更改依然有效。</strong></p><p><strong>若 BEFORE 触发程序失败，则 MySQL 将不执行相应行上的操作。</strong></p><p><strong>若在 BEFORE 或 AFTER 触发程序的执行过程中出现错误，则将导致调用触发程序的整个语句失败。</strong></p><p><strong>仅当 BEFORE 触发程序和行操作均已被成功执行，MySQL 才会执行 AFTER 触发程序。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;A：MySQL触发器到底是什么？&quot;&gt;A：MySQL触发器到底是什么？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MySQL 的触发器和存储过程一样，都是嵌入到 MySQL 中的一段程序，是 MySQL 中管理数据的有力工具。不同的是执行存储过程要使用 CALL 语句来调用，
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://wsdlxgp.top/categories/mysql/"/>
    
    
      <category term="sql结构化查询语句" scheme="https://wsdlxgp.top/tags/sql%E7%BB%93%E6%9E%84%E5%8C%96%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"/>
    
      <category term="数值类型" scheme="https://wsdlxgp.top/tags/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL创建存储过程</title>
    <link href="https://wsdlxgp.top/posts/bc0b.html"/>
    <id>https://wsdlxgp.top/posts/bc0b.html</id>
    <published>2020-06-13T16:00:00.000Z</published>
    <updated>2020-06-19T05:15:48.608Z</updated>
    
    <content type="html"><![CDATA[<h1>一、MySQL创建存储过程</h1><h2 id="1、基本语法">1、基本语法</h2><p><strong>可以使用 <code>CREATE PROCEDURE</code> 语句创建存储过程。</strong></p><h5 id="语法格式如下：">语法格式如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE &lt;过程名&gt; ( [过程参数[,…] ] ) &lt;过程体&gt;<br>[过程参数[,…] ] 格式<br>[ IN | OUT | INOUT ] &lt;参数名&gt; &lt;类型&gt;<br></code></pre></td></tr></table></figure><h2 id="2、语法说明如下：">2、语法说明如下：</h2><h4 id="1-过程名">1) 过程名</h4><p><strong>存储过程的名称，默认在当前数据库中创建。若需要在特定数据库中创建存储过程，则要在名称前面加上数据库的名称，即 db_name.sp_name。需要注意的是，名称应当尽量避免选取与 MySQL 内置函数相同的名称，否则会发生错误。</strong></p><h4 id="2-过程参数">2) 过程参数</h4><p><strong>存储过程的参数列表。其中，<code>&lt;参数名&gt;</code>为参数名，<code>&lt;类型&gt;</code>为参数的类型（可以是任何有效的 MySQL 数据类型）。当有多个参数时，参数列表中彼此间用逗号分隔。存储过程可以没有参数（此时存储过程的名称后仍需加上一对括号），也可以有 1 个或多个参数。</strong></p><p><strong>MySQL 存储过程支持三种类型的参数，即输入参数、输出参数和输入/输出参数，分别用 IN、OUT 和 INOUT 三个关键字标识。其中，输入参数可以传递给一个存储过程，输出参数用于存储过程需要返回一个操作结果的情形，而输入/输出参数既可以充当输入参数也可以充当输出参数。</strong></p><p><strong>需要注意的是，参数的取名不要与数据表的列名相同，否则尽管不会返回出错信息，但是存储过程的 SQL 语句会将参数名看作列名，从而引发不可预知的结果。</strong></p><h4 id="3-过程体">3) 过程体</h4><p><strong>存储过程的主体部分，也称为存储过程体，包含在过程调用的时候必须执行的 SQL 语句。这个部分以关键字 BEGIN 开始，以关键字 END 结束。若存储过程体中只有一条 SQL 语句，则可以省略 BEGIN-END 标志。</strong></p><p><strong>在存储过程的创建中，经常会用到一个十分重要的 MySQL 命令，即 DELIMITER 命令，特别是对于通过命令行的方式来操作 MySQL 数据库的使用者，更是要学会使用该命令。</strong></p><p><strong>在 MySQL 中，服务器处理 SQL 语句默认是以分号作为语句结束标志的。然而，在创建存储过程时，存储过程体可能包含有多条 SQL 语句，这些 SQL 语句如果仍以分号作为语句结束符，那么 MySQL 服务器在处理时会以遇到的第一条 SQL 语句结尾处的分号作为整个程序的结束符，而不再去处理存储过程体中后面的 SQL 语句，这样显然不行。</strong></p><h3 id="为解决以上问题，通常使用-DELIMITER-命令将结束命令修改为其他字符。语法格式如下：">为解决以上问题，通常使用 <strong>DELIMITER</strong> 命令将结束命令修改为其他字符。语法格式如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER $$<br></code></pre></td></tr></table></figure><h5 id="语法说明如下：">语法说明如下：</h5><ul><li><strong>$$ 是用户定义的结束符，通常这个符号可以是一些特殊的符号，如两个“?”或两个“￥”等。</strong></li><li><strong>当使用 DELIMITER 命令时，应该避免使用反斜杠“\”字符，因为它是 MySQL 的转义字符。</strong></li></ul><p><strong>在 MySQL 命令行客户端输入如下 SQL 语句。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql &gt; DELIMITER ??<br></code></pre></td></tr></table></figure><p><strong>成功执行这条 SQL 语句后，任何命令、语句或程序的结束标志就换为两个问号“??”了。</strong></p><p><strong>若希望换回默认的分号“;”作为结束标志，则在 MySQL 命令行客户端输入下列语句即可：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql &gt; DELIMITER ;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：DELIMITER 和分号“;”之间一定要有一个空格。在创建存储过程时，必须具有 CREATE ROUTINE 权限。可以使用 SHOW PROCEDURE STATUS 命令查看数据库中存在哪些存储过程，若要查看某个存储过程的具体信息，则可以使用 SHOW CREATE PROCEDURE &lt;存储过程名&gt;。</strong></p></blockquote><h2 id="3、创建不带参数的存储过程">3、创建不带参数的存储过程</h2><h3 id="例-1">例 1</h3><p><strong>创建名称为 ShowStuScore 的存储过程，存储过程的作用是从学生成绩信息表中查询学生的成绩信息，输入的 SQL 语句和执行过程如下所示。</strong></p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs delphi">mysql&gt; DELIMITER <span class="hljs-comment">//</span><br>mysql&gt; CREATE <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">ShowStuScore</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    -&gt; <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    -&gt; <span class="hljs-title">SELECT</span> * <span class="hljs-title">FROM</span> <span class="hljs-title">tb_students_score</span>;</span><br>    -&gt; <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br>Query OK， <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.09</span> sec)<br></code></pre></td></tr></table></figure><p><strong>创建存储过程 ShowStuScore 后，通过 CALL 语句调用该存储过程的 SQL 语句和执行结果如下所示。</strong></p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; DELIMITER ;<br>mysql&gt; CALL ShowStuScore();<br>+--------------+---------------+<br>|<span class="hljs-string"> student_name </span>|<span class="hljs-string"> student_score </span>|<br>+--------------+---------------+<br>|<span class="hljs-string"> Dany         </span>|<span class="hljs-string">            90 </span>|<br>|<span class="hljs-string"> Green        </span>|<span class="hljs-string">            99 </span>|<br>|<span class="hljs-string"> Henry        </span>|<span class="hljs-string">            95 </span>|<br>|<span class="hljs-string"> Jane         </span>|<span class="hljs-string">            98 </span>|<br>|<span class="hljs-string"> Jim          </span>|<span class="hljs-string">            88 </span>|<br>|<span class="hljs-string"> John         </span>|<span class="hljs-string">            94 </span>|<br>|<span class="hljs-string"> Lily         </span>|<span class="hljs-string">           100 </span>|<br>|<span class="hljs-string"> Susan        </span>|<span class="hljs-string">            96 </span>|<br>|<span class="hljs-string"> Thomas       </span>|<span class="hljs-string">            93 </span>|<br>|<span class="hljs-string"> Tom          </span>|<span class="hljs-string">            89 </span>|<br>+--------------+---------------+<br>10 rows in set (0.00 sec)<br>Query OK, 0 rows affected (0.02 sec)<br></code></pre></td></tr></table></figure><h3 id="例-2">例 2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建存储过程<br>delimiter $$<br>create PROCEDURE test_bank()<br>BEGIN<br>select * from bank;<br>END$$<br><br># 调用存储过程<br>delimiter ;<br>call test_bank();<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200615150109398.png" alt="image-20200615150109398"></p><h2 id="4、创建带参数的存储过程">4、创建带参数的存储过程</h2><h3 id="例-3">例 3</h3><p><strong>创建名称为 GetScoreByStu 的存储过程，输入参数是学生姓名。存储过程的作用是通过输入的学生姓名从学生成绩信息表中查询指定学生的成绩信息，输入的 SQL 语句和执行过程如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; DELIMITER &#x2F;&#x2F;<br>mysql&gt; CREATE PROCEDURE GetScoreByStu<br>    -&gt; (IN name VARCHAR(30))<br>    -&gt; BEGIN<br>    -&gt; SELECT student_score FROM tb_students_score<br>    -&gt; WHERE student_name&#x3D;name;<br>    -&gt; END &#x2F;&#x2F;<br>Query OK, 0 rows affected (0.01 sec)<br></code></pre></td></tr></table></figure><p><strong>创建存储过程 GetScoreByStu 后，通过 CALL 语句调用该存储过程，SQL 语句和执行结果如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; DELIMITER ;<br>mysql&gt; CALL GetScoreByStu(&#39;Green&#39;);<br>+---------------+<br>| student_score |<br>+---------------+<br>|            99 |<br>+---------------+<br>1 row in set (0.03 sec)<br>Query OK, 0 rows affected (0.03 sec)<br></code></pre></td></tr></table></figure><h3 id="例-4">例 4</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建带参数的存储过程<br>delimiter $$<br>create PROCEDURE show_customer<br>(in name VARCHAR(20))<br>BEGIN<br>select * from bank where cusName&#x3D;name;<br>END $$<br>#调用带参数的存储过程<br>delimiter ;<br>call show_customer(&#39;zs&#39;);<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200615150729887.png" alt="image-20200615150729887"></p><h1>二、存储过程的参数</h1><p><strong>MySQL存储过程的参数用在存储过程的定义，共有三种参数类型,IN,OUT,INOUT,形式如：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATEPROCEDURE 存储过程名([[IN |OUT |INOUT ] 参数名 数据类形...])<br></code></pre></td></tr></table></figure><ul><li><strong>IN 输入参数：表示调用者向过程传入值（传入值可以是字面量或变量）</strong></li><li><strong>OUT 输出参数：表示过程向调用者传出值(可以返回多个值)（传出值只能是变量）</strong></li><li><strong>INOUT 输入输出参数：既表示调用者向过程传入值，又表示过程向调用者传出值（值只能是变量）</strong></li></ul><h2 id="1、in-输入参数">1、in 输入参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 存储过程的参数<br>delimiter $$<br>create PROCEDURE test(in p_in int)<br>BEGIN<br>  SELECT p_in;<br>  set p_in &#x3D; 2;<br>  select p_in;<br>END $$<br>    <br>delimiter ; <br>set @p_in&#x3D;1;<br>call in_param(@p_in);<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200615151115048.png" alt="image-20200615151115048"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200615151137069.png" alt="image-20200615151137069"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select @p_in;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200615151124534.png" alt="image-20200615151124534"></p><p><strong>以上可以看出，p_in 在存储过程中被修改，但并不影响 @p_id 的值，因为前者为局部变量、后者为全局变量。</strong></p><h2 id="2、out输出参数">2、out输出参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; delimiter &#x2F;&#x2F;<br>mysql&gt; create procedure out_param(out p_out int)<br>    -&gt;   begin<br>    -&gt;     select p_out;<br>    -&gt;     set p_out&#x3D;2;<br>    -&gt;     select p_out;<br>    -&gt;   end<br>    -&gt; &#x2F;&#x2F;<br>mysql&gt; delimiter ;<br> <br>mysql&gt; set @p_out&#x3D;1;<br> <br>mysql&gt; call out_param(@p_out);<br>+-------+<br>| p_out |<br>+-------+<br>|  NULL |<br>+-------+<br>　　#因为out是向调用者输出参数，不接收输入的参数，所以存储过程里的p_out为null<br>+-------+<br>| p_out |<br>+-------+<br>|     2 |<br>+-------+<br> <br>mysql&gt; select @p_out;<br>+--------+<br>| @p_out |<br>+--------+<br>|      2 |<br>+--------+<br>　　#调用了out_param存储过程，输出参数，改变了p_out变量的值<br></code></pre></td></tr></table></figure><h2 id="3、inout输入参数">3、inout输入参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; delimiter $$<br>mysql&gt; create procedure inout_param(inout p_inout int)<br>    -&gt;   begin<br>    -&gt;     select p_inout;<br>    -&gt;     set p_inout&#x3D;2;<br>    -&gt;     select p_inout;<br>    -&gt;   end<br>    -&gt; $$<br>mysql&gt; delimiter ;<br> <br>mysql&gt; set @p_inout&#x3D;1;<br> <br>mysql&gt; call inout_param(@p_inout);<br>+---------+<br>| p_inout |<br>+---------+<br>|       1 |<br>+---------+<br> <br>+---------+<br>| p_inout |<br>+---------+<br>|       2 |<br>+---------+<br> <br>mysql&gt; select @p_inout;<br>+----------+<br>| @p_inout |<br>+----------+<br>|        2 |<br>+----------+<br>#调用了inout_param存储过程，接受了输入的参数，也输出参数，改变了变量<br></code></pre></td></tr></table></figure><h3 id="注意："><strong>注意：</strong></h3><h4 id="1、如果过程没有参数，也必须在过程名后面写上小括号例：">1、如果过程没有参数，也必须在过程名后面写上小括号例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE sp_name ([proc_parameter[,...]]) ……<br></code></pre></td></tr></table></figure><h4 id="2、确保参数的名字不等于列的名字，否则在过程体中，参数名被当做列名来处理">2、确保参数的名字不等于列的名字，否则在过程体中，参数名被当做列名来处理</h4><h4 id="建议：">建议：</h4><ul><li><strong>输入值使用in参数。</strong></li><li><strong>返回值使用out参数。</strong></li><li><strong>inout参数就尽量的少用。</strong></li></ul><h1>三、MySQL删除存储过程（DROP PROCEDURE）</h1><p><strong>存储过程被创建后，就会一直保存在数据库服务器上，直至被删除。当 <a href="http://c.biancheng.net/mysql/" target="_blank" rel="noopener">MySQL</a> 数据库中存在废弃的存储过程时，我们需要将它从数据库中删除。</strong></p><p><strong>MySQL 中使用 DROP PROCEDURE 语句来删除数据库中已经存在的存储过程。语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP &#123; PROCEDURE | FUNCTION &#125; [ IF EXISTS ] &lt;过程名&gt;<br></code></pre></td></tr></table></figure><h4 id="语法说明如下：-2">语法说明如下：</h4><ul><li><strong>过程名：指定要删除的存储过程的名称。</strong></li><li><strong>IF EXISTS：指定这个关键字，用于防止因删除不存在的存储过程而引发的错误。</strong></li></ul><p><em><strong>注意：存储过程名称后面没有参数列表，也没有括号，在删除之前，必须确认该存储过程没有任何依赖关系，否则会导致其他与之关联的存储过程无法运行。</strong></em></p><h3 id="实例-1">实例 1</h3><p><strong>下面删除存储过程 showstuscore，SQL 语句和运行结果如下：</strong></p><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cal">mysql&gt; DROP <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">test</span>;</span><br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.08</span> sec)<br></code></pre></td></tr></table></figure><p><strong>删除后，可以通过查询 information_schema 数据库下的 routines 表来确认上面的删除是否成功。SQL 语句和运行结果如下：</strong></p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">mysql&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> information_schema.routines <span class="hljs-keyword">WHERE</span> routine_name=<span class="hljs-string">'showstuscore'</span>;<br><span class="hljs-keyword">Empty</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.03</span> sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，没有查询出任何记录，说明存储过程 showstuscore 已经被删除了。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;一、MySQL创建存储过程&lt;/h1&gt;
&lt;h2 id=&quot;1、基本语法&quot;&gt;1、基本语法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;可以使用 &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; 语句创建存储过程。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;语法格式如下：&quot;&gt;语法格
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://wsdlxgp.top/categories/mysql/"/>
    
    
      <category term="sql结构化查询语句" scheme="https://wsdlxgp.top/tags/sql%E7%BB%93%E6%9E%84%E5%8C%96%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"/>
    
      <category term="数值类型" scheme="https://wsdlxgp.top/tags/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储过程</title>
    <link href="https://wsdlxgp.top/posts/ae29.html"/>
    <id>https://wsdlxgp.top/posts/ae29.html</id>
    <published>2020-06-12T16:00:00.000Z</published>
    <updated>2020-06-19T05:15:43.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A：MySQL存储过程简介">A：MySQL存储过程简介</h2><p><strong>我们前面所学习的 MySQL 语句都是针对一个表或几个表的单条 SQL 语句，但是在数据库的实际操作中，经常会有需要多条 SQL 语句处理多个表才能完成的操作。</strong></p><p><strong>例如，为了确认学生能否毕业，需要同时查询学生档案表、成绩表和综合表，此时就需要使用多条 SQL 语句来针对这几个数据表完成处理要求。</strong></p><p><strong><code>存储过程是一组为了完成特定功能的 SQL 语句集合。</code>使用存储过程的目的是将常用或复杂的工作预先用 SQL 语句写好并用一个指定名称存储起来，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需调用“CALL存储过程名字”即可自动完成。</strong></p><p><strong>常用操作数据库的 SQL 语句在执行的时候需要先编译，然后执行。存储过程则采用另一种方式来执行 SQL 语句。</strong></p><p><strong>一个存储过程是一个可编程的函数，它在数据库中创建并保存，一般由 SQL 语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的特定功能时，存储过程尤为合适。</strong></p><p><strong>MySQL 5.0 版本以前并不支持存储过程，这使 MySQL 在应用上大打折扣。MySQL 从 5.0 版本开始支持存储过程，既提高了数据库的处理速度，同时也提高了数据库编程的灵活性</strong></p><p><strong>存储过程是数据库中的一个重要功能，存储过程可以用来转换数据、数据迁移、制作报表，它类似于编程语言，一次执行成功，就可以随时被调用，完成指定的功能操作。</strong></p><p><strong>使用存储过程不仅可以提高数据库的访问效率，同时也可以提高数据库使用的安全性。</strong></p><p><strong>对于调用者来说，存储过程封装了 SQL 语句，调用者无需考虑逻辑功能的具体实现过程。只是简单调用即可，它可以被 Java 和 C# 等编程语言调用。</strong></p><h2 id="B：存储过程有如下优点：">B：存储过程有如下优点：</h2><h3 id="1-封装性">1) 封装性</h3><p><strong>通常完成一个逻辑功能需要多条 SQL 语句，而且各个语句之间很可能传递参数，所以，编写逻辑功能相对来说稍微复杂些，而存储过程可以把这些 SQL 语句包含到一个独立的单元中，使外界看不到复杂的 SQL 语句，只需要简单调用即可达到目的。并且数据库专业人员可以随时对存储过程进行修改，而不会影响到调用它的应用程序源代码。</strong></p><h3 id="2-可增强-SQL-语句的功能和灵活性">2) 可增强 SQL 语句的功能和灵活性</h3><p><strong>存储过程可以用流程控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</strong></p><h3 id="3-可减少网络流量">3) 可减少网络流量</h3><p><strong>由于存储过程是在服务器端运行的，且执行速度快，因此当客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而可降低网络负载。</strong></p><h3 id="4-高性能">4) 高性能</h3><p><strong>当存储过程被成功编译后，就存储在数据库服务器里了，以后客户端可以直接调用，这样所有的 SQL 语句将从服务器执行，从而提高性能。但需要说明的是，存储过程不是越多越好，过多的使用存储过程反而影响系统性能。</strong></p><h3 id="5-提高数据库的安全性和数据的完整性">5) 提高数据库的安全性和数据的完整性</h3><p><strong>存储过程提高安全性的一个方案就是把它作为中间组件，存储过程里可以对某些表做相关操作，然后存储过程作为接口提供给外部程序。这样，外部程序无法直接操作数据库表，只能通过存储过程来操作对应的表，因此在一定程度上，安全性是可以得到提高的。</strong></p><h3 id="6-使数据独立">6) 使数据独立</h3><p><strong>数据的独立可以达到解耦的效果，也就是说，程序可以调用存储过程，来替代执行多条的 SQL 语句。这种情况下，存储过程把数据同用户隔离开来，优点就是当数据表的结构改变时，调用表不用修改程序，只需要数据库管理者重新编写存储过程即可。</strong></p><h2 id="C：MySQL存储过程的优点">C：<strong>MySQL存储过程的优点</strong></h2><ul><li><strong>通常存储过程有助于提高应用程序的性能。当创建，存储过程被编译之后，就存储在数据库中。 但是，MySQL实现的存储过程略有不同。 MySQL存储过程按需编译。 在编译存储过程之后，MySQL将其放入缓存中。 MySQL为每个连接维护自己的存储过程高速缓存。 如果应用程序在单个连接中多次使用存储过程，则使用编译版本，否则存储过程的工作方式类似于查询。</strong></li><li><strong>存储过程有助于减少应用程序和数据库服务器之间的流量，因为应用程序不必发送多个冗长的SQL语句，而只能发送存储过程的名称和参数。</strong></li><li><strong>存储的程序对任何应用程序都是可重用的和透明的。 存储过程将数据库接口暴露给所有应用程序，以便开发人员不必开发存储过程中已支持的功能。</strong></li><li><strong>存储的程序是安全的。 数据库管理员可以向访问数据库中存储过程的应用程序授予适当的权限，而不向基础数据库表提供任何权限。</strong></li></ul><h2 id="D：MySQL存储过程的缺点">D：MySQL存储过程的缺点</h2><ul><li><strong>如果使用大量存储过程，那么使用这些存储过程的每个连接的内存使用量将会大大增加。 此外，如果您在存储过程中过度使用大量逻辑操作，则CPU使用率也会增加，因为数据库服务器的设计不当于逻辑运算。</strong></li><li><strong>存储过程的构造使得开发具有复杂业务逻辑的存储过程变得更加困难。</strong></li><li><strong>很难调试存储过程。只有少数数据库管理系统允许您调试存储过程。不幸的是，MySQL不提供调试存储过程的功能。</strong></li><li><strong>开发和维护存储过程并不容易。开发和维护存储过程通常需要一个不是所有应用程序开发人员拥有的专业技能。这可能会导致应用程序开发和维护阶段的问题。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;A：MySQL存储过程简介&quot;&gt;A：MySQL存储过程简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;我们前面所学习的 MySQL 语句都是针对一个表或几个表的单条 SQL 语句，但是在数据库的实际操作中，经常会有需要多条 SQL 语句处理多个表才能完成的操作。&lt;/stron
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://wsdlxgp.top/categories/mysql/"/>
    
    
      <category term="sql结构化查询语句" scheme="https://wsdlxgp.top/tags/sql%E7%BB%93%E6%9E%84%E5%8C%96%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"/>
    
      <category term="数值类型" scheme="https://wsdlxgp.top/tags/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL用户管理（2）</title>
    <link href="https://wsdlxgp.top/posts/66c1.html"/>
    <id>https://wsdlxgp.top/posts/66c1.html</id>
    <published>2020-06-11T16:00:00.000Z</published>
    <updated>2020-06-19T05:15:37.604Z</updated>
    
    <content type="html"><![CDATA[<h1>一、MySQL root修改普通用户密码</h1><h2 id="1、使用SET语句修改普通用户的密码">1、使用SET语句修改普通用户的密码</h2><p><strong>在 MySQL 中，只有 root 用户可以通过更新 MySQL 数据库来更改密码。使用 root 用户登录到 MySQL 服务器后，可以使用 SET 语句来修改普通用户密码。语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">SET PASSWORD FOR &#39;username&#39;@&#39;hostname&#39; &#x3D; PASSWORD (&#39;newpwd&#39;);<br></code></pre></td></tr></table></figure><p><strong>其中，username 参数是普通用户的用户名，hostname 参数是普通用户的主机名，newpwd 是要更改的新密码。</strong></p><p><strong>注意：新密码必须使用 PASSWORD() 函数来加密，如果不使用 PASSWORD() 加密，也会执行成功，但是用户会无法登录。</strong></p><p><strong>如果是普通用户修改密码，可省略 FOR 子句来更改自己的密码。语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">SET PASSWORD &#x3D; PASSWORD(&#39;newpwd&#39;);<br></code></pre></td></tr></table></figure><h3 id="示例-1">示例 1</h3><p><strong>首先创建一个没有密码的 testuser 用户，SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">mysql&gt; CREATE USER &#39;testuser&#39;@&#39;localhost&#39;;<br>Query OK, 0 rows affected (0.14 sec)<br></code></pre></td></tr></table></figure><p><strong>root 用户登录 MySQL 服务器后，再使用 SET 语句将 testuser 用户的密码修改为“newpwd”，SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">mysql&gt; SET PASSWORD FOR &#39;testuser&#39;@&#39;localhost&#39; &#x3D; PASSWORD(&quot;newpwd&quot;);<br>Query OK, 0 rows affected, 1 warning (0.01 sec)<br></code></pre></td></tr></table></figure><p><strong>由运行结果可以看出，SET 语句执行成功，testuser 用户的密码被成功设置为“newpwd”。</strong></p><p><strong>下面验证 testuser 用户密码是否修改成功。退出 MySQL 服务器，使用 testuser 用户登录，输入密码“newpwd”，SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">C:\Users\leovo&gt;mysql -utestuser -p<br>Enter password: ******<br>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 15<br>Server version: 5.7.29-log MySQL Community Server (GPL)<br> <br>Copyright (c) 2000, 2020, Oracle and&#x2F;or its affiliates. All rights reserved.<br> <br>Oracle is a registered trademark of Oracle Corporation and&#x2F;or its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br> <br>Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.<br></code></pre></td></tr></table></figure><p><strong>由运行结果可以看出，testuser 用户登录成功，修改密码成功。</strong></p><h3 id="示例-2">示例 2</h3><p><strong>使用 testuser 用户登录 MySQL 服务器，再使用 SET 语句将密码更改为“newpwd1”，SQL 语句和运行结果如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">mysql&gt; SET PASSWORD &#x3D; PASSWORD(&#39;newpwd1&#39;);<br>Query OK, 0 rows affected, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>由运行结果可以看出，修改密码成功。</strong></p><h2 id="2、使用UPDATE语句修改普通用户的密码">2、使用UPDATE语句修改普通用户的密码</h2><p><strong>使用 root 用户登录 MySQL 服务器后，可以使用 UPDATE 语句修改 MySQL 数据库的 user 表的 authentication_string 字段，从而修改普通用户的密码。UPDATA 语句的语法如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">UPDATE MySQL.user SET authentication_string &#x3D; PASSWORD(&quot;newpwd&quot;) WHERE User &#x3D; &quot;username&quot; AND Host &#x3D; &quot;hostname&quot;;<br></code></pre></td></tr></table></figure><p><strong>其中，username 参数是普通用户的用户名，hostname 参数是普通用户的主机名，newpwd 是要更改的新密码。</strong></p><p><strong>注意，执行 UPDATE 语句后，需要执行 FLUSH PRIVILEGES 语句重新加载用户权限。</strong></p><h3 id="示例-3">示例 3</h3><p><strong>使用 root 用户登录 MySQL 服务器，再使用 UPDATE 语句将 testuser 用户的密码修改为“newpwd2”的 SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">mysql&gt; UPDATE MySQL.user SET authentication_string &#x3D; PASSWORD (&quot;newpwd2&quot;)<br>    -&gt; WHERE User &#x3D; &quot;testuser&quot; AND Host &#x3D; &quot;localhost&quot;;<br>Query OK, 1 row affected, 1 warning (0.07 sec)<br>Rows matched: 1  Changed: 1  Warnings: 1<br>mysql&gt; FLUSH PRIVILEGES;<br>Query OK, 0 rows affected (0.03 sec)<br></code></pre></td></tr></table></figure><p><strong>由运行结果可以看出，密码修改成功。testuser 的密码被修改成了 newpwd2。使用 FLUSH PRIVILEGES 重新加载权限后，就可以使用新的密码登录 testuser 用户了。</strong></p><h2 id="3、使用-GRANT-语句修改普通用户密码">3、使用 GRANT 语句修改普通用户密码</h2><p><strong>除了前面介绍的方法，还可以在全局级别使用 GRANT USAGE 语句指定某个账户的密码而不影响账户当前的权限。需要注意的是，使用 GRANT 语句修改密码，必须拥有 GRANT 权限。一般情况下最好使用该方法来指定或修改密码。语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">GRANT USAGE ON *.* TO &#39;user&#39;@’hostname’ IDENTIFIED BY &#39;newpwd&#39;;<br></code></pre></td></tr></table></figure><p><strong>其中，username 参数是普通用户的用户名，hostname 参数是普通用户的主机名，newpwd 是要更改的新密码。</strong></p><h3 id="示例-4">示例 4</h3><p><strong>使用 root 用户登录 MySQL 服务器，再使用 GRANT 语句将 testuser 用户的密码修改为“newpwd3”，SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">mysql&gt; GRANT USAGE ON *.* TO &#39;testuser&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;newpwd3&#39;;<br>Query OK, 0 rows affected, 1 warning (0.05 sec)<br></code></pre></td></tr></table></figure><p><strong>由运行结果可以看出，密码修改成功。</strong></p><h1>二、MySQL修改root密码</h1><h2 id="1、使用mysqladmin命令在命令行指定新密码">1、使用mysqladmin命令在命令行指定新密码</h2><p><strong>root 用户可以使用 mysqladmin 命令来修改密码，mysqladmin 的语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqladmin -u username -h hostname -p password &quot;newpwd&quot;<br></code></pre></td></tr></table></figure><h4 id="语法参数说明如下：">语法参数说明如下：</h4><ul><li><strong>usermame 指需要修改密码的用户名称，在这里指定为 root 用户；</strong></li><li><strong>hostname 指需要修改密码的用户主机名，该参数可以不写，默认是 localhost；</strong></li><li><strong>password 为关键字，而不是指旧密码；</strong></li><li><strong>newpwd 为新设置的密码，必须用双引号括起来。如果使用单引号会引发错误，可能会造成修改后的密码不是你想要的。</strong></li></ul><p><strong>执行完上面的语句，root 用户的密码将被修改为“newpwd”。</strong></p><h3 id="示例-1-2">示例 1</h3><p><strong>下面使用 mysqladmin 将 root 用户的密码修改为“rootpwd”，在 Windows 命令行窗口（cmd）中执行命令和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">C:\Users\leovo&gt;mysqladmin -u root -p password &quot;rootpwd&quot;<br>Enter password: ****<br>mysqladmin: [Warning] Using a password on the command line interface can be insecure.<br>Warning: Since password will be sent to server in plain text, use ssl connection to ensure password safety.<br></code></pre></td></tr></table></figure><p><strong>输入 mysqladmin 命令后，按回车键，然后输入 root 用户原来的密码。执行完毕后，密码修改成功，root 用户登录时将使用新的密码。</strong></p><p><strong>运行结果中，输入密码后会提示在命令行界面上使用密码可能不安全的警告信息，因为在命令行输入密码时，MySQL 服务器就会提示这些安全警告信息。</strong></p><p><strong>下面使用修改后的“rootpwd”密码登录 root 用户，SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">C:\Users\leovo&gt;mysql -uroot -p<br>Enter password: *******<br>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 23<br>Server version: 5.7.29-log MySQL Community Server (GPL)<br><br>Copyright (c) 2000, 2020, Oracle and&#x2F;or its affiliates. All rights reserved.<br><br>Oracle is a registered trademark of Oracle Corporation and&#x2F;or its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br><br>Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.<br></code></pre></td></tr></table></figure><p><strong>结果显示，root 用户登录成功，所以使用 mysqladmin 命令修改 root 用户密码成功。</strong></p><h2 id="2、修改MySQL数据库的user表">2、修改MySQL数据库的user表</h2><p><strong>因为所有账户信息都保存在 user 表中，因此可以直接通过修改 user 表来改变 root 用户的密码。</strong></p><p><strong>root 用户登录到 MySQL 服务器后，可以使用 UPDATE 语句修改 MySQL 数据库的 user 表的 authentication_string 字段，从而修改用户的密码。</strong></p><p><strong>使用 UPDATA 语句修改 root 用户密码的语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE mysql.user set authentication_string &#x3D; PASSWORD (&quot;rootpwd) WHERE User &#x3D; &quot;root&quot; and Host&#x3D;&quot;localhost&quot;;<br></code></pre></td></tr></table></figure><p><strong>新密码必须使用 PASSWORD() 函数来加密。执行UPDATE语句后，需要执行FLUSH PRIVILEGES语句重新加载用户权限。</strong></p><h3 id="示例-2-2">示例 2</h3><p><strong>下面使用 UPDATE 语句将 root用户的密码修改为“rootpwd2”。</strong></p><p><strong>使用 root 用户登录到 MySQL 服务器后，SQL 语句和运行结果如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; UPDATE mysql.user set authentication_string &#x3D; password (&quot;rootpwd2&quot;)<br>    -&gt; WHERE User &#x3D; &quot;root&quot; and Host &#x3D; &quot;localhost&quot;;<br>Query OK, 1 row affected, 0 warning (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings:0<br>mysql&gt; FLUSH PRIVILEGES;<br>Query OK, 0 rows affected (0.06 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，密码修改成功。而且使用了<code>FLUSH PRIVILEGES;</code>语句加载权限。退出后就必须使用新密码来登录了。</strong></p><h2 id="3、使用SET语句修改root用户的密码">3、使用SET语句修改root用户的密码</h2><p><strong>SET PASSWORD 语句可以用来重新设置其他用户的登录密码或者自己使用的账户的密码。使用 SET 语句修改密码的语法结构如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET PASSWORD &#x3D; PASSWORD (&quot;rootpwd&quot;);<br></code></pre></td></tr></table></figure><h3 id="示例-3-2">示例 3</h3><p><strong>下面使用 SET 语句将 root 用户的密码修改为“rootpwd3”。</strong></p><p><strong>使用 root 用户登录到 MySQL 服务器后，SQL 语句和运行结果如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">MySQL&gt; SET PASSWORD &#x3D; password (&quot;rootpwd3&quot;);<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，SET 语句执行成功，root 用户的密码被成功设置为“rootpwd3”。</strong></p><h1>三、MySQL忘记root密码解决方案</h1><p><strong>在忘记 MySQL 密码的情况下，可以通过 <code>--skip-grant-tables</code> 关闭服务器的认证，然后重置 root 的密码，具体操作步骤如下。</strong></p><p><strong>步骤 1)：关闭正在运行的 MySQL 服务。打开 cmd 进入 MySQL 的 bin 目录。</strong></p><p><strong>步骤 2)：输入<code>mysqld --console --skip-grant-tables --shared-memory</code> 命令。–skip-grant-tables 会让 MySQL 服务器跳过验证步骤，允许所有用户以匿名的方式，无需做密码验证就可以直接登录 MySQL 服务器，并且拥有所有的操作权限。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200614165937752.png" alt="image-20200614165937752"></p><p><strong>步骤 3)：上一个 DOS 窗口不要关闭，打开一个新的 DOS 窗口，此时仅输入 mysql 命令，不需要用户名和密码，即可连接到 MySQL。</strong></p><p><strong>步骤 4)：输入命令 <code>update mysql.user set authentication_string=password('root') where user='root' and Host ='localhost';</code> 设置新密码。</strong></p><p><strong>注意：MySQL 5.7 版本中的 user 表里已经去掉了 password 字段，改为了 authentication_string。</strong></p><p><strong>步骤 5)：刷新权限（必须步骤），输入<code>flush privileges;</code>命令。</strong></p><p><strong>步骤 6)：因为之前使用 --skip-grant-tables 启动，所以需要重启 MySQL 服务器去掉 --skip-grant-tables。输入无误后输入<code>quit;</code>命令退出 MySQL 服务。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200614170003331.png" alt="image-20200614170003331"></p><p><strong>步骤 7)：重启 MySQL 服务，使用用户名 root 和刚才设置的新密码 root 登录就可以了。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200614170016966.png" alt="image-20200614170016966"></p><h1>四、MySQL修改密码的3种方式</h1><h2 id="1-使用-SET-PASSWORD-命令">1. 使用 SET PASSWORD 命令</h2><p><strong>步骤 1)：输入命令<code>mysql -u root -p</code>指定 root 用户登录 MySQL，输入后按回车键输入密码。如果没有配置环境变量，请在 MySQL 的 bin 目录下登录操作。</strong></p><p><strong>步骤 2)：使用 SET PASSWORD 修改密码命令格式为 <code>set password for username @localhost = password(newpwd);</code>，其中 username 为要修改密码的用户名，newpwd 为要修改的新密码。如图所示。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200614170059293.png" alt="image-20200614170059293"></p><p><strong>步骤 3)：输入<code>quit;</code>命令退出 MySQL 重新登录，输入新密码“root”登录就可以了；</strong></p><h2 id="2-使用mysqladmin修改密码">2. 使用mysqladmin修改密码</h2><p><strong>使用 mysqladmin 命令修改 MySQL 的 root 用户密码格式为 <code>mysqladmin -u用户名 -p旧密码 password 新密码</code>。</strong></p><p><strong>注意：下图修改密码的命令中 -uroot 和 -proot 是整体，不要写成 -u root -p root，-u 和 root 间可以加空格，但是会有警告出现，所以就不要加空格了。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200614170130114.png" alt="image-20200614170130114"></p><h2 id="3-UPDATE直接编辑user表">3. UPDATE直接编辑user表</h2><p><strong>步骤 1)：输入命令<code>mysql -u root -p</code>指定 root 用户登录 MySQL，输入后按回车键输入密码。如果没有配置环境变量，请在 MySQL 的 bin 目录下登录操作。</strong></p><p><strong>步骤 2)：输入<code>use mysql;</code>命令连接权限数据库。</strong></p><p><strong>步骤 3)：输入命令<code>update mysql.user set authentication_string=password('新密码') where user='用户名' and Host ='localhost';</code>设置新密码。</strong></p><p><strong>步骤 4)：输入 <code>flush privileges;</code> 命令刷新权限。</strong></p><p><strong>步骤 5)：输入<code>quit;</code>命令退出 MySQL 重新登录，此时密码已经修改为刚才输入的新密码了。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200614170154428.png" alt="image-20200614170154428"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#创建数据库<br>DROP DATABASE IF EXISTS &#96;bankDB&#96;;<br>CREATE DATABASE &#96;bankDB&#96;;<br><br>USE &#96;bankDB&#96;;<br><br>DROP TABLE IF EXISTS &#96;userInfo&#96;;<br>CREATE TABLE &#96;userInfo&#96;  #用户信息表<br>(<br>  &#96;customerID&#96; INT(4) PRIMARY KEY AUTO_INCREMENT COMMENT &#39;用户编号&#39;,<br>  &#96;customerName&#96; CHAR(8) NOT NULL COMMENT &#39;用户编号&#39;,<br>  &#96;PID&#96; CHAR(18) UNIQUE NOT NULL COMMENT &#39;身份证号&#39;,<br>  &#96;telephone&#96; CHAR(20) NOT NULL COMMENT &#39;手机号码&#39;,<br>  &#96;address&#96; VARCHAR(50) COMMENT &#39;居住地址&#39;<br>)ENGINE &#x3D; INNODB,CHARSET&#x3D;UTF8,COMMENT&#x3D;&#39;用户表&#39;;<br><br>DROP TABLE IF EXISTS &#96;cardInfo&#96;;<br>CREATE TABLE &#96;cardInfo&#96;  #银行卡信息表<br>(<br>  &#96;cardID&#96;  CHAR(19) NOT NULL PRIMARY KEY COMMENT &#39;卡号&#39;,<br>   &#96;password&#96; CHAR(6) NOT NULL DEFAULT &#39;888888&#39; COMMENT &#39;密码&#39;,<br>  &#96;curID&#96;  VARCHAR(10) NOT NULL DEFAULT &#39;RMB&#39; COMMENT &#39;币种&#39;,<br>  &#96;savingID&#96; INT NOT NULL COMMENT &#39;存款类型&#39;,<br>  &#96;openDate&#96;  TIMESTAMP NOT NULL COMMENT &#39;开户日期&#39; ,<br>  &#96;openMoney&#96;  DECIMAL(20,2) NOT NULL DEFAULT 1 COMMENT &#39;开户金额&#39; ,<br>  &#96;balance&#96;  DECIMAL(20,2) NOT NULL DEFAULT 1 COMMENT &#39;余额&#39;,<br>  &#96;IsReportLoss&#96; BIT  NOT NULL  DEFAULT 0 COMMENT &#39;是否挂失&#39;,<br>  &#96;customerID&#96; INT NOT NULL<br>) ENGINE &#x3D; INNODB,CHARSET&#x3D;UTF8,COMMENT&#x3D;&#39;银行卡信息表&#39;;<br><br>DROP TABLE IF EXISTS &#96;tradeInfo&#96;;<br>CREATE TABLE &#96;tradeInfo&#96;  #交易信息表<br>(<br>  cardID  CHAR(16) NOT NULL COMMENT &#39;卡号&#39;,<br>  tradeDate  TIMESTAMP NOT NULL  COMMENT &#39;交易日期&#39;,<br>  tradeMoney  DECIMAL(20,2) NOT NULL COMMENT &#39;实际交易金额&#39;,<br>  tradeType  CHAR(4) NOT NULL COMMENT &#39;交易类型&#39;, <br>  remark  TEXT COMMENT &#39;备注&#39;  <br>)ENGINE &#x3D; INNODB,CHARSET&#x3D;UTF8,COMMENT&#x3D;&#39;交易信息表&#39;;<br><br>DROP TABLE IF EXISTS &#96;deposit&#96;;<br>CREATE TABLE &#96;deposit&#96;  #存款类型表<br>(<br>  savingID  INT(4)  AUTO_INCREMENT PRIMARY KEY,<br>  savingName  VARCHAR(20) NOT NULL,<br>  descrip VARCHAR(50)<br>)ENGINE &#x3D; INNODB,CHARSET&#x3D;UTF8,COMMENT&#x3D;&#39;存款类型表&#39;;<br><br><br>&#x2F;*--加约束--$*&#x2F;<br><br>ALTER TABLE cardInfo     <br>   ADD CONSTRAINT  FK_customerID <br>   FOREIGN KEY(customerID) <br>   REFERENCES userInfo(customerID),<br>   ADD  CONSTRAINT  FK_savingID  <br>   FOREIGN KEY(savingID) <br>   REFERENCES deposit(savingID);<br><br>ALTER TABLE tradeInfo<br>  ADD CONSTRAINT  FK_cardID  <br>  FOREIGN KEY(cardID) <br>  REFERENCES cardInfo(cardID);<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;一、MySQL root修改普通用户密码&lt;/h1&gt;
&lt;h2 id=&quot;1、使用SET语句修改普通用户的密码&quot;&gt;1、使用SET语句修改普通用户的密码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;在 MySQL 中，只有 root 用户可以通过更新 MySQL 数据库来更改密码。使用 ro
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://wsdlxgp.top/categories/mysql/"/>
    
    
      <category term="sql结构化查询语句" scheme="https://wsdlxgp.top/tags/sql%E7%BB%93%E6%9E%84%E5%8C%96%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"/>
    
      <category term="数值类型" scheme="https://wsdlxgp.top/tags/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL用户管理（1）</title>
    <link href="https://wsdlxgp.top/posts/22c1.html"/>
    <id>https://wsdlxgp.top/posts/22c1.html</id>
    <published>2020-06-10T16:00:00.000Z</published>
    <updated>2020-06-19T05:15:31.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A：补充技能点">A：补充技能点</h2><h3 id="MySQL用户管理"><strong>MySQL用户管理</strong></h3><ul><li><strong>创建普通用户</strong></li><li><strong>执行GRANT语句创建用户并授权</strong></li><li><strong>使用mysqladmin命令修改root账户密码</strong></li><li><strong>使用SET命令修改用户密码</strong></li><li><strong>删除普通用户</strong></li></ul><p><strong>MySQL 在安装时会自动创建一个名为 mysql 的数据库，mysql 数据库中存储的都是用户权限表。用户登录以后，MySQL 会根据这些权限表的内容为每个用户赋予相应的权限。</strong></p><p><strong>user 表是 MySQL 中最重要的一个权限表，用来记录允许连接到服务器的账号信息。需要注意的是，在 user 表里启用的所有权限都是全局级的，适用于所有数据库。</strong></p><p><strong>user 表中的字段大致可以分为 4 类，分别是用户列、权限列、安全列和资源控制列。</strong></p><h2 id="B：为什么需要用户管理">B：为什么需要用户管理</h2><h4 id="root是超级管理员用户，很容易引发由于误操作所导致的数据不安全问题，怎么办"><strong>root是超级管理员用户，很容易引发由于误操作所导致的数据不安全问题，怎么办?</strong></h4><blockquote><p><strong>针对不同用户进行合理的用户角色权限分配，即用户管理</strong></p></blockquote><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200612150731946.png" alt="image-20200612150731946"></p><h1>一、MySQL创建用户（3种方式）</h1><h4 id="MySQL-提供了以下-3-种方法创建用户。">MySQL 提供了以下 3 种方法创建用户。</h4><ul><li><strong>使用 CREATE USER 语句创建用户</strong></li><li><strong>在 mysql.user 表中添加用户</strong></li><li><strong>使用 GRANT 语句创建用户</strong></li></ul><h2 id="1-使用CREATE-USER语句创建用户">1. 使用CREATE USER语句创建用户</h2><p><strong>可以使用 <code>CREATE USER</code> 语句来创建 MySQL 用户，并设置相应的密码。其基本语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE USER &lt;用户&gt; [ IDENTIFIED BY [ PASSWORD ] &#39;password&#39; ] [ ,用户 [ IDENTIFIED BY [ PASSWORD ] &#39;password&#39; ]]<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200612150916248.png" alt="image-20200612150916248"></p><h3 id="例1">例1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建普通用户<br>create user &#96;teacher&#96;@&#96;localhost&#96; IDENTIFIED BY &#39;123456&#39;;<br>create user &#96;student&#96;@&#96;localhost&#96;<br><br># 查看用户<br>use mysql;<br>select host,user from user;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200612151258167.png" alt="image-20200612151258167"></p><h3 id="例2">例2</h3><p><strong>在 MySQL 中，可以使用 password() 函数获取密码的哈希值，查看 test1 哈希值的 SQL 语句和执行过程如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT password(&#39;teacher&#39;);<br>+-------------------------------------------+<br>| password(&#39;teacher&#39;)                       |<br>+-------------------------------------------+<br>| *977F15BF49C046DA76BC81A80146AAB943F679F1 |<br>+-------------------------------------------+<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p>*<em>“<em>977F15BF49C046DA76BC81A80146AAB943F679F1”就是 test1 的哈希值。下面创建用户 test1，SQL 语句和执行过程如下：</em></em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE USER &#39;text1&#39;@&#39;localhost&#39;IDENTIFIED BY PASSWORD &#39;*977F15BF49C046DA76BC81A80146AAB943F679F1&#39;;<br>Query OK, 0 rows affected, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>执行成功后就可以使用密码“test1”登录了。</strong></p><h2 id="2-使用-INSERT-语句新建用户">2. 使用 INSERT 语句新建用户</h2><p><strong>可以使用 INSERT 语句将用户的信息添加到 mysql.user 表中，但必须拥有对 mysql.user 表的 INSERT 权限。通常 INSERT 语句只添加 Host、User 和 authentication_string 这 3 个字段的值。</strong></p><blockquote><p><strong>MySQL 5.7 的 user 表中的密码字段从 Password 变成了 authentication_string，如果你使用的是 MySQL 5.7 之前的版本，将 authentication_string 字段替换成 Password 即可。</strong></p></blockquote><p><strong>使用 <code>INSERT</code> 语句创建用户的代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO mysql.user(Host, User,  authentication_string, ssl_cipher, x509_issuer, x509_subject) VALUES (&#39;hostname&#39;, &#39;username&#39;, PASSWORD(&#39;password&#39;), &#39;&#39;, &#39;&#39;, &#39;&#39;);<br></code></pre></td></tr></table></figure><p><strong>由于 mysql 数据库的 user 表中，ssl_cipher、x509_issuer 和 x509_subject 这 3 个字段没有默认值，所以向 user 表插入新记录时，一定要设置这 3 个字段的值，否则 INSERT 语句将不能执行。</strong></p><h3 id="例-3">例 3</h3><p><strong>下面使用 INSERT 语句创建名为 test2 的用户，主机名是 localhost，密码也是 test2。SQL 语句和执行过程如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; INSERT INTO mysql.user(Host, User, authentication_string, ssl_cipher, x509_issuer, x509_subject) VALUES (&#39;localhost&#39;, &#39;test2&#39;, PASSWORD(&#39;test2&#39;), &#39;&#39;, &#39;&#39;, &#39;&#39;);<br>Query OK, 1 row affected, 1 warning (0.02 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，新建用户成功。但是这时如果通过该账户登录 MySQL 服务器，不会登录成功，因为 test2 用户还没有生效。</strong></p><p><strong>可以使用 FLUSH 命令让用户生效，命令如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><p><strong>使用以上命令可以让 MySQL 刷新系统权限相关表。执行 FLUSH 命令需要 RELOAD 权限。</strong></p><p><strong>注意：user 表中的 User 和 Host 字段区分大小写，创建用户时要指定正确的用户名称或主机名。</strong></p><h2 id="3-使用GRANT语句新建用户">3. 使用GRANT语句新建用户</h2><p><strong>虽然 CREATE USER 和 INSERT INTO 语句都可以创建普通用户，但是这两种方式不便授予用户权限。于是 MySQL 提供了 GRANT 语句。</strong></p><p><strong>使用 GRANT 语句创建用户的基本语法形式如下:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">GRANT priv_type ON database.table TO user [IDENTIFIED BY [PASSWORD] &#39;password&#39;]<br></code></pre></td></tr></table></figure><p><strong>其中：</strong></p><ul><li><strong>priv_type 参数表示新用户的权限；</strong></li><li><strong>database.table 参数表示新用户的权限范围，即只能在指定的数据库和表上使用自己的权限；</strong></li><li><strong>user 参数指定新用户的账号，由用户名和主机名构成；</strong></li><li><strong>IDENTIFIED BY 关键字用来设置密码；</strong></li><li><strong>password 参数表示新用户的密码。</strong></li></ul><h3 id="例-4">例 4</h3><p><strong>下面使用 GRANT 语句创建名为 test3 的用户，主机名为 localhost，密码为 test3。该用户对所有数据库的所有表都有 SELECT 权限。SQL 语句和执行过程如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; GRANT SELECT ON*.* TO &#39;test3&#39;@localhost IDENTIFIED BY &#39;test3&#39;;<br>Query OK, 0 rows affected, 1 warning (0.01 sec)<br></code></pre></td></tr></table></figure><p><strong>其中，“<em>.</em>” 表示所有数据库下的所有表。结果显示创建用户成功，且 test3 用户对所有表都有查询（SELECT）权限。</strong></p><p><strong>技巧：GRANT 语句是 MySQL 中一个非常重要的语句，它可以用来创建用户、修改用户密码和设置用户权限。教程后面会详细介绍如何使用 GRANT 语句修改密码、更改权限。</strong></p><h1>二、MySQL修改用户（RENAME USER）</h1><p><strong>在 MySQL中，我们可以使用 RENAME USER 语句修改一个或多个已经存在的用户账号。</strong></p><h5 id="语法格式如下：">语法格式如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">RENAME USER &lt;旧用户&gt; TO &lt;新用户&gt;<br></code></pre></td></tr></table></figure><h5 id="其中：">其中：</h5><ul><li><strong>&lt;旧用户&gt;：系统中已经存在的 MySQL 用户账号。</strong></li><li><strong>&lt;新用户&gt;：新的 MySQL 用户账号。</strong></li></ul><h4 id="使用-RENAME-USER-语句时应注意以下几点：">使用 RENAME USER 语句时应注意以下几点：</h4><ul><li><strong>RENAME USER 语句用于对原有的 MySQL 用户进行重命名。</strong></li><li><strong>若系统中旧账户不存在或者新账户已存在，该语句执行时会出现错误。</strong></li><li><strong>使用 RENAME USER 语句，必须拥有 mysql 数据库的 UPDATE 权限或全局 CREATE USER 权限。</strong></li></ul><h3 id="例-1">例 1</h3><p><strong>使用 RENAME USER 语句将用户名 test1 修改为 testUser1，主机是 localhost。SQL 语句和执行过程如下。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; RENAME USER &#39;test1&#39;@&#39;localhost&#39;<br>    -&gt; TO &#39;testUser1&#39;@&#39;localhost&#39;;<br>Query OK, 0 rows affected (0.03 sec)<br></code></pre></td></tr></table></figure><p><strong>在 cmd 命令行工具中，使用 testUser1 用户登录数据库服务器，如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">C:\Users\USER&gt;mysql -h localhost -u testUser1 -p<br>Enter password: *****<br>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 7<br>Server version: 5.7.20-log MySQL Community Server (GPL)<br>Copyright (c) 2000, 2017, Oracle and&#x2F;or its affiliates. All rights reserved.<br>Oracle is a registered trademark of Oracle Corporation and&#x2F;or its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br>Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.<br></code></pre></td></tr></table></figure><h1>三、MySQL删除用户（DROP/DELETE USER）</h1><p><strong>在 MySQL 数据库中，可以使用 DROP USER 语句删除用户，也可以直接在 mysql.user 表中删除用户以及相关权限。</strong></p><h2 id="1-使用-DROP-USER-语句删除普通用户">1. 使用 DROP USER 语句删除普通用户</h2><p><strong>使用 DROP USER 语句删除用户的语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP USER &lt;用户1&gt; [ , &lt;用户2&gt; ]…<br></code></pre></td></tr></table></figure><p><strong>其中，用户用来指定需要删除的用户账号。</strong></p><p><strong>使用 DROP USER 语句应注意以下几点：</strong></p><ul><li><strong>DROP USER 语句可用于删除一个或多个用户，并撤销其权限。</strong></li><li><strong>使用 DROP USER 语句必须拥有 mysql 数据库的 DELETE 权限或全局 CREATE USER 权限。</strong></li><li><strong>在 DROP USER 语句的使用中，若没有明确地给出账户的主机名，则该主机名默认为“%”。</strong></li></ul><blockquote><p><strong>注意：用户的删除不会影响他们之前所创建的表、索引或其他数据库对象，因为 MySQL 并不会记录是谁创建了这些对象。</strong></p></blockquote><h3 id="例-1-2">例 1</h3><p><strong>下面使用 DROP USER 语句删除用户’test1@‘localhost’。SQL 语句和执行过程如下。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; DROP USER &#39;test1&#39;@&#39;localhost&#39;;<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>在 cmd 命令行工具中，使用 test1 用户登录数据库服务器，发现登录失败，说明用户已经删除，如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">C:\Users\USER&gt;mysql -h localhost -u test1 -p<br>Enter password: ****<br>ERROR 1045 (28000): Access denied for user &#39;test&#39;@&#39;localhost&#39; (using  password: YES)<br></code></pre></td></tr></table></figure><h2 id="2-使用DELETE语句删除普通用户">2. 使用DELETE语句删除普通用户</h2><p><strong>可以使用 DELETE 语句直接删除 mysql.user 表中相应的用户信息，但必须拥有 mysql.user 表的 DELETE 权限。其基本语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM mysql.user WHERE Host&#x3D;&#39;hostname&#39; AND User&#x3D;&#39;username&#39;;<br></code></pre></td></tr></table></figure><p><strong>Host 和 User 这两个字段都是 mysql.user 表的主键。因此，需要两个字段的值才能确定一条记录。</strong></p><h3 id="例-2">例 2</h3><p><strong>下面使用 DELETE 语句删除用户’test2’@‘localhost’。SQL 语句和执行过程如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM mysql.user WHERE Host&#x3D;&#39;localhost&#39;AND User&#x3D;&#39;test2&#39;;<br>Query OK, 1 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示删除成功。可以使用 SELETE 语句查询 mysql.user 表，以确定该用户是否已经成功删除。</strong></p><h1>四、MySQL查看用户权限</h1><p><strong>在 MySQL 中，可以通过查看 mysql.user 表中的数据记录来查看相应的用户权限，也可以使用 SHOW GRANTS 语句查询用户的权限。</strong></p><p><strong>mysql 数据库下的 user 表中存储着用户的基本权限，可以使用 SELECT 语句来查看。SELECT 语句的代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM mysql.user;<br></code></pre></td></tr></table></figure><p><strong>要执行该语句，必须拥有对 user 表的查询权限。</strong></p><p><em><strong>注意：新创建的用户只有登录 MySQL 服务器的权限，没有任何其它权限，不能查询 user 表。</strong></em></p><p><strong>除了使用 SELECT 语句之外，还可以使用 SHOW GRANTS FOR 语句查看权限。其语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW GRANTS FOR &#39;username&#39;@&#39;hostname&#39;;<br></code></pre></td></tr></table></figure><p><strong>其中，username 表示用户名，hostname 表示主机名或主机 IP。</strong></p><h3 id="例-1-3">例 1</h3><p><strong>下面创建 testuser1 用户并查询权限，SQL 语句和执行过程如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE USER &#39;testuser1&#39;@&#39;localhost&#39;;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; SHOW GRANTS FOR &#39;testuser1&#39;@&#39;localhost&#39;;<br>+-----------------------------------------------+<br>| Grants for testuser1@localhost                |<br>+-----------------------------------------------+<br>| GRANT USAGE ON *.* TO &#39;testuser1&#39;@&#39;localhost&#39; |<br>+-----------------------------------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>其中，<code>USAGE ON *.*</code>表示该用户对任何数据库和任何表都没有权限。</strong></p><h3 id="例-2-2">例 2</h3><p><strong>下面查询 root 用户的权限，代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW GRANTS FOR &#39;root&#39;@&#39;localhost&#39;;<br>+---------------------------------------------------------------------+<br>| Grants for root@localhost                                           |<br>+---------------------------------------------------------------------+<br>| GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;localhost&#39; WITH GRANT OPTION |<br>| GRANT PROXY ON &#39;&#39;@&#39;&#39; TO &#39;root&#39;@&#39;localhost&#39; WITH GRANT OPTION        |<br>+---------------------------------------------------------------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h1>五、MySQL GRANT：用户授权</h1><p><strong>授权就是为某个用户赋予某些权限。例如，可以为新建的用户赋予查询所有数据库和表的权限。MySQL 提供了 GRANT 语句来为用户设置权限。</strong></p><p><strong>在 MySQL 中，拥有 GRANT 权限的用户才可以执行 GRANT 语句，其语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">GRANT priv_type [(column_list)] ON database.table<br>TO user [IDENTIFIED BY [PASSWORD] &#39;password&#39;]<br>[, user[IDENTIFIED BY [PASSWORD] &#39;password&#39;]] ...<br>[WITH with_option [with_option]...]<br></code></pre></td></tr></table></figure><h2 id="1、权限类型说明">1、权限类型说明</h2><h3 id="1）授予数据库权限时，-权限类型-可以指定为以下值：">1）授予数据库权限时，&lt;权限类型&gt;可以指定为以下值：</h3><p>![image-20200614164858090](G:\四期\数据库\mysql文档\11  MySQL 事务（2）.assets\image-20200614164858090.png)</p><h3 id="2-授予表权限时，-权限类型-可以指定为以下值：">2) 授予表权限时，&lt;权限类型&gt;可以指定为以下值：</h3><p>![image-20200614164921901](G:\四期\数据库\mysql文档\11  MySQL 事务（2）.assets\image-20200614164921901.png)</p><h3 id="3-授予列权限时，-权限类型-的值只能指定为-SELECT、INSERT-和-UPDATE，同时权限的后面需要加上列名列表-column-list。">3) 授予列权限时，&lt;权限类型&gt;的值只能指定为 SELECT、INSERT 和 UPDATE，同时权限的后面需要加上列名列表 column-list。</h3><h3 id="4-最有效率的权限是用户权限。">4) 最有效率的权限是用户权限。</h3><p><strong>授予用户权限时，&lt;权限类型&gt;除了可以指定为授予数据库权限时的所有值之外，还可以是下面这些值：</strong></p><ul><li><strong>CREATE USER：表示授予用户可以创建和删除新用户的权限。</strong></li><li><strong>SHOW DATABASES：表示授予用户可以使用 SHOW DATABASES 语句查看所有已有的数据库的定义的权限。</strong></li></ul><h3 id="例-1-4">例 1</h3><p><strong>使用 GRANT 语句创建一个新的用户 testUser，密码为 testPwd。用户 testUser 对所有的数据有查询、插入权限，并授予 GRANT 权限。SQL 语句和执行过程如下。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; GRANT SELECT,INSERT ON *.*<br>    -&gt; TO &#39;testUser&#39;@&#39;localhost&#39;<br>    -&gt; IDENTIFIED BY &#39;testPwd&#39;<br>    -&gt; WITH GRANT OPTION;<br>Query OK, 0 rows affected, 1 warning (0.05 sec)<br></code></pre></td></tr></table></figure><p><strong>使用 SHOW GRANTS 语句查询用户 testUser 的权限，如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW GRANTS FOR &#39;testUser&#39;@&#39;localhost&#39;;<br>+-------------------------------------------------------------------------+<br>| Grants for testUser@localhost                                           |<br>+-------------------------------------------------------------------------+<br>| GRANT SELECT, INSERT ON *.* TO &#39;testUser&#39;@&#39;localhost&#39; WITH GRANT OPTION |<br>+-------------------------------------------------------------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，testUser 对所有数据库的所有表有查询、插入权限，并可以将这些权限赋予给别的用户。</strong></p><h1>六、MySQL REVOKE：删除用户权限</h1><p><strong>在 MySQL 中，可以使用 REVOKE 语句删除某个用户的某些权限（此用户不会被删除），在一定程度上可以保证系统的安全性。例如，如果数据库管理员觉得某个用户不应该拥有 DELETE 权限，那么就可以删除 DELETE 权限。</strong></p><p><strong>使用 REVOKE 语句删除权限的语法格式有两种形式，如下所示：</strong></p><h2 id="1）第一种">1）第一种</h2><p><strong>删除用户某些特定的权限，语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">REVOKE priv_type [(column_list)]...<br>ON database.table<br>FROM user [, user]...<br></code></pre></td></tr></table></figure><p><strong>REVOKE 语句中的参数与 GRANT 语句的参数意思相同。其中：</strong></p><ul><li><strong>priv_type 参数表示权限的类型；</strong></li><li><strong>column_list 参数表示权限作用于哪些列上，没有该参数时作用于整个表上；</strong></li><li><strong>user 参数由用户名和主机名构成，格式为“username’@‘hostname’”。</strong></li></ul><h2 id="2）第二种">2）第二种</h2><p><strong>删除特定用户的所有权限，语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">REVOKE ALL PRIVILEGES, GRANT OPTION FROM user [, user] ...<br></code></pre></td></tr></table></figure><p><strong>删除用户权限需要注意以下几点：</strong></p><ul><li><strong>REVOKE 语法和 GRANT 语句的语法格式相似，但具有相反的效果。</strong></li><li><strong>要使用 REVOKE 语句，必须拥有 MySQL 数据库的全局 CREATE USER 权限或 UPDATE 权限。</strong></li></ul><h3 id="例-1-5">例 1</h3><p><strong>使用 REVOKE 语句取消用户 testUser 的插入权限，SQL 语句和执行过程如下。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; REVOKE INSERT ON *.*<br>    -&gt; FROM &#39;testUser&#39;@&#39;localhost&#39;;<br>Query OK, 0 rows affected (0.01 sec)<br><br>mysql&gt; SHOW GRANTS FOR &#39;testUser&#39;@&#39;localhost&#39;;<br>+-----------------------------------------------------------------+<br>| Grants for testUser@localhost                                   |<br>+-----------------------------------------------------------------+<br>| GRANT SELECT ON *.* TO &#39;testUser&#39;@&#39;localhost&#39; WITH GRANT OPTION |<br>+-----------------------------------------------------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，删除 testUser 用户的 INSERT 权限成功。</strong></p><h3 id="创建用户并授权">创建用户并授权</h3><p><strong>GRANT语句可实现创建用户同时授权或为已存在的用户授权</strong><br>![image-20200612151755831](G:\四期\数据库\mysql文档\11  MySQL用户管理（1）.assets\image-20200612151755831.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 给用户授权<br>grant insert,select on myschool.student<br>to &#96;xgp&#96;@&#96;localhost&#96; IDENTIFIED by &#39;123456&#39;;<br><br>grant select on myschool.student to &#96;student&#96;@&#96;localhost&#96;;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use myschool;<br>delete from student;<br></code></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">C:\<span class="hljs-title">WINDOWS</span>\<span class="hljs-title">system32</span>&gt;<span class="hljs-title">mysqladmin</span> -<span class="hljs-title">u</span> <span class="hljs-title">xgp</span> -<span class="hljs-title">p</span> <span class="hljs-title">password</span> "1111"</span><br><span class="hljs-function"><span class="hljs-title">Enter</span> <span class="hljs-title">password</span>: ******</span><br><span class="hljs-function"><span class="hljs-title">mysqladmin</span>: [<span class="hljs-title">Warning</span>] <span class="hljs-title">Using</span> <span class="hljs-title">a</span> <span class="hljs-title">password</span> <span class="hljs-title">on</span> <span class="hljs-title">the</span> <span class="hljs-title">command</span> <span class="hljs-title">line</span> <span class="hljs-title">interface</span> <span class="hljs-title">can</span> <span class="hljs-title">be</span> <span class="hljs-title">insecure</span>.</span><br><span class="hljs-function"><span class="hljs-title">Warning</span>: <span class="hljs-title">Since</span> <span class="hljs-title">password</span> <span class="hljs-title">will</span> <span class="hljs-title">be</span> <span class="hljs-title">sent</span> <span class="hljs-title">to</span> <span class="hljs-title">server</span> <span class="hljs-title">in</span> <span class="hljs-title">plain</span> <span class="hljs-title">text</span>, <span class="hljs-title">use</span> <span class="hljs-title">ssl</span> <span class="hljs-title">connection</span> <span class="hljs-title">to</span> <span class="hljs-title">ensure</span> <span class="hljs-title">password</span> <span class="hljs-title">safety</span>.</span><br></code></pre></td></tr></table></figure><p>![image-20200612153552461](G:\四期\数据库\mysql文档\11  MySQL用户管理（1）.assets\image-20200612153552461.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">set password &#x3D; password(&quot; 8888 )<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET PASSWORD FOR &#96;teacher&#96;@localhost&#96; &#x3D; PASSWORD(&quot;8888&quot;);<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop user xgp@localhost;<br>select * from user;<br></code></pre></td></tr></table></figure><p>![image-20200612154416018](G:\四期\数据库\mysql文档\11  MySQL用户管理（1）.assets\image-20200612154416018.png)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;A：补充技能点&quot;&gt;A：补充技能点&lt;/h2&gt;
&lt;h3 id=&quot;MySQL用户管理&quot;&gt;&lt;strong&gt;MySQL用户管理&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建普通用户&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行GRANT语句
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://wsdlxgp.top/categories/mysql/"/>
    
    
      <category term="sql结构化查询语句" scheme="https://wsdlxgp.top/tags/sql%E7%BB%93%E6%9E%84%E5%8C%96%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"/>
    
      <category term="数值类型" scheme="https://wsdlxgp.top/tags/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 事务(2)</title>
    <link href="https://wsdlxgp.top/posts/40d5.html"/>
    <id>https://wsdlxgp.top/posts/40d5.html</id>
    <published>2020-06-09T16:00:00.000Z</published>
    <updated>2020-06-19T05:15:25.985Z</updated>
    
    <content type="html"><![CDATA[<h1>一、MySQL设置事务自动提交（开启和关闭）</h1><p><strong>MySQL 默认开启事务自动提交模式，即除非显式的开启事务（BEGIN 或 START TRANSACTION），否则每条 SOL 语句都会被当做一个单独的事务自动执行。但有些情况下，我们需要关闭事务自动提交来保证数据的一致性。下面主要介绍如何设置事务自动提交模式。</strong></p><p><strong>在 MySQL 中，可以通过  SHOW VARIABLES 语句查看当前事务自动提交模式，如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW VARIABLES LIKE &#39;autocommit&#39;;<br>+---------------+-------+<br>| Variable_name | Value |<br>+---------------+-------+<br>| autocommit    | ON    |<br>+---------------+-------+<br>1 row in set, 1 warning (0.04 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，autocommit 的值是 ON，表示系统开启自动提交模式。</strong></p><p><strong>在 MySQL 中，可以使用 SET autocommit 语句设置事务的自动提交模式，语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET autocommit &#x3D; 0|1|ON|OFF;<br></code></pre></td></tr></table></figure><p><strong>对取值的说明：</strong></p><ul><li><strong>值为 0 和值为 OFF：关闭事务自动提交。如果关闭自动提交，用户将会一直处于某个事务中，只有提交或回滚后才会结束当前事务，重新开始一个新事务。</strong></li><li><strong>值为 1 和值为 ON：开启事务自动提交。如果开启自动提交，则每执行一条 SQL 语句，事务都会提交一次。</strong></li></ul><h2 id="示例">示例</h2><p><strong>下面我们关闭事务自动提交，模拟银行转账。</strong></p><p><strong>使用 SET autocommit 语句关闭事务自动提交，且张三转给李四 500 元，SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SET autocommit &#x3D; 0;                                                      ;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; SELECT * FROM mybank.bank;<br>+--------------+--------------+<br>| cusName | cusMoney |<br>+--------------+--------------+<br>| 张三         |      1000.00 |<br>| 李四         |         1.00 |<br>+--------------+--------------+<br>2 rows in set (0.00 sec)<br>mysql&gt; UPDATE bank SET cusMoney &#x3D; cusMoney-500 WHERE cusName&#x3D;&#39;张三&#39; ;<br>Query OK, 1 row affected (0.02 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>mysql&gt; UPDATE bank SET cusMoney &#x3D; cusMoney+500 WHERE cusName&#x3D;&#39;李四&#39;;<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br></code></pre></td></tr></table></figure><p><strong>这时重新打开一个 cmd 窗口，查看 bank 数据表中张三和李四的余额，SQL 语句和运行结果如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM mybank.bank;<br>+--------------+--------------+<br>| cusName | cusMoney |<br>+--------------+--------------+<br>| 张三         |      1000.00 |<br>| 李四         |         1.00 |<br>+--------------+--------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，张三和李四的余额是事务执行前的数据。</strong></p><p><strong>下面在之前的窗口中使用 COMMIT 语句提交事务，并查询 bank 数据表的数据，如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; COMMIT;<br>Query OK, 0 rows affected (0.07 sec)<br>mysql&gt; SELECT * FROM mybank.bank;<br>+--------------+--------------+<br>| cusName | cusMoney |<br>+--------------+--------------+<br>| 张三         |       500.00 |<br>| 李四         |       501.00 |<br>+--------------+--------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，bank 数据表的数据更新成功。</strong></p><p><strong>在本例中，关闭自动提交后，该位置会作为一个事务起点，直到执行 COMMIT 语句和 ROLLBACK 语句后，该事务才结束。结束之后，这就是下一个事务的起点。</strong></p><p><strong>关闭自动提交功能后，只用当执行 COMMIT 命令后，MySQL 才将数据表中的资料提交到数据库中。如果执行 ROLLBACK 命令，数据将会被回滚。如果不提交事务，而终止 MySQL 会话，数据库将会自动执行回滚操作。</strong></p><p><strong>使用 BEGIN 或 START TRANSACTION 开启一个事务之后，自动提交将保持禁用状态，直到使用 COMMIT 或 ROLLBACK 结束事务。之后，自动提交模式会恢复到之前的状态，即如果 BEGIN 前 autocommit = 1，则完成本次事务后 autocommit 还是 1。如果 BEGIN 前 autocommit = 0，则完成本次事务后 autocommit 还是 0。</strong></p><h1>二、MySQL事务隔离级别详解</h1><p><strong>在《<a href="http://c.biancheng.net/view/7289.html" target="_blank" rel="noopener">数据库事务</a>》一节中介绍了 MySQL 事务的四大特性，其中事务的隔离性就是指当多个事务同时运行时，各事务之间相互隔离，不可互相干扰。</strong></p><p><strong>如果事务没有隔离性，就容易出现脏读、不可重复读和幻读等情况。</strong></p><h4 id="1-脏读">1) 脏读</h4><p><strong>脏读是指一个事务正在访问数据，并且对数据进行了修改，但是这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</strong></p><h4 id="2-不可重复读">2) 不可重复读</h4><p><strong>不可重复读是指在一个事务内，多次读取同一个数据。</strong></p><p><strong>在这个事务还没有结束时，另外一个事务也访问了该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</strong></p><h4 id="3-幻读">3) 幻读</h4><p><strong>幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</strong></p><p><strong>为了解决以上这些问题，标准 SQL 定义了 4 类事务隔离级别，用来指定事务中的哪些数据改变是可见的，哪些数据改变是不可见的。</strong></p><h4 id="MySQL-包括的事务隔离级别如下："><strong>MySQL 包括的事务隔离级别如下：</strong></h4><ul><li><strong>读未提交（READ UNCOMITTED）</strong></li><li><strong>读提交（READ COMMITTED）</strong></li><li><strong>可重复读（REPEATABLE READ）</strong></li><li><strong>串行化（SERIALIZABLE）</strong></li></ul><h4 id="MySQL-事务隔离级别可能产生的问题如下表所示："><strong>MySQL 事务隔离级别可能产生的问题如下表所示：</strong></h4><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p><strong>MySQL 的事务的隔离级别由低到高分别为 READ UNCOMITTED、READ COMMITTED、REPEATABLE READ、SERIALIZABLE。低级别的隔离级别可以支持更高的并发处理，同时占用的系统资源更少。</strong></p><p><strong>下面根据实例来一一阐述它们的概念和联系。</strong></p><h2 id="1-读未提交（READ-UNCOMITTED，RU）">1. 读未提交（READ UNCOMITTED，RU）</h2><p><strong>顾名思义，读未提交就是可以读到未提交的内容。</strong></p><p><strong>如果一个事务读取到了另一个未提交事务修改过的数据，那么这种隔离级别就称之为读未提交。</strong></p><p><strong>在该隔离级别下，所有事务都可以看到其它未提交事务的执行结果。因为它的性能与其他隔离级别相比没有高多少，所以一般情况下，该隔离级别在实际应用中很少使用。</strong></p><p><strong>例 1 主要演示了在读未提交隔离级别中产生的脏读现象。</strong></p><h3 id="示例-1">示例 1</h3><h4 id="1-先在-test-数据库中创建-testnum-数据表，并插入数据。SQL-语句和执行结果如下：">1) 先在 test 数据库中创建 testnum 数据表，并插入数据。SQL 语句和执行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE TABLE testnum(<br>    -&gt; num INT(4));<br>Query OK, 0 rows affected (0.57 sec)<br>mysql&gt; INSERT INTO test.testnum (num) VALUES(1),(2),(3),(4),(5);<br>Query OK, 5 rows affected (0.09 sec)<br></code></pre></td></tr></table></figure><h4 id="2-下面的语句需要在两个命令行窗口中执行。为了方便理解，我们分别称之为-A-窗口和-B-窗口。">2) 下面的语句需要在两个命令行窗口中执行。为了方便理解，我们分别称之为 A 窗口和 B 窗口。</h4><p><strong>在 A 窗口中修改事务隔离级别，因为 A 窗口和 B 窗口的事务隔离级别需要保持一致，所以我们使用 SET GLOBAL TRANSACTION 修改全局变量。SQL 语句如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;<br>Query OK, 0 rows affected (0.04 sec)<br>flush privileges;<br>Query OK, 0 rows affected (0.04 sec)<br></code></pre></td></tr></table></figure><p><strong>查询事务隔离级别，SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#39;%tx_isolation%&#39;\G<br>*************************** 1. row ***************************<br>Variable_name: tx_isolation<br>        Value: READ-UNCOMMITTED<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，现在 MySQL 的事务隔离级别为 READ-UNCOMMITTED。</strong></p><h4 id="3-在-A-窗口中开启一个事务，并查询-testnum-数据表，SQL-语句和运行结果如下：">3) 在 A 窗口中开启一个事务，并查询 testnum 数据表，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; BEGIN;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; SELECT * FROM testnum;<br>+------+<br>| num  |<br>+------+<br>|    1 |<br>|    2 |<br>|    3 |<br>|    4 |<br>|    5 |<br>+------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="4-打开-B-窗口，查看当前-MySQL-的事务隔离级别，SQL-语句如下：">4) 打开 B 窗口，查看当前 MySQL 的事务隔离级别，SQL 语句如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#39;%tx_isolation%&#39;\G<br>*************************** 1. row ***************************<br>Variable_name: tx_isolation<br>        Value: READ-UNCOMMITTED<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>确定事务隔离级别是 READ-UNCOMMITTED 后，开启一个事务，并使用 UPDATE 语句更新 testnum 数据表，SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; BEGIN;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; UPDATE test.testnum SET num&#x3D;num*2 WHERE num&#x3D;2;<br>Query OK, 1 row affected (0.02 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br></code></pre></td></tr></table></figure><h4 id="5-现在返回-A-窗口，再次查询-testnum-数据表，SQL-语句和运行结果如下：">5) 现在返回 A 窗口，再次查询 testnum 数据表，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM testnum;<br>+------+<br>| num  |<br>+------+<br>|    1 |<br>|    4 |<br>|    3 |<br>|    4 |<br>|    5 |<br>+------+<br>5 rows in set (0.02 sec)<br></code></pre></td></tr></table></figure><p><strong>由结果可以看出，A 窗口中的事务读取到了更新后的数据。</strong></p><h4 id="6-下面在-B-窗口中回滚事务，SQL-语句和运行结果如下：">6) 下面在 B 窗口中回滚事务，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; ROLLBACK;<br>Query OK, 0 rows affected (0.09 sec)<br></code></pre></td></tr></table></figure><h4 id="7-在-A-窗口中查询-testnum-数据表，SQL-语句和运行结果如下：">7) 在 A 窗口中查询 testnum 数据表，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM testnum;<br>+------+<br>| num  |<br>+------+<br>|    1 |<br>|    2 |<br>|    3 |<br>|    4 |<br>|    5 |<br>+------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>当 MySQL 的事务隔离级别为 READ UNCOMITTED 时，首先分别在 A 窗口和 B 窗口中开启事务，在 B 窗口中的事务更新但未提交之前， A 窗口中的事务就已经读取到了更新后的数据。但由于 B 窗口中的事务回滚了，所以 A 事务出现了脏读现象。</strong></p><p><strong>使用读提交隔离级别可以解决实例中产生的脏读问题。</strong></p><h2 id="2-读提交（READ-COMMITTED，RC）">2. 读提交（READ COMMITTED，RC）</h2><p><strong>顾名思义，读提交就是只能读到已经提交了的内容。</strong></p><p><strong>如果一个事务只能读取到另一个已提交事务修改过的数据，并且其它事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那么这种隔离级别就称之为读提交。</strong></p><p><strong>该隔离级别满足了隔离的简单定义：一个事务从开始到提交前所做的任何改变都是不可见的，事务只能读取到已经提交的事务所做的改变。</strong></p><p><strong>这是大多数数据库系统的默认事务隔离级别（例如 Oracle、SQL Server），但不是 MySQL 默认的。</strong></p><p><strong>例 2 演示了在读提交隔离级别中产生的不可重复读问题。</strong></p><h3 id="示例-2">示例 2</h3><h4 id="1-使用-SET-语句将-MySQL-事务隔离级别修改为-READ-COMMITTED，并查看。SQL-语句和运行结果如下：">1) 使用 SET 语句将 MySQL 事务隔离级别修改为 READ COMMITTED，并查看。SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; show variables like &#39;%tx_isolation%&#39;\G<br>*************************** 1. row ***************************<br>Variable_name: tx_isolation<br>        Value: READ-COMMITTED<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="2-确定当前事务隔离级别为-READ-COMMITTED-后，开启一个事务，SQL-语句和运行结果如下：">2) 确定当前事务隔离级别为 READ COMMITTED 后，开启一个事务，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; BEGIN;<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="3-在-B-窗口中开启事务，并使用-UPDATE-语句更新-testnum-数据表，SQL-语句和运行结果如下：">3) 在 B 窗口中开启事务，并使用 UPDATE 语句更新 testnum 数据表，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; BEGIN;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt;  UPDATE test.testnum SET num&#x3D;num*2 WHERE num&#x3D;2;<br>Query OK, 1 row affected (0.07 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br></code></pre></td></tr></table></figure><h4 id="4-在-A-窗口中查询-testnum-数据表，SQL-语句和运行结果如下：">4) 在 A 窗口中查询 testnum 数据表，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * from test.testnum;<br>+------+<br>| num  |<br>+------+<br>|    1 |<br>|    2 |<br>|    3 |<br>|    4 |<br>|    5 |<br>+------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="5-提交-B-窗口中的事务，SQL-语句和运行结果如下：">5) 提交 B 窗口中的事务，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; COMMIT;<br>Query OK, 0 rows affected (0.07 sec)<br></code></pre></td></tr></table></figure><h4 id="6-在-A-窗口中查询-testnum-数据表，SQL-语句和运行结果如下：">6) 在 A 窗口中查询 testnum 数据表，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * from test.testnum;<br>+------+<br>| num  |<br>+------+<br>|    1 |<br>|    4 |<br>|    3 |<br>|    4 |<br>|    5 |<br>+------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>当 MySQL 的事务隔离级别为 READ COMMITTED 时，首先分别在 A 窗口和 B 窗口中开启事务，在 B 窗口中的事务更新并提交后，A 窗口中的事务读取到了更新后的数据。在该过程中，A 窗口中的事务必须要等待 B 窗口中的事务提交后才能读取到更新后的数据，这样就解决了脏读问题。而处于 A 窗口中的事务出现了不同的查询结果，即不可重复读现象。</strong></p><p><strong>使用可重复读隔离级别可以解决实例中产生的不可重复读问题。</strong></p><h2 id="3-可重复读（REPEATABLE-READ，RR）">3. 可重复读（REPEATABLE READ，RR）</h2><p><strong>顾名思义，可重复读是专门针对不可重复读这种情况而制定的隔离级别，可以有效的避免不可重复读。</strong></p><p><strong>在一些场景中，一个事务只能读取到另一个已提交事务修改过的数据，但是第一次读过某条记录后，即使其它事务修改了该记录的值并且提交，之后该事务再读该条记录时，读到的仍是第一次读到的值，而不是每次都读到不同的数据。那么这种隔离级别就称之为可重复读。</strong></p><p><strong>可重复读是 MySQL 的默认事务隔离级别，它能确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。在该隔离级别下，如果有事务正在读取数据，就不允许有其它事务进行修改操作，这样就解决了可重复读问题。</strong></p><p><strong>例 3 演示了在可重复读隔离级别中产生的幻读问题。</strong></p><h3 id="示例-3">示例 3</h3><h4 id="1-在-test-数据库中创建-testuser-数据表，SQL-语句和执行结果如下：">1) 在 test 数据库中创建 testuser 数据表，SQL 语句和执行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE TABLE testuser(<br>    -&gt; id INT (4) PRIMARY KEY,<br>    -&gt; name VARCHAR(20));<br>Query OK, 0 rows affected (0.29 sec)<br></code></pre></td></tr></table></figure><h4 id="2-使用-SET-语句修改事务隔离级别，SQL-语句如下：">2) 使用 SET 语句修改事务隔离级别，SQL 语句如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="3-在-A-窗口中开启事务，并查询-testuser-数据表，SQL-语句和运行结果如下：">3) 在 A 窗口中开启事务，并查询 testuser 数据表，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; BEGIN;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; SELECT * FROM test.testuser where id&#x3D;1;<br>Empty set (0.04 sec)<br></code></pre></td></tr></table></figure><h4 id="4-在-B-窗口中开启一个事务，并向-testuser-表中插入一条数据，SQL-语句和运行结果如下：">4) 在 B 窗口中开启一个事务，并向 testuser 表中插入一条数据，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; BEGIN;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt;  INSERT INTO test.testuser VALUES(1,&#39;zhangsan&#39;);<br>Query OK, 1 row affected (0.04 sec)<br>mysql&gt; COMMIT;<br>Query OK, 0 rows affected (0.06 sec)<br></code></pre></td></tr></table></figure><h4 id="5-现在返回-A-窗口，向-testnum-数据表中插入数据，SQL-语句和运行结果如下：">5) 现在返回 A 窗口，向 testnum 数据表中插入数据，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; INSERT INTO test.testuser VALUES(1,&#39;lisi&#39;);<br>ERROR 1062 (23000): Duplicate entry &#39;1&#39; for key &#39;PRIMARY&#39;<br>mysql&gt;  SELECT * FROM test.testuser where id&#x3D;1;<br>Empty set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>使用串行化隔离级别可以解决实例中产生的幻读问题。</strong></p><h2 id="4-串行化（SERIALIZABLE）">4. 串行化（SERIALIZABLE）</h2><p><strong>如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。那么这种隔离级别就称之为串行化。</strong></p><p><strong>SERIALIZABLE 是最高的事务隔离级别，主要通过强制事务排序来解决幻读问题。简单来说，就是在每个读取的数据行上加上共享锁实现，这样就避免了脏读、不可重复读和幻读等问题。但是该事务隔离级别执行效率低下，且性能开销也最大，所以一般情况下不推荐使用。</strong></p><h1>三、MySQL查看和修改事务隔离级别</h1><p><strong>在《<a href="http://c.biancheng.net/view/7265.html" target="_blank" rel="noopener">MySQL事务隔离级别</a>》一节中我们了解了 MySQL 的事务隔离级别，本节主要介绍查看和修改事务隔离级别的几种方法。</strong></p><h2 id="查看事务隔离级别">查看事务隔离级别</h2><p><strong>在 MySQL 中，可以通过<code>show variables like '%tx_isolation%'</code>或<code>select @@tx_isolation;</code>语句来查看当前事务隔离级别。</strong></p><p><strong>查看当前事务隔离级别的 SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#39;%tx_isolation%&#39;;<br>+---------------+-----------------+<br>| Variable_name | Value           |<br>+---------------+-----------------+<br>| tx_isolation  | REPEATABLE-READ |<br>+---------------+-----------------+<br>1 row in set, 1 warning (0.17 sec）<br>mysql&gt; select @@tx_isolation;<br>+-----------------+<br>| @@tx_isolation  |<br>+-----------------+<br>| REPEATABLE-READ |<br>+-----------------+<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，目前 MySQL 的事务隔离级别是 REPEATABLE-READ。</strong></p><p><strong>另外，还可以使用下列语句分别查询全局和会话的事务隔离级别：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT @@global.tx_isolation;<br>SELECT @@session.tx_isolation;<br></code></pre></td></tr></table></figure><p><strong>提示：在MySQL 8.0.3 中，tx_isolation 变量被 transaction_isolation 变量替换了。在 MySQL 8.0.3 版本中查询事务隔离级别，只要把上述查询语句中的 tx_isolation 变量替换成 transaction_isolation 变量即可。</strong></p><h2 id="修改事务隔离级别">修改事务隔离级别</h2><p><strong>MySQL 提供了 SET TRANSACTION 语句，该语句可以改变单个会话或全局的事务隔离级别。语法格式如下：</strong></p><p><strong>SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}</strong></p><p><strong>其中，SESSION 和 GLOBAL 关键字用来指定修改的事务隔离级别的范围：</strong></p><ul><li><strong>SESSION：表示修改的事务隔离级别将应用于当前 session（当前 cmd 窗口）内的所有事务；</strong></li><li><strong>GLOBAL：表示修改的事务隔离级别将应用于所有 session（全局）中的所有事务，且当前已经存在的 session 不受影响；</strong></li><li><strong>如果省略 SESSION 和 GLOBAL，表示修改的事务隔离级别将应用于当前 session 内的下一个还未开始的事务。</strong></li></ul><p><strong>任何用户都能改变会话的事务隔离级别，但是只有拥有 SUPER 权限的用户才能改变全局的事务隔离级别。</strong></p><p><strong>如果使用普通用户修改全局事务隔离级别，就会提示需要超级权限才能执行此操作的错误信息，SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">C:\Users\leovo&gt;mysql -utestuser -p<br>Enter password: ******<br>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 41<br>Server version: 5.7.29-log MySQL Community Server (GPL)<br> <br>Copyright (c) 2000, 2020, Oracle and&#x2F;or its affiliates. All rights reserved.<br> <br>Oracle is a registered trademark of Oracle Corporation and&#x2F;or its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br> <br>Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.<br> <br>mysql&gt; SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;<br>ERROR 1227 (42000): Access denied; you need (at least one of) the SUPER privilege(s) for this operation<br>mysql&gt; SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="示例-1-2">示例 1</h4><p><strong>使用 SET TRANSACTION 语句分别修改 session 和全局的事务隔离级别SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt;  select @@session.tx_isolation;<br>+------------------------+<br>| @@session.tx_isolation |<br>+------------------------+<br>| SERIALIZABLE           |<br>+------------------------+<br>1 row in set, 1 warning (0.00 sec)<br><br>mysql&gt; SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt;  select @@global.tx_isolation;<br>+-----------------------+<br>| @@global.tx_isolation |<br>+-----------------------+<br>| REPEATABLE-READ       |<br>+-----------------------+<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>还可以使用 set tx_isolation 命令直接修改当前 session 的事务隔离级别，SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; set tx_isolation&#x3D;&#39;READ-COMMITTED&#39;;<br>Query OK, 0 rows affected, 1 warning (0.00 sec)<br><br>mysql&gt; select @@session.tx_isolation;<br>+------------------------+<br>| @@session.tx_isolation |<br>+------------------------+<br>| READ-COMMITTED         |<br>+------------------------+<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;一、MySQL设置事务自动提交（开启和关闭）&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;MySQL 默认开启事务自动提交模式，即除非显式的开启事务（BEGIN 或 START TRANSACTION），否则每条 SOL 语句都会被当做一个单独的事务自动执行。但有些情况下，我们需要关
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://wsdlxgp.top/categories/mysql/"/>
    
    
      <category term="sql结构化查询语句" scheme="https://wsdlxgp.top/tags/sql%E7%BB%93%E6%9E%84%E5%8C%96%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"/>
    
      <category term="数值类型" scheme="https://wsdlxgp.top/tags/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
</feed>
