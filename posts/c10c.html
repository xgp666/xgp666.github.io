<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>04 DOCKER源码分析（一）：DOCKER架构 | Xgp &amp; Blog</title><meta name="description" content="1 背景 1.1 Docker简介 Docker是Docker公司开源的一个基于轻量级虚拟化技术的容器引擎项目,整个项目基于Go语言开发，并遵从Apache 2.0协议。目前，Docker可以在容器内部快速自动化部署应用，并可以通过内核虚拟化技术（namespaces及cgroups等）来提供容器的资源隔离与安全保障等。由于Docker通过操作系统层的虚拟化实现隔离，所以Docker容器在运行时，"><meta name="keywords" content="docker命令"><meta name="author" content="Wu Shao Dong"><meta name="copyright" content="Wu Shao Dong"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://gitee.com/xgpqq/tuchuang/raw/master/img/Yun.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="dns-prefetch" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="rPK0WSwqdm"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="04 DOCKER源码分析（一）：DOCKER架构"><meta name="twitter:description" content="1 背景 1.1 Docker简介 Docker是Docker公司开源的一个基于轻量级虚拟化技术的容器引擎项目,整个项目基于Go语言开发，并遵从Apache 2.0协议。目前，Docker可以在容器内部快速自动化部署应用，并可以通过内核虚拟化技术（namespaces及cgroups等）来提供容器的资源隔离与安全保障等。由于Docker通过操作系统层的虚拟化实现隔离，所以Docker容器在运行时，"><meta name="twitter:image" content="https://gitee.com/xgpqq/tuchuang/raw/master/img/323507 拷贝.jpg"><meta property="og:type" content="article"><meta property="og:title" content="04 DOCKER源码分析（一）：DOCKER架构"><meta property="og:url" content="https://wsdlxgp.top/posts/c10c.html"><meta property="og:site_name" content="Xgp &amp; Blog"><meta property="og:description" content="1 背景 1.1 Docker简介 Docker是Docker公司开源的一个基于轻量级虚拟化技术的容器引擎项目,整个项目基于Go语言开发，并遵从Apache 2.0协议。目前，Docker可以在容器内部快速自动化部署应用，并可以通过内核虚拟化技术（namespaces及cgroups等）来提供容器的资源隔离与安全保障等。由于Docker通过操作系统层的虚拟化实现隔离，所以Docker容器在运行时，"><meta property="og:image" content="https://gitee.com/xgpqq/tuchuang/raw/master/img/323507 拷贝.jpg"><meta property="article:published_time" content="2019-08-03T16:00:00.000Z"><meta property="article:modified_time" content="2020-06-18T12:26:36.933Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://wsdlxgp.top/posts/c10c.html"><link rel="prev" title="05 Dockers镜像分层" href="https://wsdlxgp.top/posts/4e5d.html"><link rel="next" title="03 Docker的基本操作命令" href="https://wsdlxgp.top/posts/f1f1.html"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?cad0cd04042fcca2c687648c42a45fc9";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: true,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Xgp & Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://gitee.com/xgpqq/tuchuang/raw/master/img/666.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">52</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">80</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">1.</span> <span class="toc-text">1 背景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Docker简介"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 Docker简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Docker版本信息"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 Docker版本信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">2.</span> <span class="toc-text">2 Docker架构分析内容安排</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">3.</span> <span class="toc-text">3 Docker总架构图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-DOCKER架构总体包含七个部分：client-daemon-driver-libcontainer-container-graph-registry。"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 DOCKER架构总体包含七个部分：client,daemon,driver,libcontainer,container,graph,registry。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-DockerClient"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 DockerClient</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-DockerDaemon"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 DockerDaemon</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-DockerServer"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 DockerServer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Engine"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 Engine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-DockerDriver"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 DockerDriver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-libcontainer"><span class="toc-number">3.7.</span> <span class="toc-text">3.6 libcontainer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">4.</span> <span class="toc-text">4 Docker架构内各模块的功能与实现分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Docker-Client"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 Docker Client</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Docker-Daemon"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 Docker Daemon</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-DOCKER-SERVER"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1 DOCKER SERVER</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-ENGINE"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2 ENGINE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-JOB"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3 JOB</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Docker-Registry"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 Docker Registry</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-Graph"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 Graph</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-Driver"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 Driver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-Docker-container"><span class="toc-number">4.6.</span> <span class="toc-text">4.7 Docker container</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">5.</span> <span class="toc-text">5 Docker运行案例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-docker-pull"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 docker pull</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-docker-run"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 docker run</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#"><span class="toc-number">6.</span> <span class="toc-text">6 总结</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://gitee.com/xgpqq/tuchuang/raw/master/img/323507 拷贝.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Xgp &amp; Blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">04 DOCKER源码分析（一）：DOCKER架构</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2019-08-04 00:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-08-04</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-18 20:26:36"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-18</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/docker/">docker</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon far fa-file-word" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">5.4k</span><span class="post-meta__separator">|</span><i class="post-meta__icon far fa-clock" aria-hidden="true"></i><span>阅读时长: 17 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1><strong>1 背景</strong></h1>
<h2 id="1-1-Docker简介">1.1 Docker简介</h2>
<p><strong>Docker是Docker公司开源的一个基于轻量级虚拟化技术的容器引擎项目,整个项目基于Go语言开发，并遵从Apache 2.0协议。目前，Docker可以在容器内部快速自动化部署应用，并可以通过内核虚拟化技术（namespaces及cgroups等）来提供容器的资源隔离与安全保障等。由于Docker通过操作系统层的虚拟化实现隔离，所以Docker容器在运行时，不需要类似虚拟机（VM）额外的操作系统开销，提高资源利用率，并且提升诸如IO等方面的性能。</strong><br>
<strong>由于众多新颖的特性以及项目本身的开放性，Docker在不到两年的时间里迅速获得诸多厂商的青睐，其中更是包括Google、Microsoft、VMware等业界行业领导者。Google在今年六月份推出了Kubernetes，提供Docker容器的调度服务，而今年8月Microsoft宣布Azure上支持Kubernetes，随后传统虚拟化巨头VMware宣布与Docker强强合作。今年9月中旬，Docker更是获得4000万美元的C轮融资，以推动分布式应用方面的发展。</strong><br>
<strong>从目前的形势来看，Docker的前景一片大好。本系列文章从源码的角度出发，详细介绍Docker的架构、Docker的运行以及Docker的卓越特性。本文是Docker源码分析系列的第一篇———Docker架构篇。</strong></p>
<h2 id="1-2-Docker版本信息"><strong>1.2 Docker版本信息</strong></h2>
<p><strong>本文关于Docker架构的分析都是基于Docker的源码与Docker相应版本的运行结果，其中Docker为最新的1.2版本。</strong></p>
<h1><strong>2 Docker架构分析内容安排</strong></h1>
<p><strong>本文的目的是：在理解Docker源代码的基础上，分析Docker架构。分析过程中主要按照以下三个步骤进行：</strong><br>
<strong>•	Docker的总架构图展示</strong><br>
<strong>•	Docker架构图内部各模块功能与实现分析</strong><br>
<strong>•	以Docker命令的执行为例，进行Docker运行流程阐述</strong></p>
<h1><strong>3 Docker总架构图</strong></h1>
<p><strong>学习Docker的源码并不是一个枯燥的过程，反而可以从中理解Docker架构的设计原理。Docker对使用者来讲是一个C/S模式的架构，而Docker的后端是一个非常松耦合的架构，模块各司其职，并有机组合，支撑Docker的运行。</strong><br>
<strong>在此，先附上Docker总架构，如图3.1。</strong><br>
<img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163240356.png" alt="image-20200607163240356"><br>
<strong>图3.1 Docker总架构图</strong><br>
<strong>如图3.1，不难看出，用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。</strong><br>
<strong>而Docker Daemon作为Docker架构中的主体部分，首先提供Server的功能使其可以接受Docker Client的请求；而后Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。</strong><br>
<strong>Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动graphdriver将下载镜像以Graph的形式存储；当需要为Docker创建网络环境时，通过网络管理驱动networkdriver创建并配置Docker容器网络环境；当需要限制Docker容器运行资源或执行用户指令等操作时，则通过execdriver来完成。</strong><br>
<strong>而libcontainer是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。</strong><br>
<strong>当执行完运行容器的命令后，一个实际的Docker容器就处于运行状态，该容器拥有独立的文件系统，独立并且安全的运行环境等。</strong></p>
<h2 id="3-1-DOCKER架构总体包含七个部分：client-daemon-driver-libcontainer-container-graph-registry。"><strong>3.1 DOCKER架构总体包含七个部分：client,daemon,driver,libcontainer,container,graph,registry。</strong></h2>
<p><strong>外表来看，docker是一个C/S的架构，用户可以在客户端输入各种指令，客户端负责接受请求并作出相应的响应返回给客户。</strong></p>
<h2 id="3-2-DockerClient"><strong>3.2 DockerClient</strong></h2>
<p><strong>DockerClient 负责接受并传递请求指令 。</strong></p>
<h2 id="3-3-DockerDaemon"><strong>3.3 DockerDaemon</strong></h2>
<p><strong>DockerDaemon的功能主要有两个：</strong></p>
<p><strong>负责接受client的请求 管理docker容器</strong><br>
<strong>dockerdaemon的架构主要可以分为两部分：dockerserver和engine</strong></p>
<h2 id="3-4-DockerServer"><strong>3.4 DockerServer</strong></h2>
<p><strong>DockerServer作为服务端最主要的作用就是配合client端将请求指令接受过来，如图所示，DockerServer主要分为三个部分：Http.server,mux.server,Handler。</strong><br>
<strong>DockerServer运行时会从一个名为mux的包中创建一个mux.Router路由器，然后为路由器中添加相关的路由项用于路由信息， 每个路由项由HTTP请求方法（get,post,put,delete）+URL+Handler三部分组成。</strong><br>
<strong>DockerServer每收到一个请求就会生成一个goroutine然后进行相应的解析、匹配相应的路由项最后会找到相匹配的Handler来处理，Handler处理玩请求之后给DockerClient返回响应。</strong></p>
<h2 id="3-5-Engine"><strong>3.5 Engine</strong></h2>
<p><strong>Engine是docker中的运行引擎，存储着大量的容器信息并管理着大部分job的执行。</strong><br>
<strong>job是docker中的最小执行单元，类似于unix中的进程，也会有相应的名字、参数、环境变量、标准输入输出、返回状态等等。docker每进行一次相应的操作都会 生成一个相应的Job，比如创建一个容器、下载一个文件等等都是由job完成的。</strong></p>
<h2 id="3-6-DockerDriver"><strong>3.6 DockerDriver</strong></h2>
<p><strong>DockerDriver是docker内部的驱动模块，负责容器内部相关网络、文件系统等的构建</strong></p>
<h2 id="3-6-libcontainer"><strong>3.6 libcontainer</strong></h2>
<p><strong>libcontainer主要是对linux内核的一些诸如namespace、cgroups、capabilities等特性做了封装</strong></p>
<h1><strong>4 Docker架构内各模块的功能与实现分析</strong></h1>
<p><strong>接下来，我们将从Docker总架构图入手，抽离出架构内各个模块，并对各个模块进行更为细化的架构分析与功能阐述。主要的模块有：Docker Client、Docker Daemon、Docker Registry、Graph、Driver、libcontainer以及Docker container。</strong></p>
<h2 id="4-1-Docker-Client"><strong>4.1 Docker Client</strong></h2>
<p><strong>Docker Client是Docker架构中用户用来和Docker Daemon建立通信的客户端。用户使用的可执行文件为docker，通过docker命令行工具可以发起众多管理container的请求。</strong><br>
<strong>Docker Client可以通过以下三种方式和Docker Daemon建立通信：tcp://host:port，unix://path_to_socket和fd://socketfd。为了简单起见，本文一律使用第一种方式作为讲述两者通信的原型。与此同时，与Docker Daemon建立连接并传输请求的时候，Docker Client可以通过设置命令行flag参数的形式设置安全传输层协议(TLS)的有关参数，保证传输的安全性。</strong><br>
<strong>Docker Client发送容器管理请求后，由Docker Daemon接受并处理请求，当Docker Client接收到返回的请求相应并简单处理后，Docker Client一次完整的生命周期就结束了。当需要继续发送容器管理请求时，用户必须再次通过docker可执行文件创建Docker Client。</strong></p>
<h2 id="4-2-Docker-Daemon"><strong>4.2 Docker Daemon</strong></h2>
<p><strong>Docker Daemon是Docker架构中一个常驻在后台的系统进程，功能是：接受并处理Docker Client发送的请求。该守护进程在后台启动了一个Server，Server负责接受Docker Client发送的请求；接受请求后，Server通过路由与分发调度，找到相应的Handler来执行请求。</strong><br>
<strong>Docker Daemon启动所使用的可执行文件也为docker，与Docker Client启动所使用的可执行文件docker相同。在docker命令执行时，通过传入的参数来判别Docker Daemon与Docker Client。</strong><br>
<strong>Docker Daemon的架构，大致可以分为以下三部分：Docker Server、Engine和Job。Daemon架构如图4.1。</strong><br>
<strong><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163320391.png" alt="image-20200607163320391"></strong><br>
<strong>图4.1 Docker Daemon架构示意图</strong></p>
<h3 id="4-2-1-DOCKER-SERVER"><strong>4.2.1 DOCKER SERVER</strong></h3>
<p><strong>Docker Server在Docker架构中是专门服务于Docker Client的server。该server的功能是：接受并调度分发Docker Client发送的请求。Docker Server的架构如图4.2。</strong><br>
<img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163335364.png" alt="image-20200607163335364">**<br>
<strong>图4.2 Docker Server架构示意图</strong><br>
<strong>在Docker的启动过程中，通过包gorilla/mux，创建了一个mux.Router，提供请求的路由功能。在Golang中，gorilla/mux是一个强大的URL路由器以及调度分发器。该mux.Router中添加了众多的路由项，每一个路由项由HTTP请求方法（PUT、POST、GET或DELETE）、URL、Handler三部分组成。</strong><br>
<strong>若Docker Client通过HTTP的形式访问Docker Daemon，创建完mux.Router之后，Docker将Server的监听地址以及mux.Router作为参数，创建一个httpSrv=http.Server{}，最终执行httpSrv.Serve()为请求服务。</strong><br>
<strong>在Server的服务过程中，Server在listener上接受Docker Client的访问请求，并创建一个全新的goroutine来服务该请求。在goroutine中，首先读取请求内容，然后做解析工作，接着找到相应的路由项，随后调用相应的Handler来处理该请求，最后Handler处理完请求之后回复该请求。</strong><br>
<strong>需要注意的是：Docker Server的运行在Docker的启动过程中，是靠一个名为”serveapi”的job的运行来完成的。原则上，Docker Server的运行是众多job中的一个，但是为了强调Docker Server的重要性以及为后续job服务的重要特性，将该”serveapi”的job单独抽离出来分析，理解为Docker Server。</strong></p>
<h3 id="4-2-2-ENGINE"><strong>4.2.2 ENGINE</strong></h3>
<p><strong>Engine是Docker架构中的运行引擎，同时也Docker运行的核心模块。它扮演Docker container存储仓库的角色，并且通过执行job的方式来操纵管理这些容器。</strong><br>
<strong>在Engine数据结构的设计与实现过程中，有一个handler对象。该handler对象存储的都是关于众多特定job的handler处理访问。举例说明，Engine的handler对象中有一项为：{“create”: daemon.ContainerCreate,}，则说明当名为”create”的job在运行时，执行的是daemon.ContainerCreate的handler。</strong></p>
<h3 id="4-2-3-JOB"><strong>4.2.3 JOB</strong></h3>
<p><strong>一个Job可以认为是Docker架构中Engine内部最基本的工作执行单元。Docker可以做的每一项工作，都可以抽象为一个job。例如：在容器内部运行一个进程，这是一个job；创建一个新的容器，这是一个job，从Internet上下载一个文档，这是一个job；包括之前在Docker Server部分说过的，创建Server服务于HTTP的API，这也是一个job，等等。</strong><br>
<strong>Job的设计者，把Job设计得与Unix进程相仿。比如说：Job有一个名称，有参数，有环境变量，有标准的输入输出，有错误处理，有返回状态等。</strong></p>
<h2 id="4-3-Docker-Registry"><strong>4.3 Docker Registry</strong></h2>
<p><strong>Docker Registry是一个存储容器镜像的仓库。而容器镜像是在容器被创建时，被加载用来初始化容器的文件架构与目录。</strong><br>
<strong>在Docker的运行过程中，Docker Daemon会与Docker Registry通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的job名称分别为”search”，”pull” 与 “push”。</strong><br>
<strong>其中，在Docker架构中，Docker可以使用公有的Docker Registry，即大家熟知的Docker Hub，如此一来，Docker获取容器镜像文件时，必须通过互联网访问Docker Hub；同时Docker也允许用户构建本地私有的Docker Registry，这样可以保证容器镜像的获取在内网完成。</strong></p>
<h2 id="4-4-Graph"><strong>4.4 Graph</strong></h2>
<p><strong>Graph在Docker架构中扮演已下载容器镜像的保管者，以及已下载容器镜像之间关系的记录者。一方面，Graph存储着本地具有版本信息的文件系统镜像，另一方面也通过GraphDB记录着所有文件系统镜像彼此之间的关系。Graph的架构如图4.3。</strong><br>
<img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163357944.png" alt="image-20200607163357944"><br>
<strong>图4.3 Graph架构示意图</strong><br>
<strong>其中，GraphDB是一个构建在SQLite之上的小型图数据库，实现了节点的命名以及节点之间关联关系的记录。它仅仅实现了大多数图数据库所拥有的一个小的子集，但是提供了简单的接口表示节点之间的关系。</strong><br>
<strong>同时在Graph的本地目录中，关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体rootfs。</strong></p>
<h2 id="4-5-Driver"><strong>4.5 Driver</strong></h2>
<p><strong>Driver是Docker架构中的驱动模块。通过Driver驱动，Docker可以实现对Docker容器执行环境的定制。由于Docker运行的生命周期中，并非用户所有的操作都是针对Docker容器的管理，另外还有关于Docker运行信息的获取，Graph的存储与记录等。因此，为了将Docker容器的管理从Docker Daemon内部业务逻辑中区分开来，设计了Driver层驱动来接管所有这部分请求。</strong><br>
<strong>在Docker Driver的实现中，可以分为以下三类驱动：graphdriver、networkdriver和execdriver。</strong><br>
<strong>graphdriver主要用于完成容器镜像的管理，包括存储与获取。即当用户需要下载指定的容器镜像时，graphdriver将容器镜像存储在本地的指定目录；同时当用户需要使用指定的容器镜像来创建容器的rootfs时，graphdriver从本地镜像存储目录中获取指定的容器镜像。</strong><br>
<strong>在graphdriver的初始化过程之前，有4种文件系统或类文件系统在其内部注册，它们分别是aufs、btrfs、vfs和devmapper。而Docker在初始化之时，通过获取系统环境变量”DOCKER_DRIVER”来提取所使用driver的指定类型。而之后所有的graph操作，都使用该driver来执行。</strong><br>
<strong>graphdriver的架构如图4.4：</strong><br>
<img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163420030.png" alt="image-20200607163420030"><br>
<strong>图4.4 graphdriver架构示意图</strong><br>
<strong>networkdriver的用途是完成Docker容器网络环境的配置，其中包括Docker启动时为Docker环境创建网桥；Docker容器创建时为其创建专属虚拟网卡设备；以及为Docker容器分配IP、端口并与宿主机做端口映射，设置容器防火墙策略等。networkdriver的架构如图4.5：</strong><br>
<img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163437181.png" alt="image-20200607163437181"><br>
<strong>图4. 5 networkdriver架构示意图</strong><br>
<strong>execdriver作为Docker容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。在execdriver的实现过程中，原先可以使用LXC驱动调用LXC的接口，来操纵容器的配置以及生命周期，而现在execdriver默认使用native驱动，不依赖于LXC。具体体现在Daemon启动过程中加载的ExecDriverflag参数，该参数在配置文件已经被设为”native”。这可以认为是Docker在1.2版本上一个很大的改变，或者说Docker实现跨平台的一个先兆。execdriver架构如图4.6：</strong><br>
<img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163537490.png" alt="image-20200607163537490"></p>
<p><strong>图4.6 execdriver架构示意图</strong><br>
<strong>4.6 libcontainer</strong><br>
<strong>libcontainer是Docker架构中一个使用Go语言设计实现的库，设计初衷是希望该库可以不依靠任何依赖，直接访问内核中与容器相关的API。</strong><br>
<strong>正是由于libcontainer的存在，Docker可以直接调用libcontainer，而最终操纵容器的namespace、cgroups、apparmor、网络设备以及防火墙规则等。这一系列操作的完成都不需要依赖LXC或者其他包。libcontainer架构如图4.7：</strong><br>
<img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163545287.png" alt="image-20200607163545287"><br>
<strong>图4.7 libcontainer示意图</strong><br>
<strong>另外，libcontainer提供了一整套标准的接口来满足上层对容器管理的需求。或者说，libcontainer屏蔽了Docker上层对容器的直接管理。又由于libcontainer使用Go这种跨平台的语言开发实现，且本身又可以被上层多种不同的编程语言访问，因此很难说，未来的Docker就一定会紧紧地和Linux捆绑在一起。而于此同时，Microsoft在其著名云计算平台Azure中，也添加了对Docker的支持，可见Docker的开放程度与业界的火热度。</strong><br>
<strong>暂不谈Docker，由于libcontainer的功能以及其本身与系统的松耦合特性，很有可能会在其他以容器为原型的平台出现，同时也很有可能催生出云计算领域全新的项目。</strong></p>
<h2 id="4-7-Docker-container"><strong>4.7 Docker container</strong></h2>
<p><strong>Docker container（Docker容器）是Docker架构中服务交付的最终体现形式。</strong><br>
<strong>Docker按照用户的需求与指令，订制相应的Docker容器：</strong><br>
<strong>•	用户通过指定容器镜像，使得Docker容器可以自定义rootfs等文件系统；</strong><br>
<strong>•	用户通过指定计算资源的配额，使得Docker容器使用指定的计算资源；</strong><br>
<strong>•	用户通过配置网络及其安全策略，使得Docker容器拥有独立且安全的网络环境；</strong><br>
<strong>•	用户通过指定运行的命令，使得Docker容器执行指定的工作。</strong><br>
<strong>Docker容器示意图如图4.8：</strong><br>
<img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163611716.png" alt="image-20200607163611716"><br>
<strong>图4.8 Docker容器示意图</strong></p>
<h1><strong>5 Docker运行案例分析</strong></h1>
<p><strong>上一章节着重于Docker架构中各个部分的介绍。本章的内容，将以串联Docker各模块来简要分析，分析原型为Docker中的docker pull与docker run两个命令。</strong></p>
<h2 id="5-1-docker-pull"><strong>5.1 docker pull</strong></h2>
<p><strong>docker pull命令的作用为：从Docker Registry中下载指定的容器镜像，并存储在本地的Graph中，以备后续创建Docker容器时的使用。docker pull命令执行流程如图5.1。</strong><br>
<img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163644214.png" alt="image-20200607163644214"><br>
<strong>图5.1 docker pull命令执行流程示意图</strong><br>
<strong>如图，图中标记的红色箭头表示docker pull命令在发起后，Docker所做的一系列运行。以下逐一分析这些步骤。</strong><br>
<strong>(1) Docker Client接受docker pull命令，解析完请求以及收集完请求参数之后，发送一个HTTP请求给Docker Server，HTTP请求方法为POST，请求URL为”/images/create? “+”xxx”；</strong><br>
<strong>(2) Docker Server接受以上HTTP请求，并交给mux.Router，mux.Router通过URL以及请求方法来确定执行该请求的具体handler；</strong><br>
<strong>(3) mux.Router将请求路由分发至相应的handler，具体为PostImagesCreate；</strong><br>
<strong>(4) 在PostImageCreate这个handler之中，一个名为”pull”的job被创建，并开始执行；</strong><br>
<strong>(5) 名为”pull”的job在执行过程中，执行pullRepository操作，即从Docker Registry中下载相应的一个或者多个image；</strong><br>
<strong>(6) 名为”pull”的job将下载的image交给graphdriver；</strong><br>
<strong>(7) graphdriver负责将image进行存储，一方创建graph对象，另一方面在GraphDB中记录image之间的关系。</strong></p>
<h2 id="5-2-docker-run"><strong>5.2 docker run</strong></h2>
<p><strong>docker run命令的作用是在一个全新的Docker容器内部运行一条指令。Docker在执行这条命令的时候，所做工作可以分为两部分：第一，创建Docker容器所需的rootfs；第二，创建容器的网络等运行环境，并真正运行用户指令。因此，在整个执行流程中，Docker Client给Docker Server发送了两次HTTP请求，第二次请求的发起取决于第一次请求的返回状态。Docker run命令执行流程如图5.2。</strong><br>
<img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163706160.png" alt="image-20200607163706160"><br>
<strong>图5.2 docker run命令执行流程示意图</strong><br>
<strong>如图，图中标记的红色箭头表示docker run命令在发起后，Docker所做的一系列运行。以下逐一分析这些步骤。</strong><br>
<strong>(1) Docker Client接受docker run命令，解析完请求以及收集完请求参数之后，发送一个HTTP请求给Docker Server，HTTP请求方法为POST，请求URL为”/containers/create? “+”xxx”；</strong><br>
<strong>(2) Docker Server接受以上HTTP请求，并交给mux.Router，mux.Router通过URL以及请求方法来确定执行该请求的具体handler；</strong><br>
<strong>(3) mux.Router将请求路由分发至相应的handler，具体为PostContainersCreate；</strong><br>
<strong>(4) 在PostImageCreate这个handler之中，一个名为”create”的job被创建，并开始让该job运行；</strong><br>
<strong>(5) 名为”create”的job在运行过程中，执行Container.Create操作，该操作需要获取容器镜像来为Docker容器创建rootfs，即调用graphdriver；</strong><br>
<strong>(6) graphdriver从Graph中获取创建Docker容器rootfs所需要的所有的镜像；</strong><br>
<strong>(7) graphdriver将rootfs所有镜像，加载安装至Docker容器指定的文件目录下；</strong><br>
<strong>(8) 若以上操作全部正常执行，没有返回错误或异常，则Docker Client收到Docker Server返回状态之后，发起第二次HTTP请求。请求方法为”POST”，请求URL为”/containers/”+containerID+”/start”；</strong><br>
<strong>(9) Docker Server接受以上HTTP请求，并交给mux.Router，mux.Router通过URL以及请求方法来确定执行该请求的具体handler；</strong><br>
<strong>(10) mux.Router将请求路由分发至相应的handler，具体为PostContainersStart；</strong><br>
<strong>(11) 在PostContainersStart这个handler之中，名为”start”的job被创建，并开始执行；</strong><br>
<strong>(12) 名为”start”的job执行完初步的配置工作后，开始配置与创建网络环境，调用networkdriver；</strong><br>
<strong>(13) networkdriver需要为指定的Docker容器创建网络接口设备，并为其分配IP，port，以及设置防火墙规则，相应的操作转交至libcontainer中的netlink包来完成；</strong><br>
<strong>(14) netlink完成Docker容器的网络环境配置与创建；</strong><br>
<strong>(15) 返回至名为”start”的job，执行完一些辅助性操作后，job开始执行用户指令，调用execdriver；</strong><br>
<strong>(16) execdriver被调用，初始化Docker容器内部的运行环境，如命名空间，资源控制与隔离，以及用户命令的执行，相应的操作转交至libcontainer来完成；</strong><br>
<strong>(17) libcontainer被调用，完成Docker容器内部的运行环境初始化，并最终执行用户要求启动的命令。</strong></p>
<h1><strong>6 总结</strong></h1>
<p><strong>本文从Docker 1.2的源码入手，分析抽象出Docker的架构图，并对该架构图中的各个模块进行功能与实现的分析，最后通过两个docker命令展示了Docker内部的运行。</strong><br>
<strong>通过对Docker架构的学习，可以全面深化对Docker设计、功能与价值的理解。同时在借助Docker实现用户定制的分布式系统时，也能更好地找到已有平台与Docker较为理想的契合点。另外，熟悉Docker现有架构以及设计思想，也能对云计算PaaS领域带来更多的启发，催生出更多实践与创新。</strong><br>
链接：<a href="https://www.2cto.com/kf/201701/582655.html" target="_blank" rel="noopener">https://www.2cto.com/kf/201701/582655.html</a><br>
链接：<a href="https://blog.csdn.net/gsllovefly/article/details/51083419" target="_blank" rel="noopener">https://blog.csdn.net/gsllovefly/article/details/51083419</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Wu Shao Dong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wsdlxgp.top/posts/c10c.html">https://wsdlxgp.top/posts/c10c.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wsdlxgp.top" target="_blank">Xgp & Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/docker%E5%91%BD%E4%BB%A4/">docker命令</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/xgpqq/tuchuang/raw/master/img/323507 拷贝.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="http://xgp-cunchu.test.upcdn.net/k8s/3.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="http://xgp-cunchu.test.upcdn.net/k8s/1.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li><li class="reward-item"><img class="post-qr-code__img" src="http://xgp-cunchu.test.upcdn.net/k8s/2.jpg" alt="QQ支付"/><div class="post-qr-code__desc">QQ支付</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/posts/4e5d.html"><img class="prev_cover" src="https://gitee.com/xgpqq/tuchuang/raw/master/img/323507 拷贝.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">05 Dockers镜像分层</div></div></a></div><div class="next-post pull_right"><a href="/posts/f1f1.html"><img class="next_cover" src="https://gitee.com/xgpqq/tuchuang/raw/master/img/323507 拷贝.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">03 Docker的基本操作命令</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/f1f1.html" title="03 Docker的基本操作命令"><img class="relatedPosts_cover" src="https://gitee.com/xgpqq/tuchuang/raw/master/img/323507 拷贝.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-history fa-fw" aria-hidden="true"></i> 2020-06-18</div><div class="relatedPosts_title">03 Docker的基本操作命令</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC80OTM0NS8yNTgzNw=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></article></main><footer id="footer" style="background-image: url(https://gitee.com/xgpqq/tuchuang/raw/master/img/323507 拷贝.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Wu Shao Dong</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="ypy"><a href="https://console.upyun.com/services/file/" target="_blank" rel="noopener"><img class="icp-icon" src="/img/1591433700(1).png"/><span></span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode far fa-moon" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>