<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL自带工具使用介绍</title>
      <link href="/posts/f96f.html"/>
      <url>/posts/f96f.html</url>
      
        <content type="html"><![CDATA[<h1>一、MySQL自带工具使用介绍</h1><p><strong>MySQL数据库不仅提供了数据库的服务器端应用程序，同时还提供了大量的客户端工具程序，如mysql，mysqladmin，mysqldump等等 。</strong></p><p>语法格式：</p><blockquote><p><strong>Usage: mysql [OPTIONS] [database] 例如：</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># mysql -e &quot;select user,host from user&quot; mysql<br></code></pre></td></tr></table></figure><p><strong>大家只要运行一下“mysql --help”就会得到如下相应的基本使用帮助信息：</strong></p><p><strong>这里主要介绍一些在运维过程中会用到的相关选项： 首先看看“-e, --execute=name”参数，这个参数是告诉</strong><br><strong>mysql，我要执行“-e”后面的某个命令，而不是要通过mysql连接登录到MySQL Server 上面。此参数在我们写一些基本的MySQL 检查和监控的脚本中非常有用，运维mysql时经常在脚本中使用到它。</strong></p><blockquote><p><strong>#mysql -hhostname -Pport -uusername -ppassword -e 相关mysql的sql语句</strong></p></blockquote><h2 id="1、mysql命令">1、mysql命令</h2><p><strong>Mysql命令是用的最多的一个命令工具了，为用户提供一个命令行接口来操作管理MySQL 服务器。可以通过mysql --help来查看其详细使用方法。</strong></p><table><thead><tr><th>mysql命令选项</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>-u</td><td>指定连接数据库时使用的用户</td><td></td></tr><tr><td>-p</td><td>指定用户的密码</td><td>可以-p后面直接写密码，也可以不写，进行交互式输入密码，推荐后者</td></tr><tr><td>-h</td><td>指定要登录的主机</td><td>可选，如果为空，则登录本机</td></tr><tr><td>-P</td><td>指定要连接的端口</td><td>可选，默认是3306</td></tr><tr><td>-e</td><td>可以通过-e命令直接执行SQL语句，而不用进入数据库</td><td>免交互登录数据库执行SQL语句，通常在脚本中使用</td></tr><tr><td>-D</td><td>指定要登录到哪个库</td><td>默认不会登录到库，可以省略此选项，直接写库名</td></tr><tr><td>-E</td><td>查询到的结果以行来显示</td><td>类似于每条SQL语句后面加“\G”</td></tr><tr><td>-f</td><td>即使出现SQL错误，也强制继续</td><td>比如在不登陆数据库执行删除库的操作会有一个交互式的确认操作，可以使用此选项来避免交互式</td></tr><tr><td>-X</td><td>将查询到的数据导出位xml文件</td><td>导出的文件在windows系统中可以使用excel表格打开</td></tr><tr><td>-H</td><td>将查询到的数据导出位html文件</td><td>导出的文件在windows系统中可以使用浏览器打开</td></tr><tr><td>–prompt</td><td>定制自己的MySQL提示符显示的内容</td><td>默认登登录到MySQL后的提示符是“mysql &gt;”，可以使用该选项定制提示符</td></tr><tr><td>–tee</td><td>将操作数据库所有输入和输出的内容都记录进文件中</td><td>在一些较大维护变更的时候，为了方便被查，可以将整个操作过程中的输出信息保存到某个文件中</td></tr></tbody></table><p><strong>这里主要介绍一些在运维过程中会用到的相关选项。</strong></p><h3 id="1）-e、-u、-p、-h、-P、-等选项的使用语法">1）-e、-u、-p、-h、-P、 等选项的使用语法</h3><p><strong>首先看看“-e, --execute=name”参数，这个参数是告诉mysql，我要执行“-e”后面的某个命令，而不是要通过mysql连接登录到MySQL Server 上面。此参数在我们写一些基本的MySQL 检查和监控的脚本中非常有用，运维mysql时经常在脚本中使用到它。</strong></p><h5 id="语法格式：">语法格式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@mysql ~]# mysql  -hhostname -Pport -uusername -ppassword  -e  相关mysql的sql语句<br></code></pre></td></tr></table></figure><h4 id="示例1：免登录执行sql语句">示例1：免登录执行sql语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@mysql ~]# mysql -hlocalhost -P3306 -uroot -p mysql -e &quot;select user,host from user;&quot;<br>Enter password: <br>+---------------+-----------+<br>| user          | host      |<br>+---------------+-----------+<br>| bankMaster    | %         |<br>| bankMaster    | 127.0.0.1 |<br>| epetadmin     | localhost |<br>| mysql.session | localhost |<br>| mysql.sys     | localhost |<br>| root          | localhost |<br>+---------------+-----------+<br></code></pre></td></tr></table></figure><h4 id="示例2：">示例2：</h4><p><strong>通过binlog_cache_use 以及 binlog_cache_disk_use来分析设置的binlog_cache_size是否足够</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">[root@mysql ~]#  mysql -uroot -p -e &quot;show status like &#39;binlog_cache%&#39;&quot;<br>Enter password: <br>+-----------------------+-------+<br>| Variable_name         | Value |<br>+-----------------------+-------+<br>| Binlog_cache_disk_use | 0     |<br>| Binlog_cache_use      | 0     |<br>+-----------------------+-------+<br></code></pre></td></tr></table></figure><h4 id="示例3：">示例3：</h4><p><strong>通过脚本创建数据库、表及对表进行增、改、删、查操作.脚本内容如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># cat mysql1.sh<br><br>#!&#x2F;bin&#x2F;bash<br>HOSTNAME&#x3D;&quot;localhost&quot;<br>PORT&#x3D;&quot;3306&quot;<br>USERNAME&#x3D;&quot;root&quot;<br>PASSWORD&#x3D;&quot;123&quot;<br>DBNAME&#x3D;&quot;test_db&quot;<br>TABLENAME&#x3D;&quot;tb1&quot;<br><br>#create database<br>create_db_sql&#x3D;&quot;create database if not exists $&#123;DBNAME&#125;&quot;<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; -e &quot;$&#123;create_db_sql&#125;&quot;<br><br>#create table<br>create_table_sql&#x3D;&quot;create table if not exists $&#123;TABLENAME&#125; (name varchar(20),id int default 0)&quot;<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e &quot;$&#123;create_table_sql&#125;&quot;<br><br>#insert data to table<br>insert_sql&#x3D;&quot;insert into $&#123;TABLENAME&#125; values (&#39;tom&#39;,1)&quot;<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e &quot;$&#123;insert_sql&#125;&quot;<br><br>#select data<br>select_sql&#x3D;&quot;select * from $&#123;TABLENAME&#125;&quot;<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e &quot;$&#123;select_sql&#125;&quot;<br><br>#update data<br>update_sql&#x3D;&quot;update $&#123;TABLENAME&#125; set id&#x3D;3&quot;<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e &quot;$&#123;update_sql&#125;&quot;<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e &quot;$&#123;select_sql&#125;&quot;<br><br>#delete data<br>delete_sql&#x3D;&quot;delete from $&#123;TABLENAME&#125;&quot;<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e &quot;$&#123;delete_sql&#125;&quot;<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e &quot;$&#123;select_sql&#125;&quot;<br></code></pre></td></tr></table></figure><h4 id="执行一下">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# sh mysql1.sh <br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>+------+------+<br>| name | id   |<br>+------+------+<br>| tom  |    1 |<br>+------+------+<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>+------+------+<br>| name | id   |<br>+------+------+<br>| tom  |    3 |<br>+------+------+<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br></code></pre></td></tr></table></figure><h2 id="2、-E">2、-E</h2><p><strong>如果在连接时候使用了“-E, --vertical”参数，登入之后的所有查询结果都将以纵列显示，效果和我们在一条query 之后以“\G”结尾一样。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># mysql -uroot -p123 -E<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>Welcome to the MySQL monitor. Commands end with ; or \g.<br>Your MySQL connection id is 27<br>Server version: 5.7.22 Source distribution<br>Copyright (c) 2000, 2018, Oracle and&#x2F;or its affiliates. All rights reserved.<br>Oracle is a registered trademark of Oracle Corporation and&#x2F;or its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br>Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.<br>mysql&gt; show databases;<br>*************************** 1. row ***************************<br>Database: information_schema<br>*************************** 2. row ***************************<br>Database: mysql<br>*************************** 3. row ***************************<br>Database: test_db<br>10 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>“-H, --html”与“-X, --xml”，在启用这两个参数之后，select出来的所有结果都会按照“Html”与“Xml”格式来输出，在有些场合之下，比如希望Xml或者Html 文件格式导出某些报表文件的时候，是非常方便的。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@192 ~]# mysql -utest -p -X<br>Enter password: <br>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 40<br>Server version: 5.7.30 MySQL Community Server (GPL)<br><br>Copyright (c) 2000, 2020, Oracle and&#x2F;or its affiliates. All rights reserved.<br><br>Oracle is a registered trademark of Oracle Corporation and&#x2F;or its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br><br>Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.<br><br>mysql&gt; use test_db;<br>Reading table information for completion of table and column names<br>You can turn off this feature to get a quicker startup with -A<br><br>Database changed<br>mysql&gt; select * from tb1;<br>&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;<br><br>&lt;resultset statement&#x3D;&quot;select * from tb1;&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;&gt;<br>  &lt;row&gt;<br>        &lt;field name&#x3D;&quot;name&quot;&gt;tom&lt;&#x2F;field&gt;<br>        &lt;field name&#x3D;&quot;id&quot;&gt;1&lt;&#x2F;field&gt;<br>  &lt;&#x2F;row&gt;<br><br>  &lt;row&gt;<br>        &lt;field name&#x3D;&quot;name&quot;&gt;tom&lt;&#x2F;field&gt;<br>        &lt;field name&#x3D;&quot;id&quot;&gt;2&lt;&#x2F;field&gt;<br>  &lt;&#x2F;row&gt;<br><br>  &lt;row&gt;<br>        &lt;field name&#x3D;&quot;name&quot;&gt;tom&lt;&#x2F;field&gt;<br>        &lt;field name&#x3D;&quot;id&quot;&gt;3&lt;&#x2F;field&gt;<br>  &lt;&#x2F;row&gt;<br>&lt;&#x2F;resultset&gt;<br>3 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><h2 id="3、-H选项的使用方式">3、-H选项的使用方式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# mysql -H -uroot -p123.com -e "select * from mysql.user" &gt; a.html<br><span class="hljs-meta">#</span><span class="bash">将查询的结果重定向输出到a.html文件中</span><br>[root@mysql ~]# sz a.html    #下载这个文件到本地windows系统<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200618184838389.png" alt="image-20200618184838389"></p><h2 id="4、创建授予test用户可以在指定的源登录">4、创建授予test用户可以在指定的源登录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># mysql -uroot -p -e &quot;grant all on test_db.* to root@&#39;192.168.1.10&#39; identified by<br>&#39;123&#39;&quot;<br>Enter password:<br></code></pre></td></tr></table></figure><h4 id="测试test用户连接mysql服务器">测试test用户连接mysql服务器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@mysql ~]# mysql -u root -p -e &quot;grant all on test_db.* to test@&#39;192.168.1.%&#39; identified by &#39;123&#39;&quot;<br>Enter password: <br>[root@mysql ~]#  mysql -utest -p123 -h 192.168.1.10<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 18<br>Server version: 5.7.22 MySQL Community Server (GPL)<br><br>Copyright (c) 2000, 2018, Oracle and&#x2F;or its affiliates. All rights reserved.<br><br>Oracle is a registered trademark of Oracle Corporation and&#x2F;or its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br><br>Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.<br><br>mysql&gt;<br></code></pre></td></tr></table></figure><h1>二、–prompt使用方法</h1><p><strong>“–prompt=name”参数对于做运维的人来说是一个非常重要的参数选项，其主要功能是<code>定制自己的mysql提示符的显示内容。</code></strong></p><p><strong>在默认情况下，我们通过mysql登入到数据库之后，mysql的提示符只是一个很简单的内容”mysql&gt;“，没有其他任何附加信息。非常幸运的是mysql通过“<code>--prompt=name</code>”参数给我们提供了自定义提示信息的办法，可以通过配置显示登入的主机地址，登录用户名，当前时间，当前数据库schema，MySQL Server 的一些信息等等。</strong></p><p><strong>个人强烈建议将登录主机名，登录用户名和所在的schema 这三项加入提示内容，因为当大家手边管理的MySQL 越来越多，操作越来越频繁的时候，非常容易因为操作的时候没有太在意自己当前所处的环境而造成在错误的环境执行了错误的命令并造成严重后果的情况。如果我们在提示内容中加入了这几项之后，至少可以更方便的提醒自己当前所处环境，以尽量减少犯错误的概率.</strong></p><p><strong>个人强烈建议提示符定义：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&quot;\\u@\\h : \\d \\r:\\m:\\s&gt; &quot;<br></code></pre></td></tr></table></figure><h4 id="提示符解释：">提示符解释：</h4><ul><li><strong>\u ：表示用户名,</strong></li><li><strong>\h ：表示主机名，</strong></li><li><strong>\d ：表示当前数据库，</strong></li><li><strong>\r小时：（12小时制），</strong></li><li><strong>\R小时（24小时制），</strong></li><li><strong>\m：分种，</strong></li><li><strong>\s秒，</strong></li></ul><h4 id="显示效果">显示效果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@mysql ~]# mysql -uroot -p --prompt&#x3D;&quot;\\u@\\h: \\d \\r:\\m:\\s&quot;<br>Enter password: <br>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 26<br>Server version: 5.7.22 MySQL Community Server (GPL)<br><br>Copyright (c) 2000, 2018, Oracle and&#x2F;or its affiliates. All rights reserved.<br><br>Oracle is a registered trademark of Oracle Corporation and&#x2F;or its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br><br>Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.<br><br>root@localhost: (none) 04:54:56&gt; use test_db<br>Reading table information for completion of table and column names<br>You can turn off this feature to get a quicker startup with -A<br><br>Database changed<br>root@localhost: (none) 04:54:56&gt;<br></code></pre></td></tr></table></figure><h1>三、–tee的使用方法</h1><p><strong>“–tee=name”参数也是对运维人员非常有用的参数选项，用来告诉mysql，将所有输入和输出内容都记录进文件。在我们一些较大维护变更的时候，为了方便被查，最好是将整个操作过程的所有输入和输出内容都保存下来.假如mysql命令行状态下，要进行大量的交互操作，其实可以把这些操作记录在log中进行审计，很简单 <code>mysql -u root -p --tee=/path/xxxx.log</code></strong></p><p><strong>也可以在服务器上的/etc/my.cnf中的[client]加入 tee =/tmp/client_mysql.log即可. 注：若没有[client]就添加即可 或者在mysql&gt;提示符下执行下面的命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; tee &#x2F;opt&#x2F;xgp.log<br>Logging to file &#39;&#x2F;opt&#x2F;xgp.log&#39;<br>mysql&gt; show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>| test_db            |<br>+--------------------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="查看一下">查看一下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@mysql ~]# cat &#x2F;opt&#x2F;xgp.log <br>mysql&gt; tee &#x2F;opt&#x2F;xgp.log<br>Logging to file &#39;&#x2F;opt&#x2F;xgp.log&#39;<br>mysql&gt; show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>| test_db            |<br>+--------------------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>同样，“–tee”这个配置项也可以写入my.cnf这个主配置文件中的client字段下，如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# vim /etc/my.cnf <br><br>[client]<br>socket=/usr/local/mysql/mysql.sock<br>[mysqld]<br>basedir=/usr/local/mysql<br>datadir=/usr/local/mysql/data<br>pid-file=/usr/local/mysql/data/mysql.pid<br>socket=/usr/local/mysql/mysql.sock<br>log-error=/usr/local/mysql/data/mysql.err<br>tee=/opt/xgp.log<br></code></pre></td></tr></table></figure><h1>四、mysqladmin命令</h1><p><strong>mysqladmin,顾名思义,提供的功能都是与MySQL管理相关的各种功能。如MySQL Server状态检查,各种统计信息的flush,创建/删除数据库，关闭MySQL Server等等。mysqladmin所能做的事情，虽然大部分都可以通过mysql连接登录上MySQL Server之后来完成，但是大部分通过mysqladmin来完成操作会更简单更方便。</strong><br><strong>mysqladmin后面可以接选项，也可以接命令,这里就不说选项了，主要说一下命令</strong></p><table><thead><tr><th>命令字</th><th>作用</th></tr></thead><tbody><tr><td>create databasename</td><td>创建一个库</td></tr><tr><td>drop databasename</td><td>删除一个库</td></tr><tr><td>status</td><td>查询MySQL的基本状态（显示的信息有限 ）</td></tr><tr><td>extended-status</td><td>查询服务器的详细状态信息（类似于在数据库中执行show status;）</td></tr><tr><td>flush-hosts</td><td>刷新服务器缓存</td></tr><tr><td>flush-logs</td><td>刷新二进制日志文件（如果二进制日志功能开启，那么执行这个操作会生成新的二进制日志文件）</td></tr><tr><td>flush-status</td><td>刷新状态变量</td></tr><tr><td>flush-tables</td><td>刷新所有表</td></tr><tr><td>flush-threads</td><td>刷新所有线程缓存</td></tr><tr><td>flush-privileges</td><td>重新加载授权表</td></tr><tr><td>processlist</td><td>查看当前连接数据库的所有ID详细信息</td></tr><tr><td>kill id</td><td>杀掉某个或多个连接ID（一般需要先使用processlist查看出ID列表，然后根据ID将其kill掉 ）</td></tr><tr><td>ping</td><td>检测某个MySQL服务是否处于启动状态</td></tr><tr><td>password</td><td>修改用户密码</td></tr><tr><td>shutdown</td><td>关闭MySQL服务</td></tr><tr><td>start-slave</td><td>开启主从复制</td></tr><tr><td>stop-slave</td><td>关闭主从复制</td></tr><tr><td>variables</td><td>查询MySQL服务中的所有变量</td></tr><tr><td>version</td><td>查询MySQL的版本详细信息</td></tr></tbody></table><h3 id="（1）ping">（1）ping</h3><p><strong>监测服务是否正常</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# mysqladmin -uroot -p  ping<br>Enter password: <br>mysqld is alive<br></code></pre></td></tr></table></figure><h3 id="（2）status">（2）status</h3><p><strong>获取mysql当前状态值</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# mysqladmin -uroot -p  status<br>Enter password: <br>Uptime: 3413  Threads: 2  Questions: 102  Slow queries: 0  Opens: 118  Flush tables: 1  Open tables: 111  Queries per second avg: 0.029<br></code></pre></td></tr></table></figure><h4 id="状态值：">状态值：</h4><ul><li>**mysqladmin status命令结果有下述列 **</li><li><strong>Uptime:是mysql服务器运行的秒数.</strong></li><li><strong>Threads:活跃线程的数量即开启的会话数.</strong></li><li><strong>Questions： 服务器启动以来客户的问题(查询)数目 （只要跟mysql作交互，不管查询表，还是查询服务器状态都记一次）.</strong></li><li><strong>Slow queries：是慢查询的数量.</strong></li><li>**Opens：mysql已经打开的数据库表的数量 **</li><li>**Flush tables: mysql已经执行的flush tables，refresh和reload命令的数量.注：flush tables //刷新表（清除缓存）reload 重载授权表 refresh 洗掉所有表并关闭和打开日志文件 **</li><li><strong>open：打开数据库的表的数量，以服务器启动开始.</strong></li><li><strong>Queries per second avg：select语句平均查询时间 Memory in use分配的内存(只有在MySQL用–withdebug编译时可用) Max memory used分配的最大内存(只有在MySQL用–with-debug编译时可用)</strong></li></ul><h3 id="（3）processlist">（3）processlist</h3><p><strong>获取数据库当前连接信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# mysqladmin -uroot -p  processlist<br>Enter password: <br>+----+------+-----------+---------+---------+------+----------+------------------+<br>| Id | User | Host      | db      | Command | Time | State    | Info             |<br>+----+------+-----------+---------+---------+------+----------+------------------+<br>| 32 | root | localhost | test_db | Sleep   | 877  |          |                  |<br>| 40 | root | localhost |         | Query   | 0    | starting | show processlist |<br>+----+------+-----------+---------+---------+------+----------+------------------+<br></code></pre></td></tr></table></figure><h3 id="（4）获取数据库当前的连接数">（4）获取数据库当前的连接数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# mysql -uroot -p -BNe "select host,count(host) from processlist group by host" information_schema<br>Enter password: <br>localhost2<br></code></pre></td></tr></table></figure><h3 id="（5）显示mysql的启动时长">（5）显示mysql的启动时长</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# mysql -uroot -p123 -e "SHOW STATUS LIKE '%uptime%'" | awk '/ptime/&#123; calc = $NF/3600;print $(NF-1), calc"Hour"&#125;'<br><br>Uptime 1.005Hour<br>Uptime_since_flush_status 1.005Hour<br></code></pre></td></tr></table></figure><h3 id="（6）查看数据库所有库大小">（6）查看数据库所有库大小</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# mysql -uroot -p123 -e 'select table_schema,round(sum(data_length+index_length)/1024/1024,4) from information_schema.tables group by table_schema'<br><br>+--------------------+--------------------------------------------------+<br>| table_schema       | round(sum(data_length+index_length)/1024/1024,4) |<br>+--------------------+--------------------------------------------------+<br>| information_schema |                                           0.1563 |<br>| mysql              |                                           2.4425 |<br>| performance_schema |                                           0.0000 |<br>| sys                |                                           0.0156 |<br>| test_db            |                                           0.0156 |<br>+--------------------+--------------------------------------------------+<br></code></pre></td></tr></table></figure><h3 id="（7）processlist获取当前数据库的连接线程信息：-监控mysql进程运行状态："><strong>（7）processlist获取当前数据库的连接线程信息： 监控mysql进程运行状态：</strong></h3><p><strong>上面的这三个功能在一些简单监控脚本中经常使用到的.mysqladmin其他参数选项可以通过执行“mysqladmin–help”或man mysqladmin得到帮助信息.编写一个简单的mysql监控脚本，内容如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta">#</span><span class="bash">监测服务是否正常</span><br>mysqladmin -uroot -p123 -h localhost ping<br><span class="hljs-meta">#</span><span class="bash">获取mysql当前状态值</span><br>mysqladmin -uroot -p123 -h localhost status<br><span class="hljs-meta">#</span><span class="bash">获取数据库当前连接信息</span><br>mysqladmin -uroot -p123 -h localhost processlist<br><span class="hljs-meta">#</span><span class="bash">获取数据库当前的连接数</span><br>mysql -uroot -p123 -BNe "select host,count(host) from processlist group by host" information_schema<br><span class="hljs-meta">#</span><span class="bash">显示mysql的启动时长</span><br>mysql -uroot -p123 -e "SHOW STATUS LIKE '%uptime%'" | awk '/ptime/&#123; calc = $NF/3600;print $(NF-1), calc"Hour"&#125;'<br><span class="hljs-meta">#</span><span class="bash">查看数据库所有库大小</span><br>mysql -uroot -p123 -e 'select table_schema,round(sum(data_length+index_length)/1024/1024,4) from information_schema.tables group by table_schema'<br></code></pre></td></tr></table></figure><h1>五、mysqldump</h1><p><strong>这个工具其功能就是将MySQL Server中的数据以SQL 语句的形式从数据库中dump 成文本文件。mysqldump是做为MySQL 的一种逻辑备份工具，在我之前的博文中有这个工具的使用方法：<a href="https://blog.51cto.com/14154700/2395340" target="_blank" rel="noopener">MySQL的备份与恢复详解</a></strong></p><h1>六、mysqlbinlog</h1><p><strong>mysqlbinlog程序的主要功能就是分析MySQL Server 所产生的二进制日志（也就是binlog）。</strong><br><strong>通过mysqlbinlog，我们可以解析出binlog中指定时间段或者指定日志起始和结束位置的内容解析成SQL 语句。</strong></p><h1>七、Mysqlslap性能测试</h1><p><strong>MySQL二种存储引擎 mysqlslap是mysql自带的基准测试工具,优点:查询数据,语法简单,灵活容易使用.该工具可以模拟多个客户端同时并发的向服务器发出查询更新,给出了性能测试数据而且提供了多种引擎的性能比较.mysqlslap为mysql性能优化前后提供了直观的验证依据,建议系统运维和DBA人员应该掌握一些常见的压力测试工具,才能准确的掌握线上数据库支撑的用户流量上限及其抗压性等问题.现在看一下这个压力测试工具mysqlslap，关于他的选项手册上以及–help介绍的很详细。</strong></p><h4 id="这里解释一下一些常用的选项">这里解释一下一些常用的选项</h4><ul><li><strong>–concurrency代表并发数量，多个可以用逗号隔开。例如：concurrency=50,100,200 --engines代表要测试的引</strong><br><strong>擎，可以有多个，用分隔符隔开。</strong></li><li><strong>–iterations代表要运行这些测试多少次，即运行多少次后，得到结果。</strong></li><li><strong>–auto-generate-sql 代表用系统自己生成的SQL脚本来测试。</strong></li><li><strong>–auto-generate-sql-load-type 代表要测试的是读 还是写还是两者混合的（read,write,update,mixed）</strong></li><li><strong>–number-of-queries 代表总共要运行多少次查询。每个客户运行的查询数量可以用查询总数/并发数来计算。比如倒数第二个结果2=200/100。</strong></li><li><strong>–debug-info 代表要额外输出CPU以及内存的相关信息（注：只有在MySQL用–with-debug编译时可）。</strong></li><li><strong>–number-int-cols 代表测试表中的INTEGER类型的属性有几个。</strong></li><li><strong>–number-char-cols代表测试表的char类型字段的数量。</strong></li><li><strong>–create-schema 代表自己定义的模式（在MySQL中也就是库即创建测试的数据库）。</strong></li><li><strong>–query 代表自己的SQL脚本。</strong></li><li><strong>–only-print如果只想打印看看SQL语句是什么，可以用这个选项。</strong></li><li><strong>–csv=name 生产CSV格式数据文件 查看Mysql数据库默认最大连接数</strong></li></ul><h2 id="（1）查看Mysql数据库默认最大连接数">（1）查看Mysql数据库默认最大连接数</h2><p><strong>可以看到mysql5.7.13默认是151。注：不同版本默认最大连接数不差别。一般生产环境是不够的。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#39;%max_connections%&#39;;<br>+-----------------+-------+<br>| Variable_name   | Value |<br>+-----------------+-------+<br>| max_connections | 151   |<br>+-----------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>注：不同版本默认最大连接数不差别。一般生产环境是不够的</strong></p><h2 id="2、修改MySQL数据库默认最大连接数">2、修改MySQL数据库默认最大连接数</h2><h4 id="方法一">方法一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; set GLOBAL max_connections &#x3D; 1024;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; show variables like &#39;%max_connections%&#39;;<br>+-----------------+-------+<br>| Variable_name   | Value |<br>+-----------------+-------+<br>| max_connections | 1024  |<br>+-----------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="方法二">方法二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">在my.cnf[mysqld]下添加 <br>max_connections&#x3D;1024 #增加到1024<br>重启Mysql.<br><br>总结：修改my.cnf文件并重启mysqld服务<br></code></pre></td></tr></table></figure><h2 id="3、查看Mysql默认使用存储引擎，">3、查看Mysql默认使用存储引擎，</h2><p><strong>如下查看： <code>mysql&gt; show engines;</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show engines;<br>+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+<br>| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |<br>+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+<br>| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |<br>| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |<br>| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |<br>| BLACKHOLE          | YES     | &#x2F;dev&#x2F;null storage engine (anything you write to it disappears) | NO           | NO   | NO         |<br>| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |<br>| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |<br>| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |<br>| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |<br>| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |<br>+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+<br>9 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="4、测试">4、测试</h2><p><strong>现在我们来看一下具体测试的例子。</strong></p><h3 id="1）用自带的SQL脚本来测试">1）用自带的SQL脚本来测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@mysql ~]# mysqlslap --defaults-file&#x3D;&#x2F;etc&#x2F;my.cnf --concurrency&#x3D;100,200 --iterations&#x3D;1 --number-int-cols&#x3D;20 --number-char-cols&#x3D;30 --auto-generate-sql --auto-generate-sql-add-autoincrement --auto-generate-sql-load-type&#x3D;mixed --engine&#x3D;myisam,innodb --number-of-queries&#x3D;2000 -uroot -p123 --verbose<br><br>Benchmark<br>trueRunning for engine myisam<br>trueAverage number of seconds to run all queries: 0.330 seconds<br>trueMinimum number of seconds to run all queries: 0.330 seconds<br>trueMaximum number of seconds to run all queries: 0.330 seconds<br>trueNumber of clients running queries: 100<br>trueAverage number of queries per client: 20<br><br>Benchmark<br>trueRunning for engine myisam<br>trueAverage number of seconds to run all queries: 0.341 seconds<br>trueMinimum number of seconds to run all queries: 0.341 seconds<br>trueMaximum number of seconds to run all queries: 0.341 seconds<br>trueNumber of clients running queries: 200<br>trueAverage number of queries per client: 10<br><br>Benchmark<br>trueRunning for engine innodb<br>trueAverage number of seconds to run all queries: 0.610 seconds<br>trueMinimum number of seconds to run all queries: 0.610 seconds<br>trueMaximum number of seconds to run all queries: 0.610 seconds<br>trueNumber of clients running queries: 100<br>trueAverage number of queries per client: 20<br><br>Benchmark<br>trueRunning for engine innodb<br>trueAverage number of seconds to run all queries: 0.457 seconds<br>trueMinimum number of seconds to run all queries: 0.457 seconds<br>trueMaximum number of seconds to run all queries: 0.457 seconds<br>trueNumber of clients running queries: 200<br>trueAverage number of queries per client: 10<br></code></pre></td></tr></table></figure><h6 id="测试说明">测试说明</h6><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">模拟测试两次读写并发，第一次100，第二次200，自动生成SQL脚本，测试表包含20个init字段，30个char字段，每次执行2000查询请求。测试引擎分别是myisam，innodb。<br></code></pre></td></tr></table></figure><h6 id="测试结果说明">测试结果说明</h6><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">Myisam第一次100客户端同时发起增查用1.459/s,第二次200客户端同时发起增查用1.420/s<br>Innodb第一次100客户端同时发起增查用1.352/s,第二次200客户端同时发起增查用2.330/s<br></code></pre></td></tr></table></figure><h6 id="测试结论">测试结论</h6><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">由此可见MyISAM存储引擎处理性能是最好的，也是最常用的，但不支持事务。<br>InonDB存储引擎提供了事务型数据引擎（ACID），在事务型引擎里使用最多的。具有事务回滚，系统修复等特点。<br></code></pre></td></tr></table></figure><h3 id="2）测试结果保存为csv文件">2）测试结果保存为csv文件</h3><p><strong>Mysqlslap测试工具生产CSV格式数据文件并转换成图表形式：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# mysqlslap --defaults-file=/etc/my.cnf --concurrency=100,200 --iterations=1 --number-int-cols=20 --number-char-cols=30 --auto-generate-sql --auto-generate-sql-add-autoincrement --auto-generate-sql-load-type=mixed --engine=myisam,innodb --number-of-queries=2000 -uroot -p123 --csv=/root/a.csv<br></code></pre></td></tr></table></figure><p><strong>将/root/a.csv拷贝到windows主机上，打开并生成图表</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200618175243042.png" alt="image-20200618175243042"></p><h3 id="3）使用自定义sql脚本测试">3）使用自定义sql脚本测试</h3><p><strong>用我们自己定义的SQL 脚本或语句来测试 首先准备好要测试的数据库表，这里我们编写一个生成表的脚本去完成 脚本内容如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# cat /root/mysql3.sh<br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>HOSTNAME="localhost"<br>PORT="3306"<br>USERNAME="root"<br>PASSWORD="123"<br>DBNAME="test1"<br>TABLENAME="tb1"<br><span class="hljs-meta">#</span><span class="bash">create database</span><br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; -e "drop database if exists $&#123;DBNAME&#125;" create_db_sql="create database if not exists $&#123;DBNAME&#125;"<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; -e "$&#123;create_db_sql&#125;"<br><span class="hljs-meta">#</span><span class="bash">create table</span><br>create_table_sql="create table if not exists $&#123;TABLENAME&#125;(stuid int not null primary key,stuname varchar(20) not null,stusex char(1) not null,cardid varchar(20) not null,birthday datetime,entertime datetime,address varchar(100) default null)"<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e "$&#123;create_table_sql&#125;"<br><span class="hljs-meta">#</span><span class="bash">insert data to table</span><br>i=1<br>while [ $i -le 20000 ]<br>do<br>insert_sql="insert into $&#123;TABLENAME&#125; values($i,'zhangsan','1','1234567890123456','1999-10-10','2016-9-3','zhongguo beijingshi changpinqu')"<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e "$&#123;insert_sql&#125;"<br>let i++<br>done<br><span class="hljs-meta">#</span><span class="bash">select data</span><br>select_sql="select count(*) from $&#123;TABLENAME&#125;"<br>mysql -h $&#123;HOSTNAME&#125; -P $&#123;PORT&#125; -u $&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; $&#123;DBNAME&#125; -e "$&#123;select_sql&#125;"<br></code></pre></td></tr></table></figure><p><strong>授权脚本x执行权限</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@192 opt]# chmod +x mysql_test.sh<br></code></pre></td></tr></table></figure><h4 id="执行脚本mysql3-sh生成mysqlslap工具需要的测试表">执行脚本mysql3.sh生成mysqlslap工具需要的测试表</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@mysql ~]# /root/mysql3.sh<br><br>执行mysqlslap工具进行测试<br>[root@mysql ~]# mysqlslap --defaults-file=/etc/my.cnf --concurrency=10,20 --iterations=1 --create-schema='test1' --query='select * from test1.tb1' --engine=myisam,innodb --number-of-queries=2000 -uroot -p123 –verbose<br></code></pre></td></tr></table></figure><h5 id="显示结果：">显示结果：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@192 opt]# mysqlslap --defaults-file&#x3D;&#x2F;etc&#x2F;my.cnf --concurrency&#x3D;10,20 --iterations&#x3D;1 --create-schema&#x3D;&#39;test1&#39; --query&#x3D;&#39;select * from test1.tb1&#39; --engine&#x3D;myisam,innodb --number-of-queries&#x3D;2000 -uroot -p1234 –verbose<br>mysqlslap: [Warning] Using a password on the command line interface can be insecure.<br>Benchmark<br>        Running for engine myisam<br>        Average number of seconds to run all queries: 3.261 seconds<br>        Minimum number of seconds to run all queries: 3.261 seconds<br>        Maximum number of seconds to run all queries: 3.261 seconds<br>        Number of clients running queries: 10<br>        Average number of queries per client: 200<br><br>Benchmark<br>        Running for engine myisam<br>        Average number of seconds to run all queries: 3.010 seconds<br>        Minimum number of seconds to run all queries: 3.010 seconds<br>        Maximum number of seconds to run all queries: 3.010 seconds<br>        Number of clients running queries: 20<br>        Average number of queries per client: 100<br><br>Benchmark<br>        Running for engine innodb<br>        Average number of seconds to run all queries: 3.421 seconds<br>        Minimum number of seconds to run all queries: 3.421 seconds<br>        Maximum number of seconds to run all queries: 3.421 seconds<br>        Number of clients running queries: 10<br>        Average number of queries per client: 200<br><br>Benchmark<br>        Running for engine innodb<br>        Average number of seconds to run all queries: 3.252 seconds<br>        Minimum number of seconds to run all queries: 3.252 seconds<br>        Maximum number of seconds to run all queries: 3.252 seconds<br>        Number of clients running queries: 20<br>        Average number of queries per client: 100<br></code></pre></td></tr></table></figure><p><strong>注：通过mysqlslap工具对mysql server进行压力测试，可以通过–concurrency、–number-of-queries等选项的值查看每次测试的结果，通过反复测试、优化得出mysql server的最大并发数.如果mysqlslap工具输出结果为Segmentation fault (core dumped)基本表示走超出mysql server的负载。</strong></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql结构化查询语句 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据文件介绍及存放位置</title>
      <link href="/posts/80a7.html"/>
      <url>/posts/80a7.html</url>
      
        <content type="html"><![CDATA[<h1>一、MySQL数据库文件介绍</h1><p><strong>MySQL的每个数据库都对应存放在一个与数据库同名的文件夹中，MySQL数据库文件包括MySQL所建数据库文件和MySQL所用存储引擎创建的数据库文件。</strong></p><h2 id="1、MySQL创建并管理的数据库文件：">1、MySQL创建并管理的数据库文件：</h2><p><strong>.frm文件：存储数据表的框架结构，文件名与表名相同，每个表对应一个同名frm文件，与操作系统和存储引擎无关，即不管MySQL运行在何种操作系统上，使用何种存储引擎，都有这个文件。</strong></p><p><strong>除了必有的.frm文件，根据MySQL所使用的存储引擎的不同（MySQL常用的两个存储引擎是MyISAM和InnoDB），存储引擎会创建各自不同的数据库文件。</strong></p><h2 id="2、MyISAM数据库表文件：">2、MyISAM数据库表文件：</h2><ul><li><strong>.MYD文件：即MY Data，表数据文件</strong></li><li><strong>.MYI文件：即MY Index，索引文件</strong></li><li><strong>.log文件：日志文件</strong></li></ul><h2 id="3、InnoDB采用表空间（tablespace）来管理数据，存储表数据和索引，">3、InnoDB采用表空间（tablespace）来管理数据，存储表数据和索引，</h2><p><strong>InnoDB数据库文件（即InnoDB文件集，ib-file set）：</strong></p><p><strong>ibdata1、ibdata2等：系统表空间文件，存储InnoDB系统信息和用户数据库表数据和索引，所有表共用</strong></p><p><strong>.ibd文件：单表表空间文件，每个表使用一个表空间文件（file per table），存放用户数据库表数据和索引</strong></p><p><strong>日志文件： ib_logfile1、ib_logfile2</strong></p><h1>二、MySQL数据库存放位置：</h1><p><strong>1、MySQL如果使用MyISAM存储引擎，数据库文件类型就包括.frm、.MYD、.MYI，默认存放位置是C:\Documentsand Settings\All Users\Application Data\MySQL\MySQL Server 5.1\data</strong></p><p><strong>2、MySQL如果使用InnoDB存储引擎，数据库文件类型就包括.frm、ibdata1、.ibd，存放位置有两个，</strong></p><p><strong>.frm文件默认存放位置是C:\Documents and Settings\All Users\ApplicationData\MySQL\MySQL Server 5.1\data，ibdata1、.ibd文件默认存放位置是MySQL安装目录下的data文件夹</strong></p><h1>三、操作</h1><p><strong>看看我的数据库文件的存放位置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@pacteralinux ~]<span class="hljs-comment"># cd /mnt/resource/mysqldate/</span><br>[root@pacteralinux mysqldate]<span class="hljs-comment"># ll -h</span><br>total 173M<br>-rw-rw----. 1 mysql mysql   56 Nov 25 17:17 auto.cnf<br>-rw-rw----. 1 mysql mysql  76M Dec 24 17:02 ibdata1<br>-rw-rw----. 1 mysql mysql  48M Dec 24 17:02 ib_logfile0<br>-rw-rw----. 1 mysql mysql  48M Nov 26 13:39 ib_logfile1<br>drwx------. 2 mysql mysql 4.0K Nov 26 13:41 mysql<br>drwx------. 2 mysql mysql  20K Nov 26 17:00 mysqldb<br>srwxrwxrwx. 1 mysql mysql    0 Dec 24 17:02 mysql.sock<br>-rw-rw----. 1 mysql root  499K Dec 25 14:42 pacteralinux.err<br>-rw-rw----. 1 mysql mysql    6 Dec 24 17:02 pacteralinux.pid<br>drwx------. 2 mysql mysql 4.0K Nov 26 13:41 performance_schema<br>drwx------. 2 mysql mysql 4.0K Nov 26 13:41 <span class="hljs-built_in">test</span><br>drwx------. 2 mysql mysql 4.0K Dec  9 16:49 weixindemo<br>[root@pacteralinux mysqldate]<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p><strong>其中这三个文件我一直很迷惑</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">-rw-rw----. 1 mysql mysql  76M Dec 24 17:02 ibdata1<br>-rw-rw----. 1 mysql mysql  48M Dec 24 17:02 ib_logfile0<br>-rw-rw----. 1 mysql mysql  48M Nov 26 13:39 ib_logfile1<br></code></pre></td></tr></table></figure><p><strong>再看这些文件（部分）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@pacteralinux mysqldb]<span class="hljs-comment"># ll -h</span><br>total 3.6G<br>-rw-rw----. 1 mysql mysql  11K Nov 26 16:47 chen_fundnetvalue_bak.frm<br>-rw-rw----. 1 mysql mysql  62K Nov 26 16:47 chen_fundnetvalue_bak.MYD<br>-rw-rw----. 1 mysql mysql 4.0K Nov 26 16:47 chen_fundnetvalue_bak.MYI<br>-rw-rw----. 1 mysql mysql  11K Nov 26 16:47 chen_fundnetvalue.frm<br>-rw-rw----. 1 mysql mysql 834K Nov 26 16:47 chen_fundnetvalue.MYD<br>-rw-rw----. 1 mysql mysql  18K Nov 26 16:47 chen_fundnetvalue.MYI<br>-rw-rw----. 1 mysql mysql 8.4K Nov 26 16:47 codelist_bak.frm<br>-rw-rw----. 1 mysql mysql  162 Nov 26 16:47 codelist_bak.MYD<br>-rw-rw----. 1 mysql mysql 1.0K Nov 26 16:47 codelist_bak.MYI<br>-rw-rw----. 1 mysql mysql 8.4K Nov 26 16:47 codelist.frm<br>-rw-rw----. 1 mysql mysql  162 Nov 26 16:47 codelist.MYD<br>-rw-rw----. 1 mysql mysql 1.0K Nov 26 16:47 codelist.MYI<br></code></pre></td></tr></table></figure><p><strong>. 前面是表名，每个表由frm  MYD MYI三个后缀名组成，所有表都是！</strong></p><p><strong>在MySQL 中每一个数据库都会在定义好（或者默认）的数据目录下存在一个以数据库名字命名的文件夹，用来存放该数据库中各种表数据文件。不同的MySQL 存储引擎有各自不同的数据文件，存放位置也有区别。</strong></p><p><strong>多数存储引擎的数据文件都存放在和MyISAM 数据文件位置相同的目录下，但是每个数据文件的扩展名却各不一样。如MyISAM 用“.MYD”作为扩展名，Innodb 用“.ibd”，Archive 用“.arc”，CSV 用“.csv”，等等。</strong></p><h2 id="1、下面就来详细分析一下这些是什么文件！！！！！">1、下面就来详细分析一下这些是什么文件！！！！！</h2><h2 id="（1）“-frm”文件">（1）“.frm”文件</h2><p><strong>与表相关的元数据（meta）信息都存放在“.frm”文件中，包括表结构的定义信息等。不论是什么存储引擎，每一个表都会有一个以表名命名的“.frm”文件。所有的“.frm”文件都存放在所属数据库的文件夹下面。（innodb，myisam）</strong></p><h2 id="（2）“-MYD”文件">（2）“.MYD”文件</h2><p><strong>“.MYD”文件是MyISAM 存储引擎专用，存放MyISAM 表的数据。每一个MyISAM 表都会有一个“.MYD”文件与之对应，同样存放于所属数据库的文件夹下，和“.frm”文件在一起。</strong></p><h2 id="（3）“-MYI”文件">（3）“.MYI”文件</h2><p><strong>“.MYI”文件也是专属于MyISAM存储引擎的，主要存放MyISAM表的索引相关信息。对于MyISAM存储来说，可以被cache 的内容主要就是来源于“.MYI”文件中。每一个MyISAM表对应一个“.MYI”文件，存放于位置和“.frm”以及“.MYD”一样。</strong></p><h2 id="（4）小结一下：">（4）小结一下：</h2><p><strong>MyISAM 存储引擎的表在数据库中，每一个表都被存放为三个以表名命名的物理文件（frm,myd,myi）。 每个表都有且仅有这样三个文件做为MyISAM 存储类型的表的存储，也就是说不管这个表有多少个索引，都是存放在同一个.MYI 文件中。</strong></p><p><strong>这个在开始里看的比较清楚。</strong></p><h2 id="2、“-ibd”文件和ibdata-文件">2、“.ibd”文件和ibdata 文件</h2><p><strong>这两种文件都是存放Innodb 数据的文件，之所以有两种文件来存放Innodb 的数据（包括索引），是因为Innodb 的数据存储方式能够通过配置来决定是使用<code>共享表空间存放存储数据，还是独享表空间存放存储数据</code>。独享表空间存储方式使用“.ibd”文件来存放数据，且每个表一个“.ibd”文件，文件存放在和MyISAM数据相同的位置。</strong></p><p><strong>如果选用共享存储表空间来存放数据，则会使用ibdata 文件来存放，所有表<code>共同使用一个（或者多个，可自行配置）ibdata 文件</code>。ibdata 文件可以通过innodb_data_home_dir 和innodb_data_file_path两个参数共同配置组成， innodb_data_home_dir 配置数据存放的总目录， 而innodb_data_file_path 配置每一个文件的名称。当然，也可以不配innodb_data_home_dir而直接在innodb_data_file_path参数配置的时候使用绝对路径来完成配置。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">mysql&gt;</span><span class="bash"> showvariables like <span class="hljs-string">'innodb_data%'</span>;</span><br><br>+-----------------------+------------------------+<br>|Variable_name     | Value          |<br>+-----------------------+------------------------+<br>|innodb_data_file_path | ibdata1:10M:autoextend |<br>| innodb_data_home_dir  |             |<br>+-----------------------+------------------------+<br>2 rows in set(0.01 sec)<br></code></pre></td></tr></table></figure><p><strong>innodb_data_file_path中可以一次配置多个ibdata文件。文件可以是指定大小，也可以是自动扩展的，但是Innodb 限制了仅仅只有最后一个ibdata 文件能够配置成自动扩展类型。当我们需要添加新的ibdata 文件的时候，只能添加在innodb_data_file_path配置的最后，而且必须重启MySQL 才能完成ibdata 的添加工作。</strong></p><h2 id="3、ibdata文件瘦身法">3、ibdata文件瘦身法</h2><p><strong>MySql innodb如果是共享表空间，ibdata1文件越来越大，达到了30多个G，对一些没用的表进行清空：</strong><br><strong>truncate table xxx;</strong><br><strong>然后optimize table xxx; 没有效果</strong><br><strong>因为对共享表空间不起作用。</strong><br><strong>mysql ibdata1存放数据，索引等，是MYSQL的最主要的数据。</strong></p><p><strong>如果不把数据分开存放的话，这个文件的大小很容易就上了G，甚至几十G。对于某些应用来说，并不是太合适。因此要把此文件缩小。</strong><br><strong>无法自动收缩，必须数据导出，删除ibdata1，然后数据导入，比较麻烦，因此需要改为每个表单独的文件。</strong></p><p><strong>解决方法：数据文件单独存放(共享表空间如何改为每个表独立的表空间文件)。</strong></p><h3 id="步骤如下："><strong>步骤如下：</strong></h3><h4 id="1）备份数据库"><strong>1）备份数据库</strong></h4><p><strong>从命令行进入MySQL Server 5.0\bin</strong><br><strong>备份全部数据库，执行命令</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">D:\&gt;<span class="hljs-title">mysqldump</span> -<span class="hljs-title">q</span> -<span class="hljs-title">umysql</span> -<span class="hljs-title">ppassword</span> --<span class="hljs-title">add</span>-<span class="hljs-title">drop</span>-<span class="hljs-title">table</span> --<span class="hljs-title">all</span>-<span class="hljs-title">databases</span> &gt; <span class="hljs-title">c</span>:/<span class="hljs-title">all.sql</span></span><br></code></pre></td></tr></table></figure><p><strong>做完此步后，停止数据库服务。</strong></p><h4 id="2）找到my-ini或my-cnf文件"><strong>2）找到my.ini或my.cnf文件</strong></h4><p><strong>linux下执行 <code>./mysqld --verbose --help | grep -A 1 'Default options'</code></strong><br><strong>会有类似显示：</strong><br><strong>Default options are read from the following files in the given order:</strong><br><strong>/etc/my.cnf ~/.my.cnf /usr/local/service/mysql3306/etc/my.cnf</strong></p><p><strong>windows环境下可以：</strong><br><strong><code>mysqld --verbose --help &gt; mysqlhelp.txt</code></strong><br><strong><code>notepad mysqlhelp.txt</code></strong><br><strong>在里面查找Default options，可以看到查找my.ini的顺序，以找到真实目录</strong></p><h4 id="3）修改mysql配置文件"><strong>3）修改mysql配置文件</strong></h4><p><strong>打开my.ini或my.cnf文件</strong><br><strong><code>[mysqld]</code>下增加下面配置</strong><br><strong><code>innodb_file_per_table=1</code></strong></p><p><strong>验证配置是否生效，可以重启mysql后,执行</strong><br><strong><code>show variables like '%per_table%'</code></strong><br><strong>看看<code>innodb_file_per_table</code>变量是否为ON</strong></p><h4 id="4）删除原数据文件"><strong>4）删除原数据文件</strong></h4><p><strong>删除原来的ibdata1文件及日志文件<code>ib_logfile*</code>，删除data目录下的应用数据库文件夹(mysql文件夹不要删)</strong></p><h4 id="5）还原数据库"><strong>5）还原数据库</strong></h4><p><strong>启动数据库服务</strong></p><p><strong>从命令行进入MySQL Server 5.0\bin</strong><br><strong>还原全部数据库，执行命令<code>mysql -uusername -pyourpassword &lt; c:/all.sql</code></strong></p><p><strong>经过以上几步后，可以看到新的ibdata1文件就只有几十M了，数据及索引都变成了针对单个表的小ibd文件了，它们在相应数据库的文件夹下面。</strong></p><h1>四、mysql data文件夹下的ibdata1 文件作用</h1><p><strong>这个文件超级大， 查了一下， 大概的作用如下</strong><br><strong>是储存的格式</strong><br><strong>INNODB类型数据状态下，</strong><br><strong>ibdata用来储存文件的数据</strong><br><strong>而库名的文件夹里面的那些表文件只是结构而已</strong><br><strong>由于mysql4.1默认试innodb，所以这个文件默认就存在了https://wsdlxgp.top/ 这个链接试innodb的中文参考， innodb的东西可以在my.ini中设置</strong></p><p><strong>使用过MySQL的同学，刚开始接触最多的莫过于MyISAM表引擎了，这种引擎的数据库会分别创建三个文件：表结构、表索引、表数据空间。我们可以将某个数据库目录直接迁移到其他数据库也可以正常工作。</strong><br><strong>然而当你使用InnoDB的时候，一切都变了。InnoDB 默认会将所有的数据库InnoDB引擎的表数据存储在一个共享空间中：ibdata1，这样就感觉不爽，增删数据库的时候，ibdata1文件不会自动收缩，单个数据库的备份也将成为问题。通常只能将数据使用mysqldump 导出，然后再导入解决这个问题。</strong><br><strong>在MySQL的配置文件[mysqld]部分，增加innodb_file_per_table参数，可以修改InnoDB为独立表空间模式，每个数据库的每个表都会生成一个数据空间。</strong></p><h3 id="独立表空间"><strong>独立表空间</strong></h3><h4 id="优点：">优点：</h4><p><strong>1.每个表都有自已独立的表空间。</strong><br><strong>2.每个表的数据和索引都会存在自已的表空间中。</strong><br><strong>3.可以实现单表在不同的数据库中移动。</strong><br><strong>4.空间可以回收（drop/truncate table方式操作表空间不能自动回收）</strong><br><strong>5.对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。</strong></p><h4 id="缺点："><strong>缺点：</strong></h4><p><strong>单表增加比共享空间方式更大。</strong></p><h4 id="结论："><strong>结论：</strong></h4><p><strong>共享表空间在Insert操作上有一些优势，但在其它都没独立表空间表现好。</strong><br><strong>当启用独立表空间时，请合理调整一下 innodb_open_files 参数。</strong></p><h4 id="两个重要参数：">两个重要参数：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">innodb_data_file_path<br>innodb_data_home_dir<br></code></pre></td></tr></table></figure><p><strong>这两个参数看参考文献的时候一直没有理解，先说明如下</strong></p><p><strong>我的my.cnf</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#innodb_data_home_dir = /var/lib/mysql/</span><br><span class="hljs-comment">#innodb_data_file_path = ibdata1:10M:autoextend</span><br></code></pre></td></tr></table></figure><p><strong>为了在 MySQL-Max-3.23 中使用 InnoDB 表，你必须在配置文件<code>‘my.cnf’</code>中的 <code>[mysqld]</code> 区中详细指定配置参数。</strong></p><p><strong>作为最小设置，在 3.23 中你必须在 <code>innodb_data_file_path</code> 上指定数据文件名能及大小。</strong></p><p><strong>如果在<code>‘my.cnf’</code>中没有指定<code>innodb_data_home_dir</code>，系统将在 MySQL 的 <code>datadir</code> 目录下创建数据文件。</strong></p><p><strong>如果将<code> innodb_data_home_dir</code> 设为一个空串，那可以在 <code>innodb_data_file_path</code> 中给定一个绝对路径。</strong></p><p><strong>在 MySQL-4.0 中可以不设定 <code>innodb_data_file_path</code> ：MySQL-4.0 将默认地在 <code>datadir</code> 目录下建立一个 10 MB 大小自扩充(auto-extending)的文件<code>‘ibdata1’</code>(在MySQL-4.0.0 与 4.0.1 中数据文件的大小为 64 MB 并且是非自扩充的(not auto-extending))。</strong></p><p><strong>为了得到更好的性能你必须所示的例子明确地设定 InnoDB 启动参数。</strong></p><p><strong>从 3.23.50 版和 4.0.2 版开始，InnoDB 允许在 <code>innodb_data_file_path</code> 中设置的最一个数据文件描述为 auto-extending。 <code>innodb_data_file_path</code> 语法如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs as3">pathtodatafile:sizespecification;pathtodatafile:sizespec;...<br>    ...;pathtodatafile:sizespec[:autoextend[:max:sizespecification]]<br></code></pre></td></tr></table></figure><p><strong>如果用 autoextend 选项描述最后一个数据文件，当 InnoDB 用尽所有表自由空间后将会自动扩充最后一个数据文件，每次增量为 8 MB。示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs as3">innodb_data_home_dir &#x3D;<br>innodb_data_file_path &#x3D; &#x2F;ibdata&#x2F;ibdata1:100M:autoextend<br></code></pre></td></tr></table></figure><p><strong>指定 InnoDB 只建立一个最初大小为 100 MB 并且当表空间被用尽时以 8MB 每块增加的数据文件。如果硬盘空间不足，可以再添加一个数据文件并将其放在其它的硬盘中。 举例来说：先检查硬盘空间的大小，设定<code>ibdata1</code>文件使它接近于硬盘空余空间大小并为 1024 * 1024 bytes (= 1 MB)的倍数， 将<code> ibdata1</code> 明确地指定在<code> innodb_data_file_path</code> 中。在此之后可以添加另一个数据文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">innodb_data_home_dir =<br>innodb_data_file_path = /ibdata/ibdata1:988M;/disk2/ibdata2:50M:autoextend<br></code></pre></td></tr></table></figure><p><strong>注意：设定文件大小时一定要注意你的OS是否有最大文件尺寸为2GB的限制！InnoDB是不会注意你的OS文件尺寸限制的， 在一些文件系统中你可能要设定最大容量限制：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs as3">innodb_data_home_dir &#x3D;<br>innodb_data_file_path &#x3D; &#x2F;ibdata&#x2F;ibdata1:100M:autoextend:max:2000M<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql结构化查询语句 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务日志</title>
      <link href="/posts/4c37.html"/>
      <url>/posts/4c37.html</url>
      
        <content type="html"><![CDATA[<h1>事务日志(或称redo日志)</h1><p><strong>事务日志（InnoDB特有的日志）可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢的刷回到磁盘。目前大多数的存储引擎都是这样实现的。 如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。具有的恢复方式则视存储引擎而定。</strong></p><h4 id="查看事务日志的定义："><strong>查看事务日志的定义：</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show global variables like &#39;%log%&#39;;<br></code></pre></td></tr></table></figure><h5 id="显示结果">显示结果</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">| innodb_flush_log_at_timeout | 1 |<br>| innodb_flush_log_at_trx_commit | 1 #在事务提交时innodb是否同步日志从缓冲区到文件中，当这个值为1（默认值）之时，在每个事务提交时，日志缓冲被写到日志文件，对日志文件做到磁盘操作的刷新，性能会很差造成大量的磁盘I&#x2F;O但这种方式最安全；如果设为2,每次提交事务都会写日志，但并不会执行刷的操作。每秒定时会刷到日志文件。要注意的是，并不能保证100%每秒一定都会刷到磁盘，这要取决于进程的调度。每次事务提交的时候将数据写入事务日志，而这里的写入仅是调用了文件系统的写入操作，而文件系统是有 缓存的，所以这个写入并不能保证数据已经写入到物理磁盘。设置为0，日志缓冲每秒一次地被写到日志文件，并且对日志文件做到磁盘操作的刷新，但是在一个事务提交不做任何操作。<br>注：刷写的概念<br>刷写其实是两个操作，刷（flush）和写（write），区分这两个概念是很重要的。在大多数的操作系统中，把Innodb的log buffer（内存）写入日志（调用系统调用write），只是简单的把数据移到操作系统缓存中，操作系统缓存同样指的是内存。并没有实际的持久化数据。<br>所以，通常设为0和2的时候，在崩溃或断电的时候会丢失最后一秒的数据，因为这个时候数据只是存在于操作系统缓存。之所以说“通常”，可能会有丢失不只1秒的数据的情况，比如说执行flush操作的时候阻塞了。<br>总结<br>设为1当然是最安全的，但性能页是最差的（相对其他两个参数而言，但不是不能接受）。如果对数据一致性和完整性要求不高，完全可以设为2,如果只最求性能，例如高并发写的日志服务器，设为0来获得更高性能<br>|<br>| innodb_locks_unsafe_for_binlog | OFF |<br>| innodb_log_buffer_size | 16777216 |<br>| innodb_log_checksums | ON<br>|<br>| innodb_log_compressed_pages | ON |<br>| innodb_log_file_size | 50331648 #日志文件大小 |<br>| innodb_log_files_in_group | 2 # DB中设置几组事务日志，默认是2<br>|<br>| innodb_log_group_home_dir | .&#x2F; #定义innodb事务日志组的位置,此位置设置默认为<br>MySQL的datadir |<br></code></pre></td></tr></table></figure><p><strong>每个事务日志都是大小为50兆的文件（不同版本的<code>mysql</code>有差异）： 在<code>mysql</code>中默认以<code>ib_logfile0</code>,<code>ib_logfile1</code>名称存在</strong></p><h1>慢查询日志：slow query log</h1><p><strong>顾名思义，慢查询日志中记录的是执行时间较长的query，也就是我们常说的slow query。 慢查询日志采用的是简单的文本格式，可以通过各种文本编辑器查看其中的内容。其中 记录了语句执行的时刻，执行所消耗的时间，执行用户，连接主机等相关信息。 慢查询日志的作用： 慢查询日志是用来记录执行时间超过指定时间的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率很低，以便进行优化。一般建议开启，它对服务器性能的影响微乎其微，但是可以记录mysql服务器上执行了很长时间的查询语句。可以帮助我们定位性能问题的。MySQL 还提供了专门用来分析满查询日志的工具程序mysqldumpslow，用来帮助数据库管理人员解决可能存在的性能问题。 查看慢查询日志的定义：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show global variables like &#39;%slow_query_log%&#39;;<br>+---------------------+------------------------------------+<br>| Variable_name       | Value                              |<br>+---------------------+------------------------------------+<br>| slow_query_log      | OFF                                |<br>| slow_query_log_file | &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;192-slow.log |<br>+---------------------+------------------------------------+<br>2 rows in set (0.00 sec)<br><br>mysql&gt; show global variables like &#39;%long%&#39;;<br>+----------------------------------------------------------+-----------+<br>| Variable_name                                            | Value     |<br>+----------------------------------------------------------+-----------+<br>| long_query_time                                          | 10.000000 |<br>| performance_schema_events_stages_history_long_size       | 10000     |<br>| performance_schema_events_statements_history_long_size   | 10000     |<br>| performance_schema_events_transactions_history_long_size | 10000     |<br>| performance_schema_events_waits_history_long_size        | 10000     |<br>+----------------------------------------------------------+-----------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>**启动和设置慢查询日志： **</p><h3 id="方法1：通过配置文件my-cnf开启慢查询日志：">方法1：通过配置文件my.cnf开启慢查询日志：</h3><blockquote><p><strong>注：在不同的mysql版本中，开启慢查询日志参数不太一样，不过都可以通过 show variables like “%slow%” 和show variables like &quot;%long%&quot;查看出来。</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show global variables like &#39;%slow%&#39;;<br>+---------------------------+------------------------------------------+<br>| Variable_name | Value |<br>+---------------------------+------------------------------------------+<br>| log_slow_admin_statements | OFF |<br>| log_slow_slave_statements | OFF |<br>| slow_launch_time | 2 |<br>| slow_query_log | OFF |<br>| slow_query_log_file | &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;localhost-slow.log |<br>+---------------------------+------------------------------------------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>其中： slow_query_log： off关闭状态 on开启状态 slow_query_log_file 慢查询日志存放地点 long_query_time选项来设置一个时间值，时间以秒为单位，可以精确到微秒。如果查询时间超过了这个时间值（默认为10秒），这个查询语句将被记录到慢查询日志中, 设置为0的话表示记录所有的查询。 slow_launch_time 表示如果建立线程花费了比这个值更长的时间,slow_launch_threads 计数器将增加 注：如果不指定存储路径，慢查询日志默认存储到mysql数据库的数据文件下，如果不指定文件名，默认文件名为hostname-slow.log 修改my.cnf文件：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[mysqld]<br>slow_query_log=1<br>slow_query_log_file=/usr/local/mysql/data/mysql-slow.log<br>long_query_time=1<br>slow_launch_time=1<br></code></pre></td></tr></table></figure><p><strong>重启mysqld服务 再次查询慢查询日志定义</strong></p><h3 id="方法2：通过登录mysql服务器直接定义，方式如下："><strong>方法2：通过登录mysql服务器直接定义，方式如下：</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt;set global slow_query_log&#x3D;1; #开启慢查询日志<br>Query OK, 0 rowsaffected (0.35 sec)<br>mysql&gt;set session long_query_time&#x3D;0.0001; #更改时间（当前session中，退出则重置）<br>Query OK, 0 rowsaffected (0.00 sec)<br>mysql&gt;set global long_query_time&#x3D;0.0001; #更改时间（全局中，重启服务则重置）<br>mysql&gt; SHOW VARIABLES LIKE &#39;long%&#39;; #查询定义时间<br></code></pre></td></tr></table></figure><h4 id="查看慢查询日志">查看慢查询日志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; use mysql<br>mysql&gt; select user,host from user where user&#x3D;&quot;root&quot;;  <br>+------+-----------+<br>| user | host      |<br>+------+-----------+<br>| root | localhost |<br>+------+-----------+<br>1 row in set (0.02 sec)<br></code></pre></td></tr></table></figure><p><strong>或用系统查看文件内容命令如cat直接查看慢日志文件</strong></p><p><strong>第一行表示记录日志时的时间。其格式是 YYYY-MM-DD HH:MM:SS。我们可以看出上面的查询记录于 2016 年 8 月 29 日下午 15:47：24 - 注意：这个是服务器时间. MySql 用户、服务器以及主机名第三行表示总的查询时间、锁定时间、&quot;发送&quot;或者返回的行数 Query_time: 0.000304 表示用了0.000304秒 Lock_time: 0.000128 表示锁了0.000128秒 Rows_sent: 4 表示返回4行 Rows_examined: 4 表示一共查了4行 SETtimestamp=UNIXTIME; 这是查询实际发生的时间 何将其变成一个有用的时间，将 Unix 时间转成一个可读的时间，可以使用 date –d@日志中的时间戳可以看到查询进行的同时记录了该日志 ，但是对于一台超负载的服务器常常并非如此。因此记住：SETtimestamp= value 才是实际的查询的执行时间。</strong></p><p><strong>慢查询分析mysqldumpslow 们可以通过打开log文件查看得知哪些SQL执行效率低下。从日志中，可以发现查询时间超过long_query_time时间的query为慢查询，而小于long_query_time时间的没有出现在此日志中。 如果慢查询日志中记录内容很多，可以使用mysqldumpslow工具（MySQL客户端安装自带）来对慢查询日志进行分类汇总。mysqldumpslow对日志文件进行了分类汇总，显示汇总后摘要结果 进入log的存放目录，运行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@localhost data]# mysqldumpslow mysqld-slow.log<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">注： mysqldumpslow -s c -t 10 &#x2F;database&#x2F;mysql&#x2F;slow-query.log 这会输出记录次数最多<br>的10条SQL语句，其中： -s, 是表示按照何种方式排序，c、t、l、r分别是按照记录次数、时间、查询时<br>间、返回的记录数来排序，ac、at、al、ar，表示相应的倒序； -t, 是top n的意思，即为返回前面多少条<br>的数据； -g, 后边可以写一个正则匹配模式，大小写不敏感的； 例如： &#x2F;path&#x2F;mysqldumpslow -s r -t 10<br>&#x2F;database&#x2F;mysql&#x2F;slow-log 得到返回记录集最多的10个查询。<br>&#x2F;path&#x2F;mysqldumpslow -s t -t 10 -g “left join” &#x2F;database&#x2F;mysql&#x2F;slow-log 得到按照时间排序的前10条里面含有左连接的查询语句。<br></code></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql结构化查询语句 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql二进制日志</title>
      <link href="/posts/af18.html"/>
      <url>/posts/af18.html</url>
      
        <content type="html"><![CDATA[<h1>一、什么是二进制日志</h1><p><strong>MySQL的二进制日志（binary log）是一个二进制文件，主要用于记录修改数据或有可能引起数据变更的MySQL语句。二进制日志（binary log）中记录了对MySQL数据库执行更改的所有操作，并且记录了语句发生时间、执行时长、操作数据等其它额外信息，但是它不记录SELECT、SHOW等那些不修改数据的SQL语句。二进制日志（binary log）主要用于数据库恢复和主从复制，以及审计（audit）操作。</strong></p><p><strong>开启二进制日志对性能的开销很小，带来的好处远大于坏处。</strong></p><h1>二、开启和设置二进制日志</h1><h2 id="1、查看二进制日志状态">1、查看二进制日志状态</h2><p><strong>默认情况下二进制日志是关闭的。</strong></p><p><strong>系统变量log_bin的值为<code>OFF</code>表示没有开启二进制日志，<code>ON</code>表示开启了二进制日志，如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#39;log_bin&#39;;<br>+---------------------------------+------------------------------------+<br>| Variable_name                   | Value                              |<br>+---------------------------------+------------------------------------+<br>| log_bin                         | OFF                                |<br>+---------------------------------+------------------------------------+<br>1 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="2、开启二进制日志">2、开启二进制日志</h2><h3 id="（1）修改配置文件并重启mysql服务">（1）修改配置文件并重启mysql服务</h3><p><strong>如果需要开启二进制日志，则必须在配置文件中[mysqld]下面添加log-bin [=DIR[filename]] 。</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">DIR参数指定二进制文件的存储路径；<br>filename参数指定二级制文件的文件名。 <br>其中filename可以任意指定，但最好有一定规范。<br>系统变量log_bin是静态参数，不能动态修改的（因为它不是Dynamic Variable）。<br></code></pre></td></tr></table></figure><p><strong>内容如下所示：</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">server-id</span> = <span class="hljs-number">1</span>              <span class="hljs-comment"># mysql5.7必须加，否则mysql服务启动报错</span><br><span class="hljs-attr">log-bin</span> = mysql_bin_log    <span class="hljs-comment"># 路径及命名，默认在data下</span><br><span class="hljs-attr">expire_logs_days</span> = <span class="hljs-number">10</span>      <span class="hljs-comment"># 过期时间,二进制文件自动删除的天数,0代表不删除</span><br><span class="hljs-attr">max_binlog_size</span> = <span class="hljs-number">100</span>M     <span class="hljs-comment"># 单个日志文件的大小限制，超出会新建一个</span><br></code></pre></td></tr></table></figure><h4 id="操作步骤：">操作步骤：</h4><blockquote><p><strong>Linux下的配置文件为/etc/my.cnf，Windows下的配置文件为my.ini。</strong></p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs powershell">[<span class="hljs-type">root</span>@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># vim /etc/my.cnf</span><br>[<span class="hljs-type">mysqld</span>]<br><br><span class="hljs-comment"># 省略部分内容</span><br>server<span class="hljs-literal">-id</span> = <span class="hljs-number">1</span>                     <span class="hljs-comment"># mysql5.7必须加，否则mysql服务启动报错</span><br>log<span class="hljs-literal">-bin</span> = mysql_bin_log           <span class="hljs-comment"># 路径及命名，默认在data下</span><br>expire_logs_days = <span class="hljs-number">10</span>             <span class="hljs-comment"># 过期时间,二进制文件自动删除的天数,0代表不删除</span><br>max_binlog_size = <span class="hljs-number">100</span>M            <span class="hljs-comment"># 单个日志文件大小</span><br><br>[<span class="hljs-type">root</span>@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># systemctl restart mysqld.service</span><br>[<span class="hljs-type">root</span>@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># systemctl status mysqld.service</span><br>● mysqld.service - MySQL Server<br>   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled)<br>   Active: active (running) since 二 <span class="hljs-number">2020</span><span class="hljs-literal">-06</span><span class="hljs-literal">-16</span> <span class="hljs-number">17</span>:<span class="hljs-number">47</span>:<span class="hljs-number">34</span> CST; <span class="hljs-number">35</span>s ago<br>     Docs: man:mysqld(<span class="hljs-number">8</span>)<br>           http://dev.mysql.com/doc/refman/en/using<span class="hljs-literal">-systemd</span>.html<br>  <span class="hljs-keyword">Process</span>: <span class="hljs-number">78724</span> ExecStart=/usr/sbin/mysqld -<span class="hljs-literal">-daemonize</span> -<span class="hljs-literal">-pid</span><span class="hljs-operator">-file</span>=/var/run/mysqld/mysqld.pid <span class="hljs-variable">$MYSQLD_OPTS</span> (code=exited, status=<span class="hljs-number">0</span>/SUCCESS)<br>  <span class="hljs-keyword">Process</span>: <span class="hljs-number">78701</span> ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=<span class="hljs-number">0</span>/SUCCESS)<br> Main PID: <span class="hljs-number">78726</span> (mysqld)<br>    Tasks: <span class="hljs-number">27</span><br>   CGroup: /system.slice/mysqld.service<br>           └─<span class="hljs-number">78726</span> /usr/sbin/mysqld -<span class="hljs-literal">-daemonize</span> -<span class="hljs-literal">-pid</span><span class="hljs-operator">-file</span>=/var/run/mysqld/mysqld.pid<br><br><span class="hljs-number">6</span>月 <span class="hljs-number">16</span> <span class="hljs-number">17</span>:<span class="hljs-number">47</span>:<span class="hljs-number">25</span> my_oracle systemd[<span class="hljs-number">1</span>]: Starting MySQL Server...<br><span class="hljs-number">6</span>月 <span class="hljs-number">16</span> <span class="hljs-number">17</span>:<span class="hljs-number">47</span>:<span class="hljs-number">34</span> my_oracle systemd[<span class="hljs-number">1</span>]: Started MySQL Server.<br></code></pre></td></tr></table></figure><h3 id="（2）查看二进制日志状态">（2）查看二进制日志状态</h3><p><strong>重启MySQL后，你就会发现log_bin变为了ON，二进制日志（binary log）默认放在数据目录下（系统变量datadir下）。</strong></p><blockquote><p><strong>show variables like ‘log_bin%’;</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#39;log_bin%&#39;;<br>+---------------------------------+------------------------------------+<br>| Variable_name                   | Value                              |<br>+---------------------------------+------------------------------------+<br>| log_bin                         | ON                                 |<br>| log_bin_basename                | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql_bin_log       |<br>| log_bin_index                   | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql_bin_log.index |<br>| log_bin_trust_function_creators | OFF                                |<br>| log_bin_use_v1_row_events       | OFF                                |<br>+---------------------------------+------------------------------------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（3）查看当前服务器所有的二进制日志文件">（3）查看当前服务器所有的二进制日志文件</h3><blockquote><p><strong>show binary logs;</strong></p></blockquote><p><strong>MySQL二进制日志存储了所有的变更信息，MySQL二进制日志经常使用。当MySQL创建二进制日志文件时，首先创建一个以’filename’为名称，以’.index’为后缀的文件；在创建一个以’filename’为名称，以’.000001’为后缀的文件。当MySQL服务重启一次，以’.000001’为后缀的文件会增加一个，并且后缀名加1递增。如果日志长度超过max_binlog_size的上限，也会创建一个新的日志。 Show binary logs;可以查看当前的*二进制日志文件个数及其文件名。二进制日志并不能直接查看，如果想要查看日志内容，可以通过mysqlbinlog命令查看。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show binary logs;<br>+----------------------+-----------+<br>| Log_name             | File_size |<br>+----------------------+-----------+<br>| mysql_bin_log.000001 |       120 |<br>+----------------------+-----------+<br>1 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>或者：</strong></p><blockquote><p><strong>show master logs;</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show master logs;<br>+----------------------+-----------+<br>| Log_name             | File_size |<br>+----------------------+-----------+<br>| mysql_bin_log.000001 |       120 |<br>+----------------------+-----------+<br>1 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（4）查看当前二进制日志文件状态">（4）查看当前二进制日志文件状态</h3><blockquote><p><strong>show master status;</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show master status;<br>+----------------------+----------+--------------+------------------+-------------------+<br>| File                 | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |<br>+----------------------+----------+--------------+------------------+-------------------+<br>| mysql_bin_log.000001 |      120 |              |                  |                   |<br>+----------------------+----------+--------------+------------------+-------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h1>三、切换二进制日志</h1><p><strong>执行 flush logs 可以刷新切换二进制文件。</strong></p><p><strong>每次重启MySQL服务也会生成一个新的二进制日志文件，相当于二进制日志切换。</strong></p><h2 id="1、重启MySQL服务切换日志">1、重启MySQL服务切换日志</h2><h3 id="（1）重启MySQL服务器前">（1）重启MySQL服务器前</h3><p><strong>查看二进制日志状态，如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show master status;<br>+----------------------+----------+--------------+------------------+-------------------+<br>| File                 | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |<br>+----------------------+----------+--------------+------------------+-------------------+<br>| mysql_bin_log.000001 |      120 |              |                  |                   |<br>+----------------------+----------+--------------+------------------+-------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（2）重启MySQL服务">（2）重启MySQL服务</h3><blockquote><p><strong>service mysql restart</strong></p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">[<span class="hljs-type">root</span>@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># service mysql restart</span><br>Shutting down MySQL.... SUCCESS! <br>Starting MySQL.. SUCCESS! <br>[<span class="hljs-type">root</span>@<span class="hljs-number">192</span> ~]<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h3 id="（3）查看日志">（3）查看日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show master status;<br>+----------------------+----------+--------------+------------------+-------------------+<br>| File                 | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |<br>+----------------------+----------+--------------+------------------+-------------------+<br>| mysql_bin_log.000002 |      120 |              |                  |                   |<br>+----------------------+----------+--------------+------------------+-------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="2、切换二进制日志并查看">2、切换二进制日志并查看</h2><p><strong>执行flush logs刷新，切换二进制文件，并查看二进制日志状态。如下所示：</strong></p><blockquote><p><strong>flush logs;</strong></p><p><strong>show master status;</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; flush logs;<br>Query OK, 0 rows affected (0.06 sec)<br><br>mysql&gt; show master status;<br>+----------------------+----------+--------------+------------------+-------------------+<br>| File                 | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |<br>+----------------------+----------+--------------+------------------+-------------------+<br>| mysql_bin_log.000003 |      120 |              |                  |                   |<br>+----------------------+----------+--------------+------------------+-------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>切换二进制日志时，你会看到这些number会不断递增。另外，除了这些二进制日志文件外，你会看到还生成了一个mysql-bin.index的文件，这个文件中存储所有二进制日志文件的清单又称为二进制文件的索引。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@192 ~]# ll /var/lib/mysql/<br><span class="hljs-meta">#</span><span class="bash">源码安装路径是：/usr/<span class="hljs-built_in">local</span>/mysql/data/</span><br>-rw-rw----. 1 mysql mysql      171 4月  10 11:25 mysql_bin_log.000001<br>-rw-rw----. 1 mysql mysql      143 4月  10 11:25 mysql_bin_log.000002<br>-rw-rw----. 1 mysql mysql      143 4月  10 11:25 mysql_bin_log.000003<br>-rw-rw----. 1 mysql mysql       92 4月  10 11:25 mysql_bin_log.index<br><br>[root@192 ~]# cat /var/lib/mysql/mysql_bin_log.index <br>./mysql_bin_log.000001<br>./mysql_bin_log.000002<br>./mysql_bin_log.000003<br></code></pre></td></tr></table></figure><h1>四、查看二进制日志</h1><h2 id="1、查看当前日志">1、查看当前日志</h2><blockquote><p><strong>show binlog events;</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show binlog events;<br>+----------------------+-----+-------------+-----------+-------------+---------------------------------------+<br>| Log_name             | Pos | Event_type  | Server_id | End_log_pos | Info                                  |<br>+----------------------+-----+-------------+-----------+-------------+---------------------------------------+<br>| mysql_bin_log.000001 |   4 | Format_desc |         1 |         120 | Server ver: 5.6.42-log, Binlog ver: 4 |<br>| mysql_bin_log.000001 | 120 | Rotate      |         1 |         171 | mysql_bin_log.000002;pos&#x3D;4            |<br>+----------------------+-----+-------------+-----------+-------------+---------------------------------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="2、查看指定日志">2、查看指定日志</h2><h3 id="（1）模拟产生二进制日志">（1）模拟产生二进制日志</h3><blockquote><p><strong>建库、建表、插入数据</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create database demo;<br>Query OK, 1 row affected (0.00 sec)<br><br>mysql&gt; use demo;<br>Database changed<br><br>mysql&gt; create table student(stuNo int, stuName varchar(25));<br>Query OK, 0 rows affected (0.01 sec)<br><br>mysql&gt; insert into student values(1001,&#39;John&#39;);<br>Query OK, 1 row affected (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（2）查看日志">（2）查看日志</h3><blockquote><p><strong>show binlog events in ‘mysql_bin_log.000002’;</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show binlog events in &#39;mysql_bin_log.000002&#39;;<br>+----------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------+<br>| Log_name             | Pos | Event_type  | Server_id | End_log_pos | Info                                                             |<br>+----------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------+<br>| mysql_bin_log.000002 |   4 | Format_desc |         1 |         120 | Server ver: 5.6.42-log, Binlog ver: 4                            |<br>| mysql_bin_log.000002 | 120 | Query       |         1 |         214 | create database demo                                             |<br>| mysql_bin_log.000002 | 214 | Query       |         1 |         340 | use &#96;demo&#96;; create table student(stuNo int, stuName varchar(25)) |<br>| mysql_bin_log.000002 | 340 | Query       |         1 |         419 | BEGIN                                                            |<br>| mysql_bin_log.000002 | 419 | Query       |         1 |         532 | use &#96;demo&#96;; insert into student values(1001,&#39;John&#39;)              |<br>| mysql_bin_log.000002 | 532 | Xid         |         1 |         563 | COMMIT &#x2F;* xid&#x3D;15 *&#x2F;                                              |<br>+----------------------+-----+-------------+-----------+-------------+------------------------------------------------------------------+<br>6 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><blockquote><p><strong>show binlog events in ‘mysql_bin_log.000002’ from 419;</strong></p><p><strong>查看某个节点</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show binlog events in &#39;mysql_bin_log.000002&#39; from 419;<br>+----------------------+-----+------------+-----------+-------------+-----------------------------------------------------+<br>| Log_name             | Pos | Event_type | Server_id | End_log_pos | Info                                                |<br>+----------------------+-----+------------+-----------+-------------+-----------------------------------------------------+<br>| mysql_bin_log.000002 | 419 | Query      |         1 |         532 | use &#96;demo&#96;; insert into student values(1001,&#39;John&#39;) |<br>| mysql_bin_log.000002 | 532 | Xid        |         1 |         563 | COMMIT &#x2F;* xid&#x3D;15 *&#x2F;                                 |<br>+----------------------+-----+------------+-----------+-------------+-----------------------------------------------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><blockquote><p><strong>show binlog events in ‘mysql_bin_log.000002’ from 419 limit 1;</strong></p><p><strong>查看从419开始的一条数据</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show binlog events in &#39;mysql_bin_log.000002&#39; from 419 limit 1;<br>+----------------------+-----+------------+-----------+-------------+-----------------------------------------------------+<br>| Log_name             | Pos | Event_type | Server_id | End_log_pos | Info                                                |<br>+----------------------+-----+------------+-----------+-------------+-----------------------------------------------------+<br>| mysql_bin_log.000002 | 419 | Query      |         1 |         532 | use &#96;demo&#96;; insert into student values(1001,&#39;John&#39;) |<br>+----------------------+-----+------------+-----------+-------------+-----------------------------------------------------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; show binlog events in &#39;mysql_bin_log.000002&#39; from 419 limit 2;<br>+----------------------+-----+------------+-----------+-------------+-----------------------------------------------------+<br>| Log_name             | Pos | Event_type | Server_id | End_log_pos | Info                                                |<br>+----------------------+-----+------------+-----------+-------------+-----------------------------------------------------+<br>| mysql_bin_log.000002 | 419 | Query      |         1 |         532 | use &#96;demo&#96;; insert into student values(1001,&#39;John&#39;) |<br>| mysql_bin_log.000002 | 532 | Xid        |         1 |         563 | COMMIT &#x2F;* xid&#x3D;15 *&#x2F;                                 |<br>+----------------------+-----+------------+-----------+-------------+-----------------------------------------------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h1>五、使用二进制日志恢复数据库</h1><p><strong>如果开启了二进制日志，出现了数据丢失，可以通过二进制日志恢复数据库，语法如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqlbinlog [option] filename | mysql -u user -p passwd<br></code></pre></td></tr></table></figure><p><strong>option的参数主要有两个 <code>--start-datetime</code> <code>--stop-datetime</code> 和 <code>start-position</code> <code>--stop-position</code> ,前者指定恢复的时间点，后者指定恢复的位置（位置指的是二进制文件中 # at 580 580就是位置），原理就是把记录的语句重新执行了一次。如果恢复了两次。会产生重复数据。</strong></p><h2 id="1、按时间点恢复数据">1、按时间点恢复数据</h2><h3 id="（1）从日志开头截止到某个时间点的恢复">（1）从日志开头截止到某个时间点的恢复</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqlbinlog [--no-defaults] --stop-datetime&#x3D;’年-月-日 小时:分钟:秒’ 二进制日志 | mysql -u 用户名 -p<br></code></pre></td></tr></table></figure><p><strong>例如：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqlbinlog [--no-defaults] --stop-datetime=’2020-03-18 10:30:26’ /var/lib/mysql/mysql_bin_log.000005 | mysql -uroot -p<br></code></pre></td></tr></table></figure><h3 id="（2）从某个时间点到日志结尾的恢复">（2）从某个时间点到日志结尾的恢复</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqlbinlog [--no-defaults] --start-datetime&#x3D;’年-月-日 小时:分钟:秒’ 二进制日志 | mysql -u 用户名 -p<br></code></pre></td></tr></table></figure><p><strong>例如：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqlbinlog [--no-defaults] --start-datetime=’2020-01-10 8:20:20’ /var/lib/mysql/mysql_bin_log.000005 | mysql -uroot -p<br></code></pre></td></tr></table></figure><h3 id="（3）从某个时间点到某个时间点的恢复">（3）从某个时间点到某个时间点的恢复</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqlbinlog [--no-defaults] --start-datetime&#x3D;’年-月-日 小时:分钟:秒’ --stop-datetime&#x3D;’年-月-日小时:分钟:秒’ 二进制日志 | mysql -u 用户名 -p<br></code></pre></td></tr></table></figure><p><strong>例如：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysqlbinlog [--no-defaults] --start-datetime=’2010-11-10 8:20:20’ --stop-datetime=’2020-03-18 10:30:26’ /var/lib/mysql/mysql_bin_log.000005 | mysql -uroot -p<br></code></pre></td></tr></table></figure><h2 id="2、按位置恢复数据">2、按位置恢复数据</h2><h3 id="（1）从某个位置到日志结尾的恢复">（1）从某个位置到日志结尾的恢复</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/local/mysql/bin/mysqlbinlog --start-position='275' /var/lib/mysql/mysql_bin_log.000005 | mysql -uroot -p<br>Enter password: <br>[root@bogon ~]#<br></code></pre></td></tr></table></figure><h3 id="（2）从日志开头位置到日志结尾的恢复">（2）从日志开头位置到日志结尾的恢复</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/local/mysql/bin/mysqlbinlog --stop-position='465' /var/lib/mysql/mysql_bin_log.000005 | mysql -uroot -p<br>Enter password: <br>[root@bogon ~]#<br></code></pre></td></tr></table></figure><h3 id="（3）从某个位置到某个位置的恢复">（3）从某个位置到某个位置的恢复</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">/usr/local/mysql/bin/mysqlbinlog --start-position='4' --stop-position='120' /var/lib/mysql/mysql_bin_log.000005 | mysql -uroot -p<br>Enter password: <br>[root@bogon ~]#<br></code></pre></td></tr></table></figure><p><strong>例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; drop database demo;<br>Query OK, 1 row affected (0.00 sec)<br><br>mysql&gt; show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>+--------------------+<br>4 rows in set (0.00 sec)<br><br>[root@192 ~]# &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqlbinlog --start-position&#x3D;&#39;4&#39; --stop-position&#x3D;&#39;313&#39; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;mysql_bin_log.000002 | mysql -uroot -p<br><br>mysql&gt; show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| demo               |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>+--------------------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h1>六、删除二进制日志</h1><h2 id="1、删除某个日志之前的所有二进制日志文件">1、删除某个日志之前的所有二进制日志文件</h2><p><strong><code>purge binary logs to xxx;</code> 表示删除某个日志之前的所有二进制日志文件，这个命令会修改index中相关数据。</strong></p><p><strong>如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show master logs;<br>+----------------------+-----------+<br>| Log_name             | File_size |<br>+----------------------+-----------+<br>| mysql_bin_log.000001 |       143 |<br>| mysql_bin_log.000002 |       586 |<br>| mysql_bin_log.000003 |       171 |<br>| mysql_bin_log.000004 |       171 |<br>| mysql_bin_log.000005 |       120 |<br>+----------------------+-----------+<br>5 rows in set (0.00 sec)<br><br>mysql&gt; purge binary logs to &#39;mysql_bin_log.000002&#39;;<br>Query OK, 0 rows affected (0.03 sec)<br><br>mysql&gt; show master logs;<br>+----------------------+-----------+<br>| Log_name             | File_size |<br>+----------------------+-----------+<br>| mysql_bin_log.000002 |       586 |<br>| mysql_bin_log.000003 |       171 |<br>| mysql_bin_log.000004 |       171 |<br>| mysql_bin_log.000005 |       120 |<br>+----------------------+-----------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>查看日志清单：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@192 ~]# cat /var/lib/mysql/mysql_bin_log.index <br>./mysql_bin_log.000002<br>./mysql_bin_log.000003<br>./mysql_bin_log.000004<br>./mysql_bin_log.000005<br></code></pre></td></tr></table></figure><h2 id="2、清除某个时间点以前的二进制日志文件">2、清除某个时间点以前的二进制日志文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; purge binary logs before &#39;2020-03-10 10:10:00&#39;;<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="3、清除7天前的二进制日志文件">3、清除7天前的二进制日志文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; purge master logs before date_sub( now( ), interval 7 day);<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="4、清除所有的二进制日志文件（当前不存在主从复制关系）">4、清除所有的二进制日志文件（当前不存在主从复制关系）</h2><p><strong>reset之后，从000001开始生成全新空日志。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show master logs;<br>+----------------------+-----------+<br>| Log_name             | File_size |<br>+----------------------+-----------+<br>| mysql_bin_log.000002 |       586 |<br>| mysql_bin_log.000003 |       171 |<br>| mysql_bin_log.000004 |       171 |<br>| mysql_bin_log.000005 |       120 |<br>+----------------------+-----------+<br>4 rows in set (0.00 sec)<br><br>mysql&gt; reset master;<br>Query OK, 0 rows affected (0.01 sec)<br><br>mysql&gt; show master logs;<br>+----------------------+-----------+<br>| Log_name             | File_size |<br>+----------------------+-----------+<br>| mysql_bin_log.000001 |       120 |<br>+----------------------+-----------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="5、自动清理二进制日志文件">5、自动清理二进制日志文件</h2><p><strong>另外，我们也可以设置expire_logs_days参数，设置自动清理，其默认值为0,表示不启用过期自动删除功能，如果启用了自动清理功能，表示超出此天数的二进制日志文件将被自动删除，自动删除工作通常发生在MySQL启动时或flush日志时。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#39;expire_logs_days&#39;;<br>+------------------+-------+<br>| Variable_name    | Value |<br>+------------------+-------+<br>| expire_logs_days | 10    |<br>+------------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h1>七、停止二进制日志</h1><p><strong>可以通过修改配置文件停止二进制日志功能，但是需要重启数据库，mysql提供了语句可以在线停止二进制功能。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">set sql_log_bin &#x3D; 0       # 停止二进制日志功能<br>set sql_log_bin &#x3D; 1       # 开启二进制日志功能<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql结构化查询语句 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql日志</title>
      <link href="/posts/b6d.html"/>
      <url>/posts/b6d.html</url>
      
        <content type="html"><![CDATA[<h1>mysql日志</h1><p><strong>MySQL日志记录了MySQL数据库日常操作和错误信息。MySQL有不同类型的日志文件（各自存储了不同类型的日志），从日志当中可以查询到MySQL数据库的运行情况、用户的操作、错误的信息等。</strong></p><h2 id="A：MySQL日志分为4大类">A：MySQL日志分为4大类</h2><ul><li><strong>错误日志：记录mysql服务的启动，运行或停止mysql服务时出现的问题</strong></li><li><strong>查询日志：记录建立的客户端的连接和执行的语句</strong></li><li><strong>二进制日志：记录所有更改数据的语句，可以用于数据的复制</strong></li><li><strong>慢查询日志：记录所有执行的时间超过long_query_time的所有查询或不使用索引的查询</strong></li></ul><p><strong>默认情况下，所有日志创建与MySQL数据目录中，通过刷新日志，可以强制MySQL关闭和重新打开日志文件，Flush logs刷新日志或者执行mysqladmin flush-logs 如果正使用MySQL复制功能，在复制服务器上可以维护更多日志文件，这种日志我们称为接替日志。启动日志功能会降低MySQL数据库的性能。</strong></p><h2 id="B：错误日志：Error-Log">B：错误日志：Error Log</h2><p><strong>在mysql数据库中，错误日志功能是默认开启的。默认情况下，错误日志存储在mysql数据库的数据目录中。错误日志文件通常的名称为hostname.err。其中，hostname表示服务器主机名。 错误日志信息可以自己进行配置的，错误日志所记录的信息是可以通过log-error和log-warnings来定义的，其中log-error是定义是否启用错误日志的功能和错误日志的存储位置，log-warnings是定义是否将警告信息也定义至错误日志中。默认情况下错误日志大概记录以下几个方面的信息：服务器启动和关闭过程中的信息（未必是错误信息，如mysql如何启动InnoDB的表空间文件的、如何初始化自己的存储引擎的等等）、服务器运行过程中的错误信息、事件调度器运行一个事件时产生的信息、在从服务器上启动服务器进程时产生的信息 注1：MySQL有很多系统变量可以设置，系统变量设置不同，会导致系统运行状态的不同。因此mysql提供两组命令，分别查看系统设置和运行状态。</strong></p><h2 id="C：MySQL日志缓存">C：MySQL日志缓存</h2><p><strong>一个高速、稳定、可靠的系统，缓存在其中必定起着至关重要的作用。MySQL日志处理也使用了缓存机制。MySQL日志最初存放在MySQL服务器的内存中，若超过指定的存储容量，内存中的日志则写（或者刷新flush）到外存中，以数据库表或者以文件的方式永远的保存在硬盘中。</strong></p><h3 id="1、查看系统设置：">1、查看系统设置：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW [GLOBAL | SESSION] VARIABLES [like_or_where] SHOW VARIABLES： shows the values of MySQL system variables.<br></code></pre></td></tr></table></figure><h3 id="2、运行状态：">2、运行状态：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW [GLOBAL | SESSION] STATUS [like_or_where] SHOW STATUS： provides server status information.<br></code></pre></td></tr></table></figure><h2 id="D：如何修改系统配置">D：如何修改系统配置</h2><h3 id="方法1：配置文件设置my-cnf-如：binlog-cache-size-1M">方法1：配置文件设置my.cnf 如：binlog_cache_size = 1M</h3><h3 id="方法2：set-global-binlog-cache-size-1048576-注">方法2：set global binlog_cache_size = 1048576; 注</h3><h3 id="2：查看mysql的版本">2：查看mysql的版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@localhost ~]# mysql -V<br>mysql Ver 14.14 Distrib 5.7.28, for Linux (x86_64) using EditLine wrapper<br></code></pre></td></tr></table></figure><p><strong>或</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; status;<br>--------------<br>mysql Ver 14.14 Distrib 5.7.28, for Linux (x86_64) using EditLine wrapper<br>Connection id: 5<br>Current database:<br>Current user: root@localhost<br>SSL: Not in use<br>Current pager: stdout<br>Using outfile: &#39;&#39;<br>Using delimiter: ;<br>Server version: 5.7.28 Source distribution<br>Protocol version: 10<br>Connection: Localhost via UNIX socket<br>Server characterset: utf8<br>Db characterset: utf8<br>Client characterset: utf8<br>Conn. characterset: utf8<br>UNIX socket: &#x2F;tmp&#x2F;mysql.sock<br>Uptime: 1 hour 12 min 8 sec<br>Threads: 1 Questions: 10 Slow queries: 0 Opens: 106 Flush tables: 1 Open<br>tables: 99 Queries per second avg: 0.002<br>--------------<br></code></pre></td></tr></table></figure><p><strong>或</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select version();<br>+-----------+<br>| version() |<br>+-----------+<br>| 5.7.28 |<br>+-----------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="E-一般而言，日志级别的定义没有会话变量都只是在全局级别下进行定义-错误日志的状态：">E: 一般而言，日志级别的定义没有会话变量都只是在全局级别下进行定义 错误日志的状态：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show global variables like &#39;%log_error%&#39;;<br>+---------------------+---------------------------------+<br>| Variable_name | Value |<br>+---------------------+---------------------------------+<br>| binlog_error_action | ABORT_SERVER |<br>| log_error | &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;mysql.err |<br>| log_error_verbosity | 3 |<br>+---------------------+---------------------------------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>其中 log_error定义为错误日志文件路径 log_error_verbosity:</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200616171633354.png" alt="image-20200616171633354"></p><p><strong>更改错误日志位置可以使用log-error来设置形式如下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">\#vi /etc/my.cnf<br>log-error = /usr/local/mysql/data/mysqld.err<br></code></pre></td></tr></table></figure><p><strong>查看mysql错误日志：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">tail /usr/<span class="hljs-built_in">local</span>/mysql/data/mysqld.err</span><br></code></pre></td></tr></table></figure><p><strong>为了方便维护需要，有时候会希望将错误日志中的内容做备份并重新开始记录，这时候就可以利用MySQL 的FLUSH LOGS 命令来告诉MySQL 备份旧日志文件并生成新的日志文件。备份文件名以“.old”结尾。 删除错误日志： 在mysql5.5.7之前：数据库管理员可以删除很长时间之前的错误日志，以保证mysql服务器上的硬盘空间。mysql数据库中，可以使用mysqladmin命令开启新的错误日志。mysqladmin命令的语法如下：mysqladmin –u root –p flush-logs也可以登录mysql数据库中使用FLUSH LOGS语句来开启新的错误日志。 在mysql5.5.7之后：服务器将关闭此项功能。只能使用重命名原来的错误日志文件，手动冲洗日志创建一个新的：方式如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">\# mv mysql.err mysql.old<br>\# mysqladmin -uroot -p flush-logs<br>Enter password:<br></code></pre></td></tr></table></figure><h2 id="F：-二进制日志">F： 二进制日志</h2><p><strong>主要记录MySQL数据库的变化，二进制日志以一种有效的格式，并且是事务安全的方式包含更新日志中可用的信息。二进制日志包含了所有更新了数据或者已经潜在更新了数据。二进制日志还包含关于每个更新数据库的语句的执行时间，它不包含没有修改任何数据的语句。使用二进制日志的主要目的是最大可能地恢复数据库。</strong></p><p><strong>启动二进制日志，默认情况下二进制日志是关闭的 编辑配置文件My.ini 或my.cnf</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@localhost ~]# vim &#x2F;etc&#x2F;my.cnf<br>【格式】：<br>[mysqld]<br>log-bin<br>expire_logs_days &#x3D; 10<br>max_binlog_size &#x3D; 100M<br>log-bin [&#x3D;path&#x2F;[filename]] &#x2F;&#x2F;二进制日志[路径[指定日志文件的名字<br>Expire_logs_days &#x3D; 10 &#x2F;&#x2F;清除日志的天数<br>Max_binlog_size &#x3D; 100M &#x2F;&#x2F;单个日志文件的大小限制，超出会新建一个<br>默认为1GB<br>【重启mysql】<br></code></pre></td></tr></table></figure><p><strong><code>Show variables</code> 或<code>show variables like 'log_%';</code> 语句来查询日志设置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br>mysql&gt; show variables like &#39;log_%&#39;;<br>+---------------------------------+-----------------------------------------------<br>--+<br>| Variable_name | Value<br>|<br>+---------------------------------+-----------------------------------------------<br>--+<br>| log_bin | ON<br>|<br>| log_bin_trust_function_creators | OFF<br>|<br>| log_error |<br>&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;localhost.localdomain.err |<br>| log_output | FILE<br>|<br>| log_queries_not_using_indexes | OFF<br>|<br>| log_slave_updates | OFF<br>|<br>| log_slow_queries | OFF<br>|<br>| log_warnings | 1<br>|<br>+---------------------------------+-----------------------------------------------<br>--+<br>8 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="【查看二进制日志】">【查看二进制日志】</h3><p><strong>MySQL二进制日志存储了所有的变更信息，MySQL二进制日志经常使用。当MySQL创建二进制日志文件时，首先创建一个以’filename’为名称，以’.index’为后缀的文件；在创建一个以’filename’为名称，以’.000001’为后缀的文件。当MySQL服务重启一次，以’.000001’为后缀的文件会增加一个，并且后缀名加1递增。如果日志长度超过max_binlog_size的上限，也会创建一个新的日志。 Show binary logs;可以查看当前的二进制日志文件个数及其文件名。二进制日志并不能直接查看，如果想要查看日志内容，可以通过mysqlbinlog命令查看</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW BINARY LOGS;<br>+------------------+-----------+<br>| Log_name | File_size |<br>+------------------+-----------+<br>| mysql-bin.000001 | 2189 |<br>| mysql-bin.000002 | 107 |<br>+------------------+-----------+<br>2 rows in set (0.06 sec)<br></code></pre></td></tr></table></figure><h3 id="【查看二进制日志的内容】-退出mysql在命令行">【查看二进制日志的内容】 退出mysql在命令行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@localhost data]# mysqlbinlog mysql-bin.000001<br>&#x2F;*!40019 SET @@session.max_insert_delayed_threads&#x3D;0*&#x2F;;<br>&#x2F;*!50003 SET @OLD_COMPLETION_TYPE&#x3D;@@COMPLETION_TYPE,COMPLETION_TYPE&#x3D;0*&#x2F;;<br>DELIMITER &#x2F;*!*&#x2F;;<br># at 4<br>#170826 11:40:02 server id 1 end_log_pos 107 Start: binlog v 4, server v<br>5.5.22-log created 170826 11:40:02 at startup<br>ROLLBACK&#x2F;*!*&#x2F;;<br>BINLOG &#39;<br>... ... 省略<br></code></pre></td></tr></table></figure><h3 id="【删除二进制日志】">【删除二进制日志】</h3><p><strong>MySQL的二进制文件可以配置自动删除，同时MySQL提供了手动删除二进制文件的方法RESET MASTER 删除所有的二进制日志文件；PURGE MASTER LOGS只删除部分二进制日志文件。 Reset master; 删除所有二进制日志 Purge master logs to ‘二进制名’ 删除单个二进制日志之前的</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; PURGE MASTER LOGS TO &quot;mysql-bin.000012&quot;;<br>Query OK, 0 rows affected (0.02 sec)<br>Purge binary logs before ‘date’ 删除指定日期之前的日志<br>mysql&gt; PURGE MASTER LOGS BEFORE &#39;20170101&#39;;<br>Query OK, 0 rows affected (0.07 sec)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql结构化查询语句 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL创建触发器</title>
      <link href="/posts/184.html"/>
      <url>/posts/184.html</url>
      
        <content type="html"><![CDATA[<h1>一、MySQL创建触发器（CREATE TRIGGER）</h1><h2 id="基本语法">基本语法</h2><p><strong>在 MySQL 5.7 中，可以使用 CREATE TRIGGER 语句创建触发器。</strong></p><h4 id="语法格式如下：">语法格式如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE &lt;触发器名&gt; &lt; BEFORE | AFTER &gt;<br>&lt;INSERT | UPDATE | DELETE &gt;<br>ON &lt;表名&gt; FOR EACH Row&lt;触发器主体&gt;<br></code></pre></td></tr></table></figure><h2 id="语法说明如下。">语法说明如下。</h2><h3 id="1-触发器名">1) 触发器名</h3><p><strong>触发器的名称，触发器在当前数据库中必须具有唯一的名称。如果要在某个特定数据库中创建，名称前面应该加上数据库的名称。</strong></p><h3 id="2-INSERT-UPDATE-DELETE">2) INSERT | UPDATE | DELETE</h3><p><strong>触发事件，用于指定激活触发器的语句的种类。</strong></p><p><strong>注意：三种触发器的执行时间如下。</strong></p><ul><li><strong>INSERT：将新行插入表时激活触发器。例如，INSERT 的 BEFORE 触发器不仅能被 MySQL 的 INSERT 语句激活，也能被 LOAD DATA 语句激活。</strong></li><li><strong>DELETE： 从表中删除某一行数据时激活触发器，例如 DELETE 和 REPLACE 语句。</strong></li><li><strong>UPDATE：更改表中某一行数据时激活触发器，例如 UPDATE 语句。</strong></li></ul><h3 id="3-BEFORE-AFTER">3) BEFORE | AFTER</h3><p><strong>BEFORE 和 AFTER，触发器被触发的时刻，表示触发器是在激活它的语句之前或之后触发。若希望验证新数据是否满足条件，则使用 BEFORE 选项；若希望在激活触发器的语句执行之后完成几个或更多的改变，则通常使用 AFTER 选项。</strong></p><h3 id="4-表名">4) 表名</h3><p><strong>与触发器相关联的表名，此表必须是永久性表，不能将触发器与临时表或视图关联起来。在该表上触发事件发生时才会激活触发器。同一个表不能拥有两个具有相同触发时刻和事件的触发器。例如，对于一张数据表，不能同时有两个 BEFORE UPDATE 触发器，但可以有一个 BEFORE UPDATE 触发器和一个 BEFORE INSERT 触发器，或一个 BEFORE UPDATE 触发器和一个 AFTER UPDATE 触发器。</strong></p><h3 id="5-触发器主体">5) 触发器主体</h3><p><strong>触发器动作主体，包含触发器激活时将要执行的 MySQL 语句。如果要执行多个语句，可使用 BEGIN…END 复合语句结构。</strong></p><h3 id="6-FOR-EACH-ROW">6) FOR EACH ROW</h3><p><strong>一般是指行级触发，对于受触发事件影响的每一行都要激活触发器的动作。例如，使用 INSERT 语句向某个表中插入多行数据时，触发器会对每一行数据的插入都执行相应的触发器动作。</strong></p><blockquote><p><strong>注意：每个表都支持 INSERT、UPDATE 和 DELETE 的 BEFORE 与 AFTER，因此每个表最多支持 6 个触发器。每个表的每个事件每次只允许有一个触发器。单一触发器不能与多个事件或多个表关联。</strong></p></blockquote><p><strong>另外，在 MySQL 中，若需要查看数据库中已有的触发器，则可以使用 SHOW TRIGGERS 语句。</strong></p><h1>二、创建 BEFORE 类型触发器</h1><p><strong>在 test_db 数据库中，数据表 tb_emp8 为员工信息表，包含 id、name、deptId 和 salary 字段，数据表 tb_emp8 的表结构如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table tb_emp8(<br>    -&gt; id int(11) not null PRIMARY KEY,<br>    -&gt; name VARCHAR(22) UNIQUE,<br>    -&gt; deptId int(11) not null,<br>    -&gt; salary FLOAT DEFAULT 0<br>    -&gt; )charset &#x3D; &#39;utf8mb4&#39;;<br>Query OK, 0 rows affected (0.01 sec)<br><br>mysql&gt; SELECT * FROM tb_emp8;<br>Empty set (0.07 sec)<br>mysql&gt; DESC tb_emp8;<br>+--------+-------------+------+-----+---------+-------+<br>| Field  | Type        | Null | Key | Default | Extra |<br>+--------+-------------+------+-----+---------+-------+<br>| id     | int(11)     | NO   | PRI | NULL    |       |<br>| name   | varchar(22) | YES  | UNI | NULL    |       |<br>| deptId | int(11)     | NO   | MUL | NULL    |       |<br>| salary | float       | YES  |     | 0       |       |<br>+--------+-------------+------+-----+---------+-------+<br>4 rows in set (0.05 sec)<br></code></pre></td></tr></table></figure><h3 id="【实例-1】">【实例 1】</h3><p><strong>创建一个名为 SumOfSalary 的触发器，触发的条件是向数据表 tb_emp8 中插入数据之前，对新插入的 salary 字段值进行求和计算。输入的 SQL 语句和执行过程如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建触发器<br>create TRIGGER SumOfSalary<br>before insert on tb_emp8<br>for each ROW<br>set @sum&#x3D;@sum+NEW.salary;<br></code></pre></td></tr></table></figure><p><strong>触发器 SumOfSalary 创建完成之后，向表 tb_emp8 中插入记录时，定义的 sum 值由 0 变成了 1500，即插入值 1000 和 500 的和，如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET @sum&#x3D;0;<br>Query OK, 0 rows affected (0.05 sec)<br><br>#插入数据，会自动调用触发器会自动调用触发器<br>mysql&gt; INSERT INTO tb_emp8<br>    -&gt; VALUES(1,&#39;A&#39;,1,1000),(2,&#39;B&#39;,1,500);<br>Query OK, 2 rows affected (0.09 sec)<br>Records: 2  Duplicates: 0  Warnings: 0<br>mysql&gt; SELECT @sum;<br>+------+<br>| @sum |<br>+------+<br>| 1500 |<br>+------+<br>1 row in set (0.03 sec)<br></code></pre></td></tr></table></figure><h1>三、创建 AFTER 类型触发器</h1><p><strong>在 test_db 数据库中，数据表 tb_emp6 和 tb_emp7 都为员工信息表，包含 id、name、deptId 和 salary 字段，数据表 tb_emp6 和 tb_emp7 的表结构如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM tb_emp6;<br>Empty set (0.07 sec)<br>mysql&gt; SELECT * FROM tb_emp7;<br>Empty set (0.03 sec)<br>mysql&gt; DESC tb_emp6;<br>+--------+-------------+------+-----+---------+-------+<br>| Field  | Type        | Null | Key | Default | Extra |<br>+--------+-------------+------+-----+---------+-------+<br>| id     | int(11)     | NO   | PRI | NULL    |       |<br>| name   | varchar(25) | YES  |     | NULL    |       |<br>| deptId | int(11)     | YES  | MUL | NULL    |       |<br>| salary | float       | YES  |     | NULL    |       |<br>+--------+-------------+------+-----+---------+-------+<br>4 rows in set (0.00 sec)<br>mysql&gt; DESC tb_emp7;<br>+--------+-------------+------+-----+---------+-------+<br>| Field  | Type        | Null | Key | Default | Extra |<br>+--------+-------------+------+-----+---------+-------+<br>| id     | int(11)     | NO   | PRI | NULL    |       |<br>| name   | varchar(25) | YES  |     | NULL    |       |<br>| deptId | int(11)     | YES  |     | NULL    |       |<br>| salary | float       | YES  |     | 0       |       |<br>+--------+-------------+------+-----+---------+-------+<br>4 rows in set (0.04 sec)<br></code></pre></td></tr></table></figure><h3 id="【实例-2】">【实例 2】</h3><p><strong>创建一个名为 double_salary 的触发器，触发的条件是向数据表 tb_emp6 中插入数据之后，再向数据表 tb_emp7 中插入相同的数据，并且 salary 为 tb_emp6 中新插入的 salary 字段值的 2 倍。输入的 SQL 语句和执行过程如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE TRIGGER double_salary<br>    -&gt; AFTER INSERT ON tb_emp6<br>    -&gt; FOR EACH ROW<br>    -&gt; INSERT INTO tb_emp7<br>    -&gt; VALUES (NEW.id,NEW.name,deptId,2*NEW.salary);<br>Query OK, 0 rows affected (0.25 sec)<br></code></pre></td></tr></table></figure><p><strong>触发器 double_salary 创建完成之后，向表 tb_emp6 中插入记录时，同时向表 tb_emp7 中插入相同的记录，并且 salary 字段为 tb_emp6 中 salary 字段值的 2 倍，如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 插入后触发<br>mysql&gt; INSERT INTO tb_emp6<br>    -&gt; VALUES (1,&#39;A&#39;,1,1000),(2,&#39;B&#39;,1,500);<br>Query OK, 2 rows affected (0.09 sec)<br>Records: 2  Duplicates: 0  Warnings: 0<br><br>mysql&gt; SELECT * FROM tb_emp6;<br>+----+------+--------+--------+<br>| id | name | deptId | salary |<br>+----+------+--------+--------+<br>|  1 | A    |      1 |   1000 |<br>|  2 | B    |      1 |    500 |<br>+----+------+--------+--------+<br>3 rows in set (0.04 sec)<br><br>mysql&gt; SELECT * FROM tb_emp7;<br>+----+------+--------+--------+<br>| id | name | deptId | salary |<br>+----+------+--------+--------+<br>|  1 | A    |      1 |   2000 |<br>|  2 | B    |      1 |   1000 |<br>+----+------+--------+--------+<br>2 rows in set (0.06 sec)<br><br>#删除触发器<br>drop trigger double_salary;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql结构化查询语句 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL触发器</title>
      <link href="/posts/f9da.html"/>
      <url>/posts/f9da.html</url>
      
        <content type="html"><![CDATA[<h2 id="A：MySQL触发器到底是什么？">A：MySQL触发器到底是什么？</h2><p><strong>MySQL 的触发器和存储过程一样，都是嵌入到 MySQL 中的一段程序，是 MySQL 中管理数据的有力工具。不同的是执行存储过程要使用 CALL 语句来调用，而触发器的执行不需要使用 CALL 语句来调用，也不需要手工启动，而是通过对数据表的相关操作来触发、激活从而实现执行。比如当对 student 表进行操作（INSERT，DELETE 或 UPDATE）时就会激活它执行。</strong></p><p><strong>触发器与数据表关系密切，主要用于保护表中的数据。特别是当有多个表具有一定的相互联系的时候，触发器能够让不同的表保持数据的一致性。</strong></p><p><strong>在 MySQL 中，只有执行 INSERT、UPDATE 和 DELETE 操作时才能激活触发器，其它 SQL 语句则不会激活触发器。</strong></p><h4 id="那么为什么要使用触发器呢？比如，在实际开发项目时，我们经常会遇到以下情况：">那么为什么要使用触发器呢？比如，在实际开发项目时，我们经常会遇到以下情况：</h4><ul><li><strong>在学生表中添加一条关于学生的记录时，学生的总数就必须同时改变。</strong></li><li><strong>增加一条学生记录时，需要检查年龄是否符合范围要求。</strong></li><li><strong>删除一条学生信息时，需要删除其成绩表上的对应记录。</strong></li><li><strong>删除一条数据时，需要在数据库存档表中保留一个备份副本。</strong></li></ul><p><strong>虽然上述情况实现的业务逻辑不同，但是它们都需要在数据表发生更改时，自动进行一些处理。这时就可以使用触发器处理。例如，对于第一种情况，可以创建一个触发器对象，每当添加一条学生记录时，就执行一次计算学生总数的操作，这样就可以保证每次添加一条学生记录后，学生总数和学生记录数是一致的。</strong></p><h2 id="B-触发器的优缺点">B: 触发器的优缺点</h2><h3 id="触发器的优点如下：">触发器的优点如下：</h3><ul><li><strong>触发器的执行是自动的，当对触发器相关表的数据做出相应的修改后立即执行。</strong></li><li><strong>触发器可以实施比 FOREIGN KEY 约束、CHECK 约束更为复杂的检查和操作。</strong></li><li><strong>触发器可以实现表数据的级联更改，在一定程度上保证了数据的完整性。</strong></li></ul><h3 id="触发器的缺点如下：">触发器的缺点如下：</h3><ul><li><strong>使用触发器实现的业务逻辑在出现问题时很难进行定位，特别是涉及到多个触发器的情况下，会使后期维护变得困难。</strong></li><li><strong>大量使用触发器容易导致代码结构被打乱，增加了程序的复杂性，</strong></li><li><strong>如果需要变动的数据量较大时，触发器的执行效率会非常低。</strong></li></ul><h2 id="C：MySQL-支持的触发器">C：MySQL 支持的触发器</h2><p><strong>在实际使用中，MySQL 所支持的触发器有三种：INSERT 触发器、UPDATE 触发器和 DELETE 触发器。</strong></p><h3 id="1-INSERT-触发器">1) INSERT 触发器</h3><p><strong>在 INSERT 语句执行之前或之后响应的触发器。</strong></p><p><strong>使用 INSERT 触发器需要注意以下几点：</strong></p><ul><li><strong>在 INSERT 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问被插入的行。</strong></li><li><strong>在 BEFORE INSERT 触发器中，NEW 中的值也可以被更新，即允许更改被插入的值（只要具有对应的操作权限）。</strong></li><li><strong>对于 AUTO_INCREMENT 列，NEW 在 INSERT 执行之前包含的值是 0，在 INSERT 执行之后将包含新的自动生成值。</strong></li></ul><h4 id="2-UPDATE-触发器">2) UPDATE 触发器</h4><p><strong>在 UPDATE 语句执行之前或之后响应的触发器。</strong></p><p><strong>使用 UPDATE 触发器需要注意以下几点：</strong></p><ul><li><strong>在 UPDATE 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问更新的值。</strong></li><li><strong>在 UPDATE 触发器代码内，可引用一个名为 OLD（不区分大小写）的虚拟表来访问 UPDATE 语句执行前的值。</strong></li><li><strong>在 BEFORE UPDATE 触发器中，NEW 中的值可能也被更新，即允许更改将要用于 UPDATE 语句中的值（只要具有对应的操作权限）。</strong></li><li><strong>OLD 中的值全部是只读的，不能被更新。</strong></li></ul><p><em><strong>注意：当触发器设计对触发表自身的更新操作时，只能使用 BEFORE 类型的触发器，AFTER 类型的触发器将不被允许。</strong></em></p><h4 id="3-DELETE-触发器">3) DELETE 触发器</h4><p><strong>在 DELETE 语句执行之前或之后响应的触发器。</strong></p><p><strong>使用 DELETE 触发器需要注意以下几点：</strong></p><ul><li><strong>在 DELETE 触发器代码内，可以引用一个名为 OLD（不区分大小写）的虚拟表来访问被删除的行。</strong></li><li><strong>OLD 中的值全部是只读的，不能被更新。</strong></li></ul><p><strong>总体来说，触发器使用的过程中，MySQL 会按照以下方式来处理错误。</strong></p><p><strong>对于事务性表，如果触发程序失败，以及由此导致的整个语句失败，那么该语句所执行的所有更改将回滚；对于非事务性表，则不能执行此类回滚，即使语句失败，失败之前所做的任何更改依然有效。</strong></p><p><strong>若 BEFORE 触发程序失败，则 MySQL 将不执行相应行上的操作。</strong></p><p><strong>若在 BEFORE 或 AFTER 触发程序的执行过程中出现错误，则将导致调用触发程序的整个语句失败。</strong></p><p><strong>仅当 BEFORE 触发程序和行操作均已被成功执行，MySQL 才会执行 AFTER 触发程序。</strong></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql结构化查询语句 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL创建存储过程</title>
      <link href="/posts/bc0b.html"/>
      <url>/posts/bc0b.html</url>
      
        <content type="html"><![CDATA[<h1>一、MySQL创建存储过程</h1><h2 id="1、基本语法">1、基本语法</h2><p><strong>可以使用 <code>CREATE PROCEDURE</code> 语句创建存储过程。</strong></p><h5 id="语法格式如下：">语法格式如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE &lt;过程名&gt; ( [过程参数[,…] ] ) &lt;过程体&gt;<br>[过程参数[,…] ] 格式<br>[ IN | OUT | INOUT ] &lt;参数名&gt; &lt;类型&gt;<br></code></pre></td></tr></table></figure><h2 id="2、语法说明如下：">2、语法说明如下：</h2><h4 id="1-过程名">1) 过程名</h4><p><strong>存储过程的名称，默认在当前数据库中创建。若需要在特定数据库中创建存储过程，则要在名称前面加上数据库的名称，即 db_name.sp_name。需要注意的是，名称应当尽量避免选取与 MySQL 内置函数相同的名称，否则会发生错误。</strong></p><h4 id="2-过程参数">2) 过程参数</h4><p><strong>存储过程的参数列表。其中，<code>&lt;参数名&gt;</code>为参数名，<code>&lt;类型&gt;</code>为参数的类型（可以是任何有效的 MySQL 数据类型）。当有多个参数时，参数列表中彼此间用逗号分隔。存储过程可以没有参数（此时存储过程的名称后仍需加上一对括号），也可以有 1 个或多个参数。</strong></p><p><strong>MySQL 存储过程支持三种类型的参数，即输入参数、输出参数和输入/输出参数，分别用 IN、OUT 和 INOUT 三个关键字标识。其中，输入参数可以传递给一个存储过程，输出参数用于存储过程需要返回一个操作结果的情形，而输入/输出参数既可以充当输入参数也可以充当输出参数。</strong></p><p><strong>需要注意的是，参数的取名不要与数据表的列名相同，否则尽管不会返回出错信息，但是存储过程的 SQL 语句会将参数名看作列名，从而引发不可预知的结果。</strong></p><h4 id="3-过程体">3) 过程体</h4><p><strong>存储过程的主体部分，也称为存储过程体，包含在过程调用的时候必须执行的 SQL 语句。这个部分以关键字 BEGIN 开始，以关键字 END 结束。若存储过程体中只有一条 SQL 语句，则可以省略 BEGIN-END 标志。</strong></p><p><strong>在存储过程的创建中，经常会用到一个十分重要的 MySQL 命令，即 DELIMITER 命令，特别是对于通过命令行的方式来操作 MySQL 数据库的使用者，更是要学会使用该命令。</strong></p><p><strong>在 MySQL 中，服务器处理 SQL 语句默认是以分号作为语句结束标志的。然而，在创建存储过程时，存储过程体可能包含有多条 SQL 语句，这些 SQL 语句如果仍以分号作为语句结束符，那么 MySQL 服务器在处理时会以遇到的第一条 SQL 语句结尾处的分号作为整个程序的结束符，而不再去处理存储过程体中后面的 SQL 语句，这样显然不行。</strong></p><h3 id="为解决以上问题，通常使用-DELIMITER-命令将结束命令修改为其他字符。语法格式如下：">为解决以上问题，通常使用 <strong>DELIMITER</strong> 命令将结束命令修改为其他字符。语法格式如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER $$<br></code></pre></td></tr></table></figure><h5 id="语法说明如下：">语法说明如下：</h5><ul><li><strong>$$ 是用户定义的结束符，通常这个符号可以是一些特殊的符号，如两个“?”或两个“￥”等。</strong></li><li><strong>当使用 DELIMITER 命令时，应该避免使用反斜杠“\”字符，因为它是 MySQL 的转义字符。</strong></li></ul><p><strong>在 MySQL 命令行客户端输入如下 SQL 语句。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql &gt; DELIMITER ??<br></code></pre></td></tr></table></figure><p><strong>成功执行这条 SQL 语句后，任何命令、语句或程序的结束标志就换为两个问号“??”了。</strong></p><p><strong>若希望换回默认的分号“;”作为结束标志，则在 MySQL 命令行客户端输入下列语句即可：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql &gt; DELIMITER ;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：DELIMITER 和分号“;”之间一定要有一个空格。在创建存储过程时，必须具有 CREATE ROUTINE 权限。可以使用 SHOW PROCEDURE STATUS 命令查看数据库中存在哪些存储过程，若要查看某个存储过程的具体信息，则可以使用 SHOW CREATE PROCEDURE &lt;存储过程名&gt;。</strong></p></blockquote><h2 id="3、创建不带参数的存储过程">3、创建不带参数的存储过程</h2><h3 id="例-1">例 1</h3><p><strong>创建名称为 ShowStuScore 的存储过程，存储过程的作用是从学生成绩信息表中查询学生的成绩信息，输入的 SQL 语句和执行过程如下所示。</strong></p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs delphi">mysql&gt; DELIMITER <span class="hljs-comment">//</span><br>mysql&gt; CREATE <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">ShowStuScore</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    -&gt; <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    -&gt; <span class="hljs-title">SELECT</span> * <span class="hljs-title">FROM</span> <span class="hljs-title">tb_students_score</span>;</span><br>    -&gt; <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br>Query OK， <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.09</span> sec)<br></code></pre></td></tr></table></figure><p><strong>创建存储过程 ShowStuScore 后，通过 CALL 语句调用该存储过程的 SQL 语句和执行结果如下所示。</strong></p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">mysql&gt; DELIMITER ;<br>mysql&gt; CALL ShowStuScore();<br>+--------------+---------------+<br>|<span class="hljs-string"> student_name </span>|<span class="hljs-string"> student_score </span>|<br>+--------------+---------------+<br>|<span class="hljs-string"> Dany         </span>|<span class="hljs-string">            90 </span>|<br>|<span class="hljs-string"> Green        </span>|<span class="hljs-string">            99 </span>|<br>|<span class="hljs-string"> Henry        </span>|<span class="hljs-string">            95 </span>|<br>|<span class="hljs-string"> Jane         </span>|<span class="hljs-string">            98 </span>|<br>|<span class="hljs-string"> Jim          </span>|<span class="hljs-string">            88 </span>|<br>|<span class="hljs-string"> John         </span>|<span class="hljs-string">            94 </span>|<br>|<span class="hljs-string"> Lily         </span>|<span class="hljs-string">           100 </span>|<br>|<span class="hljs-string"> Susan        </span>|<span class="hljs-string">            96 </span>|<br>|<span class="hljs-string"> Thomas       </span>|<span class="hljs-string">            93 </span>|<br>|<span class="hljs-string"> Tom          </span>|<span class="hljs-string">            89 </span>|<br>+--------------+---------------+<br>10 rows in set (0.00 sec)<br>Query OK, 0 rows affected (0.02 sec)<br></code></pre></td></tr></table></figure><h3 id="例-2">例 2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建存储过程<br>delimiter $$<br>create PROCEDURE test_bank()<br>BEGIN<br>select * from bank;<br>END$$<br><br># 调用存储过程<br>delimiter ;<br>call test_bank();<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200615150109398.png" alt="image-20200615150109398"></p><h2 id="4、创建带参数的存储过程">4、创建带参数的存储过程</h2><h3 id="例-3">例 3</h3><p><strong>创建名称为 GetScoreByStu 的存储过程，输入参数是学生姓名。存储过程的作用是通过输入的学生姓名从学生成绩信息表中查询指定学生的成绩信息，输入的 SQL 语句和执行过程如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; DELIMITER &#x2F;&#x2F;<br>mysql&gt; CREATE PROCEDURE GetScoreByStu<br>    -&gt; (IN name VARCHAR(30))<br>    -&gt; BEGIN<br>    -&gt; SELECT student_score FROM tb_students_score<br>    -&gt; WHERE student_name&#x3D;name;<br>    -&gt; END &#x2F;&#x2F;<br>Query OK, 0 rows affected (0.01 sec)<br></code></pre></td></tr></table></figure><p><strong>创建存储过程 GetScoreByStu 后，通过 CALL 语句调用该存储过程，SQL 语句和执行结果如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; DELIMITER ;<br>mysql&gt; CALL GetScoreByStu(&#39;Green&#39;);<br>+---------------+<br>| student_score |<br>+---------------+<br>|            99 |<br>+---------------+<br>1 row in set (0.03 sec)<br>Query OK, 0 rows affected (0.03 sec)<br></code></pre></td></tr></table></figure><h3 id="例-4">例 4</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建带参数的存储过程<br>delimiter $$<br>create PROCEDURE show_customer<br>(in name VARCHAR(20))<br>BEGIN<br>select * from bank where cusName&#x3D;name;<br>END $$<br>#调用带参数的存储过程<br>delimiter ;<br>call show_customer(&#39;zs&#39;);<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200615150729887.png" alt="image-20200615150729887"></p><h1>二、存储过程的参数</h1><p><strong>MySQL存储过程的参数用在存储过程的定义，共有三种参数类型,IN,OUT,INOUT,形式如：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATEPROCEDURE 存储过程名([[IN |OUT |INOUT ] 参数名 数据类形...])<br></code></pre></td></tr></table></figure><ul><li><strong>IN 输入参数：表示调用者向过程传入值（传入值可以是字面量或变量）</strong></li><li><strong>OUT 输出参数：表示过程向调用者传出值(可以返回多个值)（传出值只能是变量）</strong></li><li><strong>INOUT 输入输出参数：既表示调用者向过程传入值，又表示过程向调用者传出值（值只能是变量）</strong></li></ul><h2 id="1、in-输入参数">1、in 输入参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 存储过程的参数<br>delimiter $$<br>create PROCEDURE test(in p_in int)<br>BEGIN<br>  SELECT p_in;<br>  set p_in &#x3D; 2;<br>  select p_in;<br>END $$<br>    <br>delimiter ; <br>set @p_in&#x3D;1;<br>call in_param(@p_in);<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200615151115048.png" alt="image-20200615151115048"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200615151137069.png" alt="image-20200615151137069"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select @p_in;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200615151124534.png" alt="image-20200615151124534"></p><p><strong>以上可以看出，p_in 在存储过程中被修改，但并不影响 @p_id 的值，因为前者为局部变量、后者为全局变量。</strong></p><h2 id="2、out输出参数">2、out输出参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; delimiter &#x2F;&#x2F;<br>mysql&gt; create procedure out_param(out p_out int)<br>    -&gt;   begin<br>    -&gt;     select p_out;<br>    -&gt;     set p_out&#x3D;2;<br>    -&gt;     select p_out;<br>    -&gt;   end<br>    -&gt; &#x2F;&#x2F;<br>mysql&gt; delimiter ;<br> <br>mysql&gt; set @p_out&#x3D;1;<br> <br>mysql&gt; call out_param(@p_out);<br>+-------+<br>| p_out |<br>+-------+<br>|  NULL |<br>+-------+<br>　　#因为out是向调用者输出参数，不接收输入的参数，所以存储过程里的p_out为null<br>+-------+<br>| p_out |<br>+-------+<br>|     2 |<br>+-------+<br> <br>mysql&gt; select @p_out;<br>+--------+<br>| @p_out |<br>+--------+<br>|      2 |<br>+--------+<br>　　#调用了out_param存储过程，输出参数，改变了p_out变量的值<br></code></pre></td></tr></table></figure><h2 id="3、inout输入参数">3、inout输入参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; delimiter $$<br>mysql&gt; create procedure inout_param(inout p_inout int)<br>    -&gt;   begin<br>    -&gt;     select p_inout;<br>    -&gt;     set p_inout&#x3D;2;<br>    -&gt;     select p_inout;<br>    -&gt;   end<br>    -&gt; $$<br>mysql&gt; delimiter ;<br> <br>mysql&gt; set @p_inout&#x3D;1;<br> <br>mysql&gt; call inout_param(@p_inout);<br>+---------+<br>| p_inout |<br>+---------+<br>|       1 |<br>+---------+<br> <br>+---------+<br>| p_inout |<br>+---------+<br>|       2 |<br>+---------+<br> <br>mysql&gt; select @p_inout;<br>+----------+<br>| @p_inout |<br>+----------+<br>|        2 |<br>+----------+<br>#调用了inout_param存储过程，接受了输入的参数，也输出参数，改变了变量<br></code></pre></td></tr></table></figure><h3 id="注意："><strong>注意：</strong></h3><h4 id="1、如果过程没有参数，也必须在过程名后面写上小括号例：">1、如果过程没有参数，也必须在过程名后面写上小括号例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE sp_name ([proc_parameter[,...]]) ……<br></code></pre></td></tr></table></figure><h4 id="2、确保参数的名字不等于列的名字，否则在过程体中，参数名被当做列名来处理">2、确保参数的名字不等于列的名字，否则在过程体中，参数名被当做列名来处理</h4><h4 id="建议：">建议：</h4><ul><li><strong>输入值使用in参数。</strong></li><li><strong>返回值使用out参数。</strong></li><li><strong>inout参数就尽量的少用。</strong></li></ul><h1>三、MySQL删除存储过程（DROP PROCEDURE）</h1><p><strong>存储过程被创建后，就会一直保存在数据库服务器上，直至被删除。当 <a href="http://c.biancheng.net/mysql/" target="_blank" rel="noopener">MySQL</a> 数据库中存在废弃的存储过程时，我们需要将它从数据库中删除。</strong></p><p><strong>MySQL 中使用 DROP PROCEDURE 语句来删除数据库中已经存在的存储过程。语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP &#123; PROCEDURE | FUNCTION &#125; [ IF EXISTS ] &lt;过程名&gt;<br></code></pre></td></tr></table></figure><h4 id="语法说明如下：-2">语法说明如下：</h4><ul><li><strong>过程名：指定要删除的存储过程的名称。</strong></li><li><strong>IF EXISTS：指定这个关键字，用于防止因删除不存在的存储过程而引发的错误。</strong></li></ul><p><em><strong>注意：存储过程名称后面没有参数列表，也没有括号，在删除之前，必须确认该存储过程没有任何依赖关系，否则会导致其他与之关联的存储过程无法运行。</strong></em></p><h3 id="实例-1">实例 1</h3><p><strong>下面删除存储过程 showstuscore，SQL 语句和运行结果如下：</strong></p><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cal">mysql&gt; DROP <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">test</span>;</span><br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.08</span> sec)<br></code></pre></td></tr></table></figure><p><strong>删除后，可以通过查询 information_schema 数据库下的 routines 表来确认上面的删除是否成功。SQL 语句和运行结果如下：</strong></p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">mysql&gt; <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> information_schema.routines <span class="hljs-keyword">WHERE</span> routine_name=<span class="hljs-string">'showstuscore'</span>;<br><span class="hljs-keyword">Empty</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.03</span> sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，没有查询出任何记录，说明存储过程 showstuscore 已经被删除了。</strong></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql结构化查询语句 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL存储过程</title>
      <link href="/posts/ae29.html"/>
      <url>/posts/ae29.html</url>
      
        <content type="html"><![CDATA[<h2 id="A：MySQL存储过程简介">A：MySQL存储过程简介</h2><p><strong>我们前面所学习的 MySQL 语句都是针对一个表或几个表的单条 SQL 语句，但是在数据库的实际操作中，经常会有需要多条 SQL 语句处理多个表才能完成的操作。</strong></p><p><strong>例如，为了确认学生能否毕业，需要同时查询学生档案表、成绩表和综合表，此时就需要使用多条 SQL 语句来针对这几个数据表完成处理要求。</strong></p><p><strong><code>存储过程是一组为了完成特定功能的 SQL 语句集合。</code>使用存储过程的目的是将常用或复杂的工作预先用 SQL 语句写好并用一个指定名称存储起来，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需调用“CALL存储过程名字”即可自动完成。</strong></p><p><strong>常用操作数据库的 SQL 语句在执行的时候需要先编译，然后执行。存储过程则采用另一种方式来执行 SQL 语句。</strong></p><p><strong>一个存储过程是一个可编程的函数，它在数据库中创建并保存，一般由 SQL 语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的特定功能时，存储过程尤为合适。</strong></p><p><strong>MySQL 5.0 版本以前并不支持存储过程，这使 MySQL 在应用上大打折扣。MySQL 从 5.0 版本开始支持存储过程，既提高了数据库的处理速度，同时也提高了数据库编程的灵活性</strong></p><p><strong>存储过程是数据库中的一个重要功能，存储过程可以用来转换数据、数据迁移、制作报表，它类似于编程语言，一次执行成功，就可以随时被调用，完成指定的功能操作。</strong></p><p><strong>使用存储过程不仅可以提高数据库的访问效率，同时也可以提高数据库使用的安全性。</strong></p><p><strong>对于调用者来说，存储过程封装了 SQL 语句，调用者无需考虑逻辑功能的具体实现过程。只是简单调用即可，它可以被 Java 和 C# 等编程语言调用。</strong></p><h2 id="B：存储过程有如下优点：">B：存储过程有如下优点：</h2><h3 id="1-封装性">1) 封装性</h3><p><strong>通常完成一个逻辑功能需要多条 SQL 语句，而且各个语句之间很可能传递参数，所以，编写逻辑功能相对来说稍微复杂些，而存储过程可以把这些 SQL 语句包含到一个独立的单元中，使外界看不到复杂的 SQL 语句，只需要简单调用即可达到目的。并且数据库专业人员可以随时对存储过程进行修改，而不会影响到调用它的应用程序源代码。</strong></p><h3 id="2-可增强-SQL-语句的功能和灵活性">2) 可增强 SQL 语句的功能和灵活性</h3><p><strong>存储过程可以用流程控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</strong></p><h3 id="3-可减少网络流量">3) 可减少网络流量</h3><p><strong>由于存储过程是在服务器端运行的，且执行速度快，因此当客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而可降低网络负载。</strong></p><h3 id="4-高性能">4) 高性能</h3><p><strong>当存储过程被成功编译后，就存储在数据库服务器里了，以后客户端可以直接调用，这样所有的 SQL 语句将从服务器执行，从而提高性能。但需要说明的是，存储过程不是越多越好，过多的使用存储过程反而影响系统性能。</strong></p><h3 id="5-提高数据库的安全性和数据的完整性">5) 提高数据库的安全性和数据的完整性</h3><p><strong>存储过程提高安全性的一个方案就是把它作为中间组件，存储过程里可以对某些表做相关操作，然后存储过程作为接口提供给外部程序。这样，外部程序无法直接操作数据库表，只能通过存储过程来操作对应的表，因此在一定程度上，安全性是可以得到提高的。</strong></p><h3 id="6-使数据独立">6) 使数据独立</h3><p><strong>数据的独立可以达到解耦的效果，也就是说，程序可以调用存储过程，来替代执行多条的 SQL 语句。这种情况下，存储过程把数据同用户隔离开来，优点就是当数据表的结构改变时，调用表不用修改程序，只需要数据库管理者重新编写存储过程即可。</strong></p><h2 id="C：MySQL存储过程的优点">C：<strong>MySQL存储过程的优点</strong></h2><ul><li><strong>通常存储过程有助于提高应用程序的性能。当创建，存储过程被编译之后，就存储在数据库中。 但是，MySQL实现的存储过程略有不同。 MySQL存储过程按需编译。 在编译存储过程之后，MySQL将其放入缓存中。 MySQL为每个连接维护自己的存储过程高速缓存。 如果应用程序在单个连接中多次使用存储过程，则使用编译版本，否则存储过程的工作方式类似于查询。</strong></li><li><strong>存储过程有助于减少应用程序和数据库服务器之间的流量，因为应用程序不必发送多个冗长的SQL语句，而只能发送存储过程的名称和参数。</strong></li><li><strong>存储的程序对任何应用程序都是可重用的和透明的。 存储过程将数据库接口暴露给所有应用程序，以便开发人员不必开发存储过程中已支持的功能。</strong></li><li><strong>存储的程序是安全的。 数据库管理员可以向访问数据库中存储过程的应用程序授予适当的权限，而不向基础数据库表提供任何权限。</strong></li></ul><h2 id="D：MySQL存储过程的缺点">D：MySQL存储过程的缺点</h2><ul><li><strong>如果使用大量存储过程，那么使用这些存储过程的每个连接的内存使用量将会大大增加。 此外，如果您在存储过程中过度使用大量逻辑操作，则CPU使用率也会增加，因为数据库服务器的设计不当于逻辑运算。</strong></li><li><strong>存储过程的构造使得开发具有复杂业务逻辑的存储过程变得更加困难。</strong></li><li><strong>很难调试存储过程。只有少数数据库管理系统允许您调试存储过程。不幸的是，MySQL不提供调试存储过程的功能。</strong></li><li><strong>开发和维护存储过程并不容易。开发和维护存储过程通常需要一个不是所有应用程序开发人员拥有的专业技能。这可能会导致应用程序开发和维护阶段的问题。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql结构化查询语句 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL用户管理（2）</title>
      <link href="/posts/66c1.html"/>
      <url>/posts/66c1.html</url>
      
        <content type="html"><![CDATA[<h1>一、MySQL root修改普通用户密码</h1><h2 id="1、使用SET语句修改普通用户的密码">1、使用SET语句修改普通用户的密码</h2><p><strong>在 MySQL 中，只有 root 用户可以通过更新 MySQL 数据库来更改密码。使用 root 用户登录到 MySQL 服务器后，可以使用 SET 语句来修改普通用户密码。语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">SET PASSWORD FOR &#39;username&#39;@&#39;hostname&#39; &#x3D; PASSWORD (&#39;newpwd&#39;);<br></code></pre></td></tr></table></figure><p><strong>其中，username 参数是普通用户的用户名，hostname 参数是普通用户的主机名，newpwd 是要更改的新密码。</strong></p><p><strong>注意：新密码必须使用 PASSWORD() 函数来加密，如果不使用 PASSWORD() 加密，也会执行成功，但是用户会无法登录。</strong></p><p><strong>如果是普通用户修改密码，可省略 FOR 子句来更改自己的密码。语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">SET PASSWORD &#x3D; PASSWORD(&#39;newpwd&#39;);<br></code></pre></td></tr></table></figure><h3 id="示例-1">示例 1</h3><p><strong>首先创建一个没有密码的 testuser 用户，SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">mysql&gt; CREATE USER &#39;testuser&#39;@&#39;localhost&#39;;<br>Query OK, 0 rows affected (0.14 sec)<br></code></pre></td></tr></table></figure><p><strong>root 用户登录 MySQL 服务器后，再使用 SET 语句将 testuser 用户的密码修改为“newpwd”，SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">mysql&gt; SET PASSWORD FOR &#39;testuser&#39;@&#39;localhost&#39; &#x3D; PASSWORD(&quot;newpwd&quot;);<br>Query OK, 0 rows affected, 1 warning (0.01 sec)<br></code></pre></td></tr></table></figure><p><strong>由运行结果可以看出，SET 语句执行成功，testuser 用户的密码被成功设置为“newpwd”。</strong></p><p><strong>下面验证 testuser 用户密码是否修改成功。退出 MySQL 服务器，使用 testuser 用户登录，输入密码“newpwd”，SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">C:\Users\leovo&gt;mysql -utestuser -p<br>Enter password: ******<br>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 15<br>Server version: 5.7.29-log MySQL Community Server (GPL)<br> <br>Copyright (c) 2000, 2020, Oracle and&#x2F;or its affiliates. All rights reserved.<br> <br>Oracle is a registered trademark of Oracle Corporation and&#x2F;or its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br> <br>Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.<br></code></pre></td></tr></table></figure><p><strong>由运行结果可以看出，testuser 用户登录成功，修改密码成功。</strong></p><h3 id="示例-2">示例 2</h3><p><strong>使用 testuser 用户登录 MySQL 服务器，再使用 SET 语句将密码更改为“newpwd1”，SQL 语句和运行结果如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">mysql&gt; SET PASSWORD &#x3D; PASSWORD(&#39;newpwd1&#39;);<br>Query OK, 0 rows affected, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>由运行结果可以看出，修改密码成功。</strong></p><h2 id="2、使用UPDATE语句修改普通用户的密码">2、使用UPDATE语句修改普通用户的密码</h2><p><strong>使用 root 用户登录 MySQL 服务器后，可以使用 UPDATE 语句修改 MySQL 数据库的 user 表的 authentication_string 字段，从而修改普通用户的密码。UPDATA 语句的语法如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">UPDATE MySQL.user SET authentication_string &#x3D; PASSWORD(&quot;newpwd&quot;) WHERE User &#x3D; &quot;username&quot; AND Host &#x3D; &quot;hostname&quot;;<br></code></pre></td></tr></table></figure><p><strong>其中，username 参数是普通用户的用户名，hostname 参数是普通用户的主机名，newpwd 是要更改的新密码。</strong></p><p><strong>注意，执行 UPDATE 语句后，需要执行 FLUSH PRIVILEGES 语句重新加载用户权限。</strong></p><h3 id="示例-3">示例 3</h3><p><strong>使用 root 用户登录 MySQL 服务器，再使用 UPDATE 语句将 testuser 用户的密码修改为“newpwd2”的 SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">mysql&gt; UPDATE MySQL.user SET authentication_string &#x3D; PASSWORD (&quot;newpwd2&quot;)<br>    -&gt; WHERE User &#x3D; &quot;testuser&quot; AND Host &#x3D; &quot;localhost&quot;;<br>Query OK, 1 row affected, 1 warning (0.07 sec)<br>Rows matched: 1  Changed: 1  Warnings: 1<br>mysql&gt; FLUSH PRIVILEGES;<br>Query OK, 0 rows affected (0.03 sec)<br></code></pre></td></tr></table></figure><p><strong>由运行结果可以看出，密码修改成功。testuser 的密码被修改成了 newpwd2。使用 FLUSH PRIVILEGES 重新加载权限后，就可以使用新的密码登录 testuser 用户了。</strong></p><h2 id="3、使用-GRANT-语句修改普通用户密码">3、使用 GRANT 语句修改普通用户密码</h2><p><strong>除了前面介绍的方法，还可以在全局级别使用 GRANT USAGE 语句指定某个账户的密码而不影响账户当前的权限。需要注意的是，使用 GRANT 语句修改密码，必须拥有 GRANT 权限。一般情况下最好使用该方法来指定或修改密码。语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">GRANT USAGE ON *.* TO &#39;user&#39;@’hostname’ IDENTIFIED BY &#39;newpwd&#39;;<br></code></pre></td></tr></table></figure><p><strong>其中，username 参数是普通用户的用户名，hostname 参数是普通用户的主机名，newpwd 是要更改的新密码。</strong></p><h3 id="示例-4">示例 4</h3><p><strong>使用 root 用户登录 MySQL 服务器，再使用 GRANT 语句将 testuser 用户的密码修改为“newpwd3”，SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">mysql&gt; GRANT USAGE ON *.* TO &#39;testuser&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;newpwd3&#39;;<br>Query OK, 0 rows affected, 1 warning (0.05 sec)<br></code></pre></td></tr></table></figure><p><strong>由运行结果可以看出，密码修改成功。</strong></p><h1>二、MySQL修改root密码</h1><h2 id="1、使用mysqladmin命令在命令行指定新密码">1、使用mysqladmin命令在命令行指定新密码</h2><p><strong>root 用户可以使用 mysqladmin 命令来修改密码，mysqladmin 的语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqladmin -u username -h hostname -p password &quot;newpwd&quot;<br></code></pre></td></tr></table></figure><h4 id="语法参数说明如下：">语法参数说明如下：</h4><ul><li><strong>usermame 指需要修改密码的用户名称，在这里指定为 root 用户；</strong></li><li><strong>hostname 指需要修改密码的用户主机名，该参数可以不写，默认是 localhost；</strong></li><li><strong>password 为关键字，而不是指旧密码；</strong></li><li><strong>newpwd 为新设置的密码，必须用双引号括起来。如果使用单引号会引发错误，可能会造成修改后的密码不是你想要的。</strong></li></ul><p><strong>执行完上面的语句，root 用户的密码将被修改为“newpwd”。</strong></p><h3 id="示例-1-2">示例 1</h3><p><strong>下面使用 mysqladmin 将 root 用户的密码修改为“rootpwd”，在 Windows 命令行窗口（cmd）中执行命令和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">C:\Users\leovo&gt;mysqladmin -u root -p password &quot;rootpwd&quot;<br>Enter password: ****<br>mysqladmin: [Warning] Using a password on the command line interface can be insecure.<br>Warning: Since password will be sent to server in plain text, use ssl connection to ensure password safety.<br></code></pre></td></tr></table></figure><p><strong>输入 mysqladmin 命令后，按回车键，然后输入 root 用户原来的密码。执行完毕后，密码修改成功，root 用户登录时将使用新的密码。</strong></p><p><strong>运行结果中，输入密码后会提示在命令行界面上使用密码可能不安全的警告信息，因为在命令行输入密码时，MySQL 服务器就会提示这些安全警告信息。</strong></p><p><strong>下面使用修改后的“rootpwd”密码登录 root 用户，SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">C:\Users\leovo&gt;mysql -uroot -p<br>Enter password: *******<br>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 23<br>Server version: 5.7.29-log MySQL Community Server (GPL)<br><br>Copyright (c) 2000, 2020, Oracle and&#x2F;or its affiliates. All rights reserved.<br><br>Oracle is a registered trademark of Oracle Corporation and&#x2F;or its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br><br>Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.<br></code></pre></td></tr></table></figure><p><strong>结果显示，root 用户登录成功，所以使用 mysqladmin 命令修改 root 用户密码成功。</strong></p><h2 id="2、修改MySQL数据库的user表">2、修改MySQL数据库的user表</h2><p><strong>因为所有账户信息都保存在 user 表中，因此可以直接通过修改 user 表来改变 root 用户的密码。</strong></p><p><strong>root 用户登录到 MySQL 服务器后，可以使用 UPDATE 语句修改 MySQL 数据库的 user 表的 authentication_string 字段，从而修改用户的密码。</strong></p><p><strong>使用 UPDATA 语句修改 root 用户密码的语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE mysql.user set authentication_string &#x3D; PASSWORD (&quot;rootpwd) WHERE User &#x3D; &quot;root&quot; and Host&#x3D;&quot;localhost&quot;;<br></code></pre></td></tr></table></figure><p><strong>新密码必须使用 PASSWORD() 函数来加密。执行UPDATE语句后，需要执行FLUSH PRIVILEGES语句重新加载用户权限。</strong></p><h3 id="示例-2-2">示例 2</h3><p><strong>下面使用 UPDATE 语句将 root用户的密码修改为“rootpwd2”。</strong></p><p><strong>使用 root 用户登录到 MySQL 服务器后，SQL 语句和运行结果如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; UPDATE mysql.user set authentication_string &#x3D; password (&quot;rootpwd2&quot;)<br>    -&gt; WHERE User &#x3D; &quot;root&quot; and Host &#x3D; &quot;localhost&quot;;<br>Query OK, 1 row affected, 0 warning (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings:0<br>mysql&gt; FLUSH PRIVILEGES;<br>Query OK, 0 rows affected (0.06 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，密码修改成功。而且使用了<code>FLUSH PRIVILEGES;</code>语句加载权限。退出后就必须使用新密码来登录了。</strong></p><h2 id="3、使用SET语句修改root用户的密码">3、使用SET语句修改root用户的密码</h2><p><strong>SET PASSWORD 语句可以用来重新设置其他用户的登录密码或者自己使用的账户的密码。使用 SET 语句修改密码的语法结构如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET PASSWORD &#x3D; PASSWORD (&quot;rootpwd&quot;);<br></code></pre></td></tr></table></figure><h3 id="示例-3-2">示例 3</h3><p><strong>下面使用 SET 语句将 root 用户的密码修改为“rootpwd3”。</strong></p><p><strong>使用 root 用户登录到 MySQL 服务器后，SQL 语句和运行结果如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">MySQL&gt; SET PASSWORD &#x3D; password (&quot;rootpwd3&quot;);<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，SET 语句执行成功，root 用户的密码被成功设置为“rootpwd3”。</strong></p><h1>三、MySQL忘记root密码解决方案</h1><p><strong>在忘记 MySQL 密码的情况下，可以通过 <code>--skip-grant-tables</code> 关闭服务器的认证，然后重置 root 的密码，具体操作步骤如下。</strong></p><p><strong>步骤 1)：关闭正在运行的 MySQL 服务。打开 cmd 进入 MySQL 的 bin 目录。</strong></p><p><strong>步骤 2)：输入<code>mysqld --console --skip-grant-tables --shared-memory</code> 命令。–skip-grant-tables 会让 MySQL 服务器跳过验证步骤，允许所有用户以匿名的方式，无需做密码验证就可以直接登录 MySQL 服务器，并且拥有所有的操作权限。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200614165937752.png" alt="image-20200614165937752"></p><p><strong>步骤 3)：上一个 DOS 窗口不要关闭，打开一个新的 DOS 窗口，此时仅输入 mysql 命令，不需要用户名和密码，即可连接到 MySQL。</strong></p><p><strong>步骤 4)：输入命令 <code>update mysql.user set authentication_string=password('root') where user='root' and Host ='localhost';</code> 设置新密码。</strong></p><p><strong>注意：MySQL 5.7 版本中的 user 表里已经去掉了 password 字段，改为了 authentication_string。</strong></p><p><strong>步骤 5)：刷新权限（必须步骤），输入<code>flush privileges;</code>命令。</strong></p><p><strong>步骤 6)：因为之前使用 --skip-grant-tables 启动，所以需要重启 MySQL 服务器去掉 --skip-grant-tables。输入无误后输入<code>quit;</code>命令退出 MySQL 服务。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200614170003331.png" alt="image-20200614170003331"></p><p><strong>步骤 7)：重启 MySQL 服务，使用用户名 root 和刚才设置的新密码 root 登录就可以了。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200614170016966.png" alt="image-20200614170016966"></p><h1>四、MySQL修改密码的3种方式</h1><h2 id="1-使用-SET-PASSWORD-命令">1. 使用 SET PASSWORD 命令</h2><p><strong>步骤 1)：输入命令<code>mysql -u root -p</code>指定 root 用户登录 MySQL，输入后按回车键输入密码。如果没有配置环境变量，请在 MySQL 的 bin 目录下登录操作。</strong></p><p><strong>步骤 2)：使用 SET PASSWORD 修改密码命令格式为 <code>set password for username @localhost = password(newpwd);</code>，其中 username 为要修改密码的用户名，newpwd 为要修改的新密码。如图所示。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200614170059293.png" alt="image-20200614170059293"></p><p><strong>步骤 3)：输入<code>quit;</code>命令退出 MySQL 重新登录，输入新密码“root”登录就可以了；</strong></p><h2 id="2-使用mysqladmin修改密码">2. 使用mysqladmin修改密码</h2><p><strong>使用 mysqladmin 命令修改 MySQL 的 root 用户密码格式为 <code>mysqladmin -u用户名 -p旧密码 password 新密码</code>。</strong></p><p><strong>注意：下图修改密码的命令中 -uroot 和 -proot 是整体，不要写成 -u root -p root，-u 和 root 间可以加空格，但是会有警告出现，所以就不要加空格了。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200614170130114.png" alt="image-20200614170130114"></p><h2 id="3-UPDATE直接编辑user表">3. UPDATE直接编辑user表</h2><p><strong>步骤 1)：输入命令<code>mysql -u root -p</code>指定 root 用户登录 MySQL，输入后按回车键输入密码。如果没有配置环境变量，请在 MySQL 的 bin 目录下登录操作。</strong></p><p><strong>步骤 2)：输入<code>use mysql;</code>命令连接权限数据库。</strong></p><p><strong>步骤 3)：输入命令<code>update mysql.user set authentication_string=password('新密码') where user='用户名' and Host ='localhost';</code>设置新密码。</strong></p><p><strong>步骤 4)：输入 <code>flush privileges;</code> 命令刷新权限。</strong></p><p><strong>步骤 5)：输入<code>quit;</code>命令退出 MySQL 重新登录，此时密码已经修改为刚才输入的新密码了。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200614170154428.png" alt="image-20200614170154428"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#创建数据库<br>DROP DATABASE IF EXISTS &#96;bankDB&#96;;<br>CREATE DATABASE &#96;bankDB&#96;;<br><br>USE &#96;bankDB&#96;;<br><br>DROP TABLE IF EXISTS &#96;userInfo&#96;;<br>CREATE TABLE &#96;userInfo&#96;  #用户信息表<br>(<br>  &#96;customerID&#96; INT(4) PRIMARY KEY AUTO_INCREMENT COMMENT &#39;用户编号&#39;,<br>  &#96;customerName&#96; CHAR(8) NOT NULL COMMENT &#39;用户编号&#39;,<br>  &#96;PID&#96; CHAR(18) UNIQUE NOT NULL COMMENT &#39;身份证号&#39;,<br>  &#96;telephone&#96; CHAR(20) NOT NULL COMMENT &#39;手机号码&#39;,<br>  &#96;address&#96; VARCHAR(50) COMMENT &#39;居住地址&#39;<br>)ENGINE &#x3D; INNODB,CHARSET&#x3D;UTF8,COMMENT&#x3D;&#39;用户表&#39;;<br><br>DROP TABLE IF EXISTS &#96;cardInfo&#96;;<br>CREATE TABLE &#96;cardInfo&#96;  #银行卡信息表<br>(<br>  &#96;cardID&#96;  CHAR(19) NOT NULL PRIMARY KEY COMMENT &#39;卡号&#39;,<br>   &#96;password&#96; CHAR(6) NOT NULL DEFAULT &#39;888888&#39; COMMENT &#39;密码&#39;,<br>  &#96;curID&#96;  VARCHAR(10) NOT NULL DEFAULT &#39;RMB&#39; COMMENT &#39;币种&#39;,<br>  &#96;savingID&#96; INT NOT NULL COMMENT &#39;存款类型&#39;,<br>  &#96;openDate&#96;  TIMESTAMP NOT NULL COMMENT &#39;开户日期&#39; ,<br>  &#96;openMoney&#96;  DECIMAL(20,2) NOT NULL DEFAULT 1 COMMENT &#39;开户金额&#39; ,<br>  &#96;balance&#96;  DECIMAL(20,2) NOT NULL DEFAULT 1 COMMENT &#39;余额&#39;,<br>  &#96;IsReportLoss&#96; BIT  NOT NULL  DEFAULT 0 COMMENT &#39;是否挂失&#39;,<br>  &#96;customerID&#96; INT NOT NULL<br>) ENGINE &#x3D; INNODB,CHARSET&#x3D;UTF8,COMMENT&#x3D;&#39;银行卡信息表&#39;;<br><br>DROP TABLE IF EXISTS &#96;tradeInfo&#96;;<br>CREATE TABLE &#96;tradeInfo&#96;  #交易信息表<br>(<br>  cardID  CHAR(16) NOT NULL COMMENT &#39;卡号&#39;,<br>  tradeDate  TIMESTAMP NOT NULL  COMMENT &#39;交易日期&#39;,<br>  tradeMoney  DECIMAL(20,2) NOT NULL COMMENT &#39;实际交易金额&#39;,<br>  tradeType  CHAR(4) NOT NULL COMMENT &#39;交易类型&#39;, <br>  remark  TEXT COMMENT &#39;备注&#39;  <br>)ENGINE &#x3D; INNODB,CHARSET&#x3D;UTF8,COMMENT&#x3D;&#39;交易信息表&#39;;<br><br>DROP TABLE IF EXISTS &#96;deposit&#96;;<br>CREATE TABLE &#96;deposit&#96;  #存款类型表<br>(<br>  savingID  INT(4)  AUTO_INCREMENT PRIMARY KEY,<br>  savingName  VARCHAR(20) NOT NULL,<br>  descrip VARCHAR(50)<br>)ENGINE &#x3D; INNODB,CHARSET&#x3D;UTF8,COMMENT&#x3D;&#39;存款类型表&#39;;<br><br><br>&#x2F;*--加约束--$*&#x2F;<br><br>ALTER TABLE cardInfo     <br>   ADD CONSTRAINT  FK_customerID <br>   FOREIGN KEY(customerID) <br>   REFERENCES userInfo(customerID),<br>   ADD  CONSTRAINT  FK_savingID  <br>   FOREIGN KEY(savingID) <br>   REFERENCES deposit(savingID);<br><br>ALTER TABLE tradeInfo<br>  ADD CONSTRAINT  FK_cardID  <br>  FOREIGN KEY(cardID) <br>  REFERENCES cardInfo(cardID);<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql结构化查询语句 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL用户管理（1）</title>
      <link href="/posts/22c1.html"/>
      <url>/posts/22c1.html</url>
      
        <content type="html"><![CDATA[<h2 id="A：补充技能点">A：补充技能点</h2><h3 id="MySQL用户管理"><strong>MySQL用户管理</strong></h3><ul><li><strong>创建普通用户</strong></li><li><strong>执行GRANT语句创建用户并授权</strong></li><li><strong>使用mysqladmin命令修改root账户密码</strong></li><li><strong>使用SET命令修改用户密码</strong></li><li><strong>删除普通用户</strong></li></ul><p><strong>MySQL 在安装时会自动创建一个名为 mysql 的数据库，mysql 数据库中存储的都是用户权限表。用户登录以后，MySQL 会根据这些权限表的内容为每个用户赋予相应的权限。</strong></p><p><strong>user 表是 MySQL 中最重要的一个权限表，用来记录允许连接到服务器的账号信息。需要注意的是，在 user 表里启用的所有权限都是全局级的，适用于所有数据库。</strong></p><p><strong>user 表中的字段大致可以分为 4 类，分别是用户列、权限列、安全列和资源控制列。</strong></p><h2 id="B：为什么需要用户管理">B：为什么需要用户管理</h2><h4 id="root是超级管理员用户，很容易引发由于误操作所导致的数据不安全问题，怎么办"><strong>root是超级管理员用户，很容易引发由于误操作所导致的数据不安全问题，怎么办?</strong></h4><blockquote><p><strong>针对不同用户进行合理的用户角色权限分配，即用户管理</strong></p></blockquote><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200612150731946.png" alt="image-20200612150731946"></p><h1>一、MySQL创建用户（3种方式）</h1><h4 id="MySQL-提供了以下-3-种方法创建用户。">MySQL 提供了以下 3 种方法创建用户。</h4><ul><li><strong>使用 CREATE USER 语句创建用户</strong></li><li><strong>在 mysql.user 表中添加用户</strong></li><li><strong>使用 GRANT 语句创建用户</strong></li></ul><h2 id="1-使用CREATE-USER语句创建用户">1. 使用CREATE USER语句创建用户</h2><p><strong>可以使用 <code>CREATE USER</code> 语句来创建 MySQL 用户，并设置相应的密码。其基本语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE USER &lt;用户&gt; [ IDENTIFIED BY [ PASSWORD ] &#39;password&#39; ] [ ,用户 [ IDENTIFIED BY [ PASSWORD ] &#39;password&#39; ]]<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200612150916248.png" alt="image-20200612150916248"></p><h3 id="例1">例1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建普通用户<br>create user &#96;teacher&#96;@&#96;localhost&#96; IDENTIFIED BY &#39;123456&#39;;<br>create user &#96;student&#96;@&#96;localhost&#96;<br><br># 查看用户<br>use mysql;<br>select host,user from user;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200612151258167.png" alt="image-20200612151258167"></p><h3 id="例2">例2</h3><p><strong>在 MySQL 中，可以使用 password() 函数获取密码的哈希值，查看 test1 哈希值的 SQL 语句和执行过程如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT password(&#39;teacher&#39;);<br>+-------------------------------------------+<br>| password(&#39;teacher&#39;)                       |<br>+-------------------------------------------+<br>| *977F15BF49C046DA76BC81A80146AAB943F679F1 |<br>+-------------------------------------------+<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p>*<em>“<em>977F15BF49C046DA76BC81A80146AAB943F679F1”就是 test1 的哈希值。下面创建用户 test1，SQL 语句和执行过程如下：</em></em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE USER &#39;text1&#39;@&#39;localhost&#39;IDENTIFIED BY PASSWORD &#39;*977F15BF49C046DA76BC81A80146AAB943F679F1&#39;;<br>Query OK, 0 rows affected, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>执行成功后就可以使用密码“test1”登录了。</strong></p><h2 id="2-使用-INSERT-语句新建用户">2. 使用 INSERT 语句新建用户</h2><p><strong>可以使用 INSERT 语句将用户的信息添加到 mysql.user 表中，但必须拥有对 mysql.user 表的 INSERT 权限。通常 INSERT 语句只添加 Host、User 和 authentication_string 这 3 个字段的值。</strong></p><blockquote><p><strong>MySQL 5.7 的 user 表中的密码字段从 Password 变成了 authentication_string，如果你使用的是 MySQL 5.7 之前的版本，将 authentication_string 字段替换成 Password 即可。</strong></p></blockquote><p><strong>使用 <code>INSERT</code> 语句创建用户的代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO mysql.user(Host, User,  authentication_string, ssl_cipher, x509_issuer, x509_subject) VALUES (&#39;hostname&#39;, &#39;username&#39;, PASSWORD(&#39;password&#39;), &#39;&#39;, &#39;&#39;, &#39;&#39;);<br></code></pre></td></tr></table></figure><p><strong>由于 mysql 数据库的 user 表中，ssl_cipher、x509_issuer 和 x509_subject 这 3 个字段没有默认值，所以向 user 表插入新记录时，一定要设置这 3 个字段的值，否则 INSERT 语句将不能执行。</strong></p><h3 id="例-3">例 3</h3><p><strong>下面使用 INSERT 语句创建名为 test2 的用户，主机名是 localhost，密码也是 test2。SQL 语句和执行过程如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; INSERT INTO mysql.user(Host, User, authentication_string, ssl_cipher, x509_issuer, x509_subject) VALUES (&#39;localhost&#39;, &#39;test2&#39;, PASSWORD(&#39;test2&#39;), &#39;&#39;, &#39;&#39;, &#39;&#39;);<br>Query OK, 1 row affected, 1 warning (0.02 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，新建用户成功。但是这时如果通过该账户登录 MySQL 服务器，不会登录成功，因为 test2 用户还没有生效。</strong></p><p><strong>可以使用 FLUSH 命令让用户生效，命令如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><p><strong>使用以上命令可以让 MySQL 刷新系统权限相关表。执行 FLUSH 命令需要 RELOAD 权限。</strong></p><p><strong>注意：user 表中的 User 和 Host 字段区分大小写，创建用户时要指定正确的用户名称或主机名。</strong></p><h2 id="3-使用GRANT语句新建用户">3. 使用GRANT语句新建用户</h2><p><strong>虽然 CREATE USER 和 INSERT INTO 语句都可以创建普通用户，但是这两种方式不便授予用户权限。于是 MySQL 提供了 GRANT 语句。</strong></p><p><strong>使用 GRANT 语句创建用户的基本语法形式如下:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">GRANT priv_type ON database.table TO user [IDENTIFIED BY [PASSWORD] &#39;password&#39;]<br></code></pre></td></tr></table></figure><p><strong>其中：</strong></p><ul><li><strong>priv_type 参数表示新用户的权限；</strong></li><li><strong>database.table 参数表示新用户的权限范围，即只能在指定的数据库和表上使用自己的权限；</strong></li><li><strong>user 参数指定新用户的账号，由用户名和主机名构成；</strong></li><li><strong>IDENTIFIED BY 关键字用来设置密码；</strong></li><li><strong>password 参数表示新用户的密码。</strong></li></ul><h3 id="例-4">例 4</h3><p><strong>下面使用 GRANT 语句创建名为 test3 的用户，主机名为 localhost，密码为 test3。该用户对所有数据库的所有表都有 SELECT 权限。SQL 语句和执行过程如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; GRANT SELECT ON*.* TO &#39;test3&#39;@localhost IDENTIFIED BY &#39;test3&#39;;<br>Query OK, 0 rows affected, 1 warning (0.01 sec)<br></code></pre></td></tr></table></figure><p><strong>其中，“<em>.</em>” 表示所有数据库下的所有表。结果显示创建用户成功，且 test3 用户对所有表都有查询（SELECT）权限。</strong></p><p><strong>技巧：GRANT 语句是 MySQL 中一个非常重要的语句，它可以用来创建用户、修改用户密码和设置用户权限。教程后面会详细介绍如何使用 GRANT 语句修改密码、更改权限。</strong></p><h1>二、MySQL修改用户（RENAME USER）</h1><p><strong>在 MySQL中，我们可以使用 RENAME USER 语句修改一个或多个已经存在的用户账号。</strong></p><h5 id="语法格式如下：">语法格式如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">RENAME USER &lt;旧用户&gt; TO &lt;新用户&gt;<br></code></pre></td></tr></table></figure><h5 id="其中：">其中：</h5><ul><li><strong>&lt;旧用户&gt;：系统中已经存在的 MySQL 用户账号。</strong></li><li><strong>&lt;新用户&gt;：新的 MySQL 用户账号。</strong></li></ul><h4 id="使用-RENAME-USER-语句时应注意以下几点：">使用 RENAME USER 语句时应注意以下几点：</h4><ul><li><strong>RENAME USER 语句用于对原有的 MySQL 用户进行重命名。</strong></li><li><strong>若系统中旧账户不存在或者新账户已存在，该语句执行时会出现错误。</strong></li><li><strong>使用 RENAME USER 语句，必须拥有 mysql 数据库的 UPDATE 权限或全局 CREATE USER 权限。</strong></li></ul><h3 id="例-1">例 1</h3><p><strong>使用 RENAME USER 语句将用户名 test1 修改为 testUser1，主机是 localhost。SQL 语句和执行过程如下。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; RENAME USER &#39;test1&#39;@&#39;localhost&#39;<br>    -&gt; TO &#39;testUser1&#39;@&#39;localhost&#39;;<br>Query OK, 0 rows affected (0.03 sec)<br></code></pre></td></tr></table></figure><p><strong>在 cmd 命令行工具中，使用 testUser1 用户登录数据库服务器，如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">C:\Users\USER&gt;mysql -h localhost -u testUser1 -p<br>Enter password: *****<br>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 7<br>Server version: 5.7.20-log MySQL Community Server (GPL)<br>Copyright (c) 2000, 2017, Oracle and&#x2F;or its affiliates. All rights reserved.<br>Oracle is a registered trademark of Oracle Corporation and&#x2F;or its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br>Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.<br></code></pre></td></tr></table></figure><h1>三、MySQL删除用户（DROP/DELETE USER）</h1><p><strong>在 MySQL 数据库中，可以使用 DROP USER 语句删除用户，也可以直接在 mysql.user 表中删除用户以及相关权限。</strong></p><h2 id="1-使用-DROP-USER-语句删除普通用户">1. 使用 DROP USER 语句删除普通用户</h2><p><strong>使用 DROP USER 语句删除用户的语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP USER &lt;用户1&gt; [ , &lt;用户2&gt; ]…<br></code></pre></td></tr></table></figure><p><strong>其中，用户用来指定需要删除的用户账号。</strong></p><p><strong>使用 DROP USER 语句应注意以下几点：</strong></p><ul><li><strong>DROP USER 语句可用于删除一个或多个用户，并撤销其权限。</strong></li><li><strong>使用 DROP USER 语句必须拥有 mysql 数据库的 DELETE 权限或全局 CREATE USER 权限。</strong></li><li><strong>在 DROP USER 语句的使用中，若没有明确地给出账户的主机名，则该主机名默认为“%”。</strong></li></ul><blockquote><p><strong>注意：用户的删除不会影响他们之前所创建的表、索引或其他数据库对象，因为 MySQL 并不会记录是谁创建了这些对象。</strong></p></blockquote><h3 id="例-1-2">例 1</h3><p><strong>下面使用 DROP USER 语句删除用户’test1@‘localhost’。SQL 语句和执行过程如下。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; DROP USER &#39;test1&#39;@&#39;localhost&#39;;<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>在 cmd 命令行工具中，使用 test1 用户登录数据库服务器，发现登录失败，说明用户已经删除，如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">C:\Users\USER&gt;mysql -h localhost -u test1 -p<br>Enter password: ****<br>ERROR 1045 (28000): Access denied for user &#39;test&#39;@&#39;localhost&#39; (using  password: YES)<br></code></pre></td></tr></table></figure><h2 id="2-使用DELETE语句删除普通用户">2. 使用DELETE语句删除普通用户</h2><p><strong>可以使用 DELETE 语句直接删除 mysql.user 表中相应的用户信息，但必须拥有 mysql.user 表的 DELETE 权限。其基本语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM mysql.user WHERE Host&#x3D;&#39;hostname&#39; AND User&#x3D;&#39;username&#39;;<br></code></pre></td></tr></table></figure><p><strong>Host 和 User 这两个字段都是 mysql.user 表的主键。因此，需要两个字段的值才能确定一条记录。</strong></p><h3 id="例-2">例 2</h3><p><strong>下面使用 DELETE 语句删除用户’test2’@‘localhost’。SQL 语句和执行过程如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM mysql.user WHERE Host&#x3D;&#39;localhost&#39;AND User&#x3D;&#39;test2&#39;;<br>Query OK, 1 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示删除成功。可以使用 SELETE 语句查询 mysql.user 表，以确定该用户是否已经成功删除。</strong></p><h1>四、MySQL查看用户权限</h1><p><strong>在 MySQL 中，可以通过查看 mysql.user 表中的数据记录来查看相应的用户权限，也可以使用 SHOW GRANTS 语句查询用户的权限。</strong></p><p><strong>mysql 数据库下的 user 表中存储着用户的基本权限，可以使用 SELECT 语句来查看。SELECT 语句的代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM mysql.user;<br></code></pre></td></tr></table></figure><p><strong>要执行该语句，必须拥有对 user 表的查询权限。</strong></p><p><em><strong>注意：新创建的用户只有登录 MySQL 服务器的权限，没有任何其它权限，不能查询 user 表。</strong></em></p><p><strong>除了使用 SELECT 语句之外，还可以使用 SHOW GRANTS FOR 语句查看权限。其语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW GRANTS FOR &#39;username&#39;@&#39;hostname&#39;;<br></code></pre></td></tr></table></figure><p><strong>其中，username 表示用户名，hostname 表示主机名或主机 IP。</strong></p><h3 id="例-1-3">例 1</h3><p><strong>下面创建 testuser1 用户并查询权限，SQL 语句和执行过程如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE USER &#39;testuser1&#39;@&#39;localhost&#39;;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; SHOW GRANTS FOR &#39;testuser1&#39;@&#39;localhost&#39;;<br>+-----------------------------------------------+<br>| Grants for testuser1@localhost                |<br>+-----------------------------------------------+<br>| GRANT USAGE ON *.* TO &#39;testuser1&#39;@&#39;localhost&#39; |<br>+-----------------------------------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>其中，<code>USAGE ON *.*</code>表示该用户对任何数据库和任何表都没有权限。</strong></p><h3 id="例-2-2">例 2</h3><p><strong>下面查询 root 用户的权限，代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW GRANTS FOR &#39;root&#39;@&#39;localhost&#39;;<br>+---------------------------------------------------------------------+<br>| Grants for root@localhost                                           |<br>+---------------------------------------------------------------------+<br>| GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;localhost&#39; WITH GRANT OPTION |<br>| GRANT PROXY ON &#39;&#39;@&#39;&#39; TO &#39;root&#39;@&#39;localhost&#39; WITH GRANT OPTION        |<br>+---------------------------------------------------------------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h1>五、MySQL GRANT：用户授权</h1><p><strong>授权就是为某个用户赋予某些权限。例如，可以为新建的用户赋予查询所有数据库和表的权限。MySQL 提供了 GRANT 语句来为用户设置权限。</strong></p><p><strong>在 MySQL 中，拥有 GRANT 权限的用户才可以执行 GRANT 语句，其语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">GRANT priv_type [(column_list)] ON database.table<br>TO user [IDENTIFIED BY [PASSWORD] &#39;password&#39;]<br>[, user[IDENTIFIED BY [PASSWORD] &#39;password&#39;]] ...<br>[WITH with_option [with_option]...]<br></code></pre></td></tr></table></figure><h2 id="1、权限类型说明">1、权限类型说明</h2><h3 id="1）授予数据库权限时，-权限类型-可以指定为以下值：">1）授予数据库权限时，&lt;权限类型&gt;可以指定为以下值：</h3><p>![image-20200614164858090](G:\四期\数据库\mysql文档\11  MySQL 事务（2）.assets\image-20200614164858090.png)</p><h3 id="2-授予表权限时，-权限类型-可以指定为以下值：">2) 授予表权限时，&lt;权限类型&gt;可以指定为以下值：</h3><p>![image-20200614164921901](G:\四期\数据库\mysql文档\11  MySQL 事务（2）.assets\image-20200614164921901.png)</p><h3 id="3-授予列权限时，-权限类型-的值只能指定为-SELECT、INSERT-和-UPDATE，同时权限的后面需要加上列名列表-column-list。">3) 授予列权限时，&lt;权限类型&gt;的值只能指定为 SELECT、INSERT 和 UPDATE，同时权限的后面需要加上列名列表 column-list。</h3><h3 id="4-最有效率的权限是用户权限。">4) 最有效率的权限是用户权限。</h3><p><strong>授予用户权限时，&lt;权限类型&gt;除了可以指定为授予数据库权限时的所有值之外，还可以是下面这些值：</strong></p><ul><li><strong>CREATE USER：表示授予用户可以创建和删除新用户的权限。</strong></li><li><strong>SHOW DATABASES：表示授予用户可以使用 SHOW DATABASES 语句查看所有已有的数据库的定义的权限。</strong></li></ul><h3 id="例-1-4">例 1</h3><p><strong>使用 GRANT 语句创建一个新的用户 testUser，密码为 testPwd。用户 testUser 对所有的数据有查询、插入权限，并授予 GRANT 权限。SQL 语句和执行过程如下。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; GRANT SELECT,INSERT ON *.*<br>    -&gt; TO &#39;testUser&#39;@&#39;localhost&#39;<br>    -&gt; IDENTIFIED BY &#39;testPwd&#39;<br>    -&gt; WITH GRANT OPTION;<br>Query OK, 0 rows affected, 1 warning (0.05 sec)<br></code></pre></td></tr></table></figure><p><strong>使用 SHOW GRANTS 语句查询用户 testUser 的权限，如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW GRANTS FOR &#39;testUser&#39;@&#39;localhost&#39;;<br>+-------------------------------------------------------------------------+<br>| Grants for testUser@localhost                                           |<br>+-------------------------------------------------------------------------+<br>| GRANT SELECT, INSERT ON *.* TO &#39;testUser&#39;@&#39;localhost&#39; WITH GRANT OPTION |<br>+-------------------------------------------------------------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，testUser 对所有数据库的所有表有查询、插入权限，并可以将这些权限赋予给别的用户。</strong></p><h1>六、MySQL REVOKE：删除用户权限</h1><p><strong>在 MySQL 中，可以使用 REVOKE 语句删除某个用户的某些权限（此用户不会被删除），在一定程度上可以保证系统的安全性。例如，如果数据库管理员觉得某个用户不应该拥有 DELETE 权限，那么就可以删除 DELETE 权限。</strong></p><p><strong>使用 REVOKE 语句删除权限的语法格式有两种形式，如下所示：</strong></p><h2 id="1）第一种">1）第一种</h2><p><strong>删除用户某些特定的权限，语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">REVOKE priv_type [(column_list)]...<br>ON database.table<br>FROM user [, user]...<br></code></pre></td></tr></table></figure><p><strong>REVOKE 语句中的参数与 GRANT 语句的参数意思相同。其中：</strong></p><ul><li><strong>priv_type 参数表示权限的类型；</strong></li><li><strong>column_list 参数表示权限作用于哪些列上，没有该参数时作用于整个表上；</strong></li><li><strong>user 参数由用户名和主机名构成，格式为“username’@‘hostname’”。</strong></li></ul><h2 id="2）第二种">2）第二种</h2><p><strong>删除特定用户的所有权限，语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">REVOKE ALL PRIVILEGES, GRANT OPTION FROM user [, user] ...<br></code></pre></td></tr></table></figure><p><strong>删除用户权限需要注意以下几点：</strong></p><ul><li><strong>REVOKE 语法和 GRANT 语句的语法格式相似，但具有相反的效果。</strong></li><li><strong>要使用 REVOKE 语句，必须拥有 MySQL 数据库的全局 CREATE USER 权限或 UPDATE 权限。</strong></li></ul><h3 id="例-1-5">例 1</h3><p><strong>使用 REVOKE 语句取消用户 testUser 的插入权限，SQL 语句和执行过程如下。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; REVOKE INSERT ON *.*<br>    -&gt; FROM &#39;testUser&#39;@&#39;localhost&#39;;<br>Query OK, 0 rows affected (0.01 sec)<br><br>mysql&gt; SHOW GRANTS FOR &#39;testUser&#39;@&#39;localhost&#39;;<br>+-----------------------------------------------------------------+<br>| Grants for testUser@localhost                                   |<br>+-----------------------------------------------------------------+<br>| GRANT SELECT ON *.* TO &#39;testUser&#39;@&#39;localhost&#39; WITH GRANT OPTION |<br>+-----------------------------------------------------------------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，删除 testUser 用户的 INSERT 权限成功。</strong></p><h3 id="创建用户并授权">创建用户并授权</h3><p><strong>GRANT语句可实现创建用户同时授权或为已存在的用户授权</strong><br>![image-20200612151755831](G:\四期\数据库\mysql文档\11  MySQL用户管理（1）.assets\image-20200612151755831.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 给用户授权<br>grant insert,select on myschool.student<br>to &#96;xgp&#96;@&#96;localhost&#96; IDENTIFIED by &#39;123456&#39;;<br><br>grant select on myschool.student to &#96;student&#96;@&#96;localhost&#96;;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use myschool;<br>delete from student;<br></code></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">C:\<span class="hljs-title">WINDOWS</span>\<span class="hljs-title">system32</span>&gt;<span class="hljs-title">mysqladmin</span> -<span class="hljs-title">u</span> <span class="hljs-title">xgp</span> -<span class="hljs-title">p</span> <span class="hljs-title">password</span> "1111"</span><br><span class="hljs-function"><span class="hljs-title">Enter</span> <span class="hljs-title">password</span>: ******</span><br><span class="hljs-function"><span class="hljs-title">mysqladmin</span>: [<span class="hljs-title">Warning</span>] <span class="hljs-title">Using</span> <span class="hljs-title">a</span> <span class="hljs-title">password</span> <span class="hljs-title">on</span> <span class="hljs-title">the</span> <span class="hljs-title">command</span> <span class="hljs-title">line</span> <span class="hljs-title">interface</span> <span class="hljs-title">can</span> <span class="hljs-title">be</span> <span class="hljs-title">insecure</span>.</span><br><span class="hljs-function"><span class="hljs-title">Warning</span>: <span class="hljs-title">Since</span> <span class="hljs-title">password</span> <span class="hljs-title">will</span> <span class="hljs-title">be</span> <span class="hljs-title">sent</span> <span class="hljs-title">to</span> <span class="hljs-title">server</span> <span class="hljs-title">in</span> <span class="hljs-title">plain</span> <span class="hljs-title">text</span>, <span class="hljs-title">use</span> <span class="hljs-title">ssl</span> <span class="hljs-title">connection</span> <span class="hljs-title">to</span> <span class="hljs-title">ensure</span> <span class="hljs-title">password</span> <span class="hljs-title">safety</span>.</span><br></code></pre></td></tr></table></figure><p>![image-20200612153552461](G:\四期\数据库\mysql文档\11  MySQL用户管理（1）.assets\image-20200612153552461.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">set password &#x3D; password(&quot; 8888 )<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET PASSWORD FOR &#96;teacher&#96;@localhost&#96; &#x3D; PASSWORD(&quot;8888&quot;);<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop user xgp@localhost;<br>select * from user;<br></code></pre></td></tr></table></figure><p>![image-20200612154416018](G:\四期\数据库\mysql文档\11  MySQL用户管理（1）.assets\image-20200612154416018.png)</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql结构化查询语句 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 事务(2)</title>
      <link href="/posts/40d5.html"/>
      <url>/posts/40d5.html</url>
      
        <content type="html"><![CDATA[<h1>一、MySQL设置事务自动提交（开启和关闭）</h1><p><strong>MySQL 默认开启事务自动提交模式，即除非显式的开启事务（BEGIN 或 START TRANSACTION），否则每条 SOL 语句都会被当做一个单独的事务自动执行。但有些情况下，我们需要关闭事务自动提交来保证数据的一致性。下面主要介绍如何设置事务自动提交模式。</strong></p><p><strong>在 MySQL 中，可以通过  SHOW VARIABLES 语句查看当前事务自动提交模式，如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW VARIABLES LIKE &#39;autocommit&#39;;<br>+---------------+-------+<br>| Variable_name | Value |<br>+---------------+-------+<br>| autocommit    | ON    |<br>+---------------+-------+<br>1 row in set, 1 warning (0.04 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，autocommit 的值是 ON，表示系统开启自动提交模式。</strong></p><p><strong>在 MySQL 中，可以使用 SET autocommit 语句设置事务的自动提交模式，语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET autocommit &#x3D; 0|1|ON|OFF;<br></code></pre></td></tr></table></figure><p><strong>对取值的说明：</strong></p><ul><li><strong>值为 0 和值为 OFF：关闭事务自动提交。如果关闭自动提交，用户将会一直处于某个事务中，只有提交或回滚后才会结束当前事务，重新开始一个新事务。</strong></li><li><strong>值为 1 和值为 ON：开启事务自动提交。如果开启自动提交，则每执行一条 SQL 语句，事务都会提交一次。</strong></li></ul><h2 id="示例">示例</h2><p><strong>下面我们关闭事务自动提交，模拟银行转账。</strong></p><p><strong>使用 SET autocommit 语句关闭事务自动提交，且张三转给李四 500 元，SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SET autocommit &#x3D; 0;                                                      ;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; SELECT * FROM mybank.bank;<br>+--------------+--------------+<br>| cusName | cusMoney |<br>+--------------+--------------+<br>| 张三         |      1000.00 |<br>| 李四         |         1.00 |<br>+--------------+--------------+<br>2 rows in set (0.00 sec)<br>mysql&gt; UPDATE bank SET cusMoney &#x3D; cusMoney-500 WHERE cusName&#x3D;&#39;张三&#39; ;<br>Query OK, 1 row affected (0.02 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>mysql&gt; UPDATE bank SET cusMoney &#x3D; cusMoney+500 WHERE cusName&#x3D;&#39;李四&#39;;<br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br></code></pre></td></tr></table></figure><p><strong>这时重新打开一个 cmd 窗口，查看 bank 数据表中张三和李四的余额，SQL 语句和运行结果如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM mybank.bank;<br>+--------------+--------------+<br>| cusName | cusMoney |<br>+--------------+--------------+<br>| 张三         |      1000.00 |<br>| 李四         |         1.00 |<br>+--------------+--------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，张三和李四的余额是事务执行前的数据。</strong></p><p><strong>下面在之前的窗口中使用 COMMIT 语句提交事务，并查询 bank 数据表的数据，如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; COMMIT;<br>Query OK, 0 rows affected (0.07 sec)<br>mysql&gt; SELECT * FROM mybank.bank;<br>+--------------+--------------+<br>| cusName | cusMoney |<br>+--------------+--------------+<br>| 张三         |       500.00 |<br>| 李四         |       501.00 |<br>+--------------+--------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，bank 数据表的数据更新成功。</strong></p><p><strong>在本例中，关闭自动提交后，该位置会作为一个事务起点，直到执行 COMMIT 语句和 ROLLBACK 语句后，该事务才结束。结束之后，这就是下一个事务的起点。</strong></p><p><strong>关闭自动提交功能后，只用当执行 COMMIT 命令后，MySQL 才将数据表中的资料提交到数据库中。如果执行 ROLLBACK 命令，数据将会被回滚。如果不提交事务，而终止 MySQL 会话，数据库将会自动执行回滚操作。</strong></p><p><strong>使用 BEGIN 或 START TRANSACTION 开启一个事务之后，自动提交将保持禁用状态，直到使用 COMMIT 或 ROLLBACK 结束事务。之后，自动提交模式会恢复到之前的状态，即如果 BEGIN 前 autocommit = 1，则完成本次事务后 autocommit 还是 1。如果 BEGIN 前 autocommit = 0，则完成本次事务后 autocommit 还是 0。</strong></p><h1>二、MySQL事务隔离级别详解</h1><p><strong>在《<a href="http://c.biancheng.net/view/7289.html" target="_blank" rel="noopener">数据库事务</a>》一节中介绍了 MySQL 事务的四大特性，其中事务的隔离性就是指当多个事务同时运行时，各事务之间相互隔离，不可互相干扰。</strong></p><p><strong>如果事务没有隔离性，就容易出现脏读、不可重复读和幻读等情况。</strong></p><h4 id="1-脏读">1) 脏读</h4><p><strong>脏读是指一个事务正在访问数据，并且对数据进行了修改，但是这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</strong></p><h4 id="2-不可重复读">2) 不可重复读</h4><p><strong>不可重复读是指在一个事务内，多次读取同一个数据。</strong></p><p><strong>在这个事务还没有结束时，另外一个事务也访问了该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</strong></p><h4 id="3-幻读">3) 幻读</h4><p><strong>幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</strong></p><p><strong>为了解决以上这些问题，标准 SQL 定义了 4 类事务隔离级别，用来指定事务中的哪些数据改变是可见的，哪些数据改变是不可见的。</strong></p><h4 id="MySQL-包括的事务隔离级别如下："><strong>MySQL 包括的事务隔离级别如下：</strong></h4><ul><li><strong>读未提交（READ UNCOMITTED）</strong></li><li><strong>读提交（READ COMMITTED）</strong></li><li><strong>可重复读（REPEATABLE READ）</strong></li><li><strong>串行化（SERIALIZABLE）</strong></li></ul><h4 id="MySQL-事务隔离级别可能产生的问题如下表所示："><strong>MySQL 事务隔离级别可能产生的问题如下表所示：</strong></h4><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p><strong>MySQL 的事务的隔离级别由低到高分别为 READ UNCOMITTED、READ COMMITTED、REPEATABLE READ、SERIALIZABLE。低级别的隔离级别可以支持更高的并发处理，同时占用的系统资源更少。</strong></p><p><strong>下面根据实例来一一阐述它们的概念和联系。</strong></p><h2 id="1-读未提交（READ-UNCOMITTED，RU）">1. 读未提交（READ UNCOMITTED，RU）</h2><p><strong>顾名思义，读未提交就是可以读到未提交的内容。</strong></p><p><strong>如果一个事务读取到了另一个未提交事务修改过的数据，那么这种隔离级别就称之为读未提交。</strong></p><p><strong>在该隔离级别下，所有事务都可以看到其它未提交事务的执行结果。因为它的性能与其他隔离级别相比没有高多少，所以一般情况下，该隔离级别在实际应用中很少使用。</strong></p><p><strong>例 1 主要演示了在读未提交隔离级别中产生的脏读现象。</strong></p><h3 id="示例-1">示例 1</h3><h4 id="1-先在-test-数据库中创建-testnum-数据表，并插入数据。SQL-语句和执行结果如下：">1) 先在 test 数据库中创建 testnum 数据表，并插入数据。SQL 语句和执行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE TABLE testnum(<br>    -&gt; num INT(4));<br>Query OK, 0 rows affected (0.57 sec)<br>mysql&gt; INSERT INTO test.testnum (num) VALUES(1),(2),(3),(4),(5);<br>Query OK, 5 rows affected (0.09 sec)<br></code></pre></td></tr></table></figure><h4 id="2-下面的语句需要在两个命令行窗口中执行。为了方便理解，我们分别称之为-A-窗口和-B-窗口。">2) 下面的语句需要在两个命令行窗口中执行。为了方便理解，我们分别称之为 A 窗口和 B 窗口。</h4><p><strong>在 A 窗口中修改事务隔离级别，因为 A 窗口和 B 窗口的事务隔离级别需要保持一致，所以我们使用 SET GLOBAL TRANSACTION 修改全局变量。SQL 语句如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;<br>Query OK, 0 rows affected (0.04 sec)<br>flush privileges;<br>Query OK, 0 rows affected (0.04 sec)<br></code></pre></td></tr></table></figure><p><strong>查询事务隔离级别，SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#39;%tx_isolation%&#39;\G<br>*************************** 1. row ***************************<br>Variable_name: tx_isolation<br>        Value: READ-UNCOMMITTED<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，现在 MySQL 的事务隔离级别为 READ-UNCOMMITTED。</strong></p><h4 id="3-在-A-窗口中开启一个事务，并查询-testnum-数据表，SQL-语句和运行结果如下：">3) 在 A 窗口中开启一个事务，并查询 testnum 数据表，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; BEGIN;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; SELECT * FROM testnum;<br>+------+<br>| num  |<br>+------+<br>|    1 |<br>|    2 |<br>|    3 |<br>|    4 |<br>|    5 |<br>+------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="4-打开-B-窗口，查看当前-MySQL-的事务隔离级别，SQL-语句如下：">4) 打开 B 窗口，查看当前 MySQL 的事务隔离级别，SQL 语句如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#39;%tx_isolation%&#39;\G<br>*************************** 1. row ***************************<br>Variable_name: tx_isolation<br>        Value: READ-UNCOMMITTED<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>确定事务隔离级别是 READ-UNCOMMITTED 后，开启一个事务，并使用 UPDATE 语句更新 testnum 数据表，SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; BEGIN;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; UPDATE test.testnum SET num&#x3D;num*2 WHERE num&#x3D;2;<br>Query OK, 1 row affected (0.02 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br></code></pre></td></tr></table></figure><h4 id="5-现在返回-A-窗口，再次查询-testnum-数据表，SQL-语句和运行结果如下：">5) 现在返回 A 窗口，再次查询 testnum 数据表，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM testnum;<br>+------+<br>| num  |<br>+------+<br>|    1 |<br>|    4 |<br>|    3 |<br>|    4 |<br>|    5 |<br>+------+<br>5 rows in set (0.02 sec)<br></code></pre></td></tr></table></figure><p><strong>由结果可以看出，A 窗口中的事务读取到了更新后的数据。</strong></p><h4 id="6-下面在-B-窗口中回滚事务，SQL-语句和运行结果如下：">6) 下面在 B 窗口中回滚事务，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; ROLLBACK;<br>Query OK, 0 rows affected (0.09 sec)<br></code></pre></td></tr></table></figure><h4 id="7-在-A-窗口中查询-testnum-数据表，SQL-语句和运行结果如下：">7) 在 A 窗口中查询 testnum 数据表，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM testnum;<br>+------+<br>| num  |<br>+------+<br>|    1 |<br>|    2 |<br>|    3 |<br>|    4 |<br>|    5 |<br>+------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>当 MySQL 的事务隔离级别为 READ UNCOMITTED 时，首先分别在 A 窗口和 B 窗口中开启事务，在 B 窗口中的事务更新但未提交之前， A 窗口中的事务就已经读取到了更新后的数据。但由于 B 窗口中的事务回滚了，所以 A 事务出现了脏读现象。</strong></p><p><strong>使用读提交隔离级别可以解决实例中产生的脏读问题。</strong></p><h2 id="2-读提交（READ-COMMITTED，RC）">2. 读提交（READ COMMITTED，RC）</h2><p><strong>顾名思义，读提交就是只能读到已经提交了的内容。</strong></p><p><strong>如果一个事务只能读取到另一个已提交事务修改过的数据，并且其它事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那么这种隔离级别就称之为读提交。</strong></p><p><strong>该隔离级别满足了隔离的简单定义：一个事务从开始到提交前所做的任何改变都是不可见的，事务只能读取到已经提交的事务所做的改变。</strong></p><p><strong>这是大多数数据库系统的默认事务隔离级别（例如 Oracle、SQL Server），但不是 MySQL 默认的。</strong></p><p><strong>例 2 演示了在读提交隔离级别中产生的不可重复读问题。</strong></p><h3 id="示例-2">示例 2</h3><h4 id="1-使用-SET-语句将-MySQL-事务隔离级别修改为-READ-COMMITTED，并查看。SQL-语句和运行结果如下：">1) 使用 SET 语句将 MySQL 事务隔离级别修改为 READ COMMITTED，并查看。SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; show variables like &#39;%tx_isolation%&#39;\G<br>*************************** 1. row ***************************<br>Variable_name: tx_isolation<br>        Value: READ-COMMITTED<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="2-确定当前事务隔离级别为-READ-COMMITTED-后，开启一个事务，SQL-语句和运行结果如下：">2) 确定当前事务隔离级别为 READ COMMITTED 后，开启一个事务，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; BEGIN;<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="3-在-B-窗口中开启事务，并使用-UPDATE-语句更新-testnum-数据表，SQL-语句和运行结果如下：">3) 在 B 窗口中开启事务，并使用 UPDATE 语句更新 testnum 数据表，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; BEGIN;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt;  UPDATE test.testnum SET num&#x3D;num*2 WHERE num&#x3D;2;<br>Query OK, 1 row affected (0.07 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br></code></pre></td></tr></table></figure><h4 id="4-在-A-窗口中查询-testnum-数据表，SQL-语句和运行结果如下：">4) 在 A 窗口中查询 testnum 数据表，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * from test.testnum;<br>+------+<br>| num  |<br>+------+<br>|    1 |<br>|    2 |<br>|    3 |<br>|    4 |<br>|    5 |<br>+------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="5-提交-B-窗口中的事务，SQL-语句和运行结果如下：">5) 提交 B 窗口中的事务，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; COMMIT;<br>Query OK, 0 rows affected (0.07 sec)<br></code></pre></td></tr></table></figure><h4 id="6-在-A-窗口中查询-testnum-数据表，SQL-语句和运行结果如下：">6) 在 A 窗口中查询 testnum 数据表，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * from test.testnum;<br>+------+<br>| num  |<br>+------+<br>|    1 |<br>|    4 |<br>|    3 |<br>|    4 |<br>|    5 |<br>+------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>当 MySQL 的事务隔离级别为 READ COMMITTED 时，首先分别在 A 窗口和 B 窗口中开启事务，在 B 窗口中的事务更新并提交后，A 窗口中的事务读取到了更新后的数据。在该过程中，A 窗口中的事务必须要等待 B 窗口中的事务提交后才能读取到更新后的数据，这样就解决了脏读问题。而处于 A 窗口中的事务出现了不同的查询结果，即不可重复读现象。</strong></p><p><strong>使用可重复读隔离级别可以解决实例中产生的不可重复读问题。</strong></p><h2 id="3-可重复读（REPEATABLE-READ，RR）">3. 可重复读（REPEATABLE READ，RR）</h2><p><strong>顾名思义，可重复读是专门针对不可重复读这种情况而制定的隔离级别，可以有效的避免不可重复读。</strong></p><p><strong>在一些场景中，一个事务只能读取到另一个已提交事务修改过的数据，但是第一次读过某条记录后，即使其它事务修改了该记录的值并且提交，之后该事务再读该条记录时，读到的仍是第一次读到的值，而不是每次都读到不同的数据。那么这种隔离级别就称之为可重复读。</strong></p><p><strong>可重复读是 MySQL 的默认事务隔离级别，它能确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。在该隔离级别下，如果有事务正在读取数据，就不允许有其它事务进行修改操作，这样就解决了可重复读问题。</strong></p><p><strong>例 3 演示了在可重复读隔离级别中产生的幻读问题。</strong></p><h3 id="示例-3">示例 3</h3><h4 id="1-在-test-数据库中创建-testuser-数据表，SQL-语句和执行结果如下：">1) 在 test 数据库中创建 testuser 数据表，SQL 语句和执行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE TABLE testuser(<br>    -&gt; id INT (4) PRIMARY KEY,<br>    -&gt; name VARCHAR(20));<br>Query OK, 0 rows affected (0.29 sec)<br></code></pre></td></tr></table></figure><h4 id="2-使用-SET-语句修改事务隔离级别，SQL-语句如下：">2) 使用 SET 语句修改事务隔离级别，SQL 语句如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="3-在-A-窗口中开启事务，并查询-testuser-数据表，SQL-语句和运行结果如下：">3) 在 A 窗口中开启事务，并查询 testuser 数据表，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; BEGIN;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; SELECT * FROM test.testuser where id&#x3D;1;<br>Empty set (0.04 sec)<br></code></pre></td></tr></table></figure><h4 id="4-在-B-窗口中开启一个事务，并向-testuser-表中插入一条数据，SQL-语句和运行结果如下：">4) 在 B 窗口中开启一个事务，并向 testuser 表中插入一条数据，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; BEGIN;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt;  INSERT INTO test.testuser VALUES(1,&#39;zhangsan&#39;);<br>Query OK, 1 row affected (0.04 sec)<br>mysql&gt; COMMIT;<br>Query OK, 0 rows affected (0.06 sec)<br></code></pre></td></tr></table></figure><h4 id="5-现在返回-A-窗口，向-testnum-数据表中插入数据，SQL-语句和运行结果如下：">5) 现在返回 A 窗口，向 testnum 数据表中插入数据，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; INSERT INTO test.testuser VALUES(1,&#39;lisi&#39;);<br>ERROR 1062 (23000): Duplicate entry &#39;1&#39; for key &#39;PRIMARY&#39;<br>mysql&gt;  SELECT * FROM test.testuser where id&#x3D;1;<br>Empty set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>使用串行化隔离级别可以解决实例中产生的幻读问题。</strong></p><h2 id="4-串行化（SERIALIZABLE）">4. 串行化（SERIALIZABLE）</h2><p><strong>如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。那么这种隔离级别就称之为串行化。</strong></p><p><strong>SERIALIZABLE 是最高的事务隔离级别，主要通过强制事务排序来解决幻读问题。简单来说，就是在每个读取的数据行上加上共享锁实现，这样就避免了脏读、不可重复读和幻读等问题。但是该事务隔离级别执行效率低下，且性能开销也最大，所以一般情况下不推荐使用。</strong></p><h1>三、MySQL查看和修改事务隔离级别</h1><p><strong>在《<a href="http://c.biancheng.net/view/7265.html" target="_blank" rel="noopener">MySQL事务隔离级别</a>》一节中我们了解了 MySQL 的事务隔离级别，本节主要介绍查看和修改事务隔离级别的几种方法。</strong></p><h2 id="查看事务隔离级别">查看事务隔离级别</h2><p><strong>在 MySQL 中，可以通过<code>show variables like '%tx_isolation%'</code>或<code>select @@tx_isolation;</code>语句来查看当前事务隔离级别。</strong></p><p><strong>查看当前事务隔离级别的 SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show variables like &#39;%tx_isolation%&#39;;<br>+---------------+-----------------+<br>| Variable_name | Value           |<br>+---------------+-----------------+<br>| tx_isolation  | REPEATABLE-READ |<br>+---------------+-----------------+<br>1 row in set, 1 warning (0.17 sec）<br>mysql&gt; select @@tx_isolation;<br>+-----------------+<br>| @@tx_isolation  |<br>+-----------------+<br>| REPEATABLE-READ |<br>+-----------------+<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>结果显示，目前 MySQL 的事务隔离级别是 REPEATABLE-READ。</strong></p><p><strong>另外，还可以使用下列语句分别查询全局和会话的事务隔离级别：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT @@global.tx_isolation;<br>SELECT @@session.tx_isolation;<br></code></pre></td></tr></table></figure><p><strong>提示：在MySQL 8.0.3 中，tx_isolation 变量被 transaction_isolation 变量替换了。在 MySQL 8.0.3 版本中查询事务隔离级别，只要把上述查询语句中的 tx_isolation 变量替换成 transaction_isolation 变量即可。</strong></p><h2 id="修改事务隔离级别">修改事务隔离级别</h2><p><strong>MySQL 提供了 SET TRANSACTION 语句，该语句可以改变单个会话或全局的事务隔离级别。语法格式如下：</strong></p><p><strong>SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}</strong></p><p><strong>其中，SESSION 和 GLOBAL 关键字用来指定修改的事务隔离级别的范围：</strong></p><ul><li><strong>SESSION：表示修改的事务隔离级别将应用于当前 session（当前 cmd 窗口）内的所有事务；</strong></li><li><strong>GLOBAL：表示修改的事务隔离级别将应用于所有 session（全局）中的所有事务，且当前已经存在的 session 不受影响；</strong></li><li><strong>如果省略 SESSION 和 GLOBAL，表示修改的事务隔离级别将应用于当前 session 内的下一个还未开始的事务。</strong></li></ul><p><strong>任何用户都能改变会话的事务隔离级别，但是只有拥有 SUPER 权限的用户才能改变全局的事务隔离级别。</strong></p><p><strong>如果使用普通用户修改全局事务隔离级别，就会提示需要超级权限才能执行此操作的错误信息，SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">C:\Users\leovo&gt;mysql -utestuser -p<br>Enter password: ******<br>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 41<br>Server version: 5.7.29-log MySQL Community Server (GPL)<br> <br>Copyright (c) 2000, 2020, Oracle and&#x2F;or its affiliates. All rights reserved.<br> <br>Oracle is a registered trademark of Oracle Corporation and&#x2F;or its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br> <br>Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.<br> <br>mysql&gt; SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;<br>ERROR 1227 (42000): Access denied; you need (at least one of) the SUPER privilege(s) for this operation<br>mysql&gt; SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="示例-1-2">示例 1</h4><p><strong>使用 SET TRANSACTION 语句分别修改 session 和全局的事务隔离级别SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt;  select @@session.tx_isolation;<br>+------------------------+<br>| @@session.tx_isolation |<br>+------------------------+<br>| SERIALIZABLE           |<br>+------------------------+<br>1 row in set, 1 warning (0.00 sec)<br><br>mysql&gt; SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt;  select @@global.tx_isolation;<br>+-----------------------+<br>| @@global.tx_isolation |<br>+-----------------------+<br>| REPEATABLE-READ       |<br>+-----------------------+<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>还可以使用 set tx_isolation 命令直接修改当前 session 的事务隔离级别，SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; set tx_isolation&#x3D;&#39;READ-COMMITTED&#39;;<br>Query OK, 0 rows affected, 1 warning (0.00 sec)<br><br>mysql&gt; select @@session.tx_isolation;<br>+------------------------+<br>| @@session.tx_isolation |<br>+------------------------+<br>| READ-COMMITTED         |<br>+------------------------+<br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql结构化查询语句 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 事务(1)</title>
      <link href="/posts/b0d5.html"/>
      <url>/posts/b0d5.html</url>
      
        <content type="html"><![CDATA[<h2 id="A-MySQL-事务">A: MySQL 事务</h2><p><strong>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</strong></p><ul><li><strong>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</strong></li><li><strong>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</strong></li><li><strong>事务用来管理 insert,update,delete 语句</strong></li></ul><p><strong>一般来说，事务是必须满足4个条件（ACID）: :原子性（<code>A</code>tomicity，或称不可分割性）、一致性（<code>C</code>onsistency）、隔离性（<code>I</code>solation，又称独立性）、持久性（<code>D</code>urability）。</strong></p><ul><li><strong><code>原子性</code>:一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</strong></li><li><strong><code>一致性</code>:在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</strong></li><li><strong><code>隔离性</code>:数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</strong></li><li><strong><code>持久性</code>:事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</strong></li></ul><blockquote><p><strong>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。</strong></p></blockquote><h2 id="B-关于事务的一些术语">B: 关于事务的一些术语</h2><ul><li><strong>开启事务：Start Transaction</strong></li><li><strong>事务结束：End Transaction</strong></li><li><strong>提交事务：Commit Transaction</strong></li><li><strong>回滚事务：Rollback Transaction</strong></li></ul><h2 id="C-MYSQL-事务处理主要有两种方法：">C: MYSQL 事务处理主要有两种方法：</h2><h3 id="1、用-BEGIN-ROLLBACK-COMMIT来实现">1、用 BEGIN, ROLLBACK, COMMIT来实现</h3><ul><li><strong>BEGIN</strong> 开始一个事务</li><li><strong>ROLLBACK</strong> 事务回滚</li><li><strong>COMMIT</strong> 事务确认</li></ul><h3 id="2、直接用-SET-来改变-MySQL-的自动提交模式">2、直接用 SET 来改变 MySQL 的自动提交模式:</h3><ul><li><strong>SET AUTOCOMMIT=0</strong> 禁止自动提交</li><li><strong>SET AUTOCOMMIT=1</strong> 开启自动提交</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; use RUNOOB;<br>Database changed<br>mysql&gt; CREATE TABLE runoob_transaction_test( id int(5)) engine&#x3D;innodb;  # 创建数据表<br>Query OK, 0 rows affected (0.04 sec)<br> <br>mysql&gt; select * from runoob_transaction_test;<br>Empty set (0.01 sec)<br> <br>mysql&gt; begin;  # 开始事务<br>Query OK, 0 rows affected (0.00 sec)<br> <br>mysql&gt; insert into runoob_transaction_test value(5);<br>Query OK, 1 rows affected (0.01 sec)<br> <br>mysql&gt; insert into runoob_transaction_test value(6);<br>Query OK, 1 rows affected (0.00 sec)<br> <br>mysql&gt; commit; # 提交事务<br>Query OK, 0 rows affected (0.01 sec)<br> <br>mysql&gt;  select * from runoob_transaction_test;<br>+------+<br>| id   |<br>+------+<br>| 5    |<br>| 6    |<br>+------+<br>2 rows in set (0.01 sec)<br> <br>mysql&gt; begin;    # 开始事务<br>Query OK, 0 rows affected (0.00 sec)<br> <br>mysql&gt;  insert into runoob_transaction_test values(7);<br>Query OK, 1 rows affected (0.00 sec)<br> <br>mysql&gt; rollback;   # 回滚<br>Query OK, 0 rows affected (0.00 sec)<br> <br>mysql&gt;   select * from runoob_transaction_test;   # 因为回滚所以数据没有插入<br>+------+<br>| id   |<br>+------+<br>| 5    |<br>| 6    |<br>+------+<br>2 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><h2 id="D-什么是事务">D: 什么是事务</h2><ul><li><strong>事务(TRANSACTION)是作为单个逻辑工作单元执行的一系列操作</strong></li><li><strong>多个操作作为一个整体向系统提交，要么都执行、要么都不执行</strong></li><li><strong>事务是一个不可分割的工作逻辑单元</strong></li></ul><blockquote><p><strong>转账过程就是一个整体</strong><br><strong>它需要两条UPDATE语句来完成，这两条语句是一个整体</strong><br><strong>如果其中任一条出现错误， 则整个转账业务也应取消，两个账户中的余额应恢复</strong><br><strong>到原来的数据，从而确保转账前和转账后的余额不变，即都是1001元</strong></p></blockquote><h2 id="E-为什么需要事务">E: 为什么需要事务</h2><p><strong>了解事务之前，先来看看数据库为什么需要有事务，假设没有事务会有什么影响？</strong></p><p><strong>举一个转账的例子，假设你朋友向你借10000元，你打开APP，乐呵呵的把钱转了，你的卡里已经少了10000元，但是你打电话给朋友时，你朋友说没有收到啊，你这时候肯定卖银行怎么不靠谱，没到账怎么把我卡里的钱给扣了。</strong></p><p><strong>我们来捋一捋上述银行发生的过程，简单的分三步：</strong></p><p><strong>A发起转账10000给B -&gt; A银行卡减10000元 -&gt; B银行卡增加10000元。</strong></p><p><strong>上述案例是第三步出现了问题，如果有事务，则不会发生案例中的事情，可以理解为事务就是这三个步骤是一根绳子上的蚂蚱，要么都成功，要么都失败。</strong></p><p><strong>所以数据库引入事务的主要目的是事务会把数据库会从一种一致状态转换到另一种一致状态，数据库提交工作时可以确保要么所有修改都保存，要么所有修改都不保存。</strong></p><p><strong>了解事务，还需要了解事务的理论依据ACID，也可以说事务的几个特性。</strong></p><h1>一、银行转账问题</h1><ul><li><strong>假定资金从账户A转到账户B，至少需要两步</strong></li><li><ul><li><strong>账户A的资金减少</strong></li></ul></li><li><ul><li><strong>然后账户B的资金相应增加</strong></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop database if EXISTS &#96;bankdb&#96;;<br>create database &#96;bankdb&#96;;<br>use &#96;bankdb&#96;;<br><br>drop table IF EXISTS &#96;bank&#96;;<br>create table &#96;bank&#96;(<br>  &#96;cusName&#96; VARCHAR(20),   #用户名<br>  &#96;cusMoney&#96; DECIMAL(10,2)   #用户名<br>)CHARSET &#x3D; &#39;utf8mb4&#39;;<br><br>insert into bank<br>VALUES(&#39;张三&#39;,1000),(&#39;李四&#39;,1);<br><br># 模拟转账<br>UPDATE bank<br>set cusMoney&#x3D;cusMoney-500<br>where cusName&#x3D;&#39;张三&#39;;<br><br>UPDATE bank<br>set cusMoney&#x3D;cusMoney+500<br>where cusName&#x3D;&#39;李四&#39;;<br><br># 查看账户<br>select * from bank;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200612144209571.png" alt="image-20200612144209571"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200612143038859.png" alt="image-20200612143038859"></p><p><strong>下面开始模拟实现转账功能。从张三的账户直接转账 500 元到李四的账户，可以使用 UPDATE 语句分别修改张三的账户和李四的账户。张三的账户减少 500 元，李四的账户增加 500 元， SQL 语句如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 模拟转账<br>BEGIN;         #开始<br>UPDATE bank<br>set cusMoney&#x3D;cusMoney-500<br>where cusName&#x3D;&#39;张三&#39;;<br><br>UPDATE bank<br>set cusMoney&#x3D;cusMoney+500<br>where cusName&#x3D;&#39;李四&#39;;<br>COMMIT;        # 结束<br><br># 查看一下<br>select * from bank;<br></code></pre></td></tr></table></figure><p>![image-20200614160258903](G:\四期\数据库\mysql文档\09 MySQL 事务+用户权限.assets\image-20200614160258903.png)</p><p><strong>正常情况下，执行以上的转账操作后，余额总和应保持不变，仍为 1001 元。但是，如果在这个过程的其中一个环节出现差错，如在张三的账户减少 500 元之后，这时发生了服务器故障，李四的账户没有立即增加 500 元，此时，第三方读取到两个账户的余额总和变为 500+1=501 元，即账户总额间少了 500 元。</strong></p><p><strong>MySQL 为了解决此类问题，提供了事务。事务可以将一系列的数据操作捆绑成一个整体进行统一管理，如果某一事务执行成功，则在该事务中进行的所有数据更改均会提交，成为数据库中的永久组成部分。如果事务执行时遇到错误，则就必须取消或回滚。取消或回滚后，数据将全部恢复到操作前的状态，所有数据的更改均被清除。</strong></p><p><strong>MySQL 通过事务保证了数据的一致性。上述提到的转账过程就是一个事务，它需要两条 UPDATE 语句来完成。这两条语句是一个整体，如果其中任何一个环节出现问题，则整个转账业务也应取消，两个账户中的余额应恢复为原来的数据，从而确保转账前和转账后的余额总和不变，即都是 1001 元。</strong></p><h1>二、执行事务的语法和流程</h1><p><strong>SQL 使用下列语句来管理事务。</strong></p><h4 id="1-开始事务">1) 开始事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">BEGIN;<br></code></pre></td></tr></table></figure><p><strong>或</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">START TRANSACTION;<br></code></pre></td></tr></table></figure><p><strong>这个语句显式地标记一个事务的起始点。</strong></p><h4 id="2-提交事务">2) 提交事务</h4><p><strong>MySQL 使用下面的语句来提交事务：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">COMMIT;<br></code></pre></td></tr></table></figure><p><strong>COMMIT 表示提交事务，即提交事务的所有操作，具体地说，就是将事务中所有对数据库的更新都写到磁盘上的物理数据库中，事务正常结束。</strong></p><p><strong>提交事务，意味着将事务开始以来所执行的所有数据都修改成为数据库的永久部分，因此也标志着一个事务的结束。一旦执行了该命令，将不能回滚事务。只有在所有修改都准备好提交给数据库时，才执行这一操作。</strong></p><h4 id="3-回滚（撤销）事务">3) 回滚（撤销）事务</h4><p><strong>MySQL 使用以下语句回滚事务：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ROLLBACK;<br></code></pre></td></tr></table></figure><p><strong>ROLLBACK 表示撤销事务，即在事务运行的过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始时的状态。这里的操作指对数据库的更新操作。</strong></p><p><strong>当事务执行过程中遇到错误时，使用 ROLLBACK 语句使事务回滚到起点或指定的保持点处。同时，系统将清除自事务起点或到某个保存点所做的所有的数据修改，并且释放由事务控制的资源。因此，这条语句也标志着事务的结束。</strong></p><h4 id="总结">总结</h4><p><strong>BEGIN 或 START TRANSACTION 语句后面的 SQL 语句对数据库数据的更新操作都将记录在事务日志中，直至遇到 ROLLBACK 语句或 COMMIT 语句。如果事务中某一操作失败且执行了 ROLLBACK 语句，那么在开启事务语句之后所有更新的数据都能回滚到事务开始前的状态。如果事务中的所有操作都全部正确完成，并且使用了 COMMIT 语句向数据库提交更新数据，则此时的数据又处在新的一致状态。</strong></p><h2 id="1、实例演示">1、实例演示</h2><p><strong>下面通过两个例子来演示一下 MySQL 事务的具体用法。</strong></p><h3 id="示例-1">示例 1</h3><p><strong>下面模拟在张三的账户减少 500 元后，李四的账户还未增加 500 时，有其他会话访问数据表的场景。由于代码需要在两个窗口中执行，为了方便阅读，这里我们称为 A 窗口和 B 窗口。</strong></p><h4 id="1-在-A-窗口中开启一个事务，并更新-mybank-数据库中-bank-表的数据，SQL-语句和运行结果如下：">1) 在 A 窗口中开启一个事务，并更新 mybank 数据库中 bank 表的数据，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; USE mybank;<br>Database changed<br>mysql&gt; BEGIN;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; UPDATE bank SET cusMoney &#x3D; cusMoney-500<br>    -&gt; WHERE cusName&#x3D;&#39;张三&#39;;<br>Query OK, 1 row affected (0.05 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br></code></pre></td></tr></table></figure><h4 id="2-在-B-窗口中查询-bank-数据表中的数据，SQL-语句和运行结果如下：">2) 在 B 窗口中查询 bank 数据表中的数据，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM mybank.bank;<br>+--------------+--------------+<br>| cusName | cusMoney |<br>+--------------+--------------+<br>| 张三         |      1000.00 |<br>| 李四         |         1.00 |<br>+--------------+--------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>从结果可以看出，虽然 A 窗口中的事务已经更改了 bank 表中的数据，但没有立即更新数据，这时其他会话读取到的仍然是更新前的数据。</strong></p><h4 id="3-在-A-窗口中继续执行事务并提交事务，SQL-语句和运行结果如下：">3) 在 A 窗口中继续执行事务并提交事务，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; UPDATE bank SET cusMoney &#x3D; cusMoney+500<br>    -&gt; WHERE cusName&#x3D;&#39;李四&#39;;<br>Query OK, 1 row affected (0.05 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br>mysql&gt; COMMIT;<br>Query OK, 0 rows affected (0.07 sec)<br></code></pre></td></tr></table></figure><h4 id="4-在-B-窗口中再次查询-bank-数据表的数据，SQL-语句和运行结果如下：">4) 在 B 窗口中再次查询 bank 数据表的数据，SQL 语句和运行结果如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM mybank.bank;<br>+--------------+--------------+<br>| cusName | cusMoney |<br>+--------------+--------------+<br>| 张三         |       500.00 |<br>| 李四         |       501.00 |<br>+--------------+--------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>在 A 窗口中执行 COMMIT 提交事务后，对数据所做的更新将一起提交，其他会话读取到的是更新后的数据。从结果可以看出张三和李四的总账户余额和转账前保持一致，这样数据从一个一致性状态更新到另一个一致性状态。</strong></p><p><strong>前面提到，当事务在执行中出现问题，也就是不能按正常的流程执行一个完整的事务时，可以使用 ROLLBACK 语句进行回滚，使用数据恢复到初始状态。</strong></p><p><strong>在例 1 中，张三的账户余额已经减少到 500 元，如果再转出 1000 元，将会出现余额为负数，因此需要回滚到原始状态。如例 2 所示。</strong></p><h3 id="示例-2">示例 2</h3><p><strong>将张三的账户余额减少 1000 元，并让事务回滚，SQL 语句和运行结果如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; BEGIN;<br>Query OK, 0 rows affected (0.00 sec)<br> <br>mysql&gt; UPDATE bank SET cusMoney &#x3D; cusMoney-1000 WHERE cusName&#x3D;&#39;张三&#39;;<br>Query OK, 1 row affected (0.04 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br> <br>mysql&gt; ROLLBACK;<br>Query OK, 0 rows affected (0.07 sec)<br> <br>mysql&gt; SELECT * FROM mybank.bank;<br>+--------------+--------------+<br>| cusName | cusMoney |<br>+--------------+--------------+<br>| 张三         |       500.00 |<br>| 李四         |       501.00 |<br>+--------------+--------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>从结果可以看出，执行事务回滚后，账户数据恢复到初始状态，即该事务执行之前的状态。</strong></p><h3 id="拓展">拓展</h3><p><strong>在数据库操作中，为了有效保证并发读取数据的正确性，提出了事务的隔离级别。在例 1 和例 2 的演示中，事务的隔离级别为默认隔离级别。在 MySQL 中，事务的默认隔离级别是 REPEATABLE-READ （可重读）隔离级别，即事务未结束时（未执行 COMMIT 或 ROLLBACK），其它会话只能读取到未提交数据。</strong></p><p><strong>请猛击《<a href="http://c.biancheng.net/view/7265.html" target="_blank" rel="noopener">MySQL事务隔离级别</a>》了解更多内容。</strong></p><h2 id="2、注意事项">2、注意事项</h2><p><strong>MySQL 事务是一项非常消耗资源的功能，大家在使用过程中要注意以下几点。</strong></p><h4 id="1-事务尽可能简短">1) 事务尽可能简短</h4><p><strong>事务的开启到结束会在数据库管理系统中保留大量资源，以保证事务的原子性、一致性、隔离性和持久性。如果在多用户系统中，较大的事务将会占用系统的大量资源，使得系统不堪重负，会影响软件的运行性能，甚至导致系统崩溃。</strong></p><h4 id="2-事务中访问的数据量尽量最少">2) 事务中访问的数据量尽量最少</h4><p><strong>当并发执行事务处理时，事务操作的数据量越少，事务之间对相同数据的操作就越少。</strong></p><h4 id="3-查询数据时尽量不要使用事务">3) 查询数据时尽量不要使用事务</h4><p><strong>对数据进行浏览查询操作并不会更新数据库的数据，因此应尽量不使用事务查询数据，避免占用过量的系统资源。</strong></p><h4 id="4-在事务处理过程中尽量不要出现等待用户输入的操作">4) 在事务处理过程中尽量不要出现等待用户输入的操作</h4><p><strong>在处理事务的过程中，如果需要等待用户输入数据，那么事务会长时间地占用资源，有可能造成系统阻塞。</strong></p><h3 id="回滚">回滚</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">BEGIN;<br>UPDATE bank<br>set cusMoney&#x3D;cusMoney+500<br>where cusName&#x3D;&#39;张三&#39;;<br>ROLLBACK;<br><br>select * from bank;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200612144437603.png" alt="image-20200612144437603"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">BEGIN;<br>UPDATE bank<br>set cusMoney&#x3D;cusMoney+500<br>where cusName&#x3D;&#39;张三&#39;;<br>COMMIT;<br><br>select * from bank;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200612144620291.png" alt="image-20200612144620291"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">查看事务状态:SHOW VARIABLES LIKE &#39;AUTOCOMMIT&#39;;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200612150215912.png" alt="image-20200612150215912"></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql结构化查询语句 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引</title>
      <link href="/posts/8338.html"/>
      <url>/posts/8338.html</url>
      
        <content type="html"><![CDATA[<h2 id="A-为什么要使用索引">A: 为什么要使用索引</h2><p><strong>索引是 MySQL 中一种十分重要的数据库对象。它是数据库性能调优技术的基础，常用于实现数据的快速检索。</strong></p><p><strong>索引就是根据表中的一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表，实质上是一张描述索引列的列值与原表中记录行之间一一对应关系的有序表。</strong></p><p><strong>在 MySQL 中，通常有以下两种方式访问数据库表的行数据：</strong></p><h4 id="1-顺序访问">1) 顺序访问</h4><p><strong>顺序访问是在表中实行全表扫描，从头到尾逐行遍历，直到在无序的行数据中找到符合条件的目标数据。这种方式实现比较简单，但是当表中有大量数据的时候，效率非常低下。例如，在几千万条数据中查找少量的数据时，使用顺序访问方式将会遍历所有的数据，花费大量的时间，显然会影响数据库的处理性能。</strong></p><h4 id="2-索引访问">2) 索引访问</h4><p><strong>索引访问是通过遍历索引来直接访问表中记录行的方式。使用这种方式的前提是对表建立一个索引，在列上创建了索引之后，查找数据时可以直接根据该列上的索引找到对应记录行的位置，从而快捷地查找到数据。索引存储了指定列数据值的指针，根据指定的排序顺序对这些指针排序。</strong></p><p><strong>例如，在学生基本信息表 students 中，如果基于 student_id 建立了索引，系统就建立了一张索引列到实际记录的映射表，当用户需要查找 student_id 为 12022 的数据的时候，系统先在 student_id 索引上找到该记录，然后通过映射表直接找到数据行，并且返回该行数据。因为扫描索引的速度一般远远大于扫描实际数据行的速度，所以采用索引的方式可以大大提高数据库的工作效率。</strong></p><h2 id="B-索引的分类">B: 索引的分类</h2><p><strong>索引的类型和存储引擎有关，每种存储引擎所支持的索引类型不一定完全相同。根据存储方式的不同，MySQL 中常用的索引在物理上分为以下两类。</strong></p><h4 id="1-B-树索引">1) B-树索引</h4><p><strong>B-树索引又称为 BTREE 索引，目前大部分的索引都是采用 B-树索引来存储的。B-树索引是一个典型的<a href="http://c.biancheng.net/data_structure/" target="_blank" rel="noopener">数据结构</a>，其包含的组件主要有以下几个：</strong></p><ul><li><strong>叶子节点：包含的条目直接指向表里的数据行。叶子节点之间彼此相连，一个叶子节点有一个指向下一个叶子节点的指针。</strong></li><li><strong>分支节点：包含的条目指向索引里其他的分支节点或者叶子节点。</strong></li><li><strong>根节点：一个 B-树索引只有一个根节点，实际上就是位于树的最顶端的分支节点。</strong></li></ul><h4 id="2-哈希索引">2) 哈希索引</h4><p><strong>哈希（Hash）一般翻译为“散列”，也有直接音译成“哈希”的，就是把任意长度的输入（又叫作预映射，pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。</strong></p><p><strong>哈希索引也称为散列索引或 HASH 索引。MySQL 目前仅有 MEMORY 存储引擎和 HEAP 存储引擎支持这类索引。其中，MEMORY 存储引擎可以支持 B- 树索引和 HASH 索引，且将 HASH 当成默认索引。</strong></p><h2 id="C-常用索引类型">C: 常用索引类型</h2><table><thead><tr><th>普通索引</th><th>●基本索引类型<br>●允许在定义索引的列中插入重复值和空值</th></tr></thead><tbody><tr><td>唯一索引</td><td>●索引列数据不重复<br>●允许有空值</td></tr><tr><td>主键索引</td><td>●主键列中的每个值是非空、唯一的</td></tr><tr><td>复合索引</td><td>●一个主键将自动创建主键索引<br>●将多个列组合作为索引</td></tr><tr><td>全文索引</td><td>●支持值的全文查找</td></tr><tr><td>空间索引</td><td>●允许重复值和空值<br>●对空间数据类型的列建立的索引</td></tr></tbody></table><h2 id="D-索引的使用原则和注意事项">D: 索引的使用原则和注意事项</h2><p><strong>虽然索引可以加快查询速度，提高 MySQL 的处理性能，但是过多地使用索引也会造成以下弊端：</strong></p><ul><li><strong>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</strong></li><li><strong>除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大。</strong></li><li><strong>当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</strong></li></ul><blockquote><p><strong>注意：索引可以在一些情况下加速查询，但是在某些情况下，会降低效率。</strong></p></blockquote><p><strong>索引只是提高效率的一个因素，因此在建立索引的时候应该遵循以下原则：</strong></p><ul><li><strong>在经常需要搜索的列上建立索引，可以加快搜索的速度。</strong></li><li><strong>在作为主键的列上创建索引，强制该列的唯一性，并组织表中数据的排列结构。</strong></li><li><strong>在经常使用表连接的列上创建索引，这些列主要是一些外键，可以加快表连接的速度。</strong></li><li><strong>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，所以其指定的范围是连续的。</strong></li><li><strong>在经常需要排序的列上创建索引，因为索引已经排序，所以查询时可以利用索引的排序，加快排序查询。</strong></li><li><strong>在经常使用 WHERE 子句的列上创建索引，加快条件的判断速度。</strong></li></ul><p><strong>与此对应，在某些应用场合下建立索引不能提高 MySQL 的工作效率，甚至在一定程度上还带来负面效应，降低了数据库的工作效率，一般来说不适合创建索引的环境如下：</strong></p><ul><li><strong>对于那些在查询中很少使用或参考的列不应该创建索引。因为这些列很少使用到，所以有索引或者无索引并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度，并增大了空间要求。</strong></li><li><strong>对于那些只有很少数据值的列也不应该创建索引。因为这些列的取值很少，例如人事表的性别列。查询结果集的数据行占了表中数据行的很大比例，增加索引并不能明显加快检索速度。</strong></li><li><strong>对于那些定义为 TEXT、IMAGE 和 BIT 数据类型的列不应该创建索引。因为这些列的数据量要么相当大，要么取值很少。</strong></li><li><strong>当修改性能远远大于检索性能时，不应该创建索引。因为修改性能和检索性能是互相矛盾的。当创建索引时，会提高检索性能，降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</strong></li></ul><h1>一、MySQL创建索引</h1><h2 id="1、MySQL-提供了三种创建索引的方法：">1、MySQL 提供了三种创建索引的方法：</h2><h3 id="1-使用-CREATE-INDEX-语句">1) 使用 CREATE INDEX 语句</h3><p><strong>可以使用专门用于创建索引的 CREATE INDEX 语句在一个已有的表上创建索引，但该语句不能创建主键。</strong></p><h5 id="语法格式：">语法格式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE &lt;索引名&gt; ON &lt;表名&gt; (&lt;列名&gt; [&lt;长度&gt;] [ ASC | DESC])<br></code></pre></td></tr></table></figure><h3 id="2-使用-CREATE-TABLE-语句">2) 使用 CREATE TABLE 语句</h3><p><strong>索引也可以在创建表（CREATE TABLE）的同时创建。在 CREATE TABLE 语句中添加以下语句。语法格式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CONSTRAINT PRIMARY KEY [索引类型] (&lt;列名&gt;,…)<br></code></pre></td></tr></table></figure><h5 id="语法格式：-2">语法格式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">KEY | INDEX [&lt;索引名&gt;] [&lt;索引类型&gt;] (&lt;列名&gt;,…)<br></code></pre></td></tr></table></figure><p><strong>在 CREATE TABLE 语句中添加此语句，表示在创建新表的同时创建该表的索引。</strong></p><h5 id="语法格式：-3">语法格式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UNIQUE [ INDEX | KEY] [&lt;索引名&gt;] [&lt;索引类型&gt;] (&lt;列名&gt;,…)<br></code></pre></td></tr></table></figure><p><strong>在 CREATE TABLE 语句中添加此语句，表示在创建新表的同时创建该表的唯一性索引。</strong></p><h5 id="语法格式：-4">语法格式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">FOREIGN KEY &lt;索引名&gt; &lt;列名&gt;<br></code></pre></td></tr></table></figure><p><strong>在 CREATE TABLE 语句中添加此语句，表示在创建新表的同时创建该表的外键。</strong></p><p><strong>在使用 CREATE TABLE 语句定义列选项的时候，可以通过直接在某个列定义后面添加 PRIMARY KEY 的方式创建主键。而当主键是由多个列组成的多列索引时，则不能使用这种方法，只能用在语句的最后加上一个 PRIMARY KRY(&lt;列名&gt;，…) 子句的方式来实现。</strong></p><h4 id="3-使用-ALTER-TABLE-语句">3) 使用 ALTER TABLE 语句</h4><p><strong>CREATE INDEX 语句可以在一个已有的表上创建索引，ALTER TABLE 语句也可以在一个已有的表上创建索引。在使用 ALTER TABLE 语句修改表的同时，可以向已有的表添加索引。具体的做法是在 ALTER TABLE 语句中添加以下语法成分的某一项或几项。</strong></p><h5 id="语法格式：-5">语法格式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ADD INDEX [&lt;索引名&gt;] [&lt;索引类型&gt;] (&lt;列名&gt;,…)<br></code></pre></td></tr></table></figure><p><strong>在 ALTER TABLE 语句中添加此语法成分，表示在修改表的同时为该表添加索引。</strong></p><h5 id="语法格式：-6">语法格式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ADD PRIMARY KEY [&lt;索引类型&gt;] (&lt;列名&gt;,…)<br></code></pre></td></tr></table></figure><p><strong>在 ALTER TABLE 语句中添加此语法成分，表示在修改表的同时为该表添加主键。</strong></p><h5 id="语法格式：-7">语法格式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ADD UNIQUE [ INDEX | KEY] [&lt;索引名&gt;] [&lt;索引类型&gt;] (&lt;列名&gt;,…)<br></code></pre></td></tr></table></figure><p><strong>在 ALTER TABLE 语句中添加此语法成分，表示在修改表的同时为该表添加唯一性索引。</strong></p><h5 id="语法格式：-8">语法格式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ADD FOREIGN KEY [&lt;索引名&gt;] (&lt;列名&gt;,…)<br></code></pre></td></tr></table></figure><p><strong>在 ALTER TABLE 语句中添加此语法成分，表示在修改表的同时为该表添加外键。</strong></p><h2 id="2、创建一般索引">2、创建一般索引</h2><p><strong>创建一个表 tb_stu_info，在该表的 height 字段创建一般索引。输入的 SQL 语句和执行过程如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE TABLE tb_stu_info<br>    -&gt; (<br>    -&gt; id INT NOT NULL,<br>    -&gt; name CHAR(45) DEFAULT NULL,<br>    -&gt; dept_id INT DEFAULT NULL,<br>    -&gt; age INT DEFAULT NULL,<br>    -&gt; height INT DEFAULT NULL,<br>    -&gt; INDEX(height)<br>    -&gt; );<br>Query OK，0 rows affected (0.40 sec)<br>mysql&gt; SHOW CREATE TABLE tb_stu_info\G<br>*************************** 1. row ***************************<br>       Table: tb_stu_info<br>Create Table: CREATE TABLE &#96;tb_stu_info&#96; (<br>  &#96;id&#96; int(11) NOT NULL,<br>  &#96;name&#96; char(45) DEFAULT NULL,<br>  &#96;dept_id&#96; int(11) DEFAULT NULL,<br>  &#96;age&#96; int(11) DEFAULT NULL,<br>  &#96;height&#96; int(11) DEFAULT NULL,<br>  KEY &#96;height&#96; (&#96;height&#96;)<br>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;gb2312<br>1 row in set (0.01 sec)<br></code></pre></td></tr></table></figure><h2 id="3、创建唯一索引">3、创建唯一索引</h2><p><strong>创建一个表 tb_stu_info2，在该表的 id 字段上使用 UNIQUE 关键字创建唯一索引。输入的 SQL 语句和执行过程如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE TABLE tb_stu_info2<br>    -&gt; (<br>    -&gt; id INT NOT NULL,<br>    -&gt; name CHAR(45) DEFAULT NULL,<br>    -&gt; dept_id INT DEFAULT NULL,<br>    -&gt; age INT DEFAULT NULL,<br>    -&gt; height INT DEFAULT NULL,<br>    -&gt; UNIQUE INDEX(height)<br>    -&gt; );<br>Query OK，0 rows affected (0.40 sec)<br><br>mysql&gt; SHOW CREATE TABLE tb_stu_info2\G<br>*************************** 1. row ***************************<br>       Table: tb_stu_info2<br>Create Table: CREATE TABLE &#96;tb_stu_info2&#96; (<br>  &#96;id&#96; int(11) NOT NULL,<br>  &#96;name&#96; char(45) DEFAULT NULL,<br>  &#96;dept_id&#96; int(11) DEFAULT NULL,<br>  &#96;age&#96; int(11) DEFAULT NULL,<br>  &#96;height&#96; int(11) DEFAULT NULL,<br>  UNIQUE KEY &#96;height&#96; (&#96;height&#96;)<br>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;gb2312<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h1>二、查看索引</h1><p><strong>在 MySQL 中，如果要查看已创建的索引的情况，可以使用 SHOW INDEX 语句查看表中创建的索引。</strong></p><h5 id="语法格式：-9">语法格式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">SHOW INDEX FROM &lt;表名&gt; [ FROM &lt;数据库名&gt;]<br></code></pre></td></tr></table></figure><p><strong>语法说明如下：</strong></p><ul><li><strong><code>&lt;表名&gt;</code>：要显示索引的表。</strong></li><li><strong><code>&lt;数据库名&gt;</code>：要显示的表所在的数据库。</strong></li></ul><p><strong>显示数据库 mytest 的表 course 的索引情况。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">mysql&gt; SHOW INDEX FROM course FROM mytest;<br></code></pre></td></tr></table></figure><p><strong>该语句会返回一张结果表，该表有如下几个字段，每个字段所显示的内容说明如下。</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>Table</td><td>表示创建索引的数据表名，这里是 tb_stu_info2 数据表。</td></tr><tr><td>Non_unique</td><td>表示该索引是否是唯一索引。若不是唯一索引，则该列的值为 1；若是唯一索引，则该列的值为 0。</td></tr><tr><td>Key_name</td><td>表示索引的名称。</td></tr><tr><td>Seq_in_index</td><td>表示该列在索引中的位置，如果索引是单列的，则该列的值为 1；如果索引是组合索引，则该列的值为每列在索引定义中的顺序。</td></tr><tr><td>Column_name</td><td>表示定义索引的列字段。</td></tr><tr><td>Collation</td><td>表示列以何种顺序存储在索引中。在 MySQL 中，升序显示值“A”（升序），若显示为 NULL，则表示无分类。</td></tr><tr><td>Cardinality</td><td>索引中唯一值数目的估计值。基数根据被存储为整数的统计数据计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL 使用该索引的机会就越大。</td></tr><tr><td>Sub_part</td><td>表示列中被编入索引的字符的数量。若列只是部分被编入索引，则该列的值为被编入索引的字符的数目；若整列被编入索引，则该列的值为 NULL。</td></tr><tr><td>Packed</td><td>指示关键字如何被压缩。若没有被压缩，值为 NULL。</td></tr><tr><td>Null</td><td>用于显示索引列中是否包含 NULL。若列含有 NULL，该列的值为 YES。若没有，则该列的值为 NO。</td></tr><tr><td>Index_type</td><td>显示索引使用的类型和方法（BTREE、FULLTEXT、HASH、RTREE）。</td></tr><tr><td>Comment</td><td>显示评注。</td></tr></tbody></table><h3 id="【实例-】">【实例 】</h3><p><strong>使用 SHOW INDEX 语句查看表 tb_stu_info2 的索引信息，输入的 SQL 语句和执行结果如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW INDEX FROM tb_stu_info2\G<br>*************************** 1. row ***************************<br>        Table: tb_stu_info2<br>   Non_unique: 0<br>     Key_name: height<br>Seq_in_index: 1<br>  Column_name: height<br>    Collation: A<br>  Cardinality: 0<br>     Sub_part: NULL<br>       Packed: NULL<br>         Null: YES<br>   Index_type: BTREE<br>      Comment:<br>Index_comment:<br>1 row in set (0.03 sec)<br></code></pre></td></tr></table></figure><h1>三、MySQL修改和删除索引</h1><h2 id="基本语法">基本语法</h2><p><strong>当不再需要索引时，可以使用 DROP INDEX 语句或 ALTER TABLE 语句来对索引进行删除。</strong></p><h4 id="1-使用-DROP-INDEX-语句">1) 使用 DROP INDEX 语句</h4><h5 id="语法格式：-10">语法格式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP INDEX &lt;索引名&gt; ON &lt;表名&gt;<br></code></pre></td></tr></table></figure><h4 id="语法说明如下：">语法说明如下：</h4><ul><li><strong><code>&lt;索引名&gt;</code>：要删除的索引名。</strong></li><li><strong><code>&lt;表名&gt;</code>：指定该索引所在的表名。</strong></li></ul><h4 id="2-使用-ALTER-TABLE-语句">2) 使用 ALTER TABLE 语句</h4><p><strong>根据 ALTER TABLE 语句的语法可知，该语句也可以用于删除索引。具体使用方法是将 ALTER TABLE 语句的语法中部分指定为以下子句中的某一项。</strong></p><ul><li><strong>DROP PRIMARY KEY：表示删除表中的主键。一个表只有一个主键，主键也是一个索引。</strong></li><li><strong>DROP INDEX index_name：表示删除名称为 index_name 的索引。</strong></li><li><strong>DROP FOREIGN KEY fk_symbol：表示删除外键。</strong></li></ul><blockquote><p><strong>注意：如果删除的列是索引的组成部分，那么在删除该列时，也会将该列从索引中删除；如果组成索引的所有列都被删除，那么整个索引将被删除。</strong></p></blockquote><h2 id="删除索引">删除索引</h2><h3 id="【实例-1】">【实例 1】</h3><p><strong>删除表 tb_stu_info 中的索引，输入的 SQL 语句和执行结果如下所示。</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">mysql&gt; DROP INDEX height<br>    -&gt; ON tb_stu_info;<br>Query OK, 0 rows affected (0.27 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br>mysql&gt; SHOW CREATE TABLE tb_stu_info\G<br>*************************** 1. row ***************************<br>       Table: tb_stu_info<br>Create Table: CREATE TABLE `tb_stu_info` (<br>  `id` int(11) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  `name` char(45)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span>,<br>  `dept_id` int(11)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span>,<br>  `age` int(11)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span>,<br>  `height` int(11)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span><br>) <span class="hljs-attribute">ENGINE</span>=InnoDB<span class="hljs-built_in"> DEFAULT </span><span class="hljs-attribute">CHARSET</span>=gb2312<br>1 row <span class="hljs-keyword">in</span> <span class="hljs-builtin-name">set</span> (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="【实例-2】">【实例 2】</h3><p><strong>删除表 tb_stu_info2 中名称为 id 的索引，输入的 SQL 语句和执行结果如下所示。</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">mysql&gt; ALTER TABLE tb_stu_info2<br>    -&gt; DROP INDEX height;<br>Query OK, 0 rows affected (0.13 sec)<br>Records: 0  Duplicates: 0  Warnings: 0<br>mysql&gt; SHOW CREATE TABLE tb_stu_info2\G<br>*************************** 1. row ***************************<br>       Table: tb_stu_info2<br>Create Table: CREATE TABLE `tb_stu_info2` (<br>  `id` int(11) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>  `name` char(45)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span>,<br>  `dept_id` int(11)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span>,<br>  `age` int(11)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span>,<br>  `height` int(11)<span class="hljs-built_in"> DEFAULT </span><span class="hljs-literal">NULL</span><br>) <span class="hljs-attribute">ENGINE</span>=InnoDB<span class="hljs-built_in"> DEFAULT </span><span class="hljs-attribute">CHARSET</span>=gb2312<br>1 row <span class="hljs-keyword">in</span> <span class="hljs-builtin-name">set</span> (0.00 sec)<br></code></pre></td></tr></table></figure><h1>四、MySQL索引的设计原则</h1><p><strong>索引的设计可以遵循一些已有的原则，创建索引的时候应尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。本节将介绍一些索引的设计原则。</strong></p><h4 id="1-选择唯一性索引">1. 选择唯一性索引</h4><p><strong>唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。</strong></p><h4 id="2-为经常需要排序、分组和联合操作的字段建立索引">2. 为经常需要排序、分组和联合操作的字段建立索引</h4><p><strong>经常需要 ORDER BY、GROUP BY、DISTINCT 和 UNION 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。</strong></p><h4 id="3-为常作为查询条件的字段建立索引">3. 为常作为查询条件的字段建立索引</h4><p><strong>如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。</strong></p><p><strong>注意：常查询条件的字段不一定是所要选择的列，换句话说，最适合索引的列是出现在 WHERE 子句中的列，或连接子句中指定的列，而不是出现在 SELECT 关键字后的选择列表中的列。</strong></p><h4 id="4-限制索引的数目">4. 限制索引的数目</h4><p><strong>索引的数目不是“越多越好”。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。在修改表的内容时，索引必须进行更新，有时还可能需要重构。因此，索引越多，更新表的时间就越长。</strong></p><p><strong>如果有一个索引很少利用或从不使用，那么会不必要地减缓表的修改速度。此外，MySQL 在生成一个执行计划时，要考虑各个索引，这也要花费时间。创建多余的索引给查询优化带来了更多的工作。索引太多，也可能会使 MySQL 选择不到所要使用的最佳索引。</strong></p><h4 id="5-尽量使用数据量少的索引">**5. **尽量使用数据量少的索引</h4><p><strong>如果索引的值很长，那么查询的速度会受到影响。例如，对一个 CHAR(100) 类型的字段进行全文检索需要的时间肯定要比对 CHAR(10) 类型的字段需要的时间要多。</strong></p><h4 id="6-数据量小的表最好不要使用索引">6. 数据量小的表最好不要使用索引</h4><p><strong>由于数据较小，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。</strong></p><h4 id="7-尽量使用前缀来索引">7. 尽量使用前缀来索引</h4><p><strong>如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。</strong></p><h4 id="8-删除不再使用或者很少使用的索引">**8. **删除不再使用或者很少使用的索引</h4><p><strong>表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。应该定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。</strong></p><h4 id="总结">总结</h4><p><strong>选择索引的最终目的是为了使查询的速度变快，上面给出的原则是最基本的准则，但不能只拘泥于上面的准则。应该在学习和工作中不断的实践，根据应用的实际情况进行分析和判断，选择最合适的索引方式。</strong></p><h1>小练习</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create index index_fruit<br>on fruit(sid);<br><br>show index from fruit;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200611180313902.png" alt="image-20200611180313902"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop index index_fruit on fruit;<br>show index from fruit;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200611180351884.png" alt="image-20200611180351884"></p><h2 id="创建索引的指导原则">创建索引的指导原则</h2><h3 id="按照下列标准选择建立索引的列">按照下列标准选择建立索引的列</h3><p><strong>◆频繁搜索的列</strong><br><strong>◆经常用作查询选择的列</strong><br><strong>◆经常排序、分组的列</strong><br><strong>◆经常用作连接的列(主键/外键)</strong></p><h3 id="请不要使用下面的列创建索引">请不要使用下面的列创建索引</h3><p><strong>◆仅包含几个不同值的列</strong><br><strong>◆表中仅包含几行</strong></p><h2 id="使用索引时注意事项">使用索引时注意事项</h2><ul><li><strong>查询时减少使用*返回全部列，不要返回不需要的列</strong></li><li><strong>索引应该尽量小，在字节数小的列上建立索引</strong></li><li><strong>WHERE子句中有多个条件表达式时，包含索引列的表达式应置3 F其他条件表达式之前</strong></li><li><strong>避免在ORDER BY子句中使用表达式</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql结构化查询语句 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL视图</title>
      <link href="/posts/a0ec.html"/>
      <url>/posts/a0ec.html</url>
      
        <content type="html"><![CDATA[<h2 id="A：什么是视图？视图是干什么用的？">A：什么是视图？视图是干什么用的？</h2><ul><li><strong>视图（view）是一种虚拟存在的表，是一个逻辑表，本身并不包含数据。作为一个select语句保存在数据字典中的。</strong></li><li><strong>通过视图，可以展现基表的部分数据；视图数据来自定义视图的查询中使用的表，使用视图动态生成。</strong></li><li><strong>基表：用来创建视图的表叫做基表base table</strong></li></ul><p><strong>数据库视图的创建是基于<code>SQL SELECT query</code>和<code>JOIN</code>的。视图和表很相似，它也包含行和列，所以可以直接对它进行查询操作。另外大多数的数据库同样允许进行<code>UPADTE</code>操作，但必须满足一定的条件。视图的数据结构如图：</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200614111224870.png" alt="image-20200614111224870"></p><p><strong>我们需要理解，数据库并没有存储视图所关联的数据，存储的只是视图的定义也就是相应的<code>SQL SELECT and JOIN</code>。</strong></p><h2 id="B：为什么要使用视图？">B：为什么要使用视图？</h2><h3 id="（a）因为视图的诸多优点，如下">（a）因为视图的诸多优点，如下</h3><ul><li><p><strong><code>视图可以简化你的复杂查询</code>：视图的定义是基于一个查询声明，这个查询声明可能关联了很多底层表。我们可以使用视图向数据库的使用者或者外部程序隐藏复杂的底层表关系。</strong></p></li><li><p><strong><code>视图可以限制特定用户的数据访问权</code>：有时我们希望隐藏某些表的一些数据对一些特定用户，这时视图可以很好的帮助我们实现这个功能。</strong></p></li><li><p><strong><code>视图可以使用可计算的列</code>：我们知道表的列一般都不支持动态计算，但是视图的列是支持的。假设在有一张<code>order_details</code>表，其中包含<code>product_nums</code>和<code>price_each</code>两列，当我们需要查询<code>order</code>总价时我们就需要查询出结果后在代码中进行计算，如果我们使用视图的话可以在视图中添加一列<code>total_price(product_nums*price_each)</code>。这样就可以直接查询出<code>order</code>的总价。</strong></p></li><li><p><strong><code>视图可以帮助我们兼容旧的系统</code>：假设我们拥有一个数据中心，这个数据中心被很多的程序在使用。如果有一天我们决定重新设计这个数据中心以适应一些新的业务需求，可能需要删除一些旧的表，并且创建一些新的表，但是我们并不希望这些变动影响到那些老的程序。那么我们可以创建一些视图用来适配那些老的程序</strong>。</p></li><li><p><strong><code>简单</code>：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。</strong></p></li><li><p><strong><code>安全</code>：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。</strong></p></li><li><p><strong><code>数据独立</code>：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。</strong></p></li></ul><p><strong>总而言之，使用视图的大部分情况是为了保障数据安全性，提高查询效率。</strong></p><h2 id="C：视图简易分析">C：视图简易分析</h2><p><strong>百度百科定义了什么是视图，但是对缺乏相关知识的人可能还是难以理解或者只有一个比较抽象的概念，笔者举个例子来解释下什么是视图。</strong></p><blockquote><p><strong>朕想要了解皇宫的国库的相关情况，想知道酒窖有什么酒，剩多少，窖藏多少年，于是派最信任的高公公去清点，高公公去国库清点后报给了朕；朕又想知道藏书情况，于是又派高公公去清点并回来报告给朕，又想知道金银珠宝如何，又派高公公清点。。。过一段时间又想知道藏书情况，高公公还得重新再去清点，皇上问一次，高公公就得跑一次路。</strong></p><p><strong>后来皇上觉得高公公不容易，就成立了国库管理部门，小邓子负责酒窖，小卓子负责藏书，而小六子负责金库的清点。。。后来皇上每次想了解国库就直接问话负责人，负责人就按照职责要求进行汇报。</strong></p></blockquote><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200614111016660.png" alt="image-20200614111016660"></p><blockquote><p><strong>安排专人管理后，每次皇上想要了解国库情况，就不必让高公公每次都跑一趟，而是指定的人员按照指定的任务完成指定的汇报工作就可以了。</strong></p></blockquote><p><strong>和数据库相对应，每次进行查询工作，都需要编写查询代码进行查询；而视图的作用就是不必每次都重新编写查询的SQL代码，而是通过视图直接查询即可。因此：</strong></p><p><strong>视图是虚拟表，本身不存储数据，而是按照指定的方式进行查询。</strong></p><h2 id="D：使用场合">D：使用场合</h2><p><strong>权限控制的时候，不希望用户访问表中某些含敏感信息的列，比如salary…</strong></p><p><strong>关键信息来源于多个复杂关联表，可以创建视图提取我们需要的信息，简化操作；</strong></p><h2 id="E：视图相关的MySQL指令">E：视图相关的MySQL指令</h2><table><thead><tr><th>操作指令</th><th>代码</th></tr></thead><tbody><tr><td>创建视图</td><td>CREATE VIEW 视图名(列1，列2…) AS SELECT (列1，列2…) FROM …;</td></tr><tr><td>使用视图</td><td>当成表使用就好</td></tr><tr><td>修改视图</td><td>CREATE OR REPLACE VIEW 视图名 AS SELECT […] FROM […];</td></tr><tr><td>查看数据库已有视图</td><td><code>&gt;SHOW TABLES [like...];</code>（可以使用模糊查找）</td></tr><tr><td>查看视图详情</td><td>DESC 视图名<code>或者</code>SHOW FIELDS FROM 视图名</td></tr><tr><td>视图条件限制</td><td>[WITH CHECK OPTION]</td></tr></tbody></table><h2 id="F：使用视图注意事项：">F：使用视图注意事项：</h2><ul><li><p><strong>视图中可以使用多个表</strong></p></li><li><p><strong>一个视图可以嵌套另一个视图</strong></p></li><li><p><strong>对视图数据进行添加、更新和删除操作直接影响所引用表中的数据</strong></p></li><li><p><strong>当视图数据来自多个表时，不允许添加和删除数据</strong></p></li><li><p><strong>创建视图需要足够的访问权限。</strong></p></li><li><p><strong>创建视图的数目没有限制。</strong></p></li><li><p><strong>视图不能索引，也不能有关联的触发器、默认值或规则。</strong></p></li><li><p><strong>视图可以和表一起使用。</strong></p></li><li><p><strong>视图不包含数据，所以每次使用视图时，都必须执行查询中所需的任何一个检索操作。如果用多个连接和过滤条件创建了复杂的视图或嵌套了视图，可能会发现系统运行性能下降得十分严重。因此，在部署大量视图应用时，应该进行系统测试。</strong></p></li></ul><blockquote><p><strong>提示：ORDER BY 子句可以用在视图中，但若该视图检索数据的 SELECT 语句中也含有 ORDER BY 子句，则该视图中的 ORDER BY 子句将被覆盖。</strong></p></blockquote><h1>一、MySql创建视图</h1><p><strong>创建视图与创建表语法类似，不同的是创建视图是从一条查询语句创建的。视图创建后，可以像一张表一样使用，但只能用于数据查询，如：可以在一个查询中使用、可以在存储过程中、可以在另一个视图中使用。MySql创建视图语法如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE VIEW 视图名 AS SELECT 查询语句;<br></code></pre></td></tr></table></figure><h3 id="创建表">创建表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table tb_students_info(<br>true&#96;id&#96; int(4) not null comment &#39;id&#39; primary key auto_increment,<br>true&#96;name&#96; varchar(50) not null comment &#39;name&#39;,<br>true&#96;dept_id&#96; varchar(20) not null comment &#39;dept_id&#39;,<br>true&#96;age&#96; int(4) unsigned comment &#39;age&#39;,<br>true&#96;sex&#96; varchar(50) comment &#39;sex&#39;,<br>true&#96;height&#96; int(4) unsigned comment &#39;height&#39;,<br>true&#96;login_date&#96; datetime comment &#39;login_date&#39;<br>)charset&#x3D;&#39;utf8&#39; comment&#x3D;&#39;tb_students_info&#39;;<br><br>select * from tb_students_info;<br></code></pre></td></tr></table></figure><h3 id="插入数据">插入数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into tb_students_info(id,name,dept_id,age,sex,height,login_date)<br>values(1,&#39;Dany&#39;,&#39;1&#39;,&#39;25&#39;,&#39;F&#39;,&#39;160&#39;,&#39;2015-09-10&#39;),<br>(2,&#39;Green&#39;,&#39;3&#39;,&#39;23&#39;,&#39;F&#39;,&#39;158&#39;,&#39;2016-10-22&#39;),<br>(3,&#39;Henry&#39;,&#39;2&#39;,&#39;23&#39;,&#39;M&#39;,&#39;185&#39;,&#39;2015-05-31&#39;),<br>(4,&#39;Jane&#39;,&#39;1&#39;,&#39;22&#39;,&#39;F&#39;,&#39;162&#39;,&#39;2016-12-20&#39;),<br>(5,&#39;Jim&#39;,&#39;1&#39;,&#39;24&#39;,&#39;M&#39;,&#39;175&#39;,&#39;2016-01-15&#39;),<br>(6,&#39;John&#39;,&#39;2&#39;,&#39;21&#39;,&#39;M&#39;,&#39;172&#39;,&#39;2015-11-11&#39;),<br>(7,&#39;Lily&#39;,&#39;6&#39;,&#39;22&#39;,&#39;F&#39;,&#39;165&#39;,&#39;2016-02-26&#39;),<br>(8,&#39;Susan&#39;,&#39;4&#39;,&#39;23&#39;,&#39;F&#39;,&#39;170&#39;,&#39;2015-10-01&#39;),<br>(9,&#39;Thomas&#39;,&#39;3&#39;,&#39;22&#39;,&#39;M&#39;,&#39;178&#39;,&#39;2016-06-07&#39;),<br>(10,&#39;Tom&#39;,&#39;4&#39;,&#39;23&#39;,&#39;M&#39;,&#39;165&#39;,&#39;2016-08-05&#39;);<br></code></pre></td></tr></table></figure><h3 id="查看一下">查看一下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from tb_students_info;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200614132739829.png" alt="image-20200614132739829"></p><h2 id="1、创建基于单表的视图">1、创建基于单表的视图</h2><p><strong>MySQL 可以在单个数据表上创建视图。</strong></p><p><strong>查看 test_db 数据库中的 tb_students_info 表的数据，如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM tb_students_info;<br>+----+--------+---------+------+------+--------+---------------------+<br>| id | name   | dept_id | age  | sex  | height | login_date          |<br>+----+--------+---------+------+------+--------+---------------------+<br>|  1 | Dany   | 1       |   25 | F    |    160 | 2015-09-10 00:00:00 |<br>|  2 | Green  | 3       |   23 | F    |    158 | 2016-10-22 00:00:00 |<br>|  3 | Henry  | 2       |   23 | M    |    185 | 2015-05-31 00:00:00 |<br>|  4 | Jane   | 1       |   22 | F    |    162 | 2016-12-20 00:00:00 |<br>|  5 | Jim    | 1       |   24 | M    |    175 | 2016-01-15 00:00:00 |<br>|  6 | John   | 2       |   21 | M    |    172 | 2015-11-11 00:00:00 |<br>|  7 | Lily   | 6       |   22 | F    |    165 | 2016-02-26 00:00:00 |<br>|  8 | Susan  | 4       |   23 | F    |    170 | 2015-10-01 00:00:00 |<br>|  9 | Thomas | 3       |   22 | M    |    178 | 2016-06-07 00:00:00 |<br>| 10 | Tom    | 4       |   23 | M    |    165 | 2016-08-05 00:00:00 |<br>+----+--------+---------+------+------+--------+---------------------+<br>10 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="【实例-1】">【实例 1】</h3><p><strong>在 tb_students_info 表上创建一个名为 view_students_info 的视图，输入的 SQL 语句和执行结果如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE VIEW view_students_info<br>    -&gt; AS SELECT * FROM tb_students_info;<br>Query OK, 0 rows affected (0.00 sec)<br><br>mysql&gt; SELECT * FROM view_students_info;<br>+----+--------+---------+------+------+--------+---------------------+<br>| id | name   | dept_id | age  | sex  | height | login_date          |<br>+----+--------+---------+------+------+--------+---------------------+<br>|  1 | Dany   | 1       |   25 | F    |    160 | 2015-09-10 00:00:00 |<br>|  2 | Green  | 3       |   23 | F    |    158 | 2016-10-22 00:00:00 |<br>|  3 | Henry  | 2       |   23 | M    |    185 | 2015-05-31 00:00:00 |<br>|  4 | Jane   | 1       |   22 | F    |    162 | 2016-12-20 00:00:00 |<br>|  5 | Jim    | 1       |   24 | M    |    175 | 2016-01-15 00:00:00 |<br>|  6 | John   | 2       |   21 | M    |    172 | 2015-11-11 00:00:00 |<br>|  7 | Lily   | 6       |   22 | F    |    165 | 2016-02-26 00:00:00 |<br>|  8 | Susan  | 4       |   23 | F    |    170 | 2015-10-01 00:00:00 |<br>|  9 | Thomas | 3       |   22 | M    |    178 | 2016-06-07 00:00:00 |<br>| 10 | Tom    | 4       |   23 | M    |    165 | 2016-08-05 00:00:00 |<br>+----+--------+---------+------+------+--------+---------------------+<br>10 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>默认情况下，创建的视图和基本表的字段是一样的，也可以通过指定视图字段的名称来创建视图。</strong></p><h3 id="【实例-2】">【实例 2】</h3><p><strong>在 tb_students_info 表上创建一个名为 v_students_info 的视图，输入的 SQL 语句和执行结果如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE VIEW v_students_info<br>    -&gt; (s_id,s_name,d_id,s_age,s_sex,s_height,s_date)<br>    -&gt; AS SELECT id,name,dept_id,age,sex,height,login_date<br>    -&gt; FROM tb_students_info;<br>Query OK, 0 rows affected (0.06 sec)<br><br>mysql&gt; SELECT * FROM v_students_info;<br>+------+--------+------+-------+-------+----------+---------------------+<br>| s_id | s_name | d_id | s_age | s_sex | s_height | s_date              |<br>+------+--------+------+-------+-------+----------+---------------------+<br>|    1 | Dany   | 1    |    25 | F     |      160 | 2015-09-10 00:00:00 |<br>|    2 | Green  | 3    |    23 | F     |      158 | 2016-10-22 00:00:00 |<br>|    3 | Henry  | 2    |    23 | M     |      185 | 2015-05-31 00:00:00 |<br>|    4 | Jane   | 1    |    22 | F     |      162 | 2016-12-20 00:00:00 |<br>|    5 | Jim    | 1    |    24 | M     |      175 | 2016-01-15 00:00:00 |<br>|    6 | John   | 2    |    21 | M     |      172 | 2015-11-11 00:00:00 |<br>|    7 | Lily   | 6    |    22 | F     |      165 | 2016-02-26 00:00:00 |<br>|    8 | Susan  | 4    |    23 | F     |      170 | 2015-10-01 00:00:00 |<br>|    9 | Thomas | 3    |    22 | M     |      178 | 2016-06-07 00:00:00 |<br>|   10 | Tom    | 4    |    23 | M     |      165 | 2016-08-05 00:00:00 |<br>+------+--------+------+-------+-------+----------+---------------------+<br>10 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>可以看到，view_students_info 和 v_students_info 两个视图中的字段名称不同，但是数据却相同。因此，在使用视图时，可能用户不需要了解基本表的结构，更接触不到实际表中的数据，从而保证了数据库的安全。</strong></p><h2 id="2、创建基于多表的视图">2、创建基于多表的视图</h2><p><strong>MySQL 中也可以在两个以上的表中创建视图，使用 CREATE VIEW 语句创建。</strong></p><h3 id="【实例-3】">【实例 3】</h3><p><strong>在表 tb_student_info 和表 tb_departments 上创建视图 v_students_info，输入的 SQL 语句和执行结果如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE VIEW v_students_info<br>    -&gt; (s_id,s_name,d_id,s_age,s_sex,s_height,s_date)<br>    -&gt; AS SELECT id,name,dept_id,age,sex,height,login_date<br>    -&gt; FROM tb_students_info;<br>Query OK, 0 rows affected (0.06 sec)<br>mysql&gt; SELECT * FROM v_students_info;<br>+------+--------+------+-------+-------+----------+------------+<br>| s_id | s_name | d_id | s_age | s_sex | s_height | s_date     |<br>+------+--------+------+-------+-------+----------+------------+<br>|    1 | Dany   |    1 |    24 | F     |      160 | 2015-09-10 |<br>|    2 | Green  |    3 |    23 | F     |      158 | 2016-10-22 |<br>|    3 | Henry  |    2 |    23 | M     |      185 | 2015-05-31 |<br>|    4 | Jane   |    1 |    22 | F     |      162 | 2016-12-20 |<br>|    5 | Jim    |    1 |    24 | M     |      175 | 2016-01-15 |<br>|    6 | John   |    2 |    21 | M     |      172 | 2015-11-11 |<br>|    7 | Lily   |    6 |    22 | F     |      165 | 2016-02-26 |<br>|    8 | Susan  |    4 |    23 | F     |      170 | 2015-10-01 |<br>|    9 | Thomas |    3 |    22 | M     |      178 | 2016-06-07 |<br>|   10 | Tom    |    4 |    23 | M     |      165 | 2016-08-05 |<br>+------+--------+------+-------+-------+----------+------------+<br>10 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><p><strong>通过这个视图可以很好地保护基本表中的数据。视图中包含 s_id、s_name 和 dept_name，s_id 字段对应 tb_students_info 表中的 id 字段，s_name 字段对应 tb_students_info 表中的 name 字段，dept_name 字段对应 tb_departments 表中的 dept_name 字段。</strong></p><h1>二、查询视图</h1><p><strong>视图一经定义之后，就可以如同查询数据表一样，使用 SELECT 语句查询视图中的数据，语法和查询基础表的数据一样。</strong></p><h4 id="视图用于查询主要应用在以下几个方面：">视图用于查询主要应用在以下几个方面：</h4><ul><li><strong>使用视图重新格式化检索出的数据。</strong></li><li><strong>使用视图简化复杂的表连接。</strong></li><li><strong>使用视图过滤数据。</strong></li></ul><h4 id="DESCRIBE-可以用来查看视图，语法如下：">DESCRIBE 可以用来查看视图，语法如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DESCRIBE 视图名；<br></code></pre></td></tr></table></figure><h3 id="【实例-4】">【实例 4】</h3><p><strong>通过 DESCRIBE 语句查看视图 v_students_info 的定义，输入的 SQL 语句和执行结果如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; DESCRIBE v_students_info;<br>+----------+---------------+------+-----+------------+-------+<br>| Field    | Type          | Null | Key | Default    | Extra |<br>+----------+---------------+------+-----+------------+-------+<br>| s_id     | int(11)       | NO   |     | 0          |       |<br>| s_name   | varchar(45)   | YES  |     | NULL       |       |<br>| d_id     | int(11)       | YES  |     | NULL       |       |<br>| s_age    | int(11)       | YES  |     | NULL       |       |<br>| s_sex    | enum(&#39;M&#39;,&#39;F&#39;) | YES  |     | NULL       |       |<br>| s_height | int(11)       | YES  |     | NULL       |       |<br>| s_date   | date          | YES  |     | 2016-10-22 |       |<br>+----------+---------------+------+-----+------------+-------+<br>7 rows in set (0.04 sec)<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">注意：DESCRIBE 一般情况下可以简写成 DESC，输入这个命令的执行结果和输入 DESCRIBE 是一样的。<br></code></pre></td></tr></table></figure></blockquote><h2 id="1、查看视图的字段信息">1、查看视图的字段信息</h2><p><strong>查看视图的字段信息与查看数据表的字段信息一样，都是使用 DESCRIBE 关键字来查看的。具体语法如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DESCRIBE 视图名;<br></code></pre></td></tr></table></figure><p><strong>或简写成：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DESC 视图名;<br></code></pre></td></tr></table></figure><h3 id="示例-1">示例 1</h3><p><strong>下面创建学生信息表 studentinfo 的一个视图，用于查询学生姓名和考试分数。</strong></p><p><strong>创建学生信息表 studentinfo 的 SQL 语句和运行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE TABLE studentinfo(<br>    -&gt; ID INT(11) PRIMARY KEY,<br>    -&gt; NAME VARCHAR(20),<br>    -&gt; SCORE DECIMAL(4,2),<br>    -&gt; SUBJECT VARCHAR(20),<br>    -&gt; TEACHER VARCHAR(20));<br>Query OK, 0 rows affected (0.10 sec)<br></code></pre></td></tr></table></figure><p><strong>创建查询学生姓名和分数的视图语句如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE VIEW v_studentinfo AS SELECT name,score FROM studentinfo;<br>Query OK, 0 rows affected (0.04 sec)<br></code></pre></td></tr></table></figure><p><strong>通过 DESCRIBE 语句查看视图 v_studentsinfo 中的字段信息，SQL 语句和运行结果如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; DESCRIBE v_studentinfo;<br>+-------+--------------+------+-----+---------+-------+<br>| Field | Type         | Null | Key | Default | Extra |<br>+-------+--------------+------+-----+---------+-------+<br>| name  | varchar(20)  | YES  |     | NULL    |       |<br>| score | decimal(4,2) | YES  |     | NULL    |       |<br>+-------+--------------+------+-----+---------+-------+<br>2 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><p><em><strong>注意：使用 DESC 的执行结果和使用 DESCRIBE 是一样的。</strong></em></p><p><strong>由运行结果可以看出，查看视图的字段内容与查看表的字段内容显示的格式是相同的。因此，更能说明视图实际上也是一张数据表了，不同的是，视图中的数据都来自于数据库中已经存在的表。</strong></p><h2 id="查看视图的详细信息">查看视图的详细信息</h2><p><strong>在 MySQL 中，SHOW CREATE VIEW 语句可以查看视图的详细定义。其语法如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE VIEW 视图名;<br></code></pre></td></tr></table></figure><p><strong>通过上面的语句，还可以查看创建视图的语句。创建视图的语句可以作为修改或者重新创建视图的参考，方便用户操作。</strong></p><h3 id="示例-2">示例 2</h3><p><strong>使用 SHOW CREATE VIEW 查看视图，SQL 语句和运行结果如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt;  SHOW CREATE VIEW v_studentinfo \G<br>*************************** 1. row ***************************<br>                View: v_studentinfo<br>         Create View: CREATE ALGORITHM&#x3D;UNDEFINED DEFINER&#x3D;&#96;root&#96;@&#96;localhost&#96; SQL SECURITY DEFINER VIEW &#96;v_studentinfo&#96; AS select &#96;studentinfo&#96;.&#96;NAME&#96; AS &#96;name&#96;,&#96;studentinfo&#96;.&#96;SCORE&#96; AS &#96;score&#96; from &#96;studentinfo&#96;<br>character_set_client: gbk<br>collation_connection: gbk_chinese_ci<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>上述 SQL 语句以<code>\G</code>结尾，这样能使显示结果格式化。如果不使用<code>\G</code>，显示的结果会比较混乱，如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; DESCRIBE v_studentinfo;<br>+-------+--------------+------+-----+---------+-------+<br>| Field | Type         | Null | Key | Default | Extra |<br>+-------+--------------+------+-----+---------+-------+<br>| name  | varchar(20)  | YES  |     | NULL    |       |<br>| score | decimal(4,2) | YES  |     | NULL    |       |<br>+-------+--------------+------+-----+---------+-------+<br>2 rows in set (0.01 sec)<br><br>mysql&gt;  SHOW CREATE VIEW v_studentinfo;<br>+---------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+<br>| View          | Create View                                                                                                                                                                                  | character_set_client | collation_connection |<br>+---------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+<br>| v_studentinfo | CREATE ALGORITHM&#x3D;UNDEFINED DEFINER&#x3D;&#96;root&#96;@&#96;localhost&#96; SQL SECURITY DEFINER VIEW &#96;v_studentinfo&#96; AS select &#96;studentinfo&#96;.&#96;NAME&#96; AS &#96;name&#96;,&#96;studentinfo&#96;.&#96;SCORE&#96; AS &#96;score&#96; from &#96;studentinfo&#96; | gbk                  | gbk_chinese_ci       |<br>+---------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+<br>1 row in set (0.01 sec)<br></code></pre></td></tr></table></figure><h1>二、 MySql视图修改</h1><h2 id="1、基本语法">1、基本语法</h2><p><strong>可以使用 ALTER VIEW 语句来对已有的视图进行修改。</strong></p><p><strong>语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER VIEW 视图名 AS SELECT 查询语句;<br></code></pre></td></tr></table></figure><h4 id="语法说明如下：">语法说明如下：</h4><ul><li><strong><code>&lt;视图名&gt;</code>：指定视图的名称。该名称在数据库中必须是唯一的，不能与其他表或视图同名。</strong></li><li><strong><code>&lt;SELECT 语句&gt;</code>：指定创建视图的 SELECT 语句，可用于查询多个基础表或源视图。</strong></li></ul><p><strong>需要注意的是，对于 ALTER VIEW 语句的使用，需要用户具有针对视图的 CREATE VIEW 和 DROP 权限，以及由 SELECT 语句选择的每一列上的某些权限。</strong></p><p><strong>修改视图的定义，除了可以通过 ALTER VIEW 外，也可以使用 DROP VIEW 语句先删除视图，再使用 CREATE VIEW 语句来实现。</strong></p><h2 id="2、修改视图内容">2、修改视图内容</h2><p><strong>视图是一个虚拟表，实际的数据来自于基本表，所以通过插入、修改和删除操作更新视图中的数据，实质上是在更新视图所引用的基本表的数据。</strong></p><blockquote><p><strong>注意：对视图的修改就是对基本表的修改，因此在修改时，要满足基本表的数据定义。</strong></p></blockquote><p><strong>某些视图是可更新的。也就是说，可以使用 UPDATE、DELETE 或 INSERT 等语句更新基本表的内容。对于可更新的视图，视图中的行和基本表的行之间必须具有一对一的关系。</strong></p><p><strong>还有一些特定的其他结构，这些结构会使得视图不可更新。更具体地讲，如果视图包含以下结构中的任何一种，它就是不可更新的：</strong></p><ul><li><strong>聚合函数 SUM()、MIN()、MAX()、COUNT() 等。</strong></li><li><strong>DISTINCT 关键字。</strong></li><li><strong>GROUP BY 子句。</strong></li><li><strong>HAVING 子句。</strong></li><li><strong>UNION 或 UNION ALL 运算符。</strong></li><li><strong>位于选择列表中的子查询。</strong></li><li><strong>FROM 子句中的不可更新视图或包含多个表。</strong></li><li><strong>WHERE 子句中的子查询，引用 FROM 子句中的表。</strong></li><li><strong>ALGORITHM 选项为 TEMPTABLE（使用临时表总会使视图成为不可更新的）的时候。</strong></li></ul><h3 id="【实例-1】-2">【实例 1】</h3><p><strong>使用 ALTER 语句修改视图 view_students_info，输入的 SQL 语句和执行结果如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; ALTER VIEW view_students_info<br>    -&gt; AS SELECT id,name,age<br>    -&gt; FROM tb_students_info;<br>Query OK, 0 rows affected (0.07 sec)<br>mysql&gt; DESC view_students_info;<br>+-------+-------------+------+-----+---------+-------+<br>| Field | Type        | Null | Key | Default | Extra |<br>+-------+-------------+------+-----+---------+-------+<br>| id    | int(11)     | NO   |     | 0       |       |<br>| name  | varchar(45) | YES  |     | NULL    |       |<br>| age   | int(11)     | YES  |     | NULL    |       |<br>+-------+-------------+------+-----+---------+-------+<br>3 rows in set (0.03 sec)<br></code></pre></td></tr></table></figure><p><strong>用户可以通过视图来插入、更新、删除表中的数据，因为视图是一个虚拟的表，没有数据。通过视图更新时转到基本表上进行更新，如果对视图增加或删除记录，实际上是对基本表增加或删除记录。</strong></p><p><strong>查看视图 view_students_info 的数据内容，如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM view_students_info;<br>+----+--------+------+<br>| id | name   | age  |<br>+----+--------+------+<br>|  1 | Dany   |   24 |<br>|  2 | Green  |   23 |<br>|  3 | Henry  |   23 |<br>|  4 | Jane   |   22 |<br>|  5 | Jim    |   24 |<br>|  6 | John   |   21 |<br>|  7 | Lily   |   22 |<br>|  8 | Susan  |   23 |<br>|  9 | Thomas |   22 |<br>| 10 | Tom    |   23 |<br>+----+--------+------+<br>10 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="【实例-2】-2">【实例 2】</h3><p><strong>使用 UPDATE 语句更新视图 view_students_info，输入的 SQL 语句和执行结果如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; UPDATE view_students_info<br>    -&gt; SET age&#x3D;25 WHERE id&#x3D;1;<br>Query OK, 0 rows affected (0.24 sec)<br>Rows matched: 1  Changed: 0  Warnings: 0<br>mysql&gt; SELECT * FROM view_students_info;<br>+----+--------+------+<br>| id | name   | age  |<br>+----+--------+------+<br>|  1 | Dany   |   25 |<br>|  2 | Green  |   23 |<br>|  3 | Henry  |   23 |<br>|  4 | Jane   |   22 |<br>|  5 | Jim    |   24 |<br>|  6 | John   |   21 |<br>|  7 | Lily   |   22 |<br>|  8 | Susan  |   23 |<br>|  9 | Thomas |   22 |<br>| 10 | Tom    |   23 |<br>+----+--------+------+<br>10 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>查看基本表 tb_students_info 和视图 v_students_info 的内容，如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT * FROM tb_students_info;<br>+----+--------+---------+------+------+--------+------------+<br>| id | name   | dept_id | age  | sex  | height | login_date |<br>+----+--------+---------+------+------+--------+------------+<br>|  1 | Dany   |       1 |   25 | F    |    160 | 2015-09-10 |<br>|  2 | Green  |       3 |   23 | F    |    158 | 2016-10-22 |<br>|  3 | Henry  |       2 |   23 | M    |    185 | 2015-05-31 |<br>|  4 | Jane   |       1 |   22 | F    |    162 | 2016-12-20 |<br>|  5 | Jim    |       1 |   24 | M    |    175 | 2016-01-15 |<br>|  6 | John   |       2 |   21 | M    |    172 | 2015-11-11 |<br>|  7 | Lily   |       6 |   22 | F    |    165 | 2016-02-26 |<br>|  8 | Susan  |       4 |   23 | F    |    170 | 2015-10-01 |<br>|  9 | Thomas |       3 |   22 | M    |    178 | 2016-06-07 |<br>| 10 | Tom    |       4 |   23 | M    |    165 | 2016-08-05 |<br>+----+--------+---------+------+------+--------+------------+<br>10 rows in set (0.00 sec)<br><br>mysql&gt; SELECT * FROM v_students_info;<br>+------+--------+------+-------+-------+----------+------------+<br>| s_id | s_name | d_id | s_age | s_sex | s_height | s_date     |<br>+------+--------+------+-------+-------+----------+------------+<br>|    1 | Dany   |    1 |    25 | F     |      160 | 2015-09-10 |<br>|    2 | Green  |    3 |    23 | F     |      158 | 2016-10-22 |<br>|    3 | Henry  |    2 |    23 | M     |      185 | 2015-05-31 |<br>|    4 | Jane   |    1 |    22 | F     |      162 | 2016-12-20 |<br>|    5 | Jim    |    1 |    24 | M     |      175 | 2016-01-15 |<br>|    6 | John   |    2 |    21 | M     |      172 | 2015-11-11 |<br>|    7 | Lily   |    6 |    22 | F     |      165 | 2016-02-26 |<br>|    8 | Susan  |    4 |    23 | F     |      170 | 2015-10-01 |<br>|    9 | Thomas |    3 |    22 | M     |      178 | 2016-06-07 |<br>|   10 | Tom    |    4 |    23 | M     |      165 | 2016-08-05 |<br>+------+--------+------+-------+-------+----------+------------+<br>10 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="3、修改视图名称">3、修改视图名称</h2><p><strong>修改视图的名称可以先将视图删除，然后按照相同的定义语句进行视图的创建，并命名为新的视图名称。</strong></p><h1>三、MySql视图删除</h1><h2 id="1、基本语法-2">1、基本语法</h2><p><strong>可以使用 DROP VIEW 语句来删除视图。</strong></p><p><strong>语法格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP VIEW &lt;视图名1&gt; [ , &lt;视图名2&gt; …]<br></code></pre></td></tr></table></figure><p><strong>其中：<code>&lt;视图名&gt;</code>指定要删除的视图名。DROP VIEW 语句可以一次删除多个视图，但是必须在每个视图上拥有 DROP 权限。</strong></p><h2 id="2、删除视图">2、删除视图</h2><p><strong>【实例】删除 v_students_info 视图，输入的 SQL 语句和执行过程如下所示。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; DROP VIEW IF EXISTS v_students_info;<br>Query OK, 0 rows affected (0.00 sec)<br>mysql&gt; SHOW CREATE VIEW v_students_info;<br>ERROR 1146 (42S02): Table &#39;test_db.v_students_info&#39; doesn&#39;t exist<br></code></pre></td></tr></table></figure><p><em><strong>可以看到，v_students_info 视图已不存在，将其成功删除。</strong></em></p><h1>小练习</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#删除视图<br>drop view if EXISTS view_student_for_teacher;<br><br>#创建视图<br>create view view_student_for_teacher as<br>select studentNo,studentName,sex,gradeName,phone<br>from student s<br>join grade g<br>on s.gradeId &#x3D; g.gradeID;<br><br>#查看视图<br>select * from  view_student_for_teacher;<br></code></pre></td></tr></table></figure><p>![image-20200611173158789](G:\四期\数据库\mysql文档\06 视图.assets\image-20200611173158789.png)</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd">#查看数据库的视图<br>use information_schema;<br>SELECT * from views\G;<br>select * from views where table_schema ='myschool'\G;<br></code></pre></td></tr></table></figure><h1>视图实例1-创建视图及查询数据操作</h1><p><strong>现有三张表：用户(user)、课程(course)、用户课程中间表(user_course)，表结构及数据如下：</strong></p><p><strong>表定义：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- ----------------------------<br>-- Table structure for &#96;course&#96;<br>-- ----------------------------<br>DROP TABLE IF EXISTS &#96;course&#96;;<br>CREATE TABLE &#96;course&#96; (<br>  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT,<br>  &#96;name&#96; varchar(200) NOT NULL,<br>  &#96;description&#96; varchar(500) NOT NULL,<br>  PRIMARY KEY (&#96;id&#96;)<br>) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8;<br><br>-- ----------------------------<br>-- Records of course<br>-- ----------------------------<br>INSERT INTO &#96;course&#96; VALUES (&#39;1&#39;, &#39;JAVA&#39;, &#39;JAVA课程&#39;);<br>INSERT INTO &#96;course&#96; VALUES (&#39;2&#39;, &#39;C++&#39;, &#39;C++课程&#39;);<br>INSERT INTO &#96;course&#96; VALUES (&#39;3&#39;, &#39;C语言&#39;, &#39;C语言课程&#39;);<br><br>-- ----------------------------<br>-- Table structure for &#96;user&#96;<br>-- ----------------------------<br>DROP TABLE IF EXISTS &#96;user&#96;;<br>CREATE TABLE &#96;user&#96; (<br>  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT,<br>  &#96;account&#96; varchar(255) NOT NULL,<br>  &#96;name&#96; varchar(255) NOT NULL,<br>  &#96;address&#96; varchar(255) DEFAULT NULL,<br>  &#96;others&#96; varchar(200) DEFAULT NULL,<br>  &#96;others2&#96; varchar(200) DEFAULT NULL,<br>  PRIMARY KEY (&#96;id&#96;)<br>) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8;<br><br>-- ----------------------------<br>-- Records of user<br>-- ----------------------------<br>INSERT INTO &#96;user&#96; VALUES (&#39;1&#39;, &#39;user1&#39;, &#39;小陈&#39;, &#39;美国&#39;, &#39;1&#39;, &#39;1&#39;);<br>INSERT INTO &#96;user&#96; VALUES (&#39;2&#39;, &#39;user2&#39;, &#39;小张&#39;, &#39;日本&#39;, &#39;2&#39;, &#39;2&#39;);<br>INSERT INTO &#96;user&#96; VALUES (&#39;3&#39;, &#39;user3&#39;, &#39;小王&#39;, &#39;中国&#39;, &#39;3&#39;, &#39;3&#39;);<br><br>-- ----------------------------<br>-- Table structure for &#96;user_course&#96;<br>-- ----------------------------<br>DROP TABLE IF EXISTS &#96;user_course&#96;;<br>CREATE TABLE &#96;user_course&#96; (<br>  &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT,<br>  &#96;userid&#96; bigint(20) NOT NULL,<br>  &#96;courseid&#96; bigint(20) NOT NULL,<br>  PRIMARY KEY (&#96;id&#96;)<br>) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;7 DEFAULT CHARSET&#x3D;utf8;<br><br>-- ----------------------------<br>-- Records of user_course<br>-- ----------------------------<br>INSERT INTO &#96;user_course&#96; VALUES (&#39;1&#39;, &#39;1&#39;, &#39;2&#39;);<br>INSERT INTO &#96;user_course&#96; VALUES (&#39;2&#39;, &#39;1&#39;, &#39;3&#39;);<br>INSERT INTO &#96;user_course&#96; VALUES (&#39;3&#39;, &#39;2&#39;, &#39;1&#39;);<br>INSERT INTO &#96;user_course&#96; VALUES (&#39;4&#39;, &#39;2&#39;, &#39;2&#39;);<br>INSERT INTO &#96;user_course&#96; VALUES (&#39;5&#39;, &#39;2&#39;, &#39;3&#39;);<br>INSERT INTO &#96;user_course&#96; VALUES (&#39;6&#39;, &#39;3&#39;, &#39;2&#39;);<br></code></pre></td></tr></table></figure><p><strong>这时，当我们想要查询小张上的所以课程相关信息的时候，需要这样写一条长长的SQL语句，如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT<br>    &#96;uc&#96;.&#96;id&#96; AS &#96;id&#96;,<br>    &#96;u&#96;.&#96;name&#96; AS &#96;username&#96;,<br>    &#96;c&#96;.&#96;name&#96; AS &#96;coursename&#96;<br>FROM<br>    &#96;user&#96; &#96;u&#96;<br>LEFT JOIN &#96;user_course&#96; &#96;uc&#96; ON ((&#96;u&#96;.&#96;id&#96; &#x3D; &#96;uc&#96;.&#96;userid&#96;))<br>LEFT JOIN &#96;course&#96; &#96;c&#96; ON ((&#96;uc&#96;.&#96;courseid&#96; &#x3D; &#96;c&#96;.&#96;id&#96;))<br>WHERE<br>    u.&#96;name&#96; &#x3D; &#39;小张&#39;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200614140858259.png" alt="image-20200614140858259"></p><p><strong>但是我们可以通过视图简化操作，例如我们创建视图view_user_course如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- ----------------------------<br>-- View structure for &#96;view_user_course&#96;<br>-- ----------------------------<br>DROP VIEW<br>IF EXISTS &#96;view_user_course&#96;;<br><br>CREATE ALGORITHM &#x3D; UNDEFINED <br>DEFINER &#x3D; &#96;root&#96;@&#96;localhost&#96; SQL SECURITY DEFINER <br>VIEW &#96;view_user_course&#96; AS (<br>    SELECT<br>        &#96;uc&#96;.&#96;id&#96; AS &#96;id&#96;,<br>        &#96;u&#96;.&#96;name&#96; AS &#96;username&#96;,<br>        &#96;c&#96;.&#96;name&#96; AS &#96;coursename&#96;<br>    FROM<br>        (<br>            (<br>                &#96;user&#96; &#96;u&#96;<br>                LEFT JOIN &#96;user_course&#96; &#96;uc&#96; ON ((&#96;u&#96;.&#96;id&#96; &#x3D; &#96;uc&#96;.&#96;userid&#96;))<br>            )<br>            LEFT JOIN &#96;course&#96; &#96;c&#96; ON ((&#96;uc&#96;.&#96;courseid&#96; &#x3D; &#96;c&#96;.&#96;id&#96;))<br>        )<br>);<br></code></pre></td></tr></table></figure><p><strong>几点说明（MySQL中的视图在标准SQL的基础之上做了扩展）：</strong></p><p><strong>ALGORITHM=UNDEFINED：指定视图的处理算法；</strong></p><p><strong>DEFINER=<code>root</code>@<code>localhost</code>：指定视图创建者；</strong></p><p><strong>SQL SECURITY DEFINER：指定视图查询数据时的安全验证方式；</strong></p><h4 id="创建好视图之后，我们可以直接用以下SQL语句在视图上查询小张上的所以课程相关信息，同样可以得到所需结果："><strong>创建好视图之后，我们可以直接用以下SQL语句在视图上查询小张上的所以课程相关信息，同样可以得到所需结果：</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT<br>    vuc.username,<br>    vuc.coursename<br>FROM<br>    view_user_course vuc<br>WHERE<br>     vuc.username &#x3D; &#39;小张&#39;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200614141009884.png" alt="image-20200614141009884"></p><h1>视图实例2-增删改数据操作</h1><p><strong>继续，我们可以尝试在视图view_user_course上做增删改数据操作，如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update view_user_course set username&#x3D;&#39;test&#39;,coursename&#x3D;&#39;JAVASCRIPT&#39; where id&#x3D;3<br></code></pre></td></tr></table></figure><p>遗憾的是操作失败，提示错误信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[SQL] update view_user_course set username&#x3D;&#39;test&#39;,coursename&#x3D;&#39;JAVASCRIPT&#39; where id&#x3D;3<br><br>[Err] 1393 - Can not modify more than one base table through a join view &#39;demo.view_user_course&#39;<br></code></pre></td></tr></table></figure><p><strong>因为不能在一张由多张关联表连接而成的视图上做同时修改两张表的操作；</strong></p><p><strong>那么哪些操作可以在视图上进行呢？</strong></p><p><strong><code>视图与表是一对一关系情况</code>：如果没有其它约束（如视图中没有的字段，在基本表中是必填字段情况），是可以进行增删改数据操作；</strong></p><h4 id="如我们创建用户关键信息视图view-user-keyinfo，如下："><strong>如我们创建用户关键信息视图view_user_keyinfo，如下：</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- ----------------------------<br>-- View structure for &#96;view_user_keyinfo&#96;<br>-- ----------------------------<br>DROP VIEW<br>IF EXISTS &#96;view_user_keyinfo&#96;;<br><br>CREATE ALGORITHM &#x3D; UNDEFINED DEFINER &#x3D; &#96;root&#96;@&#96;localhost&#96; SQL SECURITY DEFINER VIEW &#96;view_user_keyinfo&#96; AS SELECT<br>    &#96;u&#96;.&#96;id&#96; AS &#96;id&#96;,<br>    &#96;u&#96;.&#96;account&#96; AS &#96;account&#96;,<br>    &#96;u&#96;.&#96;name&#96; AS &#96;username&#96;<br>FROM<br>    &#96;user&#96; &#96;u&#96;;<br></code></pre></td></tr></table></figure><p><strong>进行增删改操作如下，操作成功（注意user表中的其它字段要允许为空，否则操作失败）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO view_user_keyinfo (account, username)<br>VALUES<br>    (&#39;test1&#39;, &#39;test1&#39;);<br><br>DELETE<br>FROM<br>    view_user_keyinfo<br>WHERE<br>    username &#x3D; &#39;test1&#39;;<br><br>UPDATE view_user_keyinfo<br>SET username &#x3D; &#39;updateuser&#39;<br>WHERE<br>    id &#x3D; 1<br></code></pre></td></tr></table></figure><p><strong><code>视图与表是一对多关系情况</code>：如果只修改一张表的数据，且没有其它约束（如视图中没有的字段，在基本表中是必填字段情况），是可以进行改数据操作，如以下语句，操作成功；</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update view_user_course set coursename&#x3D;&#39;JAVA&#39; where id&#x3D;1;<br><br>update view_user_course set username&#x3D;&#39;test2&#39; where id&#x3D;3;<br></code></pre></td></tr></table></figure><p><strong>以下操作失败：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from view_user_course where id&#x3D;3;<br><br>insert into view_user_course(username, coursename) VALUES(&#39;2&#39;,&#39;3&#39;);<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql结构化查询语句 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL子查询</title>
      <link href="/posts/b19d.html"/>
      <url>/posts/b19d.html</url>
      
        <content type="html"><![CDATA[<h1>子查询</h1><p><strong>子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从mysql4.1开始引入。在select子句中先计算子查询，子查询结果作为外层另一个查询的过滤条件，查询可以基于一个表或者多个表。子查询中常用的操作符有any（some）、all、in、exists。子查询可以添加到select、update和delete语句中，而且可以进行多层嵌套。子查询中也可以使用比较运算符，如“&lt;”,“&lt;=”,“&gt;”,“&gt;=”和“!=”等。</strong></p><h3 id="示例1">示例1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * from student<br>WHERE studentName &#x3D; &#39;李文才&#39;;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200610161107839.png" alt="image-20200610161107839"></p><h3 id="示例2">示例2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * from student<br>WHERE studentName &#x3D; <br>true(select studentName from student<br>truetruewhere studentNo&#x3D;10001<br>true);<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200610161604558.png" alt="image-20200610161604558"></p><h3 id="示例3">示例3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 请查找出年龄大于15岁的学生<br># select * from student<br># where 年龄 &gt; 15;<br><br>select DATEDIFF(NOW(),&#39;2005-01-01&#39;) &#x2F;365<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200610162256661.png" alt="image-20200610162256661"></p><h3 id="（1）带any、some关键字的子查询">（1）带any、some关键字的子查询</h3><p><strong>any和some关键字是同义词，表示满足其中任一条件，它们允许创建一个表达式对子查询的返回值列进行比较，只要满足内层子查询中的任何一个比较条件，就返回一个结果作为外层查询的条件。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table tb1(<br>truenum1 int not null<br>);<br>insert into tb1 values(1),(5),(13),(27);<br>select * from tb1;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200611161645057.png" alt="image-20200611161645057"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table tb2(<br>truenum2 int not null<br>);<br>insert into tb2 values(6),(14),(11),(20);<br>select * from tb2;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200611161650169.png" alt="image-20200611161650169"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查询tb1比tb2大的数<br>select num1 from tb1<br>where num1 &gt; any<br>(select num2 from tb2);<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200613140211888.png" alt="image-20200613140211888"></p><h3 id="（2）带all关键字的子查询">（2）带all关键字的子查询</h3><p><strong>all关键字与any和some不同，使用all时需要同时满足所有内层查询的条件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># tb1中大于tb2所有数字<br>select num1 from tb1<br>where num1 &gt; all<br>(select num2 from tb2);<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200613140313874.png" alt="image-20200613140313874"></p><h3 id="（3）带exists关键字的子查询">（3）带exists关键字的子查询</h3><p><strong>exists关键字后面的参数是一个任意的子查询，系统对子查询进行运算以判断它是否返回行，如果至少返回一行，那么exists的结果为true，此时外层查询语句将进行查询；如果子查询没有返回任何行，那么exists返回的结果是false，此时外层语句将不进行查询。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table suppliers(<br>  s_id int not null auto_increment,<br>  s_name char(50) not null,<br>  s_city char(50) null,<br>  s_zip char(10) null,<br>  s_call char(50) not null,<br>  primary key(s_id)<br>);<br><br>insert into suppliers(s_id,s_name,s_city,s_zip,s_call)<br>values(101,&#39;FastFruit Inc.&#39;,&#39;tianjin&#39;,&#39;300000&#39;,&#39;48075&#39;),<br>(102,&#39;LT Supplies&#39;,&#39;chongqing&#39;,&#39;400000&#39;,&#39;44333&#39;),<br>(103,&#39;acme&#39;,&#39;shanghai&#39;,&#39;200000&#39;,&#39;90046&#39;),<br>(104,&#39;fnk inc.&#39;,&#39;zhongshan&#39;,&#39;528437&#39;,&#39;11111&#39;),<br>(105,&#39;good set&#39;,&#39;taiyuang&#39;,&#39;030000&#39;,&#39;22222&#39;),<br>(106,&#39;just eat ours&#39;,&#39;beijing&#39;,&#39;010&#39;,&#39;45678&#39;),<br>(107,&#39;dk inc.&#39;,&#39;zhengzhou&#39;,&#39;450000&#39;,&#39;33332&#39;);<br><br>select * from suppliers;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200611162856326.png" alt="image-20200611162856326"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from fruit where EXISTS(<br>trueSELECT * from suppliers where s_id&#x3D;107<br>);<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200611163315649.png" alt="image-20200611163315649"></p><h3 id="（4）带in关键字的子查询">（4）带in关键字的子查询</h3><p><strong>in关键字进行子查询时，内层查询语句仅仅返回一个数据列，这个数据列里的值将提供给外层查询语句进行比较操作。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select c_id from orders where o_num in<br>-&gt; (select o_num from orderitems where f_id &#x3D; &#39;c0&#39;);<br>+-------+<br>| c_id |<br>+-------+<br>| 10004 |<br>| 10001 |<br>+-------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（5）带比较运算符的子查询">（5）带比较运算符的子查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select s_id,f_name from fruits<br>-&gt; where s_id &#x3D;<br>-&gt; (select s1.s_id from suppliers as s1 where s1.s_city&#x3D;&#39;tianjin&#39;);<br>+------+------------+<br>| s_id | f_name |<br>+------+------------+<br>| 101 | apple |<br>| 101 | blackberry |<br>| 101 | cherry |<br>+------+------------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="5、合并查询结果">5、合并查询结果</h2><p><strong>利用union关键字，可以给出多条select语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同。各个select语句之间使用union或union all关键字分隔。union不使用关键字all，执行的时候删除重复的记录，所有返回的行都是唯一的；使用关键字all的作用是不删除重复行也不对结果进行自动排序。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 合并<br>select sid,sname,sprice from fruitl<br>where sprice &gt; 6<br>UNION all <br>select * from fruit<br>where sid in (101,104);<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200611164310547.png" alt="image-20200611164310547"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 合并<br>select sid,sname,sprice from fruit<br>where sprice &gt; 6<br>UNION<br>select * from fruit<br>where sid in (101,104);<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200611164415866.png" alt="image-20200611164415866"></p><p><strong>union和union all的区别：使用union all的功能是不删除重复行，加上all关键字语句执行时所需要的资源少，所以尽可能地使用它，因此知道有重复行但是想保留这些行，确定查询结果中不会有重复数据或者不需要去掉重复数据的时候，应当使用union all以提高查询效率。</strong></p><h2 id="6、为表和字段取别名">6、为表和字段取别名</h2><p><strong>前面介绍了分组查询、聚合函数查询和嵌套子查询，取别名使用关键字as为查询结果中的某一列指定一个特别的名字。可以为字段或者表分别取别名，在查询时，使用别名替代指定的内容。</strong></p><h2 id="（1）为表取别名">（1）为表取别名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from orders as o<br>-&gt; where o.o_num &#x3D; 30001;<br>+-------+---------------------+-------+<br>| o_num | o_date | c_id |<br>+-------+---------------------+-------+<br>| 30001 | 2008-09-01 00:00:00 | 10001 |<br>+-------+---------------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="（2）为字段取别名">（2）为字段取别名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select f1.f_name as fruits_name ,f1.f_price as fruits_price<br>-&gt; from fruits as f1<br>-&gt; where f1.f_price &lt; 8;<br>+-------------+--------------+<br>| fruits_name | fruits_price |<br>+-------------+--------------+<br>| apple | 5.20 |<br>| apricot | 2.20 |<br>| berry | 7.60 |<br>| xxxx | 3.60 |<br>| cherry | 3.20 |<br>| lemon | 6.40 |<br>| xbabay | 2.60 |<br>| grape | 5.30 |<br>| xbababa | 3.60 |<br>+-------------+--------------+<br>9 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><h1>7、使用正则表达式查询</h1><p><strong>正则表达式通常被用来检索或替换那些符合某个模式的文本内容，根据指定的匹配模式匹配文本中符合要求的特殊字符串。例如从一个文本文件中提取电话号码，查找一篇文章中重复的单词或者替换用户输入的某些敏感词语等等，这些地方都可以使用正则表达式。正则表达式强大且灵活，可以应用于非常复杂的查询。mysql中使用regexp关键字指定正则表达式的字符匹配模式。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200613140726862.png" alt="image-20200613140726862"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200613140741946.png" alt="image-20200613140741946"></p><h2 id="（1）查询以特定字符或字符串开头的记录">（1）查询以特定字符或字符串开头的记录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from fruit where sname regexp &#39;^苹&#39;;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200613140918742.png" alt="image-20200613140918742"></p><h2 id="（2）查询以特定字符或字符串结尾的记录">（2）查询以特定字符或字符串结尾的记录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from fruit where sname regexp &#39;果$&#39;;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200613140928609.png" alt="image-20200613140928609"></p><h2 id="（3）用符合‘-’来代替字符串中的任意一个字符">（3）用符合‘.’来代替字符串中的任意一个字符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from fruit where sname regexp &#39;.果&#39;;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200613140939266.png" alt="image-20200613140939266"></p><h2 id="（4）匹配指定字符中的任意一个">（4）匹配指定字符中的任意一个</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from student where sex regexp &#39;[男]&#39;;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200613141320008.png" alt="image-20200613141320008"></p><h2 id="（5）使用“-”和“-”来匹配多个字符">（5）使用“*”和“+”来匹配多个字符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select studentName from student where studentName regexp &#39;^李*露&#39;;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200613140956924.png" alt="image-20200613140956924"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select studentName from student where studentName regexp &#39;^李+露&#39;;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200613140956924.png" alt="image-20200613140956924"></p><h2 id="（6）匹配指定字符以外的字符">（6）匹配指定字符以外的字符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from student where sex regexp &#39;[^男]&#39;;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200613140948846.png" alt="image-20200613140948846"></p><h2 id="（7）使用-n-或者-n-m-来指定字符串连续出现的次数">（7）使用{n,}或者{n,m}来指定字符串连续出现的次数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select studentName from student where studentName regexp &#39;李&#123;0,&#125;&#39;;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200613141004270.png" alt="image-20200613141004270"></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql结构化查询语句 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL高级查询</title>
      <link href="/posts/98ba.html"/>
      <url>/posts/98ba.html</url>
      
        <content type="html"><![CDATA[<h2 id="回想">回想</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select studentNo, studentName, sex, gradeName<br>from student s,grade g<br>where s.gradeId &#x3D; g.gradeID;<br>select studentNo,studentName,sex,gradeName<br>from student s join grade g<br>on s.gradeId &#x3D; g.gradeID;<br></code></pre></td></tr></table></figure><p>![image-20200610140605161](G:\四期\数据库\mysql文档\05 mysql通算符.assets\image-20200610140605161.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select count(1), sex from student<br>group by sex<br>HAVING sex &#x3D;&#39;男&#39;;<br></code></pre></td></tr></table></figure><p>![image-20200610140916671](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200610140916671.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 排序<br>select * from student<br>LIMIT 4,5;<br></code></pre></td></tr></table></figure><p>![image-20200610141016816](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200610141016816.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * from student<br>where studentNo in (&#39;10005&#39;,&#39;10001&#39;);<br></code></pre></td></tr></table></figure><p>![image-20200610141245878](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200610141245878.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * from student<br>where studentNo BETWEEN 10001 and 10005;<br></code></pre></td></tr></table></figure><p>![image-20200610141437404](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200610141437404.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from student<br>where email is null<br>and identityCard is null;<br></code></pre></td></tr></table></figure><p>![image-20200610141528016](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200610141528016.png)</p><h1>查询数据</h1><p><strong>数据库管理系统的一个最重要的功能就是数据查询，数据查询不应只是简单查询数据库中存储的数据，还应该根据需要对数据进行筛选，以及确定数据以什么样的格式显示。MySQL提供了功能强大、灵活的语句来实现这些操作。</strong></p><h2 id="1、基本查询语句">1、基本查询语句</h2><p><strong>mysql从数据表中查询数据的基本语句为select语句。select语句的基本格式是：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT &#123;* | &lt;字段列表&gt;&#125; [ FROM &lt;表1&gt;, &lt;表2&gt;.... [ where &lt;表达式&gt; ] [ group by ] [ having ] [ order by<br>&lt;..&gt; ] [ limit &lt;...&gt; ]<br></code></pre></td></tr></table></figure><ul><li><strong>{*|&lt;字段列表&gt;}包含星号通配符选择字段列表，表示查询的字段，其中字段列至少包含一个字段名称，如果要查询多个字段，多个字段之间用逗号隔开，最后一个字段后不要加逗号。</strong></li><li><strong>FROM&lt;表1&gt;,&lt;表2&gt;…：表1和表2表示查询数据的来源，可以是单个或多个。</strong></li><li><strong>WHERE子句是可选项，如果选择该项，将限定查询必须满足的查询条件。</strong></li><li><strong>GROUP BY&lt;字段&gt;，该子句告诉MySQL按什么样的顺序显示查询出来的数据，可以进行的排序有：升序（asc）、降序（desc）。</strong></li><li><strong>[limit]，该子句告诉mysql每次显示查询出来的数据条款。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table fruits<br>-&gt; (<br>-&gt; f_id char(10) not null,<br>-&gt; s_id int not null,<br>-&gt; f_name char(255) not null,<br>-&gt; f_price decimal(8,2) not null,<br>-&gt; primary key(f_id)<br>-&gt; );<br>Query OK, 0 rows affected (0.02 sec)<br>mysql&gt; insert into fruits(f_id,s_id,f_name,f_price)<br>-&gt; values(&#39;a1&#39;,101,&#39;apple&#39;,&#39;5.2&#39;),<br>-&gt; (&#39;b1&#39;,101,&#39;blackberry&#39;,&#39;10.2&#39;),<br>-&gt; (&#39;bs1&#39;,102,&#39;orange&#39;,&#39;11.2&#39;),<br>-&gt; (&#39;bs2&#39;,105,&#39;melon&#39;,&#39;8.2&#39;),<br>-&gt; (&#39;t1&#39;,102,&#39;banana&#39;,&#39;10.3&#39;),<br>-&gt; (&#39;t2&#39;,102,&#39;grape&#39;,&#39;5.3&#39;),<br>-&gt; (&#39;o2&#39;,103,&#39;coconut&#39;,&#39;9.2&#39;),<br>-&gt; (&#39;c0&#39;,101,&#39;cherry&#39;,&#39;3.2&#39;),<br>-&gt; (&#39;a2&#39;,103,&#39;apricot&#39;,&#39;2.2&#39;),<br>-&gt; (&#39;l2&#39;,104,&#39;lemon&#39;,&#39;6.4&#39;),<br>-&gt; (&#39;b2&#39;,104,&#39;berry&#39;,&#39;7.6&#39;),<br>-&gt; (&#39;m1&#39;,106,&#39;mango&#39;,&#39;15.7&#39;),<br>-&gt; (&#39;m2&#39;,105,&#39;xbabay&#39;,&#39;2.6&#39;),<br>-&gt; (&#39;t4&#39;,107,&#39;xbababa&#39;,&#39;3.6&#39;),<br>-&gt; (&#39;m3&#39;,105,&#39;xxtt&#39;,&#39;11.6&#39;),<br>-&gt; (&#39;b5&#39;,107,&#39;xxxx&#39;,&#39;3.6&#39;);<br>Query OK, 16 rows affected (0.02 sec)<br>Records: 16 Duplicates: 0 Warnings: 0<br></code></pre></td></tr></table></figure><h2 id="2、单表查询">2、单表查询</h2><p><strong>单表查询是指从一张表数据中查询所需的数据。主要有：查询所有字段、查询指定字段、查询指定记录、查询空值、多条件的查询、对查询结果进行排序等方式。</strong></p><h4 id="1-查询所有字段">&lt;1&gt;查询所有字段</h4><p><strong>在select语句中使用星号（）通配符查询所有字段。 select查询记录最简单的形式是从一个表中检索所有记录，实现的方法是使用星号（）通配符指定查找所有列的名称。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from fruits;<br></code></pre></td></tr></table></figure><h4 id="2-在select语句中指定所有字段-根据前面select语句的格式，select关键字后面的字段名为将要查询的数据，因此可以将表中所有字段的名称跟在select子句后面，如果忘记了字段名称，可以使用DESC命令查看表的结构。有时候，由于表中的字段多，不一定能记住所有的字段名称。因此很不方便，不建议使用。">&lt;2&gt;在select语句中指定所有字段 根据前面select语句的格式，select关键字后面的字段名为将要查询的数据，因此可以将表中所有字段的名称跟在select子句后面，如果忘记了字段名称，可以使用DESC命令查看表的结构。有时候，由于表中的字段多，不一定能记住所有的字段名称。因此很不方便，不建议使用。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Select f_id,s_id,f_name,f_price from fruit<br></code></pre></td></tr></table></figure><h3 id="（1）查询指定字段">（1）查询指定字段</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 字段名 from 表名；<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select f_name from fruits;<br>+------------+<br>| f_name |<br>+------------+<br>| apple |<br>| apricot |<br>| blackberry |<br>| berry |<br>| xxxx |<br>| orange |<br>| melon |<br>| cherry |<br>| lemon |<br>| mango |<br>| xbabay |<br>| xxtt |<br>| coconut |<br>| banana |<br>| grape |<br>| xbababa |<br>+------------+<br>16 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（2）查询多个字段-使用select声明，可以获取多个字段下的数据，只需要在关键字select后面指定要查询的字段的名称，不同字段名称之间用逗号分隔，最后一个字段后面不需要加逗号">（2）查询多个字段 使用select声明，可以获取多个字段下的数据，只需要在关键字select后面指定要查询的字段的名称，不同字段名称之间用逗号分隔，最后一个字段后面不需要加逗号</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 字段1，字段2，字段3 ....，字段n from 表名；<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select f_name,f_price from fruits;<br>+------------+---------+<br>| f_name | f_price |<br>+------------+---------+<br>| apple | 5.20 |<br>| apricot | 2.20 |<br>| blackberry | 10.20 |<br>| berry | 7.60 |<br>| xxxx | 3.60 |<br>| orange | 11.20 |<br>| melon | 8.20 |<br>| cherry | 3.20 |<br>| lemon | 6.40 |<br>| mango | 15.70 |<br>| xbabay | 2.60 |<br>| xxtt | 11.60 |<br>| coconut | 9.20 |<br>| banana | 10.30 |<br>| grape | 5.30 |<br>| xbababa | 3.60 |<br>+------------+---------+<br>16 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><h3 id="（3）查询指定记录">（3）查询指定记录</h3><p><strong>数据库中包含大量的数据，根据特殊要求可能只需要查询表中的指定数据，相当于对数据的过滤。在select语句中，通过where子句可以对数据进行过滤。</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 字段1，字段2....字段n from 表名 where 查询条件；  <br></code></pre></td></tr></table></figure></blockquote><p>![image-20200613131557954](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200613131557954.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select f_name,f_price<br>-&gt; from fruits<br>-&gt; where f_price &#x3D; 10.2;<br>+------------+---------+<br>| f_name | f_price |<br>+------------+---------+<br>| blackberry | 10.20 |<br>+------------+---------+<br>1 row in set (0.01 sec)<br></code></pre></td></tr></table></figure><h3 id="（4）带in关键字的查询">（4）带in关键字的查询</h3><p><strong>in操作符用来查询满足指定范围内的条件的记录，使用IN操作符，将所有检索条件用括号括起来，检索条件之间用逗号分隔开，只要满足条件范围内的一个值即为匹配项。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select s_id,f_name,f_price<br>-&gt; from fruits<br>-&gt; where s_id in (101,102)<br>-&gt; order by f_name;<br>+------+------------+---------+<br>| s_id | f_name | f_price |<br>+------+------------+---------+<br>| 101 | apple | 5.20 |<br>| 102 | banana | 10.30 |<br>| 101 | blackberry | 10.20 |<br>| 101 | cherry | 3.20 |<br>| 102 | grape | 5.30 |<br>| 102 | orange | 11.20 |<br>+------+------------+---------+<br>6 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（5）带between-and的范围查询">（5）带between and的范围查询</h3><p><strong>Between and用来查询某个范围内的值，该操作符需要两个参数，即范围的开始值和结束值，如果字段值满足指定的范围查询条件，则这些记录被返回。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select f_name,f_price<br>-&gt; from fruits<br>-&gt; where f_price between 2.00 and 10.20;<br>+------------+---------+<br>| f_name | f_price |<br>+------------+---------+<br>| apple | 5.20 |<br>| apricot | 2.20 |<br>| blackberry | 10.20 |<br>| berry | 7.60 |<br>| xxxx | 3.60 |<br>| melon | 8.20 |<br>| cherry | 3.20 |<br>| lemon | 6.40 |<br>| xbabay | 2.60 |<br>| coconut | 9.20 |<br>| grape | 5.30 |<br>| xbababa | 3.60 |<br>+------------+---------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（7）带like的字符匹配查询">（7）带like的字符匹配查询</h3><p><strong>通配符是一种在SQL的where条件子句中拥有特殊意思的字符，SQL语句中支持多种通配符，可以和like一起使用的通配符有‘%’和‘_’。</strong></p><h4 id="1-百分号（-）通配符，匹配任意长度的字符，甚至包括零字符">&lt;1&gt;百分号（%）通配符，匹配任意长度的字符，甚至包括零字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select f_id,f_name<br>-&gt; from fruits<br>-&gt; where f_name like &#39;b%&#39;;<br>+------+------------+<br>| f_id | f_name |<br>+------+------------+<br>| b1 | blackberry |<br>| b2 | berry |<br>| t1 | banana |<br>+------+------------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h4 id="2-下划线（-通配符，一次只能匹配任意一个字符">&lt;2&gt;下划线（__)通配符，一次只能匹配任意一个字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select f_id,f_name<br>-&gt; from fruits<br>-&gt; where f_name like &#39;____y&#39;;<br>+------+--------+<br>| f_id | f_name |<br>+------+--------+<br>| b2 | berry |<br>+------+--------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（8）查询空值">（8）查询空值</h3><p><strong>数据表创建的时候，设计者可以指定某列中是否可以包含空值（NULL)。空值不同于0，也不同于空字符串。空值一般表示数据未知、不适用或将在以后添加数据。在select语句中使用IS NULL子句，可以查询某字段内容为空的记录。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table customers<br>-&gt; (<br>-&gt; c_id int not null auto_increment,<br>-&gt; c_name char(50) not null,<br>-&gt; c_address char(50) null,<br>-&gt; c_city char(50) null,<br>-&gt; c_zip char(50) null,<br>-&gt; c_contact char(50) null,<br>-&gt; c_email char(50) null,<br>-&gt; primary key(c_id)<br>-&gt; );<br>Query OK, 0 rows affected (0.02 sec)<br>mysql&gt; insert into customers(c_id,c_name,c_address,c_city,c_zip,c_contact,c_email)<br>-&gt; values(10001,&#39;RedHook&#39;,&#39;200<br>Street&#39;,&#39;Tianjin&#39;,&#39;300000&#39;,&#39;LiMing&#39;,&#39;LMing@163.com&#39;),<br>-&gt; (10002,&#39;Stars&#39;,&#39;333 Fromage<br>Lane&#39;,&#39;Dalian&#39;,&#39;116000&#39;,&#39;Zhangbo&#39;,&#39;Jerry@hotmail.com&#39;),<br>-&gt; (10003,&#39;Netbhood&#39;,&#39;1 Sunny Place&#39;,&#39;Qingdao&#39;,&#39;266000&#39;,&#39;LuoCong&#39;,NULL),<br>-&gt;(10004,&#39;JOTO&#39;,&#39;829 Riverside Drive&#39;, &#39;Haikou&#39;,&#39;570000&#39;,&#39;YangShan&#39;,<br>&#39;sam@hotmail.com&#39;);<br>Query OK, 4 rows affected (0.02 sec)<br>Records: 4 Duplicates: 0 Warnings: 0<br>mysql&gt; select c_id,c_name,c_email from customers where c_email IS NULL;<br>+-------+----------+---------+<br>| c_id | c_name | c_email |<br>+-------+----------+---------+<br>| 10003 | Netbhood | NULL |<br>+-------+----------+---------+<br>1 row in set (0.01 sec)<br></code></pre></td></tr></table></figure><h3 id="（9）带and的多条件查询">（9）带and的多条件查询</h3><p><strong>使用select查询时，可以增加查询的限制条件，这样可以使查询的结果更加精确。MySQL在where子句中使用and操作符限定只有满足所有查询条件的记录才会被返回。可以使用and连接两个甚至多个查询条件，多个条件表达式之间用and分开。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select f_id,f_price,f_name<br>-&gt; from fruits<br>-&gt; where s_id &#x3D; &#39;101&#39; and f_price &gt;&#x3D;5;<br>+------+---------+------------+<br>| f_id | f_price | f_name |<br>+------+---------+------------+<br>| a1 | 5.20 | apple |<br>| b1 | 10.20 | blackberry |<br>+------+---------+------------+<br>2 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（10）带or的多条件查询">（10）带or的多条件查询</h3><p><strong>与and相反，在where声明中使用or操作符，表示只需要满足其中一个条件的记录即可返回。or也可以连接两个甚至多个查询条件，多个条件表达式之间用or分开。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select s_id,f_name,f_price<br>-&gt; from fruits<br>-&gt; where s_id &#x3D; 101 or s_id &#x3D; 102;<br>+------+------------+---------+<br>| s_id | f_name | f_price |<br>+------+------------+---------+<br>| 101 | apple | 5.20 |<br>| 101 | blackberry | 10.20 |<br>| 102 | orange | 11.20 |<br>| 101 | cherry | 3.20 |<br>| 102 | banana | 10.30 |<br>| 102 | grape | 5.30 |<br>+------+------------+---------+<br>6 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（11）查询结果不重复">（11）查询结果不重复</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查询不重复<br># 创建表<br>create table &#96;fruit&#96;(<br>true&#96;sid&#96; int(3) PRIMARY KEY not null,<br>true&#96;sname&#96; VARCHAR(20) not NULL,<br>true&#96;sprice&#96; FLOAT not null<br>)CHARSET &#39;utf8mb4&#39;;<br><br># 表中添加数据<br>insert into &#96;fruit&#96;(sid,sname,sprice)<br>values(100,&#39;芒果&#39;,5.00),<br>(101,&#39;苹果&#39;,5.00),<br>(102,&#39;香蕉&#39;,7.00),<br>(103,&#39;梨&#39;,6.00),<br>(104,&#39;火龙果&#39;,10.00),<br>(105,&#39;榴莲&#39;,15.00);<br><br># 查看一下<br>select * from fruit;<br></code></pre></td></tr></table></figure><p>![image-20200613132514405](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200613132514405.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#去掉重复数据<br>select DISTINCT sprice from fruit;<br><br>select DISTINCT sex from student S join grade g<br>on s.gradeId &#x3D; g.gradeID；<br></code></pre></td></tr></table></figure><p>![image-20200613132441783](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200613132441783.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#聚合函数<br>select max(sprice) 最高价,min(sprice),sum(sprice),avg(sprice) <br>from fruit;<br></code></pre></td></tr></table></figure><p>![](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200613132535375.png)</p><h2 id="3、对查询结果排序">3、对查询结果排序</h2><h3 id="（1）单列排序">（1）单列排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select f_name from fruits;<br>+------------+<br>| f_name |<br>+------------+<br>| apple |<br>| apricot |<br>| blackberry |<br>| berry |<br>| xxxx |<br></code></pre></td></tr></table></figure><h3 id="（2）多列排序">（2）多列排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select f_name,f_price from fruits order by f_name,f_price;<br>+------------+---------+<br>| f_name | f_price |<br>+------------+---------+<br>| apple | 5.20 |<br>| apricot | 2.20 |<br>| banana | 10.30 |<br>| berry | 7.60 |<br>| blackberry | 10.20 |<br>| cherry | 3.20 |<br>| coconut | 9.20 |<br>| grape | 5.30 |<br>| lemon | 6.40 |<br>| mango | 15.70 |<br>| melon | 8.20 |<br>| orange | 11.20 |<br>| xbababa | 3.60 |<br>| xbabay | 2.60 |<br>| xxtt | 11.60 |<br>| xxxx | 3.60 |<br>+------------+---------+<br>16 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>在多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。</strong></p><h3 id="（3）指定排序方向">（3）指定排序方向</h3><p><strong>默认情况下，查询数据按字母升序进行排序（从A~Z)，但数据的排序并不仅限于此，还可以使用order by对查询结果进行降序排序（从Z~A)，这可以通过关键字DESC实现。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select f_name,f_price from fruits order by f_name,f_price DESC;<br>+------------+---------+<br>| f_name | f_price |<br>+------------+---------+<br>| apple | 5.20 |<br>| apricot | 2.20 |<br>| banana | 10.30 |<br>| berry | 7.60 |<br>| blackberry | 10.20 |<br>| cherry | 3.20 |<br>| coconut | 9.20 |<br>| grape | 5.30 |<br>| lemon | 6.40 |<br>| mango | 15.70 |<br>| melon | 8.20 |<br>| orange | 11.20 |<br>| xbababa | 3.60 |<br>| xbabay | 2.60 |<br>| xxtt | 11.60 |<br>| xxxx | 3.60 |<br>+------------+---------+<br>16 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><p><strong>与DESC相反ASC是升序</strong></p><h2 id="4、分组查询">4、分组查询</h2><p><strong>分组插叙是对数据按照某个或多个字段进行分组，MySQL中使用group by关键字对数据进行分组，基本语法形式为：group by 字段 1、创建分组</strong></p><p><strong>Group by 关键字通常和集合函数一起使用，例如：MAX()、MIN()、COUNT()、SUM()、AVG()。 根据s_id对fruits表中的数据进行分组</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select s_id,count(*) as total from fruits group by s_id;<br>+------+-------+<br>| s_id | total |<br>+------+-------+<br>| 101 | 3 |<br>| 102 | 3 |<br>| 103 | 2 |<br>| 104 | 2 |<br>| 105 | 3 |<br>| 106 | 1 |<br>| 107 | 2 |<br>+------+-------+<br>7 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（1）根据s-id对fruits表中的数据进行分组，将每个供应商的水果名称显示出来"><strong>（1）根据s_id对fruits表中的数据进行分组，将每个供应商的水果名称显示出来</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select s_id,group_concat(f_name) as name from fruits group by s_id;<br>+------+-------------------------+<br>| s_id | name |<br>+------+-------------------------+<br>| 101 | apple,blackberry,cherry |<br>| 102 | orange,banana,grape |<br>| 103 | apricot,coconut |<br>| 104 | berry,lemon |<br>| 105 | melon,xbabay,xxtt |<br>| 106 | mango |<br>| 107 | xxxx,xbababa |<br>+------+-------------------------+<br>7 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（2）使用having过滤分组-根据s-id对fruits表中的数据进行分组，并显示水果种类大于1的分组信息">（2）使用having过滤分组 根据s_id对fruits表中的数据进行分组，并显示水果种类大于1的分组信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select s_id,group_concat(f_name) as name from fruits group by s_id having<br>count(f_name) &gt; 1;<br>+------+-------------------------+<br>| s_id | name |<br>+------+-------------------------+<br>| 101 | apple,blackberry,cherry |<br>| 102 | orange,banana,grape |<br>| 103 | apricot,coconut |<br>| 104 | berry,lemon |<br>| 105 | melon,xbabay,xxtt |<br>| 107 | xxxx,xbababa |<br>+------+-------------------------+<br>6 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（3）在group-by-子句中使用with-rollup-使用with-rollup关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。">（3）在group by 子句中使用with rollup 使用with rollup关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select s_id,count(*) as total<br>-&gt; from fruits<br>-&gt; group by s_id with rollup;<br>+------+-------+<br>| s_id | total |<br>+------+-------+<br>| 101 | 3 |<br>| 102 | 3 |<br>| 103 | 2 |<br>| 104 | 2 |<br>| 105 | 3 |<br>| 106 | 1 |<br>| 107 | 2 |<br>| NULL | 16 |<br>+------+-------+<br>8 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（4）多字段分组-使用group-by可以对多个字段进行分组，group-by关键字后面跟需要分组的字段，MySQL根据多字段的值来进行层次分组，分组层次从左到右，即先按第1个字段分组，然后在第1个字段值相同的记录中，再根据第2个字段的值进行分组，以此类推">（4）多字段分组 使用group by可以对多个字段进行分组，group by关键字后面跟需要分组的字段，MySQL根据多字段的值来进行层次分组，分组层次从左到右，即先按第1个字段分组，然后在第1个字段值相同的记录中，再根据第2个字段的值进行分组，以此类推</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from fruits group by s_id,f_name;<br>+------+------+------------+---------+<br>| f_id | s_id | f_name | f_price |<br>+------+------+------------+---------+<br>| a1 | 101 | apple | 5.20 |<br>| b1 | 101 | blackberry | 10.20 |<br>| c0 | 101 | cherry | 3.20 |<br>| t1 | 102 | banana | 10.30 |<br>| t2 | 102 | grape | 5.30 |<br>| bs1 | 102 | orange | 11.20 |<br>| a2 | 103 | apricot | 2.20 |<br>| o2 | 103 | coconut | 9.20 |<br>| b2 | 104 | berry | 7.60 |<br>| l2 | 104 | lemon | 6.40 |<br>| bs2 | 105 | melon | 8.20 |<br>| m2 | 105 | xbabay | 2.60 |<br>| m3 | 105 | xxtt | 11.60 |<br>| m1 | 106 | mango | 15.70 |<br>| t4 | 107 | xbababa | 3.60 |<br>| b5 | 107 | xxxx | 3.60 |<br>+------+------+------------+---------+<br>16 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（5）group-by和order-by一起使用-某些情况下需要对分组进行排序">（5）group by和order by一起使用 某些情况下需要对分组进行排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table orderitems<br>-&gt; (<br>-&gt; o_num int not null,<br>-&gt; o_item int not null,<br>-&gt; f_id char(10) not null,<br>-&gt; quantity int not null,<br>-&gt; item_price decimal(8,2) not null,<br>-&gt; primary key(o_num,o_item)<br>-&gt; );<br>Query OK, 0 rows affected (0.03 sec)<br><br>mysql&gt; insert into orderitems(o_num,o_item,f_id,quantity,item_price)<br>-&gt; values(30001,1,&#39;a1&#39;,10,&#39;5.2&#39;),<br>-&gt; (30001,2,&#39;b2&#39;,3,&#39;7.6&#39;),<br>-&gt; (30001,3,&#39;bs1&#39;,5,&#39;11.2&#39;),<br>-&gt; (30001,4,&#39;bs2&#39;,15,&#39;9.2&#39;),<br>-&gt; (30002,1,&#39;b3&#39;,2,&#39;20.0&#39;),<br>-&gt; (30003,1,&#39;c0&#39;,100,10),<br>-&gt; (30004,1,&#39;o2&#39;,50,&#39;2.50&#39;),<br>-&gt; (30005,1,&#39;c0&#39;,5,&#39;10&#39;),<br>-&gt; (30005,2,&#39;b1&#39;,10,&#39;8.99&#39;),<br>-&gt; (30005,3,&#39;a2&#39;,10,&#39;2.2&#39;),<br>-&gt; (30005,4,&#39;m1&#39;,5,&#39;14.99&#39;);<br>Query OK, 11 rows affected (0.00 sec)<br>Records: 11 Duplicates: 0 Warnings: 0<br></code></pre></td></tr></table></figure><p><strong>查询价格大于100的订单号和总价订单价格</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select o_num,sum(quantity*item_price) as ordertotal<br>-&gt; from orderitems<br>-&gt; group by o_num<br>-&gt; having sum(quantity*item_price) &gt;&#x3D; 100;<br>+-------+------------+<br>| o_num | ordertotal |<br>+-------+------------+<br>| 30001 | 268.80 |<br>| 30003 | 1000.00 |<br>| 30004 | 125.00 |<br>| 30005 | 236.85 |<br>+-------+------------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="5、使用limit限制查询结果的数量-select返回所有匹配的行，有可能是表中所有的行，如仅仅需要返回第一行或者前几行，使用limit关键字，语法格式如下：limit-位置偏移量-行数">5、使用limit限制查询结果的数量 select返回所有匹配的行，有可能是表中所有的行，如仅仅需要返回第一行或者前几行，使用limit关键字，语法格式如下：limit [位置偏移量] 行数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from fruits limit 4;<br>+------+------+------------+---------+<br>| f_id | s_id | f_name | f_price |<br>+------+------+------------+---------+<br>| a1 | 101 | apple | 5.20 |<br>| a2 | 103 | apricot | 2.20 |<br>| b1 | 101 | blackberry | 10.20 |<br>| b2 | 104 | berry | 7.60 |<br>+------+------+------------+---------+<br>4 rows in set (0.02 sec)<br>mysql&gt; select * from fruits limit 4,3;<br>+------+------+--------+---------+<br>| f_id | s_id | f_name | f_price |<br>+------+------+--------+---------+<br>| b5 | 107 | xxxx | 3.60 |<br>| bs1 | 102 | orange | 11.20 |<br>| bs2 | 105 | melon | 8.20 |<br>+------+------+--------+---------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="6、使用聚合函数查询">6、使用聚合函数查询</h2><p>![image-20200613133729764](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200613133729764.png)</p><h3 id="（1）count-函数">（1）count()函数</h3><p><strong>Count()函数统计数据表中包含的记录行的总数，或者根据查询结果返回列中包含的数据行数。 Count(*)计算表中总的函数，不管某列有数列或者为空值 Count(字段名)计算指定列下总的行数，计算时将忽略空值的行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select count(*) as cust_num<br>-&gt; from customers;<br>+----------+<br>| cust_num |<br>+----------+<br>| 4 |<br>+----------+<br>1 row in set (0.00 sec)<br>mysql&gt; select count(c_email) as email_num<br>-&gt; from customers;<br>+-----------+<br>| email_num |<br>+-----------+<br>| 3 |<br>+-----------+<br>1 row in set (0.00 sec)<br>mysql&gt; select o_num,count(f_id)<br>-&gt; from orderitems<br>-&gt; group by o_num;<br>+-------+-------------+<br>| o_num | count(f_id) |<br>+-------+-------------+<br>| 30001 | 4 |<br>| 30002 | 1 |<br>| 30003 | 1 |<br>| 30004 | 1 |<br>| 30005 | 4 |<br>+-------+-------------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（2）sum-函数">（2）sum()函数</h3><p><strong>sum()是一个求总和的函数，返回指定列值得总和。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select sum(quantity) as items_total<br>-&gt; from orderitems<br>-&gt; where o_num &#x3D; 30005;<br>+-------------+<br>| items_total |<br>+-------------+<br>| 30 |<br>+-------------+<br>1 row in set (0.01 sec)<br>mysql&gt; select o_num,sum(quantity) as items_total<br>-&gt; from orderitems<br>-&gt; group by o_num;<br>+-------+-------------+<br>| o_num | items_total |<br>+-------+-------------+<br>| 30001 | 33 |<br>| 30002 | 2 |<br>| 30003 | 100 |<br>| 30004 | 50 |<br>| 30005 | 30 |<br>+-------+-------------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>注意：sum()函数在计算时，忽略列值为NULL的行。</strong></p><h3 id="（3）avg-函数">（3）avg()函数</h3><p><strong>avg()函数通过计算返回的行数和每一行数据的和，求得指定列数据的平均值。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select avg(f_price) as avg_price<br>-&gt; from fruits<br>-&gt; where s_id&#x3D;103;<br>+-----------+<br>| avg_price |<br>+-----------+<br>| 5.700000 |<br>+-----------+<br>1 row in set (0.00 sec)<br>mysql&gt; select avg(f_price) as avg_price<br>-&gt; from fruits<br>-&gt; where s_id&#x3D;103;<br>+-----------+<br>| avg_price |<br>+-----------+<br>| 5.700000 |<br>+-----------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（4）max-函数">（4）max()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select max(f_price) as max_price from fruits;<br>+-----------+<br>| max_price |<br>+-----------+<br>| 15.70 |<br>+-----------+<br>1 row in set (0.00 sec)<br>mysql&gt; select s_id,max(f_price) as max_price<br>-&gt; from fruits<br>-&gt; group by s_id;<br>+------+-----------+<br>| s_id | max_price |<br>+------+-----------+<br>| 101 | 10.20 |<br>| 102 | 11.20 |<br>| 103 | 9.20 |<br>| 104 | 7.60 |<br>| 105 | 11.60 |<br>| 106 | 15.70 |<br>| 107 | 3.60 |<br>+------+-----------+<br>7 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（5）min-函数">（5）min()函数</h3><p><strong>min()返回查询列中的最小值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select min(f_price) as min_price from fruits;<br>+-----------+<br>| min_price |<br>+-----------+<br>| 2.20 |<br>+-----------+<br>1 row in set (0.00 sec)<br>mysql&gt; select s_id,min(f_price) as max_price from fruits group by s_id;<br>+------+-----------+<br>| s_id | max_price |<br>+------+-----------+<br>| 101 | 3.20 |<br>| 102 | 5.30 |<br>| 103 | 2.20 |<br>| 104 | 6.40 |<br>| 105 | 2.60 |<br>| 106 | 15.70 |<br>| 107 | 3.60 |<br>+------+-----------+<br>7 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h1>连接查询</h1><p><strong>连接是关系数据库模型的主要特点。连接查询是关系数据库中最主要的查询，主要包括内连接、外连接。通过连接运算符可以实现多个表查询。在关系数据库管理系统中，表建立时各数据之间的关系不必确定，常把一个实体的所有信息存放在一个表中。当查询数据时，通过连接操作查询出存放在多个表中的不同实体的信息。当两个或多个表现中存在相同意义的字段时，便可以通过这些字段对不同的表进行连接查询。</strong></p><h2 id="1、内连接查询">1、内连接查询</h2><p><strong>内连接（inner join）使用比较运算符进行表间某些列数据的比较操作，并列出这些表中与连接条件相匹配的数据行，组合成新纪录，也就是说，在内连接查询中，只有满足条件的记录才能出现在结果关系中。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; create table suppliers<br>-&gt; (<br>-&gt; s_id int not null auto_increment,<br>-&gt; s_name char(50) not null,<br>-&gt; s_city char(50) null,<br>-&gt; s_zip char(10) null,<br>-&gt; s_call char(50) not null,<br>-&gt; primary key(s_id)<br>-&gt; );<br>Query OK, 0 rows affected (0.02 sec)<br>mysql&gt; insert into suppliers(s_id,s_name,s_city,s_zip,s_call)<br>-&gt; values(101,&#39;FastFruit Inc.&#39;,&#39;tianjin&#39;,&#39;300000&#39;,&#39;48075&#39;),<br>-&gt; (102,&#39;LT Supplies&#39;,&#39;chongqing&#39;,&#39;400000&#39;,&#39;44333&#39;),<br>-&gt; (103,&#39;acme&#39;,&#39;shanghai&#39;,&#39;200000&#39;,&#39;90046&#39;),<br>-&gt; (104,&#39;fnk inc.&#39;,&#39;zhongshan&#39;,&#39;528437&#39;,&#39;11111&#39;),<br>-&gt; (105,&#39;good set&#39;,&#39;taiyuang&#39;,&#39;030000&#39;,&#39;22222&#39;),<br>-&gt; (106,&#39;just eat ours&#39;,&#39;beijing&#39;,&#39;010&#39;,&#39;45678&#39;),<br>-&gt; (107,&#39;dk inc.&#39;,&#39;zhengzhou&#39;,&#39;450000&#39;,&#39;33332&#39;);<br>Query OK, 7 rows affected (0.01 sec)<br>Records: 7 Duplicates: 0 Warnings: 0<br>mysql&gt; select suppliers.s_id,s_name,f_name,f_price<br>-&gt; from fruits ,suppliers<br>-&gt; where fruits.s_id &#x3D; suppliers.s_id;<br>+------+----------------+------------+---------+<br>| s_id | s_name | f_name | f_price |<br>+------+----------------+------------+---------+<br>| 101 | FastFruit Inc. | apple | 5.20 |<br>| 103 | acme | apricot | 2.20 |<br>| 101 | FastFruit Inc. | blackberry | 10.20 |<br>| 104 | fnk inc. | berry | 7.60 |<br>| 107 | dk inc. | xxxx | 3.60 |<br>| 102 | LT Supplies | orange | 11.20 |<br>| 105 | good set | melon | 8.20 |<br>| 101 | FastFruit Inc. | cherry | 3.20 |<br>| 104 | fnk inc. | lemon | 6.40 |<br>| 106 | just eat ours | mango | 15.70 |<br>| 105 | good set | xbabay | 2.60 |<br>| 105 | good set | xxtt | 11.60 |<br>| 103 | acme | coconut | 9.20 |<br>| 102 | LT Supplies | banana | 10.30 |<br>| 102 | LT Supplies | grape | 5.30 |<br>| 107 | dk inc. | xbababa | 3.60 |<br>+------+----------------+------------+---------+<br>16 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><strong>如果在一个连接查询中，涉及的两个表都是同一个表，这种查询称为自连接查询。自连接是一种特殊的内连接，它是指相互连接的表在物理上为同一张表，但可以在逻辑上分为两张表</strong> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select f1.f_id,f1.f_name<br>-&gt; from fruits as f1, fruits as f2<br>-&gt; where f1.s_id &#x3D; f2.s_id and f2.f_id &#x3D; &#39;a1&#39;;<br>+------+------------+<br>| f_id | f_name |<br>+------+------------+<br>| a1 | apple |<br>| b1 | blackberry |<br>| c0 | cherry |<br>+------+------------+<br>3 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="2、外连接查询">2、外连接查询</h2><blockquote><p><strong>外连接查询将将查询多个表中相关联的行，内连接时，返回查询结果集合中的仅是符合查询条件和连接条件的行。但有时候需要包含没有关联的行中数据，即返回查询结果集合中的不仅包含符合连接条件的行，而且还包含左表（左外连接或左连接）、右表（右外连接或右连接）或两个连接表（全外连接）中的所有数据行。外连接分为左外连接或左连接和右外连接或右连接。</strong></p></blockquote><p><strong>Left join（左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。</strong></p><p><strong>Right join（右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 左连接<br>select * from student s<br>LEFT JOIN grade g<br>on s.gradeId &#x3D; g.gradeID;<br><br># 右连接<br>select * from student s<br>RIGHT JOIN grade g<br>on s.gradeId &#x3D; g.gradeID;<br></code></pre></td></tr></table></figure><p>![image-20200613134628052](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200613134628052.png)</p><h3 id="创建表">创建表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table orders(<br>  o_num int not null auto_increment,<br>  o_date datetime not null,<br>  c_id int not null,<br>  primary key(o_num)<br>);<br><br>insert into orders(o_num,o_date,c_id)<br>values(30001,&#39;2008-09-01&#39;,10001),<br>(30002,&#39;2008-09-12&#39;,10003),<br>(30003,&#39;2008-09-30&#39;,10004),<br>(30004,&#39;2008-10-03&#39;,10005),<br>(30005,&#39;2008-10-08&#39;,10001);<br><br>create table customers(<br>  c_id int not null auto_increment,<br>  c_name char(50) not null,<br>  c_address char(50) null,<br>  c_city char(50) null,<br>  c_zip char(50) null,<br>  c_contact char(50) null,<br>  c_email char(50) null,<br>  primary key(c_id)<br>);<br></code></pre></td></tr></table></figure><h3 id="插入数据">插入数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into customers(c_id,c_name,c_address,c_city,c_zip,c_contact,c_email)<br>values(10001,&#39;RedHook&#39;,&#39;200Street&#39;,&#39;Tianjin&#39;,&#39;300000&#39;,&#39;LiMing&#39;,&#39;LMing@163.com&#39;),<br>(10002,&#39;Stars&#39;,&#39;333 Fromage Lane&#39;,&#39;Dalian&#39;,&#39;116000&#39;,&#39;Zhangbo&#39;,&#39;Jerry@hotmail.com&#39;),<br>(10003,&#39;Netbhood&#39;,&#39;1 Sunny Place&#39;,&#39;Qingdao&#39;,&#39;266000&#39;,&#39;LuoCong&#39;,NULL),<br>(10004,&#39;JOTO&#39;,&#39;829 Riverside Drive&#39;, &#39;Haikou&#39;,&#39;570000&#39;,&#39;YangShan&#39;,&#39;sam@hotmail.com&#39;);<br><br><br>select * from customers;<br>select * from orders;<br></code></pre></td></tr></table></figure><p>![image-20200613135037758](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200613135037758.png)</p><p>![image-20200613135042714](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200613135042714.png)</p><h3 id="（1）左连接">（1）左连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 左外连接<br>select c.c_id,o.o_num from customers c<br>LEFT OUTER JOIN orders o<br>on c.c_id &#x3D; o.c_id;<br></code></pre></td></tr></table></figure><p>![image-20200610151134872](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200610151134872.png)</p><h3 id="（2）右连接">（2）右连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 右外连接<br>select c.c_id,o.o_num from customers c<br>RIGHT  OUTER JOIN orders o<br>on c.c_id &#x3D; o.c_id;<br></code></pre></td></tr></table></figure><p>![image-20200610151240505](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200610151240505.png)</p><h2 id="3、复合条件连接查询">3、复合条件连接查询</h2><p><strong>复合条件连接查询是在连接查询的过程中，通过添加过滤条件，限制查询的结果，使查询的结果更加准确。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select c.c_id,o.o_num from customers c<br>LEFT OUTER JOIN orders o<br>on c.c_id &#x3D; o.c_id<br>and c.c_id&#x3D;10001;<br></code></pre></td></tr></table></figure><p>![image-20200610152148735](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200610152148735.png)</p><h2 id="4、编写SQL语句，查看年龄比“李斯文”小的学生，要求显示这些学生的信息">4、编写SQL语句，查看年龄比“李斯文”小的学生，要求显示这些学生的信息</h2><p>![image-20200610162453310](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200610162453310.png)</p><blockquote><p><strong>第一步:查询得到“李斯文”的出生日期</strong></p><p><strong>第二步:利用WHERE语句，筛选出生日期比“李斯文”大的学生</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 请查找出年龄比李斯文小的学生<br>select bornDate from student<br>where studentName &#x3D; &#39;李斯文&#39;;<br></code></pre></td></tr></table></figure><p>![image-20200610163928028](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200610163928028.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select studentName,bornDate from student<br>where bornDate&gt;&#39;1993-07-23&#39;;<br></code></pre></td></tr></table></figure><p>![image-20200610163937508](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200610163937508.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select studentName,bornDate from student<br>where bornDate&gt;(<br>  select bornDate from student<br>    where studentName &#x3D; &#39;李斯文&#39;<br>);<br></code></pre></td></tr></table></figure><p>![image-20200610163937508](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200610163937508.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP TABLE IF EXISTS 666;<br>create database &#96;666&#96;;<br>use &#96;666&#96;<br><br>drop table if exists &#96;t&#96;;<br>CREATE TABLE &#96;ttt&#96;(<br>true&#96;sid&#96; int (4) not null PRIMARY KEY,<br>  &#96;sname&#96; VARCHAR(20) not null<br>)CHARSET &#x3D; &#39;utf8mb4&#39;;<br><br>select * from ttt<br></code></pre></td></tr></table></figure><p>![image-20200610165549705](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200610165549705.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table tb1(<br>truenum1 int not null<br>);<br>insert into tb1 values(1),(5),(13),(27);<br>select * from tb1;<br></code></pre></td></tr></table></figure><p>![image-20200611161645057](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200611161645057.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table tb2(<br>truenum2 int not null<br>);<br>insert into tb2 values(6),(14),(11),(20);<br>select * from tb2;<br></code></pre></td></tr></table></figure><p>![image-20200611161650169](G:\四期\数据库\mysql文档\05 mysql高级查询.assets\image-20200611161650169.png)</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql结构化查询语句 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据插入和复制</title>
      <link href="/posts/e5cc.html"/>
      <url>/posts/e5cc.html</url>
      
        <content type="html"><![CDATA[<h1>一、DML语句(增删改)</h1><p><strong>插入数据的个数和类型要与表结构保持一致</strong></p><h2 id="1、插入单条数据记录">1、插入单条数据记录</h2><h3 id="语法：">语法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO 表名 [(字段名列表)] VALUES (值列表);<br></code></pre></td></tr></table></figure><h3 id="注意：">注意：</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">字段名是可选的，如省略则依次插入所有字段<br>多个列表和多个值之间使用逗号分隔<br>值列表和字段名列表一一对应<br>如插入的是表中部分数据，字段名列表必填<br></code></pre></td></tr></table></figure><h3 id="示例：">示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 插入单条数据<br>insert into student(sid,sname,gradeID)<br>VALUES(1002,&#39;徐淑丽&#39;,2);<br><br>insert into student<br>VALUES(1003,&#39;孙子涵&#39;,1);<br><br>insert into grade(gradeID,graedName)<br>values(4,&#39;云计算&#39;);<br></code></pre></td></tr></table></figure><h3 id="查看一下">查看一下</h3><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605142439474.png" alt="image-20200605142439474"></p><h2 id="2、插入多条数据记录">2、插入多条数据记录</h2><h4 id="语法：-2">语法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO 新表（字段名列表）<br>VALUES(值列表1),(值列表2),……,(值列表n);<br></code></pre></td></tr></table></figure><h3 id="示例：-2">示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 插入多条数据<br>insert into student(sid,sname,gradeID)<br>VALUES(1005,&#39;王永义&#39;,3),(1006,&#39;包晓艺&#39;,2),(1007,&#39;黑瓜子&#39;,1);<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605142445896.png" alt="image-20200605142445896"></p><h4 id="经验：">经验：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">为避免表结构发生变化引发的错误，建议插入数据时写明具体字段名！<br></code></pre></td></tr></table></figure><h2 id="3、将查询结果插入新表">3、将查询结果插入新表</h2><h3 id="（1）事先创建新表且与插入数据字段相符">（1）事先创建新表且与插入数据字段相符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO 新表（字段1,字段2……） <br>SELECT字段1，字段2……<br>FROM 原表;<br></code></pre></td></tr></table></figure><h3 id="（2）无需事先创建新表">（2）无需事先创建新表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 新表（<br>SELECT 字段1，字段2……<br>FROM 原表）;<br></code></pre></td></tr></table></figure><h3 id="（3）练习">（3）练习</h3><p><strong>编写SQL语句实现从学生表提取姓名、手机号两列数据存储到通讯录表中。</strong></p><h4 id="1-不需要事先创建表">&lt;1&gt;不需要事先创建表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table copy_grade(<br>trueselect * from grade<br>);<br></code></pre></td></tr></table></figure><h4 id="2-事先创建表">&lt;2&gt;事先创建表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create TABLE c_grade(<br>true&#96;id&#96; int(4) not null,<br>true&#96;name&#96; VARCHAR(20) not null<br>);<br><br>insert into c_grade(id,name)<br>SELECT * from grade;<br></code></pre></td></tr></table></figure><h4 id="查看一下-2">查看一下</h4><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605143500761.png" alt="image-20200605143500761"></p><h2 id="4、更新数据记录">4、更新数据记录</h2><h3 id="语法：-3">语法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE 表名 <br>SET 字段1&#x3D;值1,字段2&#x3D;值2,…,字段n&#x3D;值n <br>[WHERE 条件];<br></code></pre></td></tr></table></figure><h4 id="示例1">示例1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 更新数据<br>update c_grade<br>set name &#x3D; &#39;高级运维&#39;<br>where id &#x3D; 4<br># where条件一 定要设置，否则会修改所有的列<br><br>SELECT * from c_grade<br></code></pre></td></tr></table></figure><h4 id="查看一下-3">查看一下</h4><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605150412643.png" alt="image-20200605150412643"></p><h3 id="示例2">示例2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE student<br>set gradeID&#x3D;2,sex&#x3D;&#39;女&#39;<br>where sid&#x3D;1002;<br><br>SELECT * from student<br></code></pre></td></tr></table></figure><h4 id="查看一下-4">查看一下</h4><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605150354067.png" alt="image-20200605150354067"></p><h3 id="分析一下">分析一下</h3><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605145417460.png" alt="image-20200605145417460"></p><h2 id="5、删除数据记录">5、删除数据记录</h2><h3 id="语法：-4">语法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM 表名 [WHERE条件];<br>TRUNCATE TABLE 表名;<br></code></pre></td></tr></table></figure><h3 id="注意：-2">注意：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">TRUNCATE语句删除后将重置自增列，表结构及其字段、约束、索引保持不变，执行速度比DELETE语句快<br></code></pre></td></tr></table></figure><h4 id="示例">示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># DELETE不能 重置自增列<br>DELETE from c_grade WHERE id&#x3D;1;<br>SELECT * from c_grade;<br><br># truncate能够 重置自增列<br>truncate table c_grade;<br>SELECT * from c_grade;<br></code></pre></td></tr></table></figure><h1>小结</h1><p><strong>MySQL中如何使用一条INSERT语句插入多条数据?</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">INSERT INTO 表名(字段一,字段二,)<br>VALUES(数据一,&#39;数据二&#39;);<br></code></pre></td></tr></table></figure><p><strong>MySQL中将查询结果集插入新表的两种方式是什么?两者的区别是什么?</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">不需要实现创建表,将查询结果插入新表<br>create table 新表名称(<br>  select * from 需要查询的表<br>);<br>  需要提前创建表<br>  INSERT into 提前创建好的表名称()<br>  select * from  需要查询的表；<br></code></pre></td></tr></table></figure><p><strong>删除数据时使用DEL ETE和TRUNCATE的区别是什么?</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">删除表内数据，不会重置自增列<br>删除表内出局，也会重置自增列<br></code></pre></td></tr></table></figure><h1>二、DQL语句（查询）</h1><h2 id="1、通用查询">1、通用查询</h2><h3 id="语法：-5">语法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT  &lt;字段名列表&gt;<br>FROM  &lt;表名或视图&gt;<br>[WHERE  &lt;查询条件&gt;]<br>[GROUP BY &lt;分组的字段名&gt;]<br>[HAVING &lt;条件&gt;]<br>[ORDER BY &lt;排序的字段名&gt; [ASC 或 DESC]]<br></code></pre></td></tr></table></figure><h3 id="示例：-3">示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT &#96;studentNo&#96;,&#96;studentName&#96;,&#96;phone&#96;,&#96;address&#96;,&#96;bornDate&#96; <br>FROM &#96;student&#96;<br>WHERE &#96;gradeId&#96; &#x3D; 1<br>ORDER BY studentNo;<br></code></pre></td></tr></table></figure><h3 id="（1）把student中男和女的个数分别显示出来">（1）把student中男和女的个数分别显示出来</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT count(1) from student<br>#where sname&#x3D;&#39;黑瓜子&#39;;<br>GROUP BY sex<br>#HAVING sex&#x3D;&#39;男&#39; ;<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200606153510215.png" alt="image-20200606153510215"></p><h3 id="（2）排序">（2）排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * from student<br>-- order by sid asc;<br>order by sid desc;<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605154017144.png" alt="image-20200605154017144"></p><h2 id="2、LIMIT子句">2、LIMIT子句</h2><p><strong>MySQL查询语句中使用LIMIT子句限制结果集。</strong></p><h3 id="语法：-6">语法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT  &lt;字段名列表&gt;<br>FROM  &lt;表名或视图&gt;<br>[WHERE  &lt;查询条件&gt;]<br>[GROUP BY &lt;分组的字段名&gt;]<br>[ORDER BY  &lt;排序的列名&gt; [ASC 或 DESC]]<br>[LIMIT [位置偏移量, ]行数];<br></code></pre></td></tr></table></figure><h3 id="示例：-4">示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * from student<br>limit 4,3;<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605154710182.png" alt="image-20200605154710182"></p><p>注意：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">使用LIMIT子句时，注意第1条记录的位置是0！<br></code></pre></td></tr></table></figure><h2 id="3、常用函数">3、常用函数</h2><h3 id="（1）聚合函数">（1）聚合函数</h3><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>count()</td><td>返回某字段的行数</td></tr><tr><td>avg()</td><td>返回某字段的平均值</td></tr><tr><td>max()</td><td>返回某字段的最大值</td></tr><tr><td>min()</td><td>返回某字段的最小值</td></tr><tr><td>sum()</td><td>返回某字段的和</td></tr></tbody></table><h3 id="（2）字符串函数">（2）字符串函数</h3><table><thead><tr><th>函数名</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>LENGTH(str)</td><td>计算字符串长度</td><td>SELECT LENGTH(‘date’);</td></tr><tr><td>CONCAT(str1,str2,…)</td><td>字符串合并</td><td>select CONCAT(‘a’,‘b’,‘c’)</td></tr><tr><td>INSERT(str,pos,len,newstr)</td><td>字符串替换</td><td>select INSERT(‘old string’,1,3,‘letter’)</td></tr><tr><td>LOWER(str)</td><td>将字符串转换为小写</td><td>select LOWER(‘A’)</td></tr><tr><td>UPPER(str)</td><td>将字符串转换为大写</td><td>select UPPER(‘a’)</td></tr><tr><td>LEFT(s,n)</td><td>返回字符串 s 开始的最左边 n 个字符</td><td>SELECT LEFT(‘hello’,2);</td></tr><tr><td>RIGHT(s,n)</td><td>返回字符串 s 开始的最右边 n 个字符</td><td>SELECT RIGHT(‘hello word!’,5);</td></tr><tr><td>LPAD(s1,len,s2)</td><td>返回字符串 s1 ，其左边由字符串 s2填充到 len 字符长度，如果 s1 的长度大于 len ，则返回值被缩短至 len 长度</td><td>SELECT RPAD(‘hello’,4,’?’);</td></tr><tr><td>RPAD(s1,len,s2)</td><td>返回字符串 s1 ，其右边由字符串 s2 填充到 len 字符长度，如果 s1 的长度大于 len ，则返回值被缩短至 len 长度</td><td>SELECT RPAD(‘hello’,10,’?’);</td></tr><tr><td>LTRIM(s)</td><td>用于删除字符串 s 左侧的空格</td><td>SELECT LTRIM(’ book ');</td></tr><tr><td>RTRIM(s)</td><td>用于删除字符串 s 右侧的空格</td><td>SELECT RTRIM(’ book ');</td></tr><tr><td>TRIM(s)</td><td>用于删除字符串 s 两侧的空格</td><td>SELECT TRIM(’ book ');</td></tr><tr><td>TRIM(s1 FROM s)</td><td>删除指定字符串的函数</td><td>SELECT TRIM(‘xy’ FROM ‘xyxyabcxy’);</td></tr><tr><td>REPEAT(s,n)</td><td>用于重复字符串 s ，n 表示重复多少次</td><td>SELECT REPEAT(‘mysql’,3);</td></tr><tr><td>SPACE(n)</td><td>用于返回 n 个空格</td><td>SELECT SPACE(20);</td></tr><tr><td>REPLACE(s,s1,s2)</td><td>使用字符串 s2 替换字符串 s 中所有的字符串 s1</td><td>SELECT REPLACE(‘<a href="http://xxx.mysql.com" target="_blank" rel="noopener">xxx.mysql.com</a>’, ‘x’, ‘w’);</td></tr><tr><td>STRCMP(s1,s2)</td><td>用于比较字符串 s1 和 s2 的大小，若所有字符串相同则返回 0 ，若第一个字符串大于第二个字符串则返回 1 ，若第一个字符串小于第二个字符串则返回 -1</td><td>SELECT STRCMP(‘txt’, ‘txt2’), STRCMP(‘txt’, ‘txt’);</td></tr><tr><td>SUBSTRING(str,num,len)</td><td>获取指定位置的子字符串</td><td>select SUBSTRING(‘JavaMysqlOracle’,5,5);</td></tr><tr><td>MID(s,n,len)</td><td>用于获取指定位置的子字符串</td><td>SELECT MID(‘breakfast’,5);</td></tr><tr><td>LOCATE(str1,str)</td><td>返回字符串 str1 在字符串 str 中的开始位置</td><td>SELECT LOCATE(‘ball’, ‘football’);</td></tr><tr><td>POSITION(str1 IN str)</td><td>返回字符串 str1 在字符串 str 中的开始位置</td><td>SELECT POSITION(‘ball’ IN ‘football’);</td></tr><tr><td>INSTR(str, str1)</td><td>返回子字符串 str1 在字符串 str 中的开始位置</td><td>SELECT INSTR(‘football’, ‘ball’);</td></tr><tr><td>REVERSE(s)</td><td>将字符串 s 反转</td><td>SELECT REVERSE(‘abcd’);</td></tr><tr><td>ELT(n, s1, s2, s3, …)</td><td>返回第 n 个字符串，如果 n超出范围则返回 NULL</td><td>SELECT ELT(3, ‘a’, ‘b’, ‘c’, ‘d’);</td></tr><tr><td>FIELD(s, s1, s2, …)</td><td>返回字符串 s 在列表 s1, s2, … 中的位置，如果不存在字符串 s 则返回 0 ，如果字符串 s 是 NULL 也返回 0</td><td>SELECT FIELD(‘hi’, ‘hihi’, ‘hey’, ‘hi’, ‘bas’);</td></tr><tr><td>FIND_IN_SET(s1, s2)</td><td>返回字符串 s1 在字符串列表 s2中的位置</td><td>SELECT FIND_IN_SET(‘hi’, ‘hihi,hey,hi,bas’);</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 字符串连接<br>select CONCAT(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)<br></code></pre></td></tr></table></figure><p>![image-20200608142620041](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200608142620041.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 字符串替换<br>select INSERT(&#39;old string&#39;,1,3,&#39;letter&#39;)<br></code></pre></td></tr></table></figure><p>![image-20200608142655908](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200608142655908.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 字符串转小写<br>select LOWER(&#39;A&#39;)<br></code></pre></td></tr></table></figure><p>![image-20200608142815767](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200608142815767.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 字符串转大写<br>select LOWER(&#39;a&#39;)<br></code></pre></td></tr></table></figure><p>![image-20200608142830810](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200608142830810.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 字符串截取<br>select SUBSTRING(&#39;JavaMysqlOracle&#39;,5,5)<br></code></pre></td></tr></table></figure><p>![image-20200608142956979](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200608142956979.png)</p><h3 id="（3）时间日期函数">（3）时间日期函数</h3><table><thead><tr><th>函数名</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>CURDATE()</td><td>获取当前日期</td><td>select CURDATE();</td></tr><tr><td>CURTIME()</td><td>获取当前时间</td><td>select CURTIME();</td></tr><tr><td>CURRENT_TIMESTAMP() 、<br>.LOCALTIME() 、NOW() 、SYSDATE()<br>CURRENT_TIMESTAMP()</td><td>获取当前日期和时间</td><td>select NOW();</td></tr><tr><td>UNIX_TIMESTAMP()</td><td>获取 UNIX 格式的时间戳</td><td>SELECT UNIX_TIMESTAMP();</td></tr><tr><td>FROM_UNIXTIME()</td><td>将 UNIX 格式的时间戳转换为普通格式的时间</td><td>SELECT FROM_UNIXTIME(‘1495542689’);</td></tr><tr><td>UTC_DATE() UTC_DATE()</td><td>获取当前 UTC (世界标准时间) 日期值</td><td>SELECT UTC_DATE();</td></tr><tr><td>UTC_TIME() UTC_TIME()</td><td>获取当前 UTC (世界标准时间) 时间值</td><td>SELECT UTC_TIME();</td></tr><tr><td>YEAR(date)</td><td>返回日期date的年份</td><td>select YEAR(NOW());</td></tr><tr><td>QUARTER(date)</td><td>返回日期date为一年中第几季度</td><td>select QUARTER(NOW());</td></tr><tr><td>MONTH(date)</td><td>返回日期date的月份</td><td>select MONTH(NOW());</td></tr><tr><td>WEEK(date)</td><td>返回日期date为一年中第几周</td><td>select WEEK(NOW());</td></tr><tr><td>DAY(date)</td><td>返回日期date的日期</td><td>select DAY(NOW());</td></tr><tr><td>DAYOFYEAR(date)</td><td>返回 date 是一年中的第几天，一年有 365 天</td><td>SELECT DAYOFYEAR(‘2017-05-23’);</td></tr><tr><td>DAYOFMONTH(date)</td><td>计算 date 是一个月中的第几天</td><td>SELECT DAYOFMONTH(‘2017-05-23’);</td></tr><tr><td>HOUR(time)</td><td>返回日期date的小时</td><td>select HOUR(NOW());</td></tr><tr><td>MINUTE(time)</td><td>返回日期date的分钟</td><td>select MINUTE(NOW());</td></tr><tr><td>SECOND(time)</td><td>返回日期date的秒</td><td>select SECOND(NOW());</td></tr><tr><td>TIME_TO_SEC(time)</td><td>将 time 转换为秒钟，公式为 &quot; 小时3600 + 分钟60 + 秒 &quot;</td><td>SELECT TIME_TO_SEC(‘23:23:00’);</td></tr><tr><td>SEC_TO_TIME(time)</td><td>将秒值转换为时间格式</td><td>SELECT SEC_TO_TIME(‘84180’);</td></tr><tr><td>DATEDIFF(date1,date2)</td><td>返回日期date的date1和date2间隔的天数</td><td>select DATEDIFF(NOW(),‘2020-06-07’);</td></tr><tr><td>ADDDATE(date,n)</td><td>计算日期date加上n天以后在日期</td><td>select ADDDATE(NOW(),3);</td></tr><tr><td>DATE_FORMAT(date, format)</td><td>格式化日期，即根据 format 指定的格式显示 date 值</td><td>SELECT DATE_FORMAT(‘1997-10-04 22:23:00’, ‘%W %M %Y’);</td></tr><tr><td>TIME_FORMAT(time, format)</td><td>格式化时间，即根据 format 指定的格式显示 time 值</td><td>SELECT TIME_FORMAT(‘16:00:00’, ‘%H %k %I’);</td></tr><tr><td>GET_FORMAT()</td><td>指定值类型和格式化类型，然后会显示成格式字符串</td><td>SELECT DATE_FORMAT(‘2000-10-05 22:23:00’, GET_FORMAT(DATE,‘USA’));</td></tr></tbody></table><h4 id="参考内容：">参考内容：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 当前的日期<br>select CURDATE();<br># 当前的时间<br>select CURTIME();<br># 当前的日期和时间<br>select NOW();<br><br># 年<br>select YEAR(NOW());<br># 月<br>select MONTH(NOW());<br># 日<br>select DAY(NOW());<br># 星期<br>select WEEK(NOW());<br><br># 时<br>select HOUR(NOW());<br># 分<br>select MINUTE(NOW());<br># 秒<br>select SECOND(NOW());<br><br># 计算从2020&#x2F;1&#x2F;&#x2F;1 到 2020&#x2F;6&#x2F;8 有多少天<br>select DATEDIFF(now(),&#39;2020-01-01&#39;)<br><br># 三天后的现在<br>select adddate(now(),3)<br></code></pre></td></tr></table></figure><h3 id="（4）数学函数">（4）数学函数</h3><table><thead><tr><th>函数名</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>ABS(x)</td><td>绝对值函数</td><td>SELECT ABS(-2);</td></tr><tr><td>PI()</td><td>返回圆周率的函数</td><td>SELECT PI();</td></tr><tr><td>SQRT(x)</td><td>平方根函数，返回非负数二次方根</td><td>SELECT SQRT(9);</td></tr><tr><td>CEIL(x)</td><td>向上取整</td><td>SELECT CEIL(2.1);</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td><td>SELECT FLOOR(2.5);</td></tr><tr><td>RAND(x)</td><td>返回一个随机浮点值，范围在 0 ~ 1 之间</td><td>SELECT RAND();</td></tr><tr><td>ROUND(x)</td><td>对x进行四舍五入</td><td>SELECT ROUND(-1.34);</td></tr><tr><td>ROUND(x,y)</td><td>对x进行四舍五入，并且保留小数点后y位</td><td>SELECT ROUND(1.37,1);</td></tr><tr><td>TRUNCATE(x,y)</td><td>对x进行截取，结果保留小数点后y位</td><td>SELECT TRUNCATE(1.31,1);</td></tr><tr><td>POW(x,y)</td><td>返回 x 的 y 次方的结果</td><td>SELECT POW(2,4);</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#  只要有小数就往整数进一位<br>select ceil(3.01)<br><br># 只要整数部位<br>select FLOOR(3.91);<br><br># 随机数<br>select rand();<br></code></pre></td></tr></table></figure><h3 id="（5）系统信息函数">（5）系统信息函数</h3><table><thead><tr><th>函数名</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>VERSION()</td><td>获取 MySQL 版本号</td><td>SELECT VERSION();</td></tr><tr><td>CHARSET(str)</td><td>查看字符串 str 的字符集</td><td>SELECT CHARSET(‘abc’);</td></tr><tr><td>COLLATION(str)</td><td>查看字符串 str 的字符排列方式</td><td>SELECT COLLATION(‘abc’);</td></tr><tr><td>LAST_INSERT_ID()</td><td>获取最后一个自动生成的ID 值</td><td>SELECT LAST_INSERT_ID();</td></tr><tr><td>USER() 、<br>CURRENT_USER() 、<br>SYSTEM_USER()</td><td>返回当前登录的用户及主机名</td><td>SELECT USER();<br>SELECT CURRENT_USER();<br>SELECT SYSTEM_USER();</td></tr><tr><td>CONNECTION_ID()</td><td>查看当前用户的连接数的ID</td><td>SELECT CONNECTION_ID();</td></tr><tr><td>DATABASE()、SCHEMA()</td><td>查看当前使用的数据库</td><td>SELECT DATABASE();<br>SELECT SCHEMA();</td></tr><tr><td>SHOW PROCESSLIST</td><td>查看当前用户的连接信息</td><td>SHOW PROCESSLIST;</td></tr></tbody></table><blockquote><p>CONNECTION_ID()函数的参数</p></blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. Id ：用户登录 MySQL 时，系统分配的连接 id<br>2. User ：当前连接的用户<br>3. Host ：显示这个语句是从哪个 IP 的哪个端口上发出的，可以用来追踪出现问题语句的用户<br>4. db ：显示这个进程目前连接的是哪个数据库<br>5. Command ：显示当前连接执行的命令，一般取值为休眠(Sleep)、查询(Query)、连接(Connect)<br>6. Time ：显示这个状态持续的时间，单位是秒<br>7. State ：显示使用当前连接的 SQL 语句的状态<br>8. Info ：显示这个 SQL 语句<br></code></pre></td></tr></table></figure><h4 id="示例1：">示例1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查看MySQL版本<br>select VERSION();<br># 查看数据库连接的ID<br># 查看MySQL connection id连接id<br># 对于已经建立的连接的客户端，都有一个唯一的连接ID。<br>select CONNECTION_ID();<br># 查看MySQL接口<br>SHOW PROCESSLIST;<br><br>use mysql;<br># 查看当前数据库<br>select database();<br>SELECT SCHEMA();<br><br># 查看当前用户<br>select user();<br># 查看当前日期<br>select CURRENT_DATE();<br># 查看当前用户<br>select SYSTEM_USER();<br></code></pre></td></tr></table></figure><h4 id="示例2：">示例2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table worker(<br>trueid int auto_increment PRIMARY key,<br>truename VARCHAR(30)<br>)CHARSET&#x3D;utf8mb4;<br><br>insert into worker(name) VALUES(&#39;xxx&#39;);<br>insert into worker(name) VALUES(&#39;yyy&#39;);<br>select LAST_INSERT_ID();<br></code></pre></td></tr></table></figure><h3 id="（6）条件判断函数">（6）条件判断函数</h3><table><thead><tr><th>函数</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>IF() IF(expr, v1, v2)</td><td>如果表达式 expr 为 TRUE ，则返回值为 v1 ，否则返回 v2</td><td>SELECT IF(1&gt;2, 2, 3);</td></tr><tr><td>IFNULL() IFNULL(v1, v2)</td><td>如果 v1 不为 NULL ，则返回值为 v1 ；如果 v1 为 NULL ，则返回值为 v2</td><td>SELECT IFNULL(1,2), IFNULL(NULL,10);</td></tr><tr><td>CASE expr WHEN v1 THEN r1 [WHEN v2 THEN r2] [ELSE rn] END</td><td>如果 expr 等于某个 vn，则返回对应位置 THEN 后面的结果，如果与所有值都不相等，则返回 ELSE 后面的 rn</td><td>SELECT CASE 2 WHEN 1 THEN ‘one’ WHEN 2 THEN ‘two’ ELSE ‘more’ END;</td></tr></tbody></table><h3 id="（7）加密-解密函数">（7）加密/解密函数</h3><table><thead><tr><th>函数</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>PASSWORD(str)</td><td>从明文密码 str 计算并返回加密后的密码字符串，当参数为 NULL 时，返回 NULL</td><td>SELECT PASSWORD(‘newpwd’);</td></tr><tr><td>MD5(str)</td><td>为字符串 str 算出一个 MD5 128 比特校验值</td><td>SELECT MD5(‘newpwd’);</td></tr><tr><td>ENCODE(str, pswd_str)</td><td>使用 pswd_str 作为密码，加密 str</td><td>SELECT ENCODE(‘secret’, ‘newpwd’);</td></tr><tr><td>DECODE(crypt_str, pswd_str)</td><td>使用 pswd_str 作为密码，解密加密字符串 crypt_str</td><td>SELECT DECODE(ENCODE(‘secret’,‘cry’), ‘cry’);</td></tr></tbody></table><h4 id="加密">加密</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select PASSWORD(&#39;123456&#39;);<br>select MD5(&#39;123456&#39;);<br>select ENCODE(&#39;123456&#39;,&#39;abc&#39;)<br></code></pre></td></tr></table></figure><h4 id="解密">解密</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select DECODE(ENCODE(&#39;123456&#39;,&#39;abc&#39;),&#39;abc&#39;);<br></code></pre></td></tr></table></figure><h4 id="示例-2">示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select PASSWORD(&#39;123456&#39;);<br>select BENCHMARK(500000，PASSWORD(&#39;123456&#39;));<br></code></pre></td></tr></table></figure><h3 id="（8）其它函数">（8）其它函数</h3><table><thead><tr><th>函数</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>FORMAT(x, n)</td><td>将数字 x 格式化，并以四舍五入的方式保留小数点后 n 位，结果以字符串的形式返回</td><td>SELECT FORMAT(1.23456, 4);</td></tr><tr><td>CONV()</td><td>不同进制数之间的转换</td><td>SELECT CONV(‘a’,16,2), # 将16进制的a转换为2进制<br>SELECT CONV(15,10,2), # 将10进制的15转换为2进制<br>SELECT CONV(15,10,8), # 将10进制的15转换为8进制<br>SELECT CONV(15,10,16); # 将10进制的15转换为16进制</td></tr><tr><td>INET_ATON(expr)</td><td>将网络地址转换为一个代表该地址数值的整数</td><td>SELECT INET_ATON(‘192.168.1.1’);</td></tr><tr><td>GET_LOCK(str, timeout)</td><td>使用字符串 str 来得到一个锁，持续时间 timeout 秒<br>1. 若成功得到锁，则返回 1<br>2. 若操作超时，则返回 0<br>3. 若发生错误，则返回 NULL</td><td>SELECT GET_LOCK(‘lock1’, 10);</td></tr><tr><td>RELEASE_LOCAK(str)</td><td>用于解开被 GET_LOCK() 获取的，用字符串 str 所命名的锁<br>1. 若锁被解开，则返回 1<br>2. 若该线程尚未创建锁，则返回 0<br>3. 若命名的锁不存在，则返回 NULL<br>4. 若该锁从未被 GET_LOCK() 的调用获取，或锁已经被提前解开，则该锁不存在</td><td>SELECT RELEASE_LOCK(‘lock1’);</td></tr><tr><td>IS_FREE_LOCK(str)</td><td>检查名为 str 的锁是否可以使用<br>1. 若锁可以使用，则返回 1<br>2. 若锁正在被使用，则返回 0<br>3. 若出现错误，则返回 NULL</td><td>SELECT IS_FREE_LOCK(‘lock1’);</td></tr><tr><td>IS_USED_LOCK(str)</td><td>检查名为 str 的锁是否正在被使用，若被封锁，则返回使用该锁的客户端的连接标识<br>符，否则返回 NULL</td><td>SELECT IS_USED_LOCK(‘lock1’);</td></tr><tr><td>BENCHMARK(count, expr)</td><td>用于重复 count 次执行表达式 expr<br>1. 可以用于计算 MySQL 处理表达式的速度<br>2. 可以在 MySQL 客户端内部报告语句执行的时间</td><td>SELECT PASSWORD(‘newpwd’);<br>SELECT BENCHMARK( 500000, PASSWORD(‘newpwd’) );</td></tr><tr><td>CONVERT(… USING …)</td><td>用于改变字符串的默认字符集<br>默认是utf8字符集</td><td>SELECT CHARSET(‘abc’);<br>SELECT CHARSET(CONVERT(‘abc’ USING latin1));</td></tr><tr><td>CONVERT(x, type)</td><td>将一个数据类型的值转换为另一个数据类型的值</td><td>SELECT CONVERT(100, CHAR(2));</td></tr></tbody></table><h4 id="示例1：-2">示例1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select format(3.1415926,2);<br>select format(3.14,4);<br>select format(3.14,0);<br></code></pre></td></tr></table></figure><h4 id="示例2：-2">示例2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select CONV(&#39;a&#39;,16,2);<br>select CONV(15,10,2);<br>select CONV(15,10,8);<br>select CONV(15,10,16);<br></code></pre></td></tr></table></figure><h4 id="示例3：">示例3：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select INET_ATON(&#39;192.168.79.160&#39;);<br></code></pre></td></tr></table></figure><h3 id="（7）数据类型转换百数">（7）数据类型转换百数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select if(1&gt;2,&#39;true&#39;,&#39;false&#39;);<br><br>select IFNULL(null,2);<br>select IFNULL(1,2);<br><br>select case 2 <br>when 1 then &#39;one&#39; <br>when 2 then &#39;two&#39;<br>else &#39;more&#39;<br>end;<br></code></pre></td></tr></table></figure><p>![image-20200613115249566](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200613115249566.png)</p><h2 id="4、运算符">4、运算符</h2><h3 id="（1）算术运算符">（1）算术运算符</h3><table><thead><tr><th>运算符</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>+</td><td>加法</td><td>select 1+2;</td></tr><tr><td>-</td><td>减法</td><td>select 1-2;</td></tr><tr><td>*</td><td>乘法</td><td>select 2*5;</td></tr><tr><td>/或DIV</td><td>除法</td><td>select 9/3; 或 select 9 DIV 3;</td></tr><tr><td>%或MOD</td><td>取余</td><td>select 9%2; 或 select 9 MOD 2;</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 算数运算符<br>mysql&gt; select 1+2;<br>+-----+<br>| 1+2 |<br>+-----+<br>|   3 |<br>+-----+<br>1 row in set (0.00 sec)<br><br>mysql&gt; select 3-5;<br>+-----+<br>| 3-5 |<br>+-----+<br>|  -2 |<br>+-----+<br>1 row in set (0.00 sec)<br><br>mysql&gt; select 4*5;<br>+-----+<br>| 4*5 |<br>+-----+<br>|  20 |<br>+-----+<br>1 row in set (0.00 sec)<br><br>mysql&gt; select 5&#x2F;3;<br>+--------+<br>| 5&#x2F;3    |<br>+--------+<br>| 1.6667 |<br>+--------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; select 5 DIV 3;<br>+---------+<br>| 5 DIV 3 |<br>+---------+<br>|       1 |<br>+---------+<br>1 row in set (0.00 sec)<br><br>mysql&gt; select 6%8;<br>+------+<br>| 6%8  |<br>+------+<br>|    6 |<br>+------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（2）比较运算符">（2）比较运算符</h3><p><strong>SELECT 语句中的条件语句经常要使用比较运算符。</strong></p><p><strong>通过这些比较运算符，可以判断表中的哪些记录是符合条件的。比较结果为真，则返回 1，为假则返回 0，比较结果不确定则返回 NULL。</strong></p><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">描述</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">=</td><td style="text-align:left">等于</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">&lt;&gt;, !=</td><td style="text-align:left">不等于</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">&gt;</td><td style="text-align:left">大于</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">&lt;</td><td style="text-align:left">小于</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">&lt;=</td><td style="text-align:left">小于等于</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">&gt;=</td><td style="text-align:left">大于等于</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">BETWEEN</td><td style="text-align:left">在两值之间</td><td style="text-align:left">&gt;=min&amp;&amp;&lt;=max</td></tr><tr><td style="text-align:left">NOT BETWEEN</td><td style="text-align:left">不在两值之间</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">IN</td><td style="text-align:left">在集合中</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">NOT IN</td><td style="text-align:left">不在集合中</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">&lt;=&gt;</td><td style="text-align:left">严格比较两个NULL值是否相等</td><td style="text-align:left">两个操作码均为NULL时，其所得值为1；而当一个操作码为NULL时，其所得值为0</td></tr><tr><td style="text-align:left">LIKE</td><td style="text-align:left">模糊匹配</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">REGEXP 或 RLIKE</td><td style="text-align:left">正则式匹配</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">IS NULL</td><td style="text-align:left">为空</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">IS NOT NULL</td><td style="text-align:left">不为空</td><td style="text-align:left"></td></tr></tbody></table><h6 id="1）等于">1）等于</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select 2&#x3D;3;<br>+-----+<br>| 2&#x3D;3 |<br>+-----+<br>|   0 |<br>+-----+<br><br><br>mysql&gt; select NULL &#x3D; NULL;<br>+-------------+<br>| NULL &#x3D; NULL |<br>+-------------+<br>|        NULL |<br>+-------------+<br></code></pre></td></tr></table></figure><h6 id="2）不等于">2）不等于</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select 2&lt;&gt;3;<br>+------+<br>| 2&lt;&gt;3 |<br>+------+<br>|    1 |<br>+------+<br></code></pre></td></tr></table></figure><h6 id="3）安全等于">3）安全等于</h6><p>与 <strong>=</strong> 的区别在于当两个操作码均为 NULL 时，其所得值为 1 而不为 NULL，而当一个操作码为 NULL 时，其所得值为 0而不为 NULL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select 2&lt;&#x3D;&gt;3;<br>+-------+<br>| 2&lt;&#x3D;&gt;3 |<br>+-------+<br>|     0 |<br>+-------+<br><br><br>mysql&gt; select null&#x3D;null;<br>+-----------+<br>| null&#x3D;null |<br>+-----------+<br>|      NULL |<br>+-----------+<br><br>        <br>mysql&gt; select null&lt;&#x3D;&gt;null;<br>+-------------+<br>| null&lt;&#x3D;&gt;null |<br>+-------------+<br>|           1 |<br>+-------------+<br></code></pre></td></tr></table></figure><h6 id="4）小于">4）小于</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select 2&lt;3;<br>+-----+<br>| 2&lt;3 |<br>+-----+<br>|   1 |<br>+-----+<br></code></pre></td></tr></table></figure><h6 id="5）小于等于">5）小于等于</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select 2&lt;&#x3D;3;<br>+------+<br>| 2&lt;&#x3D;3 |<br>+------+<br>|    1 |<br>+------+<br></code></pre></td></tr></table></figure><h6 id="6）大于">6）大于</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select 2&gt;3;<br>+-----+<br>| 2&gt;3 |<br>+-----+<br>|   0 |<br>+-----+<br></code></pre></td></tr></table></figure><h6 id="7）大于等于">7）大于等于</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select 2&gt;&#x3D;3;<br>+------+<br>| 2&gt;&#x3D;3 |<br>+------+<br>|    0 |<br>+------+<br></code></pre></td></tr></table></figure><h6 id="8）BETWEEN">8）BETWEEN</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select 5 between 1 and 10;<br>+--------------------+<br>| 5 between 1 and 10 |<br>+--------------------+<br>|                  1 |<br>+--------------------+<br></code></pre></td></tr></table></figure><h6 id="9）IN">9）IN</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select 5 in (1,2,3,4,5);<br>+------------------+<br>| 5 in (1,2,3,4,5) |<br>+------------------+<br>|                1 |<br>+------------------+<br></code></pre></td></tr></table></figure><h6 id="10）NOT-IN">10）NOT IN</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select 5 not in (1,2,3,4,5);<br>+----------------------+<br>| 5 not in (1,2,3,4,5) |<br>+----------------------+<br>|                    0 |<br>+----------------------+<br></code></pre></td></tr></table></figure><h6 id="11）IS-NULL">11）IS NULL</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select null is NULL;<br>+--------------+<br>| null is NULL |<br>+--------------+<br>|            1 |<br>+--------------+<br><br>mysql&gt; select &#39;a&#39; is NULL;<br>+-------------+<br>| &#39;a&#39; is NULL |<br>+-------------+<br>|           0 |<br>+-------------+<br></code></pre></td></tr></table></figure><h6 id="12）IS-NOT-NULL">12）IS NOT NULL</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select null IS NOT NULL;<br>+------------------+<br>| null IS NOT NULL |<br>+------------------+<br>|                0 |<br>+------------------+<br><br>        <br>mysql&gt; select &#39;a&#39; IS NOT NULL;<br>+-----------------+<br>| &#39;a&#39; IS NOT NULL |<br>+-----------------+<br>|               1 |<br>+-----------------+<br></code></pre></td></tr></table></figure><h6 id="13、LIKE">13、LIKE</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select &#39;12345&#39; like &#39;12%&#39;;<br>+--------------------+<br>| &#39;12345&#39; like &#39;12%&#39; |<br>+--------------------+<br>|                  1 |<br>+--------------------+<br><br>mysql&gt; select &#39;12345&#39; like &#39;12_&#39;;<br>+--------------------+<br>| &#39;12345&#39; like &#39;12_&#39; |<br>+--------------------+<br>|                  0 |<br>+--------------------+<br></code></pre></td></tr></table></figure><h6 id="14、REGEXP">14、REGEXP</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select &#39;beijing&#39; REGEXP &#39;jing&#39;;<br>+-------------------------+<br>| &#39;beijing&#39; REGEXP &#39;jing&#39; |<br>+-------------------------+<br>|                       1 |<br>+-------------------------+<br><br>mysql&gt; select &#39;beijing&#39; REGEXP &#39;xi&#39;;<br>+-----------------------+<br>| &#39;beijing&#39; REGEXP &#39;xi&#39; |<br>+-----------------------+<br>|                     0 |<br>+-----------------------+<br></code></pre></td></tr></table></figure><h3 id="（3）逻辑运算符">（3）逻辑运算符</h3><p><strong>逻辑运算符用来判断表达式的真假。如果表达式是真，结果返回 1。如果表达式是假，结果返回 0。</strong></p><table><thead><tr><th style="text-align:left">运算符号</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">NOT 或 !</td><td style="text-align:left">逻辑非</td></tr><tr><td style="text-align:left">AND</td><td style="text-align:left">逻辑与</td></tr><tr><td style="text-align:left">OR</td><td style="text-align:left">逻辑或</td></tr><tr><td style="text-align:left">XOR</td><td style="text-align:left">逻辑异或</td></tr></tbody></table><h6 id="1）与">1）与</h6><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; select 2 and 0;<br><span class="hljs-code">+---------+</span><br>| 2 and 0 |<br><span class="hljs-code">+---------+</span><br>|       0 |<br><span class="hljs-code">+---------+</span><br><br><span class="hljs-code">        </span><br>mysql&gt; select 2 and 1;   <br><span class="hljs-code">+---------+</span>     <br>| 2 and 1 |      <br><span class="hljs-code">+---------+</span>      <br>|       1 |      <br><span class="hljs-code">+---------+</span><br></code></pre></td></tr></table></figure><h6 id="2）或">2）或</h6><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; select 2 or 0;<br><span class="hljs-code">+--------+</span><br>| 2 or 0 |<br><span class="hljs-code">+--------+</span><br>|      1 |<br><span class="hljs-code">+--------+</span><br><br>mysql&gt; select 2 or 1;<br><span class="hljs-code">+--------+</span><br>| 2 or 1 |<br><span class="hljs-code">+--------+</span><br>|      1 |<br><span class="hljs-code">+--------+</span><br><br>mysql&gt; select 0 or 0;<br><span class="hljs-code">+--------+</span><br>| 0 or 0 |<br><span class="hljs-code">+--------+</span><br>|      0 |<br><span class="hljs-code">+--------+</span><br><br>mysql&gt; select 1 || 0;<br><span class="hljs-code">+--------+</span><br>| 1 || 0 |<br><span class="hljs-code">+--------+</span><br>|      1 |<br><span class="hljs-code">+--------+</span><br></code></pre></td></tr></table></figure><h6 id="3）非">3）非</h6><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; select not 1;<br><span class="hljs-code">+-------+</span><br>| not 1 |<br><span class="hljs-code">+-------+</span><br>|     0 |<br><span class="hljs-code">+-------+</span><br><br>mysql&gt; select !0;<br><span class="hljs-code">+----+</span><br>| !0 |<br><span class="hljs-code">+----+</span><br>|  1 |<br><span class="hljs-code">+----+</span><br></code></pre></td></tr></table></figure><h6 id="4）异或（其他数字只能与0比较）">4）异或（其他数字只能与0比较）</h6><p>当任意一个操作数为NULL时,返回值为NULL，对于非NULL的操作数,如果两个的逻辑真假值相异，则返回结果为1，否则为0。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; select 1 xor 1;<br><span class="hljs-code">+---------+</span><br>| 1 xor 1 |<br><span class="hljs-code">+---------+</span><br>|       0 |<br><span class="hljs-code">+---------+</span><br><br>mysql&gt; select 0 xor 0;<br><span class="hljs-code">+---------+</span><br>| 0 xor 0 |<br><span class="hljs-code">+---------+</span><br>|       0 |<br><span class="hljs-code">+---------+</span><br><br>mysql&gt; select 1 xor 0;<br><span class="hljs-code">+---------+</span><br>| 1 xor 0 |<br><span class="hljs-code">+---------+</span><br>|       1 |<br><span class="hljs-code">+---------+</span><br><br>mysql&gt; select null or 1;<br><span class="hljs-code">+-----------+</span><br>| null or 1 |<br><span class="hljs-code">+-----------+</span><br>|         1 |<br><span class="hljs-code">+-----------+</span><br><br>mysql&gt; select 1 ^ 0;<br><span class="hljs-code">+-------+</span><br>| 1 ^ 0 |<br><span class="hljs-code">+-------+</span><br>|     1 |<br><span class="hljs-code">+-------+</span><br></code></pre></td></tr></table></figure><h3 id="（4）位运算符">（4）位运算符</h3><p>位运算符是在二进制数上进行计算的运算符。位运算会先将操作数变成二进制数，进行位运算。然后再将计算结果从二进制数变回十进制数。</p><table><thead><tr><th style="text-align:left">运算符号</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">&amp;</td><td style="text-align:left">按位与</td></tr><tr><td style="text-align:left">|</td><td style="text-align:left">按位或</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">按位异或</td></tr><tr><td style="text-align:left">!</td><td style="text-align:left">取反</td></tr><tr><td style="text-align:left">&lt;&lt;</td><td style="text-align:left">左移</td></tr><tr><td style="text-align:left">&gt;&gt;</td><td style="text-align:left">右移</td></tr></tbody></table><h6 id="1）按位与">1）按位与</h6><p>对应的二进制位都为 1 ，则该位的运算结果为 1 ，否则为 0。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; select 3&amp;5;<br><span class="hljs-code">+-----+</span><br>| 3&amp;5 |<br><span class="hljs-code">+-----+</span><br>|   1 |<br><span class="hljs-code">+-----+</span><br></code></pre></td></tr></table></figure><h6 id="2）按位或">2）按位或</h6><p>对应的二进制位有一个或两个为 1 ，则该位的运算结果为 1 ，否则为 0。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">mysql&gt; SELECT <span class="hljs-number">10</span> | <span class="hljs-number">15</span> , <span class="hljs-number">9</span> | <span class="hljs-number">4</span> | <span class="hljs-number">2</span> ;<br>+---------+-----------+<br>| <span class="hljs-number">10</span> | <span class="hljs-number">15</span> | <span class="hljs-number">9</span> | <span class="hljs-number">4</span> | <span class="hljs-number">2</span> | # <span class="hljs-number">10</span>的二进制为<span class="hljs-number">1010</span>,<span class="hljs-number">15</span>的二进制为<span class="hljs-number">1111</span>，按位或运算之后结果为<br><span class="hljs-number">1111</span>，即<span class="hljs-number">15</span><br>+---------+-----------+ # <span class="hljs-number">9</span>的二进制为<span class="hljs-number">1001</span>,<span class="hljs-number">4</span>为<span class="hljs-number">0100</span>,<span class="hljs-number">2</span>的二进制为<span class="hljs-number">0010</span>，按位或运算之后<br><span class="hljs-number">1111</span><br>| <span class="hljs-number">15</span> | <span class="hljs-number">15</span> |<br>+---------+-----------+<br></code></pre></td></tr></table></figure><h6 id="3）按位异或">3）按位异或</h6><p>对应的二进制位不相同时，结果为 1，否则为 0。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; select 3^5;<br><span class="hljs-code">+-----+</span><br>| 3^5 |<br><span class="hljs-code">+-----+</span><br>|   6 |<br><span class="hljs-code">+-----+</span><br></code></pre></td></tr></table></figure><h6 id="4）按位取反">4）按位取反</h6><p><strong>将对应的二进制数逐位反转，即 1 取反后变 0 ，0 取反后变 1。</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; select ~18446744073709551612;<br><span class="hljs-code">+-----------------------+</span><br>| ~18446744073709551612 |<br><span class="hljs-code">+-----------------------+</span><br>|                     3 |<br><span class="hljs-code">+-----------------------+</span><br></code></pre></td></tr></table></figure><h6 id="5）按位右移">5）按位右移</h6><p><strong>使指定的二进制位都右移指定的位数，右移指定位之后，右边低位的数值将被移出并丢弃，左边高位空出的职位用 0 补齐。</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; select 3&gt;&gt;1;<br><span class="hljs-code">+------+</span><br>| 3&gt;&gt;1 |<br><span class="hljs-code">+------+</span><br>|    1 |<br><span class="hljs-code">+------+</span><br></code></pre></td></tr></table></figure><h6 id="6）按位左移">6）按位左移</h6><p><strong>使指定的二进制位都左移指定的位数，左移指定位之后，左边高位的数值将被移出并丢弃，右边低位空出的位置用 0 补齐。</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; select 3&lt;&lt;1;<br><span class="hljs-code">+------+</span><br>| 3&lt;&lt;1 |<br><span class="hljs-code">+------+</span><br>|    6 |<br><span class="hljs-code">+------+</span><br></code></pre></td></tr></table></figure><h3 id="（5）运算符优先级">（5）运算符优先级</h3><p><strong>最低优先级为： :=。</strong></p><p>![image-20200613115948741](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200613115948741.png)</p><p><strong>最高优先级为： !、BINARY、 COLLATE。</strong></p><h1>三、小练习</h1><h2 id="1、导入数据库">1、导入数据库</h2><p>![image-20200609171913909](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200609171913909.png)</p><p>![image-20200609171943656](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200609171943656.png)</p><p>![image-20200609172002895](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200609172002895.png)</p><h2 id="2、grade添加数据">2、grade添加数据</h2><p>![image-20200609172219791](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200609172219791.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from student;<br>select studentNo as 学号,studentName as 姓名,sex as 性别,<br>gradeId as 年级编号,bornDate as 出生日期<br>from student;<br></code></pre></td></tr></table></figure><p>![image-20200609172714342](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200609172714342.png)</p><p>![image-20200609172657559](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200609172657559.png)</p><p>![image-20200609172730224](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200609172730224.png)</p><h2 id="3、两表联查">3、两表联查</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 两表联查<br>select * from grade;<br>select * from student,grade;<br><br>select * from student,grade where grade.gradeID &#x3D; student.gradeId;<br></code></pre></td></tr></table></figure><p>![image-20200613123717083](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200613123717083.png)</p><h3 id="示例1：-3">示例1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 逗号+WHERE<br>select <br>studentNo as 学号,<br>studentName as 姓名,<br>sex as 性别,<br>gradeName as 年级,<br>bornDate as 出生日期<br>from student as s,grade as g<br>where g.gradeID &#x3D; s.gradeId;<br></code></pre></td></tr></table></figure><p>![image-20200609173647871](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200609173647871.png)</p><h3 id="示例2：-3">示例2：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># join+on<br>select <br>studentNo as 学号,<br>studentName as 姓名,<br>sex as 性别,<br>gradeName as 年级,<br>bornDate as 出生日期<br>from student as s<br>join grade as g<br>on g.gradeID &#x3D; s.gradeId;<br></code></pre></td></tr></table></figure><p>![image-20200613123857349](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200613123857349.png)</p><h2 id="4、模糊查询某学生的信息">4、模糊查询某学生的信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 查询某学生的信息<br>select * from student where studentName &#x3D; &#39;郭靖&#39;;<br>select * from student where studentName like &#39;%郭%&#39;;<br>select * from student where studentName like &#39;%靖&#39;;<br>select * from student where studentName like &#39;郭%&#39;;<br></code></pre></td></tr></table></figure><p>![image-20200613124019868](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200613124019868.png)</p><h2 id="5、排序">5、排序</h2><h3 id="降序">降序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 降序<br>select * from student ORDER BY studentNo desc;<br></code></pre></td></tr></table></figure><p>![image-20200613124251255](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200613124251255.png)</p><h3 id="升序">升序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 升序<br>select * from student ORDER BY studentNo asc;<br></code></pre></td></tr></table></figure><p>![image-20200613124257120](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200613124257120.png)</p><h2 id="6、分组">6、分组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 分组: 只有聚会的数和参与了分组的字段能够出现在select语句后面<br>select sex,count(1) from student GROUP BY sex;<br></code></pre></td></tr></table></figure><p>![image-20200613124341995](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200613124341995.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 分组后再筛选数据<br>select count(1),sex<br>from student<br>GROUP BY sex<br>having sex&#x3D;&#39;男&#39;;<br></code></pre></td></tr></table></figure><p>![image-20200613124412250](G:\四期\数据库\mysql文档\04 MySQL数据插入和复制.assets\image-20200613124412250.png)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># AND<br>select * from student where sex&#x3D;&#39;男&#39; and studentName&#x3D;&#39;李文才&#39;;<br>+-----------+----------+-------------+-----+---------+-------------+----------+---------------------+-------+--------------+<br>| studentNo | loginPwd | studentName | sex | gradeId | phone       | address  | bornDate            | email | identityCard |<br>+-----------+----------+-------------+-----+---------+-------------+----------+---------------------+-------+--------------+<br>|     10001 | 123      | 李文才      | 男  |       1 | 13645667890 | 地址不详 | 1994-04-12 00:00:00 | NULL  | NULL         |<br>+-----------+----------+-------------+-----+---------+-------------+----------+---------------------+-------+--------------+<br>1 row in set (0.00 sec)<br># OR<br>select * from student where sex&#x3D;&#39;男&#39; or studentName&#x3D;&#39;李文才&#39;;<br>+-----------+----------+-------------+-----+---------+-------------+--------------+---------------------+-------+--------------+<br>| studentNo | loginPwd | studentName | sex | gradeId | phone       | address      | bornDate            | email | identityCard |<br>+-----------+----------+-------------+-----+---------+-------------+--------------+---------------------+-------+--------------+<br>|     10000 | 123      | 郭靖        | 男  |       1 | 13645667783 | 天津市河西区 | 1990-09-08 00:00:00 | NULL  | NULL         |<br>|     10001 | 123      | 李文才      | 男  |       1 | 13645667890 | 地址不详     | 1994-04-12 00:00:00 | NULL  | NULL         |<br>|     10002 | 123      | 李斯文      | 男  |       1 | 13645556793 | 河南洛阳     | 1993-07-23 00:00:00 | NULL  | NULL         |<br>|     10007 | 123      | 秦洋        | 男  |       1 | 13056434411 | 上海市卢湾区 | 1992-04-18 00:00:00 | NULL  | NULL         |<br>|     20000 | 123      | 王宝宝      | 男  |       2 | 15076552323 | 地址不详     | 1996-06-05 00:00:00 | NULL  | NULL         |<br>|     30011 | 123      | 陈志强      | 男  |       3 | 13689965430 | 地址不详     | 1994-09-27 00:00:00 | NULL  | NULL         |<br>+-----------+----------+-------------+-----+---------+-------------+--------------+---------------------+-------+--------------+<br># &#x3D;<br>select * from student where sex&lt;&gt;&#39;男&#39;;<br>+-----------+----------+-------------+-----+---------+-------------+----------------+---------------------+-------+--------------+<br>| studentNo | loginPwd | studentName | sex | gradeId | phone       | address        | bornDate            | email | identityCard |<br>+-----------+----------+-------------+-----+---------+-------------+----------------+---------------------+-------+--------------+<br>|     10003 | 123      | 张萍        | 女  |       1 | 13642345112 | 地址不详       | 1995-06-10 00:00:00 | NULL  | NULL         |<br>|     10004 | 123      | 韩秋洁      | 女  |       1 | 13812344566 | 北京市海淀区   | 1995-07-15 00:00:00 | NULL  | NULL         |<br>|     10005 | 123      | 张秋丽      | 女  |       1 | 13567893246 | 北京市东城区   | 1994-01-17 00:00:00 | NULL  | NULL         |<br>|     10006 | 123      | 肖梅        | 女  |       1 | 13563456721 | 河北省石家庄市 | 1991-02-17 00:00:00 | NULL  | NULL         |<br>|     10008 | 123      | 何睛睛      | 女  |       1 | 13053445221 | 广州市天河区   | 1997-07-23 00:00:00 | NULL  | NULL         |<br>|     20010 | 123      | 何小华      | 女  |       2 | 13318877954 | 地址不详       | 1995-09-10 00:00:00 | NULL  | NULL         |<br>|     30012 | 123      | 李露露      | 女  |       3 | 13685678854 | 地址不详       | 1992-09-27 00:00:00 | NULL  | NULL         |<br>+-----------+----------+-------------+-----+---------+-------------+----------------+---------------------+-------+--------------+<br>7 rows in set (0.00 sec)<br># &lt;&gt;<br>select * from student where bornDate&lt;&#39;1991&#39;;<br>+-----------+----------+-------------+-----+---------+-------------+--------------+---------------------+-------+--------------+<br>| studentNo | loginPwd | studentName | sex | gradeId | phone       | address      | bornDate            | email | identityCard |<br>+-----------+----------+-------------+-----+---------+-------------+--------------+---------------------+-------+--------------+<br>|     10000 | 123      | 郭靖        | 男  |       1 | 13645667783 | 天津市河西区 | 1990-09-08 00:00:00 | NULL  | NULL         |<br>+-----------+----------+-------------+-----+---------+-------------+--------------+---------------------+-------+--------------+<br>1 row in set, 1 warning (0.00 sec)<br><br>select * from student;<br>where  select DATEDIFF(NOW(),&#39;1991-1-1&#39;)&#x2F;365;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql结构化查询语句 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的增删改查</title>
      <link href="/posts/edab.html"/>
      <url>/posts/edab.html</url>
      
        <content type="html"><![CDATA[<h1>MySQL高级查询</h1><h3 id="学习目的">学习目的</h3><ul><li><strong>使用SQL语句为成绩表添加主、外键</strong></li><li><strong>使用SQL语句实现数据添加、修改、查询</strong></li><li><strong>查询指定学生考试成绩</strong></li><li><strong>查询某学期开设的课程</strong></li><li><strong>查询某课程最近一次考试缺考的学生名单</strong></li></ul><h1>一、RDBMS 术语</h1><ul><li><p><strong>数据库: 数据库是一些关联表的集合。</strong></p></li><li><p><strong>数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</strong></p></li><li><p><strong>列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</strong></p></li><li><p><strong>行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</strong></p></li><li><p><strong>冗余：存储两倍数据，冗余可以使系统速度更快。</strong></p></li><li><p><strong>主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</strong></p></li><li><p><strong>外键：外键用于关联两个表。</strong></p></li><li><p><strong>复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</strong></p></li><li><p><strong>索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</strong></p></li><li><p><strong>参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</strong></p></li></ul><blockquote><p><strong>数据库的主键代表了唯一标示一条数据，所以主键是唯一的，比如学号，卡号之类的；<br>数据库的外键是为了保证数据库的一致性，假设表1中的一个外键是表2的主键，此时要在表2中插入一条数据时就必须查看（这条数据，也就是表2的那个主键的信息在表1中是否存在，如果不存在则无法插入），而当你需要在表1中删除一条信息是，如果在表2中还存在这个数据的话也是无法直接删除的。</strong></p></blockquote><h1>二、增删改查操作</h1><h2 id="1、创建一个操作表">1、创建一个操作表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#创建数据库<br>cerate database test_mysql;<br><br>#进入数据库<br>use test_mysql;<br><br>#创建表<br>CREATE TABLE &#96;ttt&#96;(<br>true&#96;sid&#96; int(4) not null key auto_increment,<br>true&#96;sname&#96; varchar(20) default&#39;姓名不详&#39; not null<br>)<br></code></pre></td></tr></table></figure><h3 id="查看一下">查看一下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">desc ttt;<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605101421451.png" alt="image-20200605101421451"></p><h2 id="2、修改表名">2、修改表名</h2><h4 id="语法：">语法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table 旧表名 rename 新表名;<br></code></pre></td></tr></table></figure><h3 id="操作">操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 修改表名<br>alter table ttt rename teacher;<br></code></pre></td></tr></table></figure><h4 id="查看一下-2">查看一下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查看表<br>show tables;<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605101627941.png" alt="image-20200605101627941"></p><h2 id="3、添加列">3、添加列</h2><h4 id="语法">语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 添加字段<br>alter table 表名 add 字段名 数据类型[属性];<br></code></pre></td></tr></table></figure><h3 id="操作-2">操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#添加列<br>alter table teacher add &#96;sex&#96; char(2);<br></code></pre></td></tr></table></figure><h4 id="查看一下-3">查看一下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">desc teacher;<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605101745339.png" alt="image-20200605101745339"></p><h2 id="4、修改列">4、修改列</h2><h4 id="语法-2">语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 修改字段<br>alter table 表名 CHANGE 原字段名 新字段名 数据类型[属性];<br></code></pre></td></tr></table></figure><h3 id="操作-3">操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#修改列中 sex修改为gender 类型改为char(2)<br>alter table teacher CHANGE &#96;sex&#96; &#96;gender&#96; char(2);<br></code></pre></td></tr></table></figure><h4 id="查看一下-4">查看一下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查看表内容<br>desc teacher;<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605102039580.png" alt="image-20200605102039580"></p><h2 id="4、删除字段">4、删除字段</h2><h4 id="语法-3">语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 删除字段<br>alter table 表名 drop 字段名;<br></code></pre></td></tr></table></figure><h3 id="操作-4">操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table teacher drop gender;<br></code></pre></td></tr></table></figure><h4 id="查看一下-5">查看一下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#查看表内容<br>desc teacher;<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605102507400.png" alt="image-20200605102507400"></p><h1>三、主键和外键</h1><h2 id="1、SQL-的主键和外键的作用：">1、SQL 的主键和外键的作用：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">外键取值规则：空值或参照的主键值<br>(1)插入非空值时，如果主键值中没有这个值，则不能插入。<br>(2)更新时，不能改为主键表中没有的值。<br>(3)删除主键表记录时，可以在建外键时选定外键记录一起联删除还是拒绝删除。<br>(4)更新主键记录时，同样有级联更新和拒绝执行的选择。<br></code></pre></td></tr></table></figure><h2 id="2、创建一个表">2、创建一个表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table grade(<br>true&#96;gradeID&#96; int(4) not null,<br>true&#96;gredName&#96; varchar(20) not null<br>);<br></code></pre></td></tr></table></figure><h3 id="查看一下-6">查看一下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">desc grade;<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605103033488.png" alt="image-20200605103033488"></p><h2 id="3、创建主键">3、创建主键</h2><h3 id="（1）语法">（1）语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 ADD CONSTRAINT主键名<br>PRIMARY KEY 表名(主键字段);<br></code></pre></td></tr></table></figure><h3 id="（2）创建">（2）创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table grade add CONSTRAINT pk_grade<br>PRIMARY key grage(&#96;gradeID&#96;);<br></code></pre></td></tr></table></figure><h4 id="查看一下-7">查看一下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">desc grade;<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605103511778.png" alt="image-20200605103511778"></p><h2 id="4、添加外键">4、添加外键</h2><p><strong>外键（从表）：可以增加数据的完整性与准确性</strong></p><h3 id="（1）语法-2">（1）语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 ADD CONSTRAINT 外键名<br>FOREIGN KEY (外键字段)<br>REFERENCES 关联表名 (关联字段) ;<br></code></pre></td></tr></table></figure><h3 id="（2）创建一个表">（2）创建一个表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table student(<br>true&#96;sid&#96; int(4) not null PRIMARY KEY,<br>true&#96;sname&#96; VARCHAR(50) not null,<br>true&#96;gradeID&#96; int(4) not null,<br>    &#96;sex&#96; char(2) comment &#39;性别&#39;,<br>);<br></code></pre></td></tr></table></figure><h4 id="查看一下-8">查看一下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">desc student;<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605104455408.png" alt="image-20200605104455408"></p><h3 id="（3）创建外键">（3）创建外键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table student add CONSTRAINT fk_student_grade<br>FOREIGN KEY (&#96;gradeID&#96;)<br>REFERENCES &#96;grade&#96;(&#96;gradeID&#96;);<br></code></pre></td></tr></table></figure><h4 id="查看一下-9">查看一下</h4><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605110110783.png" alt="image-20200605110110783"></p><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605110133352.png" alt="image-20200605110133352"></p><h2 id="5、测试">5、测试</h2><h3 id="（1）grade表添加内容">（1）grade表添加内容</h3><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605110608079.png" alt="image-20200605110608079"></p><h3 id="（2）student表添加内容">（2）student表添加内容</h3><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605110914599.png" alt="image-20200605110914599"></p><p><strong>所以我们添加数值不要超过主表设置的默认值。</strong></p><h1>四、练习</h1><h2 id="1、需求说明">1、需求说明</h2><p><strong>在test数据库中创建person表</strong></p><table><thead><tr><th>字段名称</th><th>字段说明</th><th>数据类型</th><th>长度</th><th>属性</th></tr></thead><tbody><tr><td>number</td><td>序号</td><td>INT</td><td>4</td><td>自增列</td></tr><tr><td>name</td><td>姓名</td><td>VARCHAR</td><td>50</td><td>非空</td></tr><tr><td>sex</td><td>性别</td><td>CHAR</td><td>2</td><td></td></tr><tr><td>bornDate</td><td>出生日期</td><td>DATETIME</td><td></td><td></td></tr></tbody></table><ul><li><strong>将表名修改为tb_person</strong></li><li><strong>删除出生日期字段</strong></li><li><strong>添加出生日期字段, 数据类型为DATE类型</strong></li><li><strong>修改序号字段名(number) 为id,类型为BIGINT类型</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table person(<br>true&#96;number&#96; int(4) comment &#39;序号&#39; key auto_increment,<br>    &#96;name&#96; varchar(50) comment &#39;姓名&#39; not null,<br>    &#96;sex&#96; char(2) comment &#39;性别&#39;,<br>    &#96;bornDarte&#96; datetime(0) comment &#39;出生日期&#39;<br>);<br><br># 修改表名<br>alter table person rename tb_person;<br># 删除字段<br>alter table tb_person drop &#96;bornDarte&#96;;<br># 添加列<br>alter table tb_person add &#96;bornDarte&#96; date;<br># 修改表中字段名<br>alter table tb_person change number id bigint;<br><br># 查看表结构<br>desc tb_person;<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605111552071.png" alt="image-20200605111552071"></p><h2 id="2、需求说明-result表需要添加的内容">2、需求说明 result表需要添加的内容</h2><ul><li><strong>主键约束:学号、课程编号和日期构成组合主键.</strong></li><li><strong>外键约束:主表student和从表result通过studentNo字段建立主外键关联</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 主键<br>create table result(<br>true&#96;studentNo&#96; int(4) comment &#39;学号&#39;,<br>true&#96;subjedctNo&#96; int(4) comment &#39;课程编号&#39;,<br>true&#96;examDate&#96; datetime comment &#39; 日期&#39;<br>)charset&#x3D;&#39;utf8&#39;;<br><br>alter table result add CONSTRAINT PK_result<br>PRIMARY key result(&#96;studentNo&#96;,&#96;subjedctNo&#96;,&#96;examDate&#96;);<br><br>desc result;<br><br># 外键<br>create table student(<br>true&#96;sid&#96; int(4) not null PRIMARY KEY,<br>true&#96;sname&#96; VARCHAR(50) not null,<br>true&#96;studentNo&#96; int(4) not null<br>);<br><br>alter table student add CONSTRAINT fk_student_result<br>FOREIGN key (&#96;studentNo&#96;)<br>REFERENCES &#96;result&#96;(&#96;studentNo&#96;);<br>desc student;<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605111909945.png" alt="image-20200605111909945"></p><h3 id="查看一下外键">查看一下外键</h3><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605110110783.png" alt="image-20200605110110783"></p><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200605111958631.png" alt="image-20200605111958631"></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql结构化查询语句 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的建库、建表、建约束与存储引擎</title>
      <link href="/posts/1d95.html"/>
      <url>/posts/1d95.html</url>
      
        <content type="html"><![CDATA[<h1>一、MySQL建库、建表</h1><h2 id="1、创建数据库">1、创建数据库</h2><p><strong>创建数据库是在系统磁盘上划分⼀块区域用于数据的存储和管理，如果管理员在设置权限的时候为用户创建了数据库，则可以直接使用，否则，需要自己创建数据库。</strong></p><h5 id="语法格式：">语法格式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE [IF NOT EXISTS] 数据库名<br></code></pre></td></tr></table></figure><h5 id="示例：">示例：</h5><p><strong>IF NOT EXISTS：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。</strong><br><strong>此选项可以用来避免数据库已经存在而重复创建的错误。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建myschool数据库<br>create database myschool;<br></code></pre></td></tr></table></figure><p><strong>IF NOT EXISTS：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。</strong><br><strong>此选项可以用来避免数据库已经存在而重复创建的错误。</strong></p><h2 id="2、创建表">2、创建表</h2><h4 id="语法格式：-2">语法格式：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE [IF NOT EXISTS] 表名 (<br>字段1 数据类型 [字段属性|约束][索引][注释],<br>……<br>字段n 数据类型 [字段属性|约束][索引][注释]<br>)[表类型][表字符集][注释];<br></code></pre></td></tr></table></figure><h4 id="示例：-2">示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#创建学生表<br>CREATE TABLE &#96;student&#96;（<br>&#96;studentNo&#96; INT(4) PRIMARY KEY,<br>&#96; name&#96; CHAR(10),<br>……）;<br></code></pre></td></tr></table></figure><h4 id="注意：">注意：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">多字段使用逗号分隔<br>保留字用撇号括起来<br>单行注释：#……<br>多行注释：&#x2F;*……*&#x2F;<br></code></pre></td></tr></table></figure><h3 id="（1）字段的约束及属性">（1）字段的约束及属性</h3><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200603202656986.png" alt="image-20200603202656986"></p><h4 id="主键">主键</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE student（<br>&#96;studentNo&#96; INT(4) PRIMARY KEY,<br>……）;<br></code></pre></td></tr></table></figure><h4 id="注释">注释</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE test (<br>&#96;id&#96; int(11) UNSIGNED COMMENT ‘编号’<br>)COMMENT&#x3D;&#39;测试表’ ;<br></code></pre></td></tr></table></figure><h4 id="设置字符集编码">设置字符集编码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE [IF NOT EXISTS] 表名（<br>#省略代码<br>）CHARSET &#x3D; 字符集名;<br></code></pre></td></tr></table></figure><h3 id="（2）在myschool数据库中创建学生表">（2）在myschool数据库中创建学生表</h3><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200603202824035.png" alt="image-20200603202824035"></p><h4 id="所需执行的命令">所需执行的命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create databases myschool;<br>use myschool;<br>create table student(<br>true&#96;studentNo&#96; int(4) not null comment &#39;学号&#39; primary key,<br>true&#96;loginPwd&#96; varchar(20) not null comment &#39;密码&#39;,<br>true&#96;studentName&#96; varchar(50) not null comment &#39;姓名&#39;,<br>true&#96;sex&#96; char(2) not null default &#39;男&#39; comment &#39;性别&#39;,<br>true&#96;gradeID&#96; int(4) unsigned comment &#39;年级编号&#39;,<br>true&#96;phone&#96; varchar(50) comment &#39;电话&#39;,<br>true&#96;address&#96; varchar(255) default &#39;地址不详&#39; comment &#39;地址&#39;,<br>true&#96;bornDate&#96; datetime comment &#39;出生日期&#39;,<br>true&#96;email&#96; varchar(50) comment &#39;邮件账号&#39;,<br>true&#96;identityCard&#96; varchar(18) comment &#39;身份证号&#39; unique key<br>)charset&#x3D;&#39;utf8&#39; comment&#x3D;&#39;学生表&#39;;<br></code></pre></td></tr></table></figure><h4 id="查看一下表结构">查看一下表结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; desc student;<br>+--------------+-----------------+------+-----+----------+-------+<br>| Field        | Type            | Null | Key | Default  | Extra |<br>+--------------+-----------------+------+-----+----------+-------+<br>| studentNo    | int(4)          | NO   | PRI | NULL     |       |<br>| loginPwd     | varchar(20)     | NO   |     | NULL     |       |<br>| studentName  | varchar(50)     | NO   |     | NULL     |       |<br>| sex          | char(2)         | NO   |     | 男       |       |<br>| gradeID      | int(4) unsigned | YES  |     | NULL     |       |<br>| phone        | varchar(50)     | YES  |     | NULL     |       |<br>| address      | varchar(255)    | YES  |     | 地址不详 |       |<br>| bornDate     | datetime        | YES  |     | NULL     |       |<br>| email        | varchar(50)     | YES  |     | NULL     |       |<br>| identityCard | varchar(18)     | YES  | UNI | NULL     |       |<br>+--------------+-----------------+------+-----+----------+-------+<br>10 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="3、查看表">3、查看表</h2><h3 id="（1）查看表是否存在">（1）查看表是否存在</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use myschool;<br>show tables;<br></code></pre></td></tr></table></figure><h3 id="（2）查看表定义">（2）查看表定义</h3><h4 id="语法格式：-3">语法格式：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use myschool;<br>desc &#96;student&#96;;<br></code></pre></td></tr></table></figure><h4 id="示例：-3">示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use myschool;<br>desc &#96;student&#96;;<br></code></pre></td></tr></table></figure><h2 id="4、删除表">4、删除表</h2><h4 id="语法格式：-4">语法格式：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop table [if exists] 表名;<br></code></pre></td></tr></table></figure><h4 id="示例：-4">示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use myschool;<br>drop table if exists &#96;student&#96;;<br></code></pre></td></tr></table></figure><h5 id="在删除表之前，先使用-if-exists-语句验证表是否存在">在删除表之前，先使用 if exists 语句验证表是否存在</h5><h2 id="5、删除数据库">5、删除数据库</h2><p><strong>删除数据库是将已经存在的数据库从磁盘空间上清除，清除之后，数据库中的所有数据也将除。</strong><br><strong>删除数据库语句和创建数据库的命令相似，MySQL中删除数据库的基本语法格式为：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop database if exists 数据库名;<br></code></pre></td></tr></table></figure><h4 id="示例：-5">示例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop database if exists myschool;<br></code></pre></td></tr></table></figure><h2 id="6、上机练习">6、上机练习</h2><h3 id="（1）myschool数据库中创建科目表-subject">（1）myschool数据库中创建科目表(subject)</h3><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200603211956316.png" alt="image-20200603211956316"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table subject(<br>    &#96;subjectNo&#96; int(4) comment &#39;课程编号&#39; primary key auto_increment,<br>    &#96;subjectName&#96; varchar(50) comment &#39;课程名称&#39;,<br>    &#96;classHour&#96; int(4) comment &#39;学时&#39;,<br>    &#96;gradeID&#96; int(4) comment &#39;年级编号&#39;<br>);<br></code></pre></td></tr></table></figure><h4 id="查看一下表结构-2">查看一下表结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; desc subject;<br>+-------------+-------------+------+-----+---------+----------------+<br>| Field       | Type        | Null | Key | Default | Extra          |<br>+-------------+-------------+------+-----+---------+----------------+<br>| subjectNo   | int(4)      | NO   | PRI | NULL    | auto_increment |<br>| subjectName | varchar(50) | YES  |     | NULL    |                |<br>| classHour   | int(4)      | YES  |     | NULL    |                |<br>| gradeID     | int(4)      | YES  |     | NULL    |                |<br>+-------------+-------------+------+-----+---------+----------------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h3 id="（2）myschool数据库中创建成绩表（result）">（2）myschool数据库中创建成绩表（result）</h3><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200603212010801.png" alt="image-20200603212010801"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table result(<br>    &#96;studentNo&#96; int(4) comment &#39;学号&#39; not null,<br>    &#96;subjectNo&#96; int(4) comment &#39;课程编号&#39; not null,<br>    &#96;examDate&#96; datetime(0) comment &#39;考试日期&#39; not null,<br>    &#96;studentResult&#96; int(4) comment &#39;考试成绩&#39; not null<br>);<br></code></pre></td></tr></table></figure><h4 id="查看一下表结构-3">查看一下表结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; desc result;<br>+---------------+----------+------+-----+---------+-------+<br>| Field         | Type     | Null | Key | Default | Extra |<br>+---------------+----------+------+-----+---------+-------+<br>| studentNo     | int(4)   | NO   |     | NULL    |       |<br>| subjectNo     | int(4)   | NO   |     | NULL    |       |<br>| examDate      | datetime | NO   |     | NULL    |       |<br>| studentResult | int(4)   | NO   |     | NULL    |       |<br>+---------------+----------+------+-----+---------+-------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h1>二、MySQL的存储引擎</h1><h2 id="1、存储引擎简介">1、存储引擎简介</h2><p><strong>数据库存储引擎是数据库底层软件组件，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更</strong><br><strong>新和删除数据操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能。使用不同的存</strong><br><strong>储引擎，还可以获得特定的功能。</strong><br><strong>现在许多不同的数据库管理系统都支持多种不同的数据引擎。MySQL的核心就是存储引擎。</strong></p><h2 id="2、存储引擎的类型">2、存储引擎的类型</h2><p><strong>mysql有多种存储引擎，它们分别为：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">MyISAM<br>InnoDB<br>MERGE<br>MEMORY<br>EXAMPLE<br>FEDERATED<br>ARCHIVE<br>CSV<br>BLACKHOLE<br></code></pre></td></tr></table></figure><h2 id="3、存储引擎的主要区别">3、存储引擎的主要区别</h2><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200603214932982.png" alt="image-20200603214932982"></p><h3 id="（1）MyISAM-存储引擎特点">（1）MyISAM 存储引擎特点</h3><ul><li><strong>MySQL 5.5 之前使用 MyISAM 引擎，MySQL 5.5 之后使用 InnoDB 引擎</strong></li><li><strong>MyISAM 引擎读取速度较快，占用资源相对较少，不支持事务，不支持外键约束，但支持全文索引</strong></li><li><strong>读写互相阻塞，也就是说读数据的时候你就不能写数据，写数据的时候你就不能读数据</strong></li><li><strong>MyISAM 引擎只能缓存索引，而不能缓存数据</strong></li></ul><h3 id="（2）InnoDB-存储引擎特点">（2）InnoDB 存储引擎特点</h3><ul><li><strong>事务型数据库的首选引擎，支持事务安全表，支持行锁定和外键，MySQL5.5.5 版本之后，InnoDB作为默认存储引擎</strong></li><li><strong>具有提交、回滚和崩溃恢复能力的事务安全存储引擎，能处理巨大数据量，性能及效率高，完全支持外键完整性约束</strong></li><li><strong>具有非常高效的缓存特性，能缓存索引也能缓存数据，对硬件要求比较高</strong></li><li><strong>使用InnoDB时，将在MySQL数据目录下创建一个名为ibdata1的10MB大小的自动扩展数据⽂文件，以及两个名为 ib_logfile0 和 ib_logfile1 的 5MB ⼤大⼩小的日志⽂文件</strong></li></ul><h3 id="（3）Memory-存储引擎特点">（3）Memory 存储引擎特点</h3><ul><li><strong>Memory存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问</strong></li><li><strong>Memory存储引擎执行 HASH 和 BTREE 索引，不支持 BLOB 和 TEXT 列，支持AUTO_INCREMENT列和对可包含 NULL 值得列的索引</strong></li><li><strong>当不再需要 Memory 表的内容时，要释放被 Memory 表使用的内存，应该执行DELETE FROM 或</strong><br><strong>TRUNCATE TABLE ，或者删除整个表</strong></li></ul><h2 id="4、存储引擎适用场合">4、存储引擎适用场合</h2><h3 id="（1）MyISAM-适⽤用场景">（1）MyISAM 适⽤用场景</h3><ul><li><strong>不需要事务支持的业务，例如：转账就不行</strong></li><li><strong>适用于读数据比较多的业务，不适用于读写频繁的业务</strong></li><li><strong>并发相对较低、数据修改相对较少的业务</strong></li><li><strong>硬件资源比较差的机器可以考虑使用 MyISAM 引擎</strong></li></ul><h3 id="（2）InnoDB-适⽤用场景">（2）InnoDB 适⽤用场景</h3><ul><li><strong>需要事务⽀持的业务、⾼并发的业务</strong></li><li><strong>数据更新较为频繁的场景，⽐如：BBS、SNS、微博等</strong></li><li><strong>数据⼀致性要求较⾼的业务，⽐如：充值转账、银⾏卡转账</strong></li></ul><h3 id="（3）总结">（3）总结</h3><p><strong>使用MyISAM: 不需事务，空间小，以查询访问为主 使用InnoDB: 多删除、更新操作，安全性高，事务处理及并发控制</strong></p><h2 id="5、查看当前默认存储引擎">5、查看当前默认存储引擎</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mysql&gt; show variables like '%storage_engine';<br>+----------------------------------+--------+<br>| Variable_name | Value |<br>+----------------------------------+--------+<br>| default_storage_engine | InnoDB |<br>| default_tmp_storage_engine | InnoDB |<br>| internal_tmp_disk_storage_engine | InnoDB |<br>+----------------------------------+--------+<br><span class="hljs-number">3</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0</span>.<span class="hljs-number">02</span> sec)<br></code></pre></td></tr></table></figure><h2 id="6、修改默认存储引擎">6、修改默认存储引擎</h2><h3 id="（1）MySQL-5-5">（1）MySQL 5.5</h3><p><strong>修改my.ini配置文件</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">default_storage_engine=InnoDB<br></code></pre></td></tr></table></figure><h3 id="（2）MySQL-5-7">（2）MySQL 5.7</h3><p><strong>最简单的方法，就是通过命令直接修改表的存储引擎，如下所示：</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">alter table 表名 ENGINE = 引擎名;<br></code></pre></td></tr></table></figure><h4 id="示例：-6"><strong>示例：</strong></h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">ALTER TABLE student ENGINE = InnoDB;<br></code></pre></td></tr></table></figure><h2 id="7、设置表的存储引擎">7、设置表的存储引擎</h2><h4 id="语法格式：-5">语法格式：</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">CREATE TABLE 表名(<br>#省略代码<br>)ENGINE=存储引擎;<br></code></pre></td></tr></table></figure><h4 id="示例：-7">示例：</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">CREATE TABLE `myisam` (<br>id INT(<span class="hljs-number">4</span>)<br>)ENGINE=MyISAM;<br></code></pre></td></tr></table></figure><h1>三、MySQL补充知识</h1><p><strong>在mysql中，每个数据库最多可创建20亿个表，一个表允许定义1024列，每行的最大长度为8092字节（不包括⽂本和图像类型的长度）。</strong><br><strong>当表中定义有varchar、nvarchar或varbinary类型列时，如果向表中插入的数据行超过8092字节时，将导致语句失败，并产生错误信息。</strong><br><strong>SQL Server对每个表中行的数量没有直接限制，但它受数据库存储空间的限制。每个数据库的最大空间1048516TB，所以一个表可用的最大空间为1048516TB减去数据库类系统表和其它数据库对象所占用的空间。理论上无限大，就看你硬盘够不够大，大多数情况先是你的硬盘不够。</strong></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql数据库基础</title>
      <link href="/posts/ba11.html"/>
      <url>/posts/ba11.html</url>
      
        <content type="html"><![CDATA[<h1>一、数据库基础知识</h1><h2 id="1、什么是数据库">1、什么是数据库</h2><p><strong>数据库的概念诞生生于60年前，随看信息技术和市场的快速发展，数据库技术层出不穷，随着应用的扩展和深入，数据库的数量和规模越来越大，其诞生和发展给计算机信息管理带来了一场巨大的革命。</strong></p><p><strong>数据库的发展大致划分为以下几个阶段:人工管理阶段、文件系统阶段、数据库系统阶段、高级数据库阶段。其种类大概有3种:层次式数据库、网络式数据库和关系式数据库。不同种类的数据库按不同的数据结构来联系和组织。</strong></p><p><strong>对于数据库的概念，没有一个完全固定的定义。 随着数据库历史的发展，定义的内容也有很大的差异，其中一种比较普遍的观点认为，数据库(DataBase, DB)是一个长期存储在计算机内的、有组织的、有共享的，统一管理的数据集合。它是一个按数据结构来存储和管理数据的计算机软件系统。即数据库包含两层含义:保管数据的“仓库&quot;，以及数据管理的方法和技术。</strong></p><p><strong>数据库的特点包括:实现数据共享，减少数据冗余;采用特定的数据类型:具有较高的数据独立性:具有统一的数据控制功能。</strong></p><h2 id="2、为何需要数据库">2、为何需要数据库</h2><h3 id="存储数据的方法"><strong>存储数据的方法</strong></h3><ul><li><strong>第一种方法:用大脑来记住数据</strong></li><li><strong>第二种方法:写在纸上</strong></li><li><strong>第三种方法:写在计算机的内存中</strong></li><li><strong>第四种方法:写成磁盘文件</strong></li></ul><h2 id="3、数据库能够做什么">3、数据库能够做什么</h2><ul><li><strong>存储大量数据，方便检索和访问</strong></li><li><strong>保持数据信息的一致、完整</strong></li><li><strong>共享和安全</strong></li><li><strong>通过组合分析，产生新的有用信息</strong></li></ul><h2 id="4、数据库和应用程序">4、数据库和应用程序</h2><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602211619143.png" alt="image-20200602211619143"></p><table><thead><tr><th></th><th>应用程序</th><th>数据库</th></tr></thead><tbody><tr><td>作用</td><td>响应操作并显示结果、向数据库请求数据</td><td>存储数据、检索数据、生成新的数据</td></tr><tr><td>要求</td><td>美观、操作简单方便</td><td>统一安全、性能等</td></tr></tbody></table><h2 id="5、时下流行的数据库">5、时下流行的数据库</h2><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602212007647.png" alt="image-20200602212007647"></p><table><thead><tr><th>Oracle</th><th>SqIServer</th><th>MySQL</th></tr></thead><tbody><tr><td>Oracle公司的产品</td><td>针对不同用户群体的多个版本</td><td>开放源代码</td></tr><tr><td>产品免费、服务收费</td><td>易用性好</td><td>网站应用广泛</td></tr></tbody></table><h2 id="6、数据库的基本概念">6、数据库的基本概念</h2><p><strong>在关系数据库中，数据库的表是一系列二维数组的集合,用来存储数据和操作数据的逻辑结构。它是由纵向的列和横向的行组成，行被称为记录，也叫作实体,是组织数据的单位;列被称为字段，每一列表示记录的一个属性，都有相应的描述信息，如数据类型、数据宽度等。例如一个有关作者信息的名为authors的表中，每个列包含所有作者的某个特定类型的信息。</strong></p><h3 id="（1）实体">（1）实体</h3><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602212634597.png" alt="image-20200602212634597"></p><p><strong>这些客观存在的、可以被描述的事物都是“实体”。</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602212823670.png" alt="image-20200602212823670"></p><h2 id="二、MySQL数据库">二、MySQL数据库</h2><p><strong>MySQL是一个开放源代码的数据库管理系统(DBMS) ，它是由MySQL AB公司开发、发布并支持的。MySQL是一个跨平台的开源关系数据库管理系统，广泛地应用在Internet上的中小型网站公司开发中。</strong></p><h2 id="1、MySQL的优势">1、MySQL的优势</h2><ul><li><strong>运行速度快。</strong></li><li><strong>使用成本低: MySQL对多数个人用户来说是免费的。</strong></li><li><strong>容易使用:与其他大型数据库的设置和管理相比，其复杂程度较低，易于学习。</strong></li><li><strong>可移植性强:能够工作在众多不同的系统平台上，例如: Windows. Linux、Unix等。</strong></li><li><strong>支持丰富的接口;提供了用于C、C++、Java、per1、PHP、Ruby、Python等语言的API</strong></li><li><strong>支持查询语言; MySQL可以利用标准SQL语法和支持ODBC (开放式数据库连接)的应用程序</strong></li><li><strong>安全性和连续性:十分灵活和安全的权限和密码系统，允许基于主机的验证。连接到服务器器时，所有的密码传输均采用加密形式，从而保证了密码安全。并且由于Mysq1是网络化的，因此可以在因特网上的任何地方访问，提高数据共享的效率。，</strong></li></ul><h2 id="2、MySQL版本">2、MySQL版本</h2><p><strong>MySQL分为2个不同的版本:</strong></p><table><thead><tr><th>社区版(Community Server)</th><th>企业版(Enterprise Server)</th></tr></thead><tbody><tr><td>免费、开源</td><td>收费，不可自由下载</td></tr><tr><td>适合普通用户</td><td>适合对功能和安全要求高的企业用户</td></tr><tr><td></td><td>功能和服务更完善<br>它能够以很高的性价比为企业提供数据仓库应用，<br>支持ACID事务处理,<br>提供完整的提交、回滚、崩溃恢复和行级锁定功能。</td></tr></tbody></table><h2 id="3、MySQL的命名">3、MySQL的命名</h2><p><strong>MySQL的命名机制由3个数字和1个后缀组成，例如mysql-5.5.13.</strong></p><ul><li><strong>第1个数字(5)是主版本号，描述了文件格式，所有版本5的发行版都有相同的文件格式。</strong></li><li><strong>第2个数字(5)是发行级别，主版本号和发行级别组合在一-起便构成了发行序列号。</strong></li><li><strong>第3个数字(13)是在此发行系列的版本号，随每次新发布版本递增，通常选择已经发行的最新版本。</strong></li></ul><h2 id="4、MySQL的运行机制">4、MySQL的运行机制</h2><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602213655488.png" alt="image-20200602213655488"></p><h3 id="1-讲解思路">(1)讲解思路</h3><p><strong>就一个SQL语句，如select * from tablename ，从支持接口进来后，进入连接池后做权限。验证等环节，然后判断是否有缓存，有则直接放回结果，否则进入SQL接口，在查询之前查询优化器进行优化，最后进行解析，查询。并通过存储引擎与文件交互。然后再介绍MySQL的企业管理服务和工具。</strong></p><h3 id="2-名词解释">(2)名词解释</h3><h4 id="支持接口">支持接口:</h4><p><strong>不同的编程语言与SQL的交互</strong></p><h4 id="连接池">连接池:</h4><p><strong>管理缓冲用户连接，线程处理等需要缓存的需求</strong></p><h4 id="SQL接口">SQL接口:</h4><p><strong>接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL接口</strong></p><h4 id="解析器">解析器:</h4><p><strong>SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的，是一个很长的脚本。</strong></p><blockquote><p><strong>主要功能:</strong></p><p><strong>将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的;例如将select 自from tablename where 1=1; 分解为select.中、from、 tablename、where 、1=1,并去解析。</strong></p><p><strong>如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</strong></p></blockquote><h3 id="查询优化器">查询优化器:</h3><p><strong>SQL语句在查询之前会使用查询优化器对查询进行优化，使用的是”选取-投影-联接’ &quot;策略进行查询。</strong></p><blockquote><p><strong>例: select uid,name from user where gender = 1;</strong><br><strong>a.先根据where语句进行选取，而不是先将表全部查询出来以后再进行gender过滤</strong><br><strong>b.先根据uid和name进行属性投影，而不是将属性全部陬出以后再进行过滤</strong><br><strong>将这两个查询条件联接起来生成最终查询结果。</strong></p></blockquote><h3 id="缓存">缓存:</h3><p><strong>如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。</strong></p><p><strong>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等。</strong></p><h3 id="存储引擎">存储引擎:</h3><p><strong>存储引擎是MySq|中具体的与文件打交道的子系统。也是Mysq|最具有特色的一个地方。</strong></p><p><strong>Mysql的存储引擎是插件式的。它根据MySql AB公司提供的文件访问层的一个抽象接口来定制-种文件访问机制(这种访问机制就叫存储引擎)。</strong></p><p><strong>现在有很多种存储引擎,各个存储引擎的优势各不一样，最常用的9MyISAM. InnoDB. BDB。</strong></p><p><strong>MyISAM引擎.它查询速度快。有较好的索引优化和数据压缩技术，但是它不支持事务。</strong></p><p><strong>InnoDB支持事务，并且提供行级的锁定，应用也相当厂泛。</strong></p><p><strong>Mysq也支持自己定制存储引擎，甚至一个库中不同的表使用不同的存储引擎，这些都是允许的。</strong></p><p><strong>MySQL5.7默认使用InnoDB存储引擎。</strong></p><h2 id="5、MySQL安装与配置">5、MySQL安装与配置</h2><h3 id="1-安装步骤-略">(1)安装步骤(<a href="https://blog.51cto.com/14320361/2488442" target="_blank" rel="noopener">略</a>)</h3><h3 id="2-基本配置">(2)基本配置</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">端口号: <span class="hljs-number">3306</span><br>默认字符集: utf-<span class="hljs-number">8</span><br>root密码设置<br></code></pre></td></tr></table></figure><h3 id="3-安装目录介绍">(3)安装目录介绍</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">bin:</span><br><span class="hljs-function"><span class="hljs-title">include</span>:</span><br><span class="hljs-function">1<span class="hljs-title">ib</span>:</span><br><span class="hljs-function"><span class="hljs-title">share</span>:</span><br></code></pre></td></tr></table></figure><h3 id="4-命令行连接MySQL-cmd窗口">(4)命令行连接MySQL(cmd窗口)</h3><h4 id="1-检查MySQL服务是否启动">1)检查MySQL服务是否启动</h4><p><strong>方式1: Windows服务</strong></p><blockquote><p><strong>右击此电脑——管理——服务和应用程序——服务——查找MYSQL57服务（我的mysql名称是mysqlxgp888）</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602215405188.png" alt="image-20200602215405188"></p><p><strong>如果关闭该服务，登陆mysql会出错</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">C:\<span class="hljs-title">WINDOWS</span>\<span class="hljs-title">system32</span>&gt;<span class="hljs-title">mysql</span> -<span class="hljs-title">u</span> <span class="hljs-title">root</span>  -<span class="hljs-title">p</span></span><br><span class="hljs-function"><span class="hljs-title">ERROR</span> 2003 (<span class="hljs-title">HY000</span>): <span class="hljs-title">Can</span>'<span class="hljs-title">t</span> <span class="hljs-title">connect</span> <span class="hljs-title">to</span> <span class="hljs-title">MySQL</span> <span class="hljs-title">server</span> <span class="hljs-title">on</span> '<span class="hljs-title">localhost</span>' (10061)</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>方式2: dos命令启动mysql</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">C:\<span class="hljs-title">WINDOWS</span>\<span class="hljs-title">system32</span>&gt;<span class="hljs-title">net</span> <span class="hljs-title">start</span> <span class="hljs-title">mysqlxgp888</span></span><br><span class="hljs-function"><span class="hljs-title">MYSQLxgp888</span> 服务正在启动 .</span><br><span class="hljs-function"><span class="hljs-title">MYSQLxgp888</span> 服务已经启动成功。</span><br></code></pre></td></tr></table></figure><p><strong>关闭mysql服务</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">C:\<span class="hljs-title">WINDOWS</span>\<span class="hljs-title">system32</span>&gt;<span class="hljs-title">net</span> <span class="hljs-title">stop</span> <span class="hljs-title">mysqlxgp888</span></span><br><span class="hljs-function"><span class="hljs-title">MYSQLxgp888</span> 服务正在停止.</span><br><span class="hljs-function"><span class="hljs-title">MYSQLxgp888</span> 服务已成功停止。</span><br></code></pre></td></tr></table></figure><p><strong>修改了配置文件，必须重启MySQL服务才能生效。</strong></p><h4 id="2-连接MySQL">2)连接MySQL</h4><p><strong>语法格式:</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mysq1 -h服务器主机地址-u用户名-p密码<br></code></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mysq1 -u root -p<br></code></pre></td></tr></table></figure><p><strong>方式1: dos命令启动</strong></p><p><strong>方式2: MySQL Command Line Client</strong></p><p><strong>默认root登录，仅输入密码。</strong></p><h1><strong>三、MySQL数据库类型</strong></h1><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602220130538.png" alt="image-20200602220130538"></p><h2 id="1、系统数据库">1、系统数据库</h2><p><strong>安装完MySQL服务器后，MySQL会附带系统数据库，包括:</strong></p><ul><li><strong>information_ schema:主要存储系统中的一些数据库对象信息，如用户表信息、字段信息、权限信息、字符集信息和分区信息等。</strong></li><li><strong>performance_ schema: 主要存储数据库服务器性能参数</strong></li><li><strong>mysql:主要存储系统的用户权限信息</strong></li><li><strong>test :MySQL数据库管理系统自动创建的测试数据库，任何用户都可以使用</strong></li></ul><h2 id="2、用户数据库">2、用户数据库</h2><p><strong>用户数据库是用户根据实际需求创建的数据库。本章后面的讲解主要针对用户数据库。</strong></p><h1>四、数据库基本操作（cmd）</h1><h2 id="1、登陆数据库">1、登陆数据库</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">C:\<span class="hljs-title">WINDOWS</span>\<span class="hljs-title">system32</span>&gt;<span class="hljs-title">mysql</span> -<span class="hljs-title">u</span> <span class="hljs-title">root</span>  -<span class="hljs-title">p123456</span></span><br></code></pre></td></tr></table></figure><h3 id="查看一下">查看一下</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mysql&gt; show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| student_info       |<br>| sys                |<br>| userinfo           |<br>+--------------------+<br><span class="hljs-number">7</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0</span>.<span class="hljs-number">00</span> sec)<br></code></pre></td></tr></table></figure><h2 id="2、创建数据库（test）"><strong>2、创建数据库</strong>（test）</h2><p><strong>基本语法： create database <code>数据库名称</code> ；</strong></p><p><strong>创建应该名称为itcast的数据库。sql语法如下：</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">create database  itcast;<br></code></pre></td></tr></table></figure><p><strong>需要主要的是，为了避免用户自定义的名称与系统命令冲突，最好使用反引号（``）包括数据库名称/字段名称和数据表名称</strong><br><strong>如果创建数据库存在，则程序会报错，为了防止此情况发生，再创建数据库可以使用“if not exists”，语法如下：</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mysql&gt; create database test;<br>Query OK, <span class="hljs-number">1</span> row affected (<span class="hljs-number">0</span>.<span class="hljs-number">00</span> sec)<br></code></pre></td></tr></table></figure><h2 id="3、查看数据库">3、查看数据库</h2><p><strong>查看MySql数据库服务器已经存在的数据库</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mysql&gt; show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| student_info       |<br>| sys                |<br>| test               |<br>| userinfo           |<br>+--------------------+<br><span class="hljs-number">7</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0</span>.<span class="hljs-number">00</span> sec)<br></code></pre></td></tr></table></figure><h2 id="4、选择数据库">4、选择数据库</h2><p><strong>数据库服务器可能存在多个数据，选择数据库的命令语法：</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">use 数据库名称<br></code></pre></td></tr></table></figure><h3 id="操作">操作</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mysql&gt; use test;<br>Database changed<br></code></pre></td></tr></table></figure><h2 id="5、删除数据库">5、删除数据库</h2><p><strong>数据库的删除操作不仅会删除里面的数据，还会回收原来分配的存储空间</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">drop database 数据库名称<br></code></pre></td></tr></table></figure><p><strong>在使用“drop database” 命令删除数据库时，若删除数据库不存在，MySql服务器会报错，因此，可以再删除数据库时，使用“if existe”</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mysql&gt; drop database test;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0</span>.<span class="hljs-number">00</span> sec)<br></code></pre></td></tr></table></figure><p><strong>//若删除MySql数据库服务器中存在数据库itcase,则删除该数据库，否则不执行删除 数据库itcasse的操作。</strong></p><h3 id="查看一下-2">查看一下</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mysql&gt; show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| student_info       |<br>| sys                |<br>| userinfo           |<br>+--------------------+<br><span class="hljs-number">6</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0</span>.<span class="hljs-number">00</span> sec)<br></code></pre></td></tr></table></figure><h1>五、图形化MySQL<a href="https://blog.51cto.com/14320361/2488442" target="_blank" rel="noopener">管理工具</a></h1><h2 id="1、连接数据库">1、连接数据库</h2><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602222708401.png" alt="image-20200602222708401"></p><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602222753400.png" alt="image-20200602222753400"></p><h2 id="2、查看数据库">2、查看数据库</h2><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602222935559.png" alt="image-20200602222935559"></p><h2 id="3、选择数据库">3、选择数据库</h2><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602223107551.png" alt="image-20200602223107551"></p><h1>六、结构化查询语言</h1><h2 id="1、SQL">1、SQL</h2><p><strong>对数据库进行查询和修改操作的语言叫SQL.</strong></p><p><strong>SQL的含义是结构化查询语句(Structured Query Languate)，是对数据库进行查询和修改操作的语言。</strong></p><h2 id="2、T-SQL">2、T-SQL</h2><p><strong>T-SQL: Transact-SQL</strong></p><p><strong>T-SQL是SQL的增强版，对功能进行了扩充：如变量说明、流程控制、功能函数。</strong></p><h2 id="3、SQL的组成">3、SQL的组成</h2><table><thead><tr><th>名称</th><th>解释</th><th>命令举例</th></tr></thead><tbody><tr><td>DML (数据操作语言)</td><td>用来操作数据库中所包含的数据</td><td>INSERT- 将数据插入表中<br>DELETE-更新表中的现有数据<br>UPDATE-删除数据库表中的所有记录<br>等</td></tr><tr><td>DDL (数据定义语言)</td><td>用于创建和删除数据库对象等操作</td><td>CREATE-创建数据库及其对象（表，索引，视图，存储过程，函数和触发器）<br>DROP-改变现有数据库的结构<br>ALTER-从数据库中删除对象<br>TRUNCATE-删除表中的所有记录，包括为记录分配的所有空格<br>COMMENT-为数据字典添加注释<br>RENAME-重命名对象</td></tr><tr><td>DQL (数据查询语言)</td><td>用来对数据库中的数据进行查询</td><td>SELECT-从数据库中检索数据</td></tr><tr><td>DCL (数据控制语言)</td><td>用来控制数据库组件的存取许可、存取权限等</td><td>GRANT-允许用户访问数据库的权限<br>COMMIT-提交事务<br>ROLLBACK-在发生任何错误的情况下回滚事务</td></tr></tbody></table><p><strong>结构化查询语言是高级的非过程化编程语言，允许用户在高层数据结构上工作。它不要求用户指定对数据的存放方法，也不需要用户了zhi解具体的数据存放方式，所以具有完全不同底层结构的不同数据库系统, 可以使用相同的结构化dao查询语言作为数据内输入与管理的接口。结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200603103608445.png" alt="image-20200603103608445"></p><h4 id="扩展资料："><strong>扩展资料：</strong></h4><p><strong>SQL可以独立完成数据容库生命周期中的全部活动，包括定义关系模式、录入数据、建立数据库、査询、更新、维护、数据库重构、数据库安全性控制等一系列操作，这就为数据库应用系统开发提供了良好的环境，在数据库投入运行后，还可根据需要随时逐步修改模式，且不影响数据库的运行，从而使系统具有良好的可扩充性。</strong></p><h1>七、MySQL常用数据类型</h1><ul><li><strong>MySql提供了很多数值类型，大体分为整数类型和浮点类型</strong></li><li><strong>整数类型根据取值范围分为int，smallint等，</strong></li><li><strong>浮点类型又分为float，declmal等。</strong></li></ul><h2 id="1、数值类型">1、数值类型</h2><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602224211091.png" alt="image-20200602224211091"></p><h2 id="2、数值类型的属性"><strong>2、数值类型的属性:</strong></h2><ul><li><strong>UNSIGNED</strong></li><li><ul><li><strong>标识为无符号数</strong></li></ul></li><li><strong>ZEROFILL</strong></li><li><ul><li><strong>宽度(位数)不足，以0填充</strong></li></ul></li></ul><h2 id="3、实施一下">3、实施一下</h2><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602231517163.png" alt="image-20200602231517163"></p><h3 id="（1）ZEROFILL：没有数值的位置用0填充">（1）ZEROFILL：没有数值的位置用0填充</h3><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602225302906.png" alt="image-20200602225302906"></p><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602225850935.png" alt="image-20200602225850935"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cmd">create database `school`;<br>#创建数据库<br><br>use `school`;<br>#切换数据库<br><br>create table `student` (<br>true`sid` INT(<span class="hljs-number">4</span>) ZEROFILL<br>);<br>#创建表<br><br>desc student;<br>#查看表结构<br></code></pre></td></tr></table></figure><h4 id="插入数据">插入数据</h4><p><strong>在上面的部分添加如下内容，选中并执行</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">insert into `student` VALUES(<span class="hljs-number">12</span>),(<span class="hljs-number">123</span>),(<span class="hljs-number">1234</span>);<br>#插入数据<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602230928785.png" alt="image-20200602230928785"></p><h4 id="查看一下-3">查看一下</h4><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602231033996.png" alt="image-20200602231033996"></p><h4 id="命令行—查看一下">命令行—查看一下</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mysql&gt; use school;<br>Database changed<br><br>mysql&gt; select * from student;<br>+------+<br>| sid  |<br>+------+<br>| <span class="hljs-number">0012</span> |<br>| <span class="hljs-number">0123</span> |<br>| <span class="hljs-number">1234</span> |<br>+------+<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602231347636.png" alt="image-20200602231347636"></p><h3 id="（2）UNSIGNED不用0填充空值">（2）UNSIGNED不用0填充空值</h3><p><strong>把上面的ZEROFILL改为UNSIGNED</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cmd">create database `school`;<br>#创建数据库<br><br>use `school`;<br>#切换数据库<br><br>create table `student` (<br>true`sid` INT(<span class="hljs-number">4</span>) UNSIGNED<br>);<br>#创建表<br><br>desc student;<br>#查看表结构<br><br>insert into `student` VALUES(<span class="hljs-number">12</span>),(<span class="hljs-number">123</span>),(<span class="hljs-number">1234</span>)<br>#插入数据<br></code></pre></td></tr></table></figure><h4 id="命令行—查看一下-2">命令行—查看一下</h4><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602231836287.png" alt="image-20200602231836287"></p><h2 id="4、字符串类型">4、字符串类型</h2><p><strong>BLOB和TEXT都是用于存储大量数据的，但二者的区别在于，对于存储的数据进行排序和比较时，BLOB是区分大小写的，而TEXT是不区分大小写的</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602232422465.png" alt="image-20200602232422465"></p><blockquote><h4 id="注意："><strong>注意：</strong></h4><p><strong>char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</strong></p><p><strong>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</strong></p><p><strong>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</strong></p><p><strong>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</strong></p><p><strong>有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</strong></p></blockquote><h2 id="5、日期类型">5、日期类型</h2><p><strong>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</strong></p><p><strong>每个时间类型有一个有效值范围和一个&quot;零&quot;值，当指定不合法的MySQL不能表示的值时使用&quot;零&quot;值。</strong></p><p><strong>TIMESTAMP类型有专有的自动更新特性，将在后面描述。</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200602232431734.png" alt="image-20200602232431734"></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql结构化查询语句 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小案例</title>
      <link href="/posts/a1c5.html"/>
      <url>/posts/a1c5.html</url>
      
        <content type="html"><![CDATA[<h1>编写一个案例代码</h1><h2 id="1、name-function-py-文件内容">1、name_function.py 文件内容</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-string">'''</span><br><span class="hljs-string">编写函数或者类的时候，可以给他们编写测试。</span><br><span class="hljs-string">通过测试，可确定代码面对各种各样输入都能够按照既定的要求正常工作</span><br><span class="hljs-string">对于程序员来说，编写测试，可以在用户发现问题前预先找出错误。</span><br><span class="hljs-string"></span><br><span class="hljs-string">Python中的测试模块：</span><br><span class="hljs-string">'''</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_format_name</span><span class="hljs-params">(first,last)</span>:</span><br>    <span class="hljs-string">'''创建一个姓名'''</span><br>    full_name = first + <span class="hljs-string">' '</span> + last<br>    <span class="hljs-keyword">return</span> full_name.title()<br></code></pre></td></tr></table></figure><h2 id="2、names-py-文件内容">2、<a href="http://names.py" target="_blank" rel="noopener">names.py</a> 文件内容</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">from</span> exam.name_function <span class="hljs-keyword">import</span> get_format_name<br><br>print(<span class="hljs-string">'请输入q在指定时间内退出。'</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    fist = input(<span class="hljs-string">'请输入你的姓：'</span>)<br>    <span class="hljs-keyword">if</span> fist == <span class="hljs-string">'q'</span>:<br>        <span class="hljs-keyword">break</span><br>    last = input(<span class="hljs-string">'请输入你的名：'</span>)<br>    <span class="hljs-keyword">if</span> last == <span class="hljs-string">'q'</span>:<br>        <span class="hljs-keyword">break</span><br>    formatted_name = get_format_name(fist,last)<br>    print(formatted_name)<br></code></pre></td></tr></table></figure><h5 id="输出结果">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">请输入q在指定时间内退出。<br>请输入你的姓：x<br>请输入你的名：gp<br>X Gp<br></code></pre></td></tr></table></figure></blockquote><h1>3、编写测试案例代码</h1><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200617235518152.png" alt="image-20200617235518152"></p><h3 id="test-name-function-py-文件内容">test_name_function.py 文件内容</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">from</span> exam.name_function <span class="hljs-keyword">import</span> get_format_name<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameTestCase</span><span class="hljs-params">(unittest.TestCase)</span>:</span><br>    <span class="hljs-string">'''测试name_function.py'''</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_firt_last_name</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">'''能够正确处理某种格式的姓名'''</span><br>        formatted_name = get_format_name(<span class="hljs-string">'janis'</span>,<span class="hljs-string">'joplin'</span>)<br>        <span class="hljs-comment">#断言：期待的结果</span><br>        self.assertEqual(formatted_name,<span class="hljs-string">'janis Joplin'</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><h5 id="输出结果-2">输出结果</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200617235503090.png" alt="image-20200617235503090"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python并发线程</title>
      <link href="/posts/2b38.html"/>
      <url>/posts/2b38.html</url>
      
        <content type="html"><![CDATA[<h1>开始学习Python线程</h1><p><strong>Python中使用线程有两种方式：函数或者用类来包装线程对象。</strong></p><p><strong>函数式：调用thread模块中的start_new_thread()函数来产生新线程。语法如下:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">thread.start_new_thread ( function, args[, kwargs] )<br></code></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><ul><li><strong>function - 线程函数。</strong></li><li><strong>args - 传递给线程函数的参数,他必须是个tuple类型。</strong></li><li><strong>kwargs - 可选参数。python</strong></li></ul><h2 id="简单的执行线程次数">简单的执行线程次数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hi</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-comment"># time.sleep(1)#延迟几秒</span><br>    print(<span class="hljs-string">'hello world!'</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):<br>        <span class="hljs-comment"># 创建线程</span><br>        thread = threading.Thread(target=say_hi)<br>        <span class="hljs-comment"># 启动线程</span><br>        thread.start()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></table></figure><h5 id="输出结果">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">hello world!<br>hello world!<br>hello world!<br>hello world!<br>hello world!<br></code></pre></td></tr></table></figure></blockquote><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200617232422565.png" alt="image-20200617232422565"></p><h2 id="1、单线程">1、单线程</h2><p><strong>在好些年前的MS-DOS时代，操作系统处理问题都是单任务的，我想做听音乐和看电影两件事儿，那么一定要先排一下顺序。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> ctime,sleep<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">music</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>        print(<span class="hljs-string">"I was listening to music. %s"</span> %ctime())<br>        sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>        print(<span class="hljs-string">"I was at the movies! %s"</span> %ctime())<br>        sleep(<span class="hljs-number">5</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    music()<br>    move()<br>    print(<span class="hljs-string">"all over %s"</span> %ctime())<br></code></pre></td></tr></table></figure><p><strong>我们先听了一首音乐，通过for循环来控制音乐的播放了两次，每首音乐播放需要1秒钟，sleep()来控制音乐播放的时长。接着我们又看了一场电影，每一场电影需要5秒钟，因为太好看了，所以我也通过for循环看两遍。在整个休闲娱乐活动结束后，我通过<code>print(&quot;all over %s&quot; %ctime())</code>看了一下当前时间，差不多该睡觉了</strong></p><h5 id="输出结果-2">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">I was listening to music. Wed Jun <span class="hljs-number">17</span> <span class="hljs-number">23</span>:<span class="hljs-number">19</span>:<span class="hljs-number">18</span> <span class="hljs-number">2020</span><br>I was listening to music. Wed Jun <span class="hljs-number">17</span> <span class="hljs-number">23</span>:<span class="hljs-number">19</span>:<span class="hljs-number">19</span> <span class="hljs-number">2020</span><br>I was at the movies! Wed Jun <span class="hljs-number">17</span> <span class="hljs-number">23</span>:<span class="hljs-number">19</span>:<span class="hljs-number">20</span> <span class="hljs-number">2020</span><br>I was at the movies! Wed Jun <span class="hljs-number">17</span> <span class="hljs-number">23</span>:<span class="hljs-number">19</span>:<span class="hljs-number">25</span> <span class="hljs-number">2020</span><br>all over Wed Jun <span class="hljs-number">17</span> <span class="hljs-number">23</span>:<span class="hljs-number">19</span>:<span class="hljs-number">30</span> <span class="hljs-number">2020</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>其实，music()和move()更应该被看作是音乐和视频播放器，至于要播放什么歌曲和视频应该由我们使用时决定。所以，我们对上面代码做了改造：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> ctime,sleep<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">music</span><span class="hljs-params">(func)</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">print</span> (<span class="hljs-string">"I was listening to %s. %s"</span> %(func,ctime()))<br>        sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move</span><span class="hljs-params">(func)</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">print</span> (<span class="hljs-string">"I was at the %s! %s"</span> %(func,ctime()))<br>        sleep(<span class="hljs-number">5</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    music(<span class="hljs-string">u'爱情买卖'</span>)<br>    move(<span class="hljs-string">u'阿凡达'</span>)<br><br>    <span class="hljs-keyword">print</span> (<span class="hljs-string">"all over %s"</span> %ctime())<br></code></pre></td></tr></table></figure><h5 id="输出结果-3">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">I was listening to 爱情买卖. Thu Apr <span class="hljs-number">17</span> <span class="hljs-number">11</span>:<span class="hljs-number">48</span>:<span class="hljs-number">59</span> <span class="hljs-number">2014</span><br>I was listening to 爱情买卖. Thu Apr <span class="hljs-number">17</span> <span class="hljs-number">11</span>:<span class="hljs-number">49</span>:<span class="hljs-number">00</span> <span class="hljs-number">2014</span><br>I was at the 阿凡达! Thu Apr <span class="hljs-number">17</span> <span class="hljs-number">11</span>:<span class="hljs-number">49</span>:<span class="hljs-number">01</span> <span class="hljs-number">2014</span><br>I was at the 阿凡达! Thu Apr <span class="hljs-number">17</span> <span class="hljs-number">11</span>:<span class="hljs-number">49</span>:<span class="hljs-number">06</span> <span class="hljs-number">2014</span><br>all over Thu Apr <span class="hljs-number">17</span> <span class="hljs-number">11</span>:<span class="hljs-number">49</span>:<span class="hljs-number">11</span> <span class="hljs-number">2014</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="2、多线程">2、多线程</h2><p><strong>Python3 通过两个标准库 _thread (python2中是thread模块）和 threading 提供对线程的支持。</strong><br><strong>_thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。</strong></p><h4 id="（1）使用-thread模块">（1）使用_thread模块</h4><p><strong>调用_thread模块中的start_new_thread()函数来产生新线程。</strong><br><strong>先用一个实例感受一下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> _thread<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 为线程定义一个函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_time</span><span class="hljs-params">(threadName, delay)</span>:</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> count &lt; <span class="hljs-number">5</span>:<br>        time.sleep(delay)<br>        count += <span class="hljs-number">1</span><br>        print(<span class="hljs-string">"%s: %s"</span> % (threadName, time.ctime(time.time())))<br><br><br><span class="hljs-comment"># 创建两个线程</span><br><span class="hljs-keyword">try</span>:<br>    _thread.start_new_thread(print_time, (<span class="hljs-string">"Thread-1"</span>, <span class="hljs-number">2</span>,))<br>    _thread.start_new_thread(print_time, (<span class="hljs-string">"Thread-2"</span>, <span class="hljs-number">4</span>,))<br><span class="hljs-keyword">except</span>:<br>    print(<span class="hljs-string">"Error: unable to start thread"</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">pass</span><br><br>print(<span class="hljs-string">"Main Finished"</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果-4">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">Thread<span class="hljs-number">-1</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">35</span>:<span class="hljs-number">47</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-2</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">35</span>:<span class="hljs-number">49</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-1</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">35</span>:<span class="hljs-number">49</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-1</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">35</span>:<span class="hljs-number">51</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-2</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">35</span>:<span class="hljs-number">53</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-1</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">35</span>:<span class="hljs-number">53</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-1</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">35</span>:<span class="hljs-number">55</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-2</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">35</span>:<span class="hljs-number">57</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-2</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">36</span>:<span class="hljs-number">01</span> <span class="hljs-number">2017</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="注意到，在主线程写了"><strong>注意到，在主线程写了:</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>   <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p><strong>这是让主线程一直在等待.</strong><br><strong>如果去掉上面两行，那就直接输出并结束程序执行:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">"Main Finished"</span><br></code></pre></td></tr></table></figure><h1>线程模块</h1><p><strong>Python通过两个标准库thread和threading提供对线程的支持。thread提供了低级别的、原始的线程以及一个简单的锁。</strong></p><p><strong>threading 模块提供的其他方法：</strong></p><ul><li><strong>threading.currentThread(): 返回当前的线程变量。</strong></li><li><strong>threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</strong></li><li><strong>threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</strong></li></ul><p><strong>除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:</strong></p><ul><li><p><strong>run(): 用以表示线程活动的方法。</strong></p></li><li><p><strong>start():</strong></p><p><strong>启动线程活动。</strong></p></li><li><p><strong>join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。</strong></p></li><li><p><strong>isAlive(): 返回线程是否活动的。</strong></p></li><li><p><strong>getName(): 返回线程名。</strong></p></li><li><p><strong>setName(): 设置线程名。</strong></p></li></ul><h2 id="1、直接创建线程">1、直接创建线程</h2><p><strong>接上面的听音乐和看电影的例子，我们可以直接使用threading.Thread 创建线程，并指定执行的方法以及传递的参数：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> ctime,sleep<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">music</span><span class="hljs-params">(func)</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">print</span> (<span class="hljs-string">"I was listening to %s. %s"</span> %(func,ctime()))<br>        sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move</span><span class="hljs-params">(func)</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">print</span> (<span class="hljs-string">"I was at the %s! %s"</span> %(func,ctime()))<br>        sleep(<span class="hljs-number">5</span>)<br><br>threads = []<br>t1 = threading.Thread(target=music,args=(<span class="hljs-string">u'爱情买卖'</span>,))<br>threads.append(t1)<br>t2 = threading.Thread(target=move,args=(<span class="hljs-string">u'阿凡达'</span>,))<br>threads.append(t2)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>        t.start()<br><br>    <span class="hljs-keyword">print</span> (<span class="hljs-string">"all over %s"</span> %ctime())<br></code></pre></td></tr></table></figure><h5 id="输出结果-5">输出结果</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">was</span> <span class="hljs-selector-tag">listening</span> <span class="hljs-selector-tag">to</span> 爱情买卖. <span class="hljs-selector-tag">Thu</span> <span class="hljs-selector-tag">Aug</span> 10 16<span class="hljs-selector-pseudo">:57</span><span class="hljs-selector-pseudo">:12</span> 2017<br><span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">was</span> <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">the</span> 阿凡达! <span class="hljs-selector-tag">Thu</span> <span class="hljs-selector-tag">Aug</span> 10 16<span class="hljs-selector-pseudo">:57</span><span class="hljs-selector-pseudo">:12</span> 2017<br><span class="hljs-selector-tag">all</span> <span class="hljs-selector-tag">over</span> <span class="hljs-selector-tag">Thu</span> <span class="hljs-selector-tag">Aug</span> 10 16<span class="hljs-selector-pseudo">:57</span><span class="hljs-selector-pseudo">:12</span> 2017<br><span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">was</span> <span class="hljs-selector-tag">listening</span> <span class="hljs-selector-tag">to</span> 爱情买卖. <span class="hljs-selector-tag">Thu</span> <span class="hljs-selector-tag">Aug</span> 10 16<span class="hljs-selector-pseudo">:57</span><span class="hljs-selector-pseudo">:13</span> 2017<br><span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">was</span> <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">the</span> 阿凡达! <span class="hljs-selector-tag">Thu</span> <span class="hljs-selector-tag">Aug</span> 10 16<span class="hljs-selector-pseudo">:57</span><span class="hljs-selector-pseudo">:17</span> 2017<br></code></pre></td></tr></table></figure><h2 id="2、使用Threading模块创建线程（构造线程类）">2、使用Threading模块创建线程（构造线程类）</h2><p><strong>我们也可以通过直接从 threading.Thread 继承创建一个新的子类，并实例化后调用 start() 方法启动新线程，即它调用了线程的 run() 方法</strong></p><p><strong>使用Threading模块创建线程，直接从<code>threading.Thread</code>继承，然后重写<code>init</code>方法和<code>run</code>方法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br>exitFlag = <span class="hljs-number">0</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myThread</span> <span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, threadID, name, counter)</span>:</span><br>        threading.Thread.__init__(self)<br>        self.threadID = threadID<br>        self.name = name<br>        self.counter = counter<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">print</span> (<span class="hljs-string">"开始线程："</span> + self.name)<br>        print_time(self.name, self.counter, <span class="hljs-number">5</span>)<br>        <span class="hljs-keyword">print</span> (<span class="hljs-string">"退出线程："</span> + self.name)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_time</span><span class="hljs-params">(threadName, delay, counter)</span>:</span><br>    <span class="hljs-keyword">while</span> counter:<br>        <span class="hljs-keyword">if</span> exitFlag:<br>            threadName.exit()<br>        time.sleep(delay)<br>        <span class="hljs-keyword">print</span> (<span class="hljs-string">"%s: %s"</span> % (threadName, time.ctime(time.time())))<br>        counter -= <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 创建新线程</span><br>thread1 = myThread(<span class="hljs-number">1</span>, <span class="hljs-string">"Thread-1"</span>, <span class="hljs-number">1</span>)<br>thread2 = myThread(<span class="hljs-number">2</span>, <span class="hljs-string">"Thread-2"</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 开启新线程</span><br>thread1.start()<br>thread2.start()<br><span class="hljs-keyword">print</span> (<span class="hljs-string">"退出主线程"</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果-6">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">开始线程：Thread<span class="hljs-number">-1</span><br>开始线程：Thread<span class="hljs-number">-2</span><br>退出主线程<br>Thread<span class="hljs-number">-1</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">48</span>:<span class="hljs-number">41</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-2</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">48</span>:<span class="hljs-number">42</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-1</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">48</span>:<span class="hljs-number">42</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-1</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">48</span>:<span class="hljs-number">43</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-2</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">48</span>:<span class="hljs-number">44</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-1</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">48</span>:<span class="hljs-number">44</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-1</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">48</span>:<span class="hljs-number">45</span> <span class="hljs-number">2017</span><br>退出线程：Thread<span class="hljs-number">-1</span><br>Thread<span class="hljs-number">-2</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">48</span>:<span class="hljs-number">46</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-2</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">48</span>:<span class="hljs-number">48</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-2</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">48</span>:<span class="hljs-number">50</span> <span class="hljs-number">2017</span><br>退出线程：Thread<span class="hljs-number">-2</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>从结果可以看到，为什么我们开启了两个线程之后，主线程立即退出了？因为我们没有使用join方法，对于主线程来说，thread1和thread2是子线程，使用join方法，会让主线程等待子线程执行解说再继续执行。</strong></p><h3 id="join-方法">join()方法</h3><p><strong>我们修改一下代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br>exitFlag = <span class="hljs-number">0</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myThread</span> <span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, threadID, name, counter)</span>:</span><br>        threading.Thread.__init__(self)<br>        self.threadID = threadID<br>        self.name = name<br>        self.counter = counter<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">print</span> (<span class="hljs-string">"开始线程："</span> + self.name)<br>        print_time(self.name, self.counter, <span class="hljs-number">5</span>)<br>        <span class="hljs-keyword">print</span> (<span class="hljs-string">"退出线程："</span> + self.name)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_time</span><span class="hljs-params">(threadName, delay, counter)</span>:</span><br>    <span class="hljs-keyword">while</span> counter:<br>        <span class="hljs-keyword">if</span> exitFlag:<br>            threadName.exit()<br>        time.sleep(delay)<br>        <span class="hljs-keyword">print</span> (<span class="hljs-string">"%s: %s"</span> % (threadName, time.ctime(time.time())))<br>        counter -= <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 创建新线程</span><br>thread1 = myThread(<span class="hljs-number">1</span>, <span class="hljs-string">"Thread-1"</span>, <span class="hljs-number">1</span>)<br>thread2 = myThread(<span class="hljs-number">2</span>, <span class="hljs-string">"Thread-2"</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 开启新线程</span><br>thread1.start()<br>thread2.start()<br>thread1.join()<br>thread2.join()<br><span class="hljs-keyword">print</span> (<span class="hljs-string">"退出主线程"</span>)<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">开始线程：Thread<span class="hljs-number">-1</span><br>开始线程：Thread<span class="hljs-number">-2</span><br>Thread<span class="hljs-number">-1</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">52</span>:<span class="hljs-number">07</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-2</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">52</span>:<span class="hljs-number">08</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-1</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">52</span>:<span class="hljs-number">08</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-1</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">52</span>:<span class="hljs-number">09</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-2</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">52</span>:<span class="hljs-number">10</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-1</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">52</span>:<span class="hljs-number">10</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-1</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">52</span>:<span class="hljs-number">11</span> <span class="hljs-number">2017</span><br>退出线程：Thread<span class="hljs-number">-1</span><br>Thread<span class="hljs-number">-2</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">52</span>:<span class="hljs-number">12</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-2</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">52</span>:<span class="hljs-number">14</span> <span class="hljs-number">2017</span><br>Thread<span class="hljs-number">-2</span>: Thu Aug <span class="hljs-number">10</span> <span class="hljs-number">16</span>:<span class="hljs-number">52</span>:<span class="hljs-number">16</span> <span class="hljs-number">2017</span><br>退出线程：Thread<span class="hljs-number">-2</span><br>退出主线程<br></code></pre></td></tr></table></figure></blockquote><p><strong>可以看到 退出主线程 在最后才被打印出来。</strong></p><h3 id="setDaemon-方法">setDaemon()方法</h3><p><strong>有一个方法常常拿来与join方法做比较，那就是setDaemon()方法。我们首先来看一下setDaemon()方法的使用效果：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br>exitFlag = <span class="hljs-number">0</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myThread</span> <span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, threadID, name, counter)</span>:</span><br>        threading.Thread.__init__(self)<br>        self.threadID = threadID<br>        self.name = name<br>        self.counter = counter<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">print</span> (<span class="hljs-string">"开始线程："</span> + self.name)<br>        print_time(self.name, self.counter, <span class="hljs-number">5</span>)<br>        <span class="hljs-keyword">print</span> (<span class="hljs-string">"退出线程："</span> + self.name)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_time</span><span class="hljs-params">(threadName, delay, counter)</span>:</span><br>    <span class="hljs-keyword">while</span> counter:<br>        <span class="hljs-keyword">if</span> exitFlag:<br>            threadName.exit()<br>        time.sleep(delay)<br>        <span class="hljs-keyword">print</span> (<span class="hljs-string">"%s: %s"</span> % (threadName, time.ctime(time.time())))<br>        counter -= <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 创建新线程</span><br>thread1 = myThread(<span class="hljs-number">1</span>, <span class="hljs-string">"Thread-1"</span>, <span class="hljs-number">1</span>)<br>thread2 = myThread(<span class="hljs-number">2</span>, <span class="hljs-string">"Thread-2"</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 开启新线程</span><br>thread1.setDaemon(<span class="hljs-literal">True</span>)<br>thread2.setDaemon(<span class="hljs-literal">True</span>)<br>thread1.start()<br>thread2.start()<br><br><span class="hljs-keyword">print</span> (<span class="hljs-string">"退出主线程"</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果-7">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">开始线程：Thread<span class="hljs-number">-1</span><br>开始线程：Thread<span class="hljs-number">-2</span><br>退出主线程<br></code></pre></td></tr></table></figure></blockquote><p><strong>可以看到，在主线程结束之后，程序就终止了，也就是说两个子线程也被终止了，这就是setDaemon方法的作用。主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon(),这个的意思是，把主线程A设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成,一并和主线程A退出.这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，如果不设置为守护线程，程序会被无限挂起。</strong></p><h2 id="3、两个疑问">3、两个疑问</h2><p><strong>我们刚才介绍了两种使用多线程的方式，一种是直接调用threading.Thread 创建线程，另一种是从 threading.Thread 继承创建一个新的子类，并实例化后调用 start() 方法启动进程。学到这里，我就抛出了两个疑问，为什么第一种方法中我们可以为不同的线程指定运行的方法，而第二种我们都运行的是同一个方法，那么它内部的实现机制是什么呢？第二个疑问是，第二种方法中，我们没有实例化start()方法，那么run和start这两个方法的联系是什么呢？</strong><br><strong>首先，start方法和run方法的关系如下：用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。</strong></p><p><strong>而run()方法的源码如下，可以看到，如果我们指定了target即线程执行的函数的话，run方法可以转而调用那个函数，如果没有的话，将不执行，而我们在自定义的Thread类里面重写了这个run 方法，所以程序会执行这一段。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>    <span class="hljs-string">"""Method representing the thread's activity.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    You may override this method in a subclass. The standard run() method</span><br><span class="hljs-string">    invokes the callable object passed to the object's constructor as the</span><br><span class="hljs-string">    target argument, if any, with sequential and keyword arguments taken</span><br><span class="hljs-string">    from the args and kwargs arguments, respectively.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    """</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">if</span> self._target:<br>            self._target(*self._args, **self._kwargs)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-comment"># Avoid a refcycle if the thread is running a function with</span><br>        <span class="hljs-comment"># an argument that has a member that points to the thread.</span><br>        <span class="hljs-keyword">del</span> self._target, self._args, self._kwargs<br></code></pre></td></tr></table></figure><h2 id="4、按时间为批次执行线程">4、按时间为批次执行线程</h2><p><strong>线程有不确定性</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> threading<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hi</span><span class="hljs-params">(count, name)</span>:</span><br>    <span class="hljs-keyword">while</span> count &gt; <span class="hljs-number">0</span>:<br>        print(<span class="hljs-string">'hello'</span>, name)<br>        count -= <span class="hljs-number">1</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    username = [<span class="hljs-string">'Alan'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Cendy'</span>, <span class="hljs-string">'Kily'</span>,<span class="hljs-string">'Heny'</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):<br>        thread = threading.Thread(target=say_hi,args=(<span class="hljs-number">50</span>,username[i]))<br>        thread.start()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></table></figure><h5 id="输出结果-8">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">hello Alan<br>hello Alan<br>hello Alan<br>hello Alan<br>hello hello Bob<br>hello Bob<br>hello Bob<br>hello Bob<br>hello Bob<br>Alanhello Cendy<br>hello Cendyhello Bob<br>hello<br>hello Alanhello Cendy<br></code></pre></td></tr></table></figure></blockquote><h2 id="5、继承的方法">5、继承的方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hi</span><span class="hljs-params">(count,name)</span>:</span><br>    <span class="hljs-comment"># time.sleep(1)#延迟几秒</span><br>    <span class="hljs-comment"># print('hello world!')</span><br>    <span class="hljs-keyword">while</span> count &gt; <span class="hljs-number">0</span>:<br>        print(<span class="hljs-string">'hello'</span>, name)<br>        count -= <span class="hljs-number">1</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    username = [<span class="hljs-string">'Alan'</span>,<span class="hljs-string">'Bob'</span>,<span class="hljs-string">'Cendy'</span>,<span class="hljs-string">'Kily'</span>,<span class="hljs-string">'Heny'</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):<br>        <span class="hljs-comment"># thread = threading.Thread(target=say_hi,args=(10,username[i]))</span><br>        thread = MyThread(<span class="hljs-number">10</span>,username[i])<br>        thread.start()<br>    <span class="hljs-comment"># for i in range(5):</span><br>    <span class="hljs-comment">#     # 创建线程</span><br>    <span class="hljs-comment">#     thread = threading.Thread(target=say_hi)</span><br>    <span class="hljs-comment">#     # 启动线程</span><br>    <span class="hljs-comment">#     thread.start()</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, count, name)</span>:</span><br>        super().__init__()<br>        self.count = count<br>        self.name = name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">while</span> self.count &gt; <span class="hljs-number">0</span>:<br>            print(<span class="hljs-string">'hello'</span>, self.name)<br>            self.count -= <span class="hljs-number">1</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_main</span><span class="hljs-params">()</span>:</span><br>    username = [<span class="hljs-string">'Alan'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Cendy'</span>, <span class="hljs-string">'Kily'</span>, <span class="hljs-string">'Heny'</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):<br>        <span class="hljs-comment"># thread = threading.Thread(target=say_hi, args=(10, username[i]))</span><br>        thread = MyThread(<span class="hljs-number">10</span>,username[i])<br>        thread.start()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    run_main()<br></code></pre></td></tr></table></figure><h5 id="输出结果-9">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">hello Alan<br>hello Alan<br>hello Bob<br>hello Bob<br>hello Cendy<br>hello Cendy<br>hello Kily<br>hello Kily<br>hello Heny<br>hello Heny<br></code></pre></td></tr></table></figure></blockquote><h1>线程同步</h1><p><strong>如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。</strong></p><p><strong>使用Thread对象的Lock和Rlock可以实现简单的线程同步，这两个对象都有acquire方法和release方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到acquire和release方法之间。如下：</strong></p><p><strong>多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。</strong></p><p><strong>考虑这样一种情况：一个列表里所有元素都是0，线程&quot;set&quot;从后向前把所有元素改成1，而线程&quot;print&quot;负责从前往后读取列表并打印。</strong></p><p><strong>那么，可能线程&quot;set&quot;开始改的时候，线程&quot;print&quot;便来打印列表了，输出就成了一半0一半1，这就是数据的不同步。为了避免这种情况，引入了锁的概念。</strong></p><p><strong>锁有两种状态——锁定和未锁定。每当一个线程比如&quot;set&quot;要访问共享数据时，必须先获得锁定；如果已经有别的线程比如&quot;print&quot;获得锁定了，那么就让线程&quot;set&quot;暂停，也就是同步阻塞；等到线程&quot;print&quot;访问完毕，释放锁以后，再让线程&quot;set&quot;继续。</strong></p><p><strong>经过这样的处理，打印列表时要么全部输出0，要么全部输出1，不会再出现一半0一半1的尴尬场面。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myThread</span> <span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, threadID, name, counter)</span>:</span><br>        threading.Thread.__init__(self)<br>        self.threadID = threadID<br>        self.name = name<br>        self.counter = counter<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">print</span> (<span class="hljs-string">"开启线程： "</span> + self.name)<br>        <span class="hljs-comment"># 获取锁，用于线程同步</span><br>        threadLock.acquire()<br>        print_time(self.name, self.counter, <span class="hljs-number">3</span>)<br>        <span class="hljs-comment"># 释放锁，开启下一个线程</span><br>        threadLock.release()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_time</span><span class="hljs-params">(threadName, delay, counter)</span>:</span><br>    <span class="hljs-keyword">while</span> counter:<br>        time.sleep(delay)<br>        <span class="hljs-keyword">print</span> (<span class="hljs-string">"%s: %s"</span> % (threadName, time.ctime(time.time())))<br>        counter -= <span class="hljs-number">1</span><br><br>threadLock = threading.Lock()<br>threads = []<br><br><span class="hljs-comment"># 创建新线程</span><br>thread1 = myThread(<span class="hljs-number">1</span>, <span class="hljs-string">"Thread-1"</span>, <span class="hljs-number">1</span>)<br>thread2 = myThread(<span class="hljs-number">2</span>, <span class="hljs-string">"Thread-2"</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 开启新线程</span><br>thread1.start()<br>thread2.start()<br><br><span class="hljs-comment"># 添加线程到线程列表</span><br>threads.append(thread1)<br>threads.append(thread2)<br><br><span class="hljs-comment"># 等待所有线程完成</span><br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>    t.join()<br><span class="hljs-keyword">print</span> (<span class="hljs-string">"退出主线程"</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果-10">输出结果</h5><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">开启线程： <span class="hljs-selector-tag">Thread-1</span><br>开启线程： <span class="hljs-selector-tag">Thread-2</span><br><span class="hljs-selector-tag">Thread-1</span>: <span class="hljs-selector-tag">Thu</span> <span class="hljs-selector-tag">Aug</span> 10 20<span class="hljs-selector-pseudo">:45</span><span class="hljs-selector-pseudo">:59</span> 2017<br><span class="hljs-selector-tag">Thread-1</span>: <span class="hljs-selector-tag">Thu</span> <span class="hljs-selector-tag">Aug</span> 10 20<span class="hljs-selector-pseudo">:46</span><span class="hljs-selector-pseudo">:00</span> 2017<br><span class="hljs-selector-tag">Thread-1</span>: <span class="hljs-selector-tag">Thu</span> <span class="hljs-selector-tag">Aug</span> 10 20<span class="hljs-selector-pseudo">:46</span><span class="hljs-selector-pseudo">:01</span> 2017<br><span class="hljs-selector-tag">Thread-2</span>: <span class="hljs-selector-tag">Thu</span> <span class="hljs-selector-tag">Aug</span> 10 20<span class="hljs-selector-pseudo">:46</span><span class="hljs-selector-pseudo">:03</span> 2017<br><span class="hljs-selector-tag">Thread-2</span>: <span class="hljs-selector-tag">Thu</span> <span class="hljs-selector-tag">Aug</span> 10 20<span class="hljs-selector-pseudo">:46</span><span class="hljs-selector-pseudo">:05</span> 2017<br><span class="hljs-selector-tag">Thread-2</span>: <span class="hljs-selector-tag">Thu</span> <span class="hljs-selector-tag">Aug</span> 10 20<span class="hljs-selector-pseudo">:46</span><span class="hljs-selector-pseudo">:07</span> 2017<br>退出主线程<br></code></pre></td></tr></table></figure></blockquote><h1>线程优先级队列（ Queue）</h1><p><strong>Python的Queue模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列PriorityQueue。这些队列都实现了锁原语，能够在多线程中直接使用。可以使用队列来实现线程间的同步。</strong></p><h4 id="Queue模块中的常用方法">Queue模块中的常用方法:</h4><ul><li><strong>Queue.qsize() 返回队列的大小</strong></li><li><strong>Queue.empty() 如果队列为空，返回True,反之False</strong></li><li><strong>Queue.full() 如果队列满了，返回True,反之False</strong></li><li><strong>Queue.full 与 maxsize 大小对应</strong></li><li><strong>Queue.get([block[, timeout]])获取队列，timeout等待时间</strong></li><li><strong>Queue.get_nowait() 相当Queue.get(False)</strong></li><li><strong>Queue.put(item) 写入队列，timeout等待时间</strong></li><li><strong>Queue.put_nowait(item) 相当Queue.put(item, False)</strong></li><li><strong>Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号</strong></li><li><strong>Queue.join() 实际上意味着等到队列为空，再执行别的操作</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">import</span> queue<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br>exitFlag = <span class="hljs-number">0</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myThread</span> <span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, threadID, name, q)</span>:</span><br>        threading.Thread.__init__(self)<br>        self.threadID = threadID<br>        self.name = name<br>        self.q = q<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">print</span> (<span class="hljs-string">"开启线程："</span> + self.name)<br>        process_data(self.name, self.q)<br>        <span class="hljs-keyword">print</span> (<span class="hljs-string">"退出线程："</span> + self.name)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_data</span><span class="hljs-params">(threadName, q)</span>:</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> exitFlag:<br>        queueLock.acquire()<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> workQueue.empty():<br>            data = q.get()<br>            queueLock.release()<br>            <span class="hljs-keyword">print</span> (<span class="hljs-string">"%s processing %s"</span> % (threadName, data))<br>        <span class="hljs-keyword">else</span>:<br>            queueLock.release()<br>        time.sleep(<span class="hljs-number">1</span>)<br><br>threadList = [<span class="hljs-string">"Thread-1"</span>, <span class="hljs-string">"Thread-2"</span>, <span class="hljs-string">"Thread-3"</span>]<br>nameList = [<span class="hljs-string">"One"</span>, <span class="hljs-string">"Two"</span>, <span class="hljs-string">"Three"</span>, <span class="hljs-string">"Four"</span>, <span class="hljs-string">"Five"</span>]<br>queueLock = threading.Lock()<br>workQueue = queue.Queue(<span class="hljs-number">10</span>)<br>threads = []<br>threadID = <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 创建新线程</span><br><span class="hljs-keyword">for</span> tName <span class="hljs-keyword">in</span> threadList:<br>    thread = myThread(threadID, tName, workQueue)<br>    thread.start()<br>    threads.append(thread)<br>    threadID += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 填充队列</span><br>queueLock.acquire()<br><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> nameList:<br>    workQueue.put(word)<br>queueLock.release()<br><br><span class="hljs-comment"># 等待队列清空</span><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> workQueue.empty():<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 通知线程是时候退出</span><br>exitFlag = <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 等待所有线程完成</span><br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>    t.join()<br><span class="hljs-keyword">print</span> (<span class="hljs-string">"退出主线程"</span>)<br></code></pre></td></tr></table></figure><p><strong>上面的代码每次执行的结果是不一样的，取决于哪个进程先获得锁，一次运行的输出如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">开启线程：Thread<span class="hljs-number">-1</span><br>开启线程：Thread<span class="hljs-number">-2</span><br>开启线程：Thread<span class="hljs-number">-3</span><br>Thread<span class="hljs-number">-2</span> processing One<br>Thread<span class="hljs-number">-3</span> processing Two<br>Thread<span class="hljs-number">-1</span> processing Three<br>Thread<span class="hljs-number">-3</span> processing Four<br>Thread<span class="hljs-number">-1</span> processing Five<br>退出线程：Thread<span class="hljs-number">-3</span><br>退出线程：Thread<span class="hljs-number">-2</span><br>退出线程：Thread<span class="hljs-number">-1</span><br>退出主线程<br></code></pre></td></tr></table></figure><h1>总结</h1><p><strong>如果你的代码是IO密集型的，线程和多进程可以帮到你。多进程比线程更易用，但是消耗更多的内存。如果你的代码是CPU密集型的，多进程就明显是更好的选择——特别是所使用的机器是多核或多CPU的。对于网络应用，在你需要扩展到多台机器上执行任务，RQ是更好的选择。</strong></p><h1>注：关于并发、并行区别与联系</h1><ul><li><strong>并发是指，程序在运行的过程中存在多于一个的执行上下文。这些执行上下文一般对应着不同的调用栈。</strong></li></ul><p><strong>在单处理器上，并发程序虽然有多个上下文运行环境，但某一个时刻只有一个任务在运行。</strong></p><p><strong>但在多处理器上，因为有了多个执行单元，就可以同时有数个任务在跑。</strong></p><ul><li><strong>这种物理上同一时刻有多个任务同时运行的方式就是并行。</strong></li></ul><p><strong>和并发相比，并行更加强调多个任务同时在运行。</strong></p><p><strong>而且并行还有一个层次问题，比如是指令间的并行还是任务间的并行。</strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python并发线程介绍</title>
      <link href="/posts/f802.html"/>
      <url>/posts/f802.html</url>
      
        <content type="html"><![CDATA[<h1>Python 多线程</h1><p><strong>多线程类似于同时执行多个不同程序，多线程运行有如下优点：</strong></p><ul><li><strong>使用线程可以把占据长时间的程序中的任务放到后台去处理。</strong></li><li><strong>用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度</strong></li><li><strong>程序的运行速度可能加快</strong></li><li><strong>在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下我们可以释放一些珍贵的资源如内存占用等等。</strong></li></ul><p><strong>线程在执行过程中与进程还是有区别的。每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</strong></p><p><strong>每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。</strong></p><p><strong>指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程地址空间中的内存。</strong></p><ul><li><strong>线程可以被抢占（中断）。</strong></li><li><strong>在其他线程正在运行时，线程可以暂时搁置（也称为睡眠） – 这就是线程的退让。</strong></li></ul><h2 id="线程和进程">线程和进程</h2><p><strong>计算机，用于计算的机器。计算机的核心是CPU，在现在多核心的电脑很常见了。为了充分利用cpu核心做计算任务，程序实现了多线程模型。通过多线程实现多任务的并行执行。</strong></p><p><strong>现在的操作系统多是多任务操作系统。每个应用程序都有一个自己的进程。操作系统会为这些进程分配一些执行资源，例如内存空间等。在进程中，又可以创建一些线程，他们共享这些内存空间，并由操作系统调用，以便并行计算。</strong></p><h2 id="线程状态">线程状态</h2><p><strong>创建线程之后，线程并不是始终保持一个状态。其状态大概如下：</strong></p><ul><li><strong><code>New</code> 创建。</strong></li><li><strong><code>Runnable</code> 就绪。等待调度</strong></li><li><strong><code>Running</code> 运行。</strong></li><li><strong><code>Blocked</code> 阻塞。阻塞可能在 <code>Wait</code> <code>Locked</code> <code>Sleeping</code></strong></li><li><strong><code>Dead</code> 消亡</strong></li></ul><p><strong>这些状态之间是可以相互转换的，一图胜千颜色：</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200617230746843.png" alt="image-20200617230746843"></p><p><strong>线程中执行到阻塞，可能有3种情况：</strong></p><blockquote><ul><li><strong>同步：线程中获取同步锁，但是资源已经被其他线程锁定时，进入Locked状态，直到该资源可获取（获取的顺序由Lock队列控制）</strong></li></ul></blockquote><blockquote><ul><li><strong>睡眠：线程运行sleep()或join()方法后，线程进入Sleeping状态。区别在于sleep等待固定的时间，而join是等待子线程执行完。当然join也可以指定一个“超时时间”。从语义上来说，如果两个线程a,b, 在a中调用b.join()，相当于合并(join)成一个线程。最常见的情况是在主线程中join所有的子线程。</strong></li></ul></blockquote><blockquote><ul><li><strong>等待：线程中执行wait()方法后，线程进入Waiting状态，等待其他线程的通知(notify）</strong>。</li></ul></blockquote><h2 id="线程类型">线程类型</h2><p><strong>线程有着不同的状态，也有不同的类型。大致可分为：</strong></p><ul><li><strong>主线程</strong></li><li><strong>子线程</strong></li><li><strong>守护线程（后台线程）</strong></li><li><strong>前台线程</strong></li></ul><h2 id="Python线程与GIL">Python线程与GIL</h2><p><strong>相比进程，线程更加轻量，可以实现并发。可是在python的世界里，对于线程，就不得不说一句GIL(全局解释器锁)。GIL的存在让python的多线程多少有点鸡肋了。Cpython的线程是操作系统原生的线程在解释器解释执行任何Python代码时，都需要先获得这把锁才行，在遇到 I/O 操作时会释放这把锁。因为python的进程做为一个整体，解释器进程内只有一个线程在执行，其它的线程都处于等待状态等着GIL的释放。</strong></p><p><strong>关于GIL可以有更多的趣事，一时半会都说不完。总之python想用多线程并发，效果可能还不如单线程（线程切换耗时间）。想要利用多核，可以考虑使用多进程。</strong></p><h2 id="线程和进程-2">线程和进程</h2><p><strong>计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200617231007827.png" alt="image-20200617231007827"></p><p><strong>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200617231015022.png" alt="image-20200617231015022"></p><p><strong>进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200617231026133.png" alt="image-20200617231026133"></p><p><strong>一个车间里，可以有很多工人。他们协同完成一个任务。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200617231043032.png" alt="image-20200617231043032"></p><p><strong>线程就好比车间里的工人。一个进程可以包括多个线程。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200617231052605.png" alt="image-20200617231052605"></p><p><strong>车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200617231102445.png" alt="image-20200617231102445"></p><p><strong>可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200617231110670.png" alt="image-20200617231110670"></p><p><strong>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫&quot;互斥锁&quot;（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200617231119981.png" alt="image-20200617231119981"></p><p><strong>还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200617231128469.png" alt="image-20200617231128469"></p><p><strong>这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做&quot;信号量&quot;（Semaphore），用来保证多个线程不会互相冲突。</strong><br><strong>不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200617231134847.png" alt="image-20200617231134847"></p><h2 id="多线程与多进程">多线程与多进程</h2><p><strong>从上面关于线程和进程的的通俗解释来看，多线程和多进程的含义如下：</strong><br><strong>多进程：允许多个任务同时进行</strong><br><strong>多线程：允许单个任务分成不同的部分运行</strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 操作 MySQL 写入读出 CSV 文件</title>
      <link href="/posts/5bf9.html"/>
      <url>/posts/5bf9.html</url>
      
        <content type="html"><![CDATA[<h2 id="一-Python-操作-MySQL-写入读出-CSV-文件">一.Python 操作 MySQL 写入读出 CSV 文件</h2><p><strong>有一个数据文件，是 csv 格式，大约 1T 数据，要导入到 MySQL，要求正确高效。</strong></p><p>csv 数据格式这个样子的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@python ~]<span class="hljs-comment"># cat data.csv</span><br>Symbol,Price,Date<br>AA, <span class="hljs-number">39.48</span>, <span class="hljs-number">6</span>/<span class="hljs-number">11</span>/<span class="hljs-number">2007</span><br>AIG, <span class="hljs-number">71.38</span>, <span class="hljs-number">6</span>/<span class="hljs-number">11</span>/<span class="hljs-number">2007</span><br>AXP, <span class="hljs-number">62.58</span>, <span class="hljs-number">6</span>/<span class="hljs-number">11</span>/<span class="hljs-number">2007</span><br>BA, <span class="hljs-number">98.31</span>, <span class="hljs-number">6</span>/<span class="hljs-number">11</span>/<span class="hljs-number">2007</span><br>C, <span class="hljs-number">53.08</span>, <span class="hljs-number">6</span>/<span class="hljs-number">11</span>/<span class="hljs-number">2007</span><br>CAT, <span class="hljs-number">78.29</span>, <span class="hljs-number">6</span>/<span class="hljs-number">11</span>/<span class="hljs-number">2007</span><br></code></pre></td></tr></table></figure><p><strong>正好最近要写再测试数据库的脚本，虽然两者不搭边，总归都是操作数据库的，正好测试的时候就用 python 连了</strong></p><p><strong>首先 Python 数据库接口支持很多数据库，什么关系型的像 mysql 啊、PG（PostgreSQL） 啊、SQL Server、Oracle，非关系型的像 MongoDB 啊，Redis 啊， Hbase 等等，</strong></p><p><strong>这里就以 MySQL 数据库为例，毕竟我要用的 MySQL 嘛，而且面试题也是，当然操作其他数据库道理也都一样，从一个 csv 文件中读入数据，插入到数据库中，再将数据库中的数据读出，保存到另一个 csv 文件。</strong></p><h2 id="介绍">介绍</h2><p><strong>主要定义两个对象，一个用于管理连接的 Connection（count） 了，另一个是用于执行查询的 Cursor （cur）对象。</strong></p><h2 id="Python-操作数据库的大致思路">Python 操作数据库的大致思路</h2><ul><li><strong>导入模块</strong></li><li><strong>连接数据库</strong></li><li><strong>执行查询返回结果</strong></li></ul><h2 id="步骤：">步骤：</h2><ul><li><strong>导入数据库模块 <code>import MySQLdb</code></strong></li><li><strong>连接数据库 <code>connect</code> ，返回一个 <code>conn</code> 对象</strong></li><li><strong>通过该对象的 <code>cursor()</code> 成员函数返回一个 <code>cur</code> 对象</strong></li><li><strong>通过 <code>cur</code> 对象的 <code>execute()</code> 方法执行 SQL 语句</strong></li><li><strong>关闭 <code>cur</code> 和 <code>conn</code>对象</strong></li></ul><h2 id="1、读文件">1、读文件</h2><p><strong>如何用Python像操作Excel一样提取其中的一列，即一个字段，利用Python自带的<a href="https://docs.python.org/2/library/csv.html" target="_blank" rel="noopener">csv模块</a>，有两种方法可以实现：</strong></p><p><strong>第一种方法使用reader函数，接收一个可迭代的对象（比如csv文件），能返回一个生成器，就可以从其中解析出csv的内容：比如下面的代码可以读取csv的全部内容，以行为单位：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">import</span> csv<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><br><span class="hljs-string">'''读取csv文件'''</span><br><span class="hljs-keyword">with</span> open(<span class="hljs-string">'data.csv'</span>) <span class="hljs-keyword">as</span> f:<br>    f_csv = csv.reader(f)<br>    <span class="hljs-comment"># 取出csv文件头：表头</span><br>    headers = next(f_csv)<br>    <span class="hljs-comment"># 遍历表头以外的所有行</span><br>    d = namedtuple(<span class="hljs-string">'Row'</span>, <span class="hljs-string">'headers'</span>)<br>    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> f_csv:<br>        row = d(r)<br>        print(row)<br></code></pre></td></tr></table></figure><h5 id="输出结果">输出结果</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">Row(headers=[<span class="hljs-string">'AA'</span>, <span class="hljs-string">' 39.48'</span>, <span class="hljs-string">' 6/11/2007'</span>])<br>Row(headers=[<span class="hljs-string">'AIG'</span>, <span class="hljs-string">' 71.38'</span>, <span class="hljs-string">' 6/11/2007'</span>])<br>Row(headers=[<span class="hljs-string">'AXP'</span>, <span class="hljs-string">' 62.58'</span>, <span class="hljs-string">' 6/11/2007'</span>])<br>Row(headers=[<span class="hljs-string">'BA'</span>, <span class="hljs-string">' 98.31'</span>, <span class="hljs-string">' 6/11/2007'</span>])<br>Row(headers=[<span class="hljs-string">'C'</span>, <span class="hljs-string">' 53.08'</span>, <span class="hljs-string">' 6/11/2007'</span>])<br>Row(headers=[<span class="hljs-string">'CAT'</span>, <span class="hljs-string">' 78.29'</span>, <span class="hljs-string">' 6/11/2007'</span>])<br></code></pre></td></tr></table></figure><p><strong>或</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br>__author__ = <span class="hljs-string">'mayi'</span><br><br><span class="hljs-keyword">import</span> csv<br><br><span class="hljs-comment">#读</span><br><span class="hljs-keyword">with</span> open(<span class="hljs-string">"data.csv"</span>, <span class="hljs-string">"r"</span>, encoding = <span class="hljs-string">"utf-8"</span>) <span class="hljs-keyword">as</span> f:<br>    reader = csv.reader(f)<br>    rows = [row <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader]<br><br>print(rows)<br></code></pre></td></tr></table></figure><h5 id="输出结果-2">输出结果</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">[[<span class="hljs-string">'Symbol'</span>, <span class="hljs-string">'Price'</span>, <span class="hljs-string">'Date'</span>], <br> [<span class="hljs-string">'AA'</span>, <span class="hljs-string">' 39.48'</span>, <span class="hljs-string">' 6/11/2007'</span>], <br> [<span class="hljs-string">'AIG'</span>, <span class="hljs-string">' 71.38'</span>, <span class="hljs-string">' 6/11/2007'</span>], <br> [<span class="hljs-string">'AXP'</span>, <span class="hljs-string">' 62.58'</span>, <span class="hljs-string">' 6/11/2007'</span>], <br> [<span class="hljs-string">'BA'</span>, <span class="hljs-string">' 98.31'</span>, <span class="hljs-string">' 6/11/2007'</span>], <br> [<span class="hljs-string">'C'</span>, <span class="hljs-string">' 53.08'</span>, <span class="hljs-string">' 6/11/2007'</span>], <br> [<span class="hljs-string">'CAT'</span>, <span class="hljs-string">' 78.29'</span>, <span class="hljs-string">' 6/11/2007'</span>]]<br></code></pre></td></tr></table></figure><h3 id="要提取其中某一列，可以用下面的代码：">要提取其中某一列，可以用下面的代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br>__author__ = <span class="hljs-string">'mayi'</span><br><br><span class="hljs-keyword">import</span> csv<br><br><span class="hljs-comment">#读取第二列的内容</span><br><span class="hljs-keyword">with</span> open(<span class="hljs-string">"data.csv"</span>, <span class="hljs-string">"r"</span>, encoding = <span class="hljs-string">"utf-8"</span>) <span class="hljs-keyword">as</span> f:<br>    reader = csv.reader(f)<br>    column = [row[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader]<br><br>print(column)<br></code></pre></td></tr></table></figure><h5 id="输出结果-3">输出结果</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">'Price'</span>, <span class="hljs-string">' 39.48'</span>, <span class="hljs-string">' 71.38'</span>, <span class="hljs-string">' 62.58'</span>, <span class="hljs-string">' 98.31'</span>, <span class="hljs-string">' 53.08'</span>, <span class="hljs-string">' 78.29'</span>]<br></code></pre></td></tr></table></figure><p><strong>注意从csv读出的都是str类型。这种方法要事先知道列的序号，比如Name在第2列，而不能根据’Name’这个标题查询。这时可以采用第二种方法：</strong></p><h2 id="2、第二种方法">2、第二种方法</h2><p><strong>是使用DictReader，和reader函数类似，接收一个可迭代的对象，能返回一个生成器，但是返回的每一个单元格都放在一个字典的值内，而这个字典的键则是这个单元格的标题（即列头）。用下面的代码可以看到DictReader的结构：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br>__author__ = <span class="hljs-string">'mayi'</span><br><br><span class="hljs-keyword">import</span> csv<br><br><span class="hljs-comment">#读</span><br><span class="hljs-keyword">with</span> open(<span class="hljs-string">"data.csv"</span>, <span class="hljs-string">"r"</span>, encoding = <span class="hljs-string">"utf-8"</span>) <span class="hljs-keyword">as</span> f:<br>    reader = csv.DictReader(f)<br>    column = [row <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader]<br><br>print(column)<br></code></pre></td></tr></table></figure><h5 id="输出结果-4">输出结果</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">[&#123;<span class="hljs-string">'Symbol'</span>: <span class="hljs-string">'AA'</span>, <span class="hljs-string">'Price'</span>: <span class="hljs-string">' 39.48'</span>, <span class="hljs-string">'Date'</span>: <span class="hljs-string">' 6/11/2007'</span>&#125;, <br> &#123;<span class="hljs-string">'Symbol'</span>: <span class="hljs-string">'AIG'</span>, <span class="hljs-string">'Price'</span>: <span class="hljs-string">' 71.38'</span>, <span class="hljs-string">'Date'</span>: <span class="hljs-string">' 6/11/2007'</span>&#125;, <br> &#123;<span class="hljs-string">'Symbol'</span>: <span class="hljs-string">'AXP'</span>, <span class="hljs-string">'Price'</span>: <span class="hljs-string">' 62.58'</span>, <span class="hljs-string">'Date'</span>: <span class="hljs-string">' 6/11/2007'</span>&#125;, <br> &#123;<span class="hljs-string">'Symbol'</span>: <span class="hljs-string">'BA'</span>, <span class="hljs-string">'Price'</span>: <span class="hljs-string">' 98.31'</span>, <span class="hljs-string">'Date'</span>: <span class="hljs-string">' 6/11/2007'</span>&#125;, <br> &#123;<span class="hljs-string">'Symbol'</span>: <span class="hljs-string">'C'</span>, <span class="hljs-string">'Price'</span>: <span class="hljs-string">' 53.08'</span>, <span class="hljs-string">'Date'</span>: <span class="hljs-string">' 6/11/2007'</span>&#125;, <br> &#123;<span class="hljs-string">'Symbol'</span>: <span class="hljs-string">'CAT'</span>, <span class="hljs-string">'Price'</span>: <span class="hljs-string">' 78.29'</span>, <span class="hljs-string">'Date'</span>: <span class="hljs-string">' 6/11/2007'</span>&#125;]<br></code></pre></td></tr></table></figure><h2 id="3、把-csv-中的数据读出来放到插入到-mysql-表">3、把 csv 中的数据读出来放到插入到 mysql 表</h2><p><strong>对于 mysql 数据库，需要安装第三方模块 Mysql-python 。安装完以后，在程序中导入模块即可。</strong></p><p><strong>库名：student_info</strong><br><strong>表名：data_csv</strong></p><p><strong>首先要导入 MySQLdb 模块先安装 MySQLdb</strong></p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install MySQLdb<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">import</span> pymysql <span class="hljs-keyword">as</span> db<br><span class="hljs-keyword">import</span> csv<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager<br><br><br><span class="hljs-meta">@contextmanager</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_conn</span><span class="hljs-params">(**kwargs)</span>:</span><br>    <span class="hljs-string">'''获取mysql数据库连接'''</span><br>    conn = db.connect(<br>        host=kwargs.get(<span class="hljs-string">'host'</span>),<br>        user=kwargs.get(<span class="hljs-string">'user'</span>),<br>        passwd=kwargs.get(<span class="hljs-string">'passwd'</span>),<br>        port=kwargs.get(<span class="hljs-string">'port'</span>, <span class="hljs-number">3306</span>),<br>        db=kwargs.get(<span class="hljs-string">'db'</span>))<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">yield</span> conn<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-keyword">if</span> conn:<br>            conn.close()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_data</span><span class="hljs-params">(filename)</span>:</span><br>    <span class="hljs-string">'''读取csv文件'''</span><br>    <span class="hljs-keyword">with</span> open(filename) <span class="hljs-keyword">as</span> f:<br>        f_csv = csv.reader(f)<br>        <span class="hljs-comment"># 取出csv文件头：表头</span><br>        headers = next(f_csv)<br>        <span class="hljs-comment"># 遍历表头以外的所有行</span><br>        Row = namedtuple(<span class="hljs-string">"Row"</span>, [<span class="hljs-string">'Symbol'</span>, <span class="hljs-string">'Price'</span>, <span class="hljs-string">'Date'</span>])<br>        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> f_csv:<br>            <span class="hljs-keyword">yield</span> Row(*r)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">execute_sql</span><span class="hljs-params">(conn, sql)</span>:</span><br>    <span class="hljs-string">'''执行SQL的函数'''</span><br>    <span class="hljs-keyword">with</span> conn <span class="hljs-keyword">as</span> cur:<br>        cur.execute(sql)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_table</span><span class="hljs-params">(conn)</span>:</span><br>    <span class="hljs-string">'''创建新表'''</span><br>    sql_drop_table = <span class="hljs-string">'drop table if exists data_csv'</span><br>    sql_create_table = <span class="hljs-string">'''create table `data_csv`(</span><br><span class="hljs-string">    `Symbol` varchar (20) not null,</span><br><span class="hljs-string">    `Price` decimal not null,</span><br><span class="hljs-string">    `Date` varchar (20)  default null) engine=innodb default charset=utf8mb4</span><br><span class="hljs-string">    '''</span><br>    <span class="hljs-keyword">for</span> sql <span class="hljs-keyword">in</span> [sql_drop_table, sql_create_table]:<br>        execute_sql(conn, sql)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert_data</span><span class="hljs-params">(conn, symbol, price, date)</span>:</span><br>    insert_format = <span class="hljs-string">"insert into data_csv values('&#123;0&#125;','&#123;1&#125;','&#123;2&#125;')"</span><br>    sql = insert_format.format(symbol, price, date)<br>    execute_sql(conn, sql)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    conn_args = dict(host=<span class="hljs-string">'127.0.0.1'</span>,<br>                     user=<span class="hljs-string">'root'</span>,<br>                     passwd=<span class="hljs-string">'123456'</span>,<br>                     port=<span class="hljs-number">3306</span>,<br>                     db=<span class="hljs-string">'student_info'</span>)<br><br>    <span class="hljs-keyword">with</span> get_conn(**conn_args) <span class="hljs-keyword">as</span> conn:<br>        <span class="hljs-keyword">with</span> conn <span class="hljs-keyword">as</span> cur:<br>            create_table(conn)<br>            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> get_data(<span class="hljs-string">'data.csv'</span>):<br>                insert_data(conn, t.Symbol, t.Price, t.Date)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200617221438084.png" alt="image-20200617221438084"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 操作 MySQL 数据库</title>
      <link href="/posts/26aa.html"/>
      <url>/posts/26aa.html</url>
      
        <content type="html"><![CDATA[<h1>Python 操作 MySQL 数据库</h1><p><strong>Python 标准数据库接口为 Python DB-API，Python DB-API为开发人员提供了数据库应用编程接口。</strong></p><p><strong>Python 数据库接口支持非常多的数据库，你可以选择适合你项目的数据库：</strong></p><ul><li><strong>GadFly</strong></li><li><strong>mSQL</strong></li><li><strong>MySQL</strong></li><li><strong>PostgreSQL</strong></li><li><strong>Microsoft SQL Server 2000</strong></li><li><strong>Informix</strong></li><li><strong>Interbase</strong></li><li><strong>Oracle</strong></li><li><strong>Sybase</strong></li></ul><p><strong>你可以访问<a href="https://wiki.python.org/moin/DatabaseInterfaces" target="_blank" rel="noopener">Python数据库接口及API</a>查看详细的支持数据库列表。</strong></p><p><strong>不同的数据库你需要下载不同的DB API模块，例如你需要访问Oracle数据库和Mysql数据，你需要下载Oracle和MySQL数据库模块。</strong></p><p><strong>DB-API 是一个规范. 它定义了一系列必须的对象和数据库存取方式, 以便为各种各样的底层数据库系统和多种多样的数据库接口程序提供一致的访问接口 。</strong></p><p><strong>Python的DB-API，为大多数的数据库实现了接口，使用它连接各数据库后，就可以用相同的方式操作各数据库。</strong></p><p><strong>Python DB-API使用流程：</strong></p><ul><li><strong>引入 API 模块。</strong></li><li><strong>获取与数据库的连接。</strong></li><li><strong>执行SQL语句和存储过程。</strong></li><li><strong>关闭数据库连接。</strong></li></ul><h2 id="1、什么是MySQLdb">1、什么是MySQLdb?</h2><p><strong>MySQLdb 是用于Python链接Mysql数据库的接口，它实现了 Python 数据库 API 规范 V2.0，基于 MySQL C API 上建立的。</strong></p><h2 id="2、如何安装MySQLdb">2、如何安装MySQLdb?</h2><p><strong>为了用DB-API编写MySQL脚本，必须确保已经安装了MySQL。复制以下代码，并执行：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">import</span> MySQLdb<br></code></pre></td></tr></table></figure><p><strong>如果执行后的输出结果如下所示，意味着你没有安装 MySQLdb 模块：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Traceback (most recent call last):<br>  File <span class="hljs-string">"test.py"</span>, line <span class="hljs-number">3</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-keyword">import</span> MySQLdb<br>ImportError: No module named MySQLdb<br></code></pre></td></tr></table></figure><p><strong>安装MySQLdb，请访问 <a href="http://sourceforge.net/projects/mysql-python" target="_blank" rel="noopener">http://sourceforge.net/projects/mysql-python</a> ，(Linux平台可以访问：<a href="https://pypi.python.org/pypi/MySQL-python" target="_blank" rel="noopener">https://pypi.python.org/pypi/MySQL-python</a>)从这里可选择适合您的平台的安装包，分为预编译的二进制文件和源代码安装包。</strong></p><p><strong>如果您选择二进制文件发行版本的话，安装过程基本安装提示即可完成。如果从源代码进行安装的话，则需要切换到MySQLdb发行版本的顶级目录，并键入下列命令:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">$ gunzip MySQL-python<span class="hljs-number">-1.2</span><span class="hljs-number">.2</span>.tar.gz<br>$ tar -xvf MySQL-python<span class="hljs-number">-1.2</span><span class="hljs-number">.2</span>.tar<br>$ cd MySQL-python<span class="hljs-number">-1.2</span><span class="hljs-number">.2</span><br>$ python setup.py build<br>$ python setup.py install<br></code></pre></td></tr></table></figure><blockquote><p>**注意：**请确保您有root权限来安装上述模块。</p></blockquote><h2 id="3、数据库连接">3、数据库连接</h2><p><strong>连接数据库前，请先确认以下事项：</strong></p><ul><li><strong>您已经创建了数据库 TESTDB.</strong></li><li><strong>在TESTDB数据库中您已经创建了表 EMPLOYEE</strong></li><li><strong>EMPLOYEE表字段为 FIRST_NAME, LAST_NAME, AGE, SEX 和 INCOME。</strong></li><li><strong>连接数据库TESTDB使用的用户名为 “testuser” ，密码为 “test123”,你可以可以自己设定或者直接使用root用户名及其密码，Mysql数据库用户授权请使用Grant命令。</strong></li><li><strong>在你的机子上已经安装了 Python MySQLdb 模块。</strong></li><li><strong>如果您对sql语句不熟悉，可以访问我们的 <a href="https://www.runoob.com/sql/sql-tutorial.html" target="_blank" rel="noopener">SQL基础教程</a></strong></li></ul><h3 id="实例1：">实例1：</h3><p><strong>以下实例链接Mysql的student_info数据库：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">import</span> MySQLdb<br><br><span class="hljs-comment"># 打开数据库连接</span><br>db = MySQLdb.connect(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"123456"</span>, <span class="hljs-string">"student_info"</span>, charset=<span class="hljs-string">'utf8'</span> )<br><span class="hljs-comment">#db = MySQLdb.connect("ip地址", "用户", "密码", "数据库", charset='utf8' )</span><br><br><span class="hljs-comment"># 使用cursor()方法获取操作游标</span><br>cursor = db.cursor()<br><br><span class="hljs-comment"># 使用execute方法执行SQL语句</span><br>cursor.execute(<span class="hljs-string">"SELECT VERSION()"</span>)<br><br><span class="hljs-comment"># 使用 fetchone() 方法获取一条数据</span><br>data = cursor.fetchone()<br><br>print(<span class="hljs-string">"Database version : %s"</span> % data)<br><br><span class="hljs-comment"># 关闭数据库连接</span><br>db.close()<br></code></pre></td></tr></table></figure><h5 id="执行以上脚本输出结果如下：">执行以上脚本输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Database version : <span class="hljs-number">5.7</span><span class="hljs-number">.14</span>-log<br></code></pre></td></tr></table></figure></blockquote><h3 id="实例2：">实例2：</h3><p><strong>以下实例链接Mysql的student_info数据库并查看user表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># encoding=utf-8</span><br><span class="hljs-keyword">import</span> pymysql <span class="hljs-keyword">as</span> db<br><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager<br><br><br><span class="hljs-meta">@contextmanager</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_conn</span><span class="hljs-params">(**kwargs)</span>:</span><br>    <span class="hljs-string">'''获取mysql数据库连接'''</span><br>    conn = db.connect(<br>        host=kwargs.get(<span class="hljs-string">'host'</span>),<br>        user=kwargs.get(<span class="hljs-string">'user'</span>),<br>        passwd=kwargs.get(<span class="hljs-string">'passwd'</span>),<br>        port=kwargs.get(<span class="hljs-string">'port'</span>, <span class="hljs-number">3306</span>),<br>        db=kwargs.get(<span class="hljs-string">'db'</span>))<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">yield</span> conn<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-keyword">if</span> conn:<br>            conn.close()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">execute_sql</span><span class="hljs-params">(conn, sql)</span>:</span><br>    <span class="hljs-string">'''执行SQL的函数'''</span><br>    <span class="hljs-comment"># cur = conn.cursor()</span><br>    <span class="hljs-keyword">with</span> conn <span class="hljs-keyword">as</span> cur:<br>        cur.execute(sql)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_table</span><span class="hljs-params">(conn)</span>:</span><br>    <span class="hljs-string">'''创建新表'''</span><br>    sql_drop_table = <span class="hljs-string">'drop table if exists student'</span><br>    sql_create_table = <span class="hljs-string">'''create table `student`(</span><br><span class="hljs-string">    `sno` int(11) not null,</span><br><span class="hljs-string">    `sname` varchar(25) default null,</span><br><span class="hljs-string">    `sage` int(11) default null,</span><br><span class="hljs-string">    primary key (`sno`)) engine=innodb default charset=utf8mb4</span><br><span class="hljs-string">    '''</span><br>    <span class="hljs-keyword">for</span> sql <span class="hljs-keyword">in</span> [sql_drop_table, sql_create_table]:<br>        execute_sql(conn, sql)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert_data</span><span class="hljs-params">(conn, sno, sname, sage)</span>:</span><br>    insert_format = <span class="hljs-string">"insert into student values(&#123;0&#125;,'&#123;1&#125;',&#123;2&#125;)"</span><br>    sql = insert_format.format(sno, sname, sage)<br>    execute_sql(conn, sql)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    conn_args = dict(host=<span class="hljs-string">'127.0.0.1'</span>,<br>                     user=<span class="hljs-string">'root'</span>,<br>                     passwd=<span class="hljs-string">'123456'</span>,<br>                     port=<span class="hljs-number">3306</span>,<br>                     db=<span class="hljs-string">'student_info'</span>)<br><br>    <span class="hljs-keyword">with</span> get_conn(**conn_args) <span class="hljs-keyword">as</span> conn:<br>        <span class="hljs-keyword">with</span> conn <span class="hljs-keyword">as</span> cur:<br>            cur.execute(<span class="hljs-string">'select * from user'</span>)<br>            rows = cur.fetchall()<br>            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows:<br>                print(row)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></table></figure><h5 id="执行以上脚本输出结果如下：-2">执行以上脚本输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(<span class="hljs-number">111</span>,)<br></code></pre></td></tr></table></figure></blockquote><h2 id="4、创建数据库表">4、创建数据库表</h2><p><strong>如果数据库连接存在我们可以使用execute()方法来为数据库创建表，如下所示创建表EMPLOYEE：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">import</span> MySQLdb<br><br><span class="hljs-comment"># 打开数据库连接</span><br>db = MySQLdb.connect(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"123456"</span>, <span class="hljs-string">"student_info"</span>, charset=<span class="hljs-string">'utf8'</span> )<br><span class="hljs-comment">#db = MySQLdb.connect("ip地址", "用户", "密码", "数据库", charset='utf8' )</span><br><br><span class="hljs-comment"># 使用cursor()方法获取操作游标 </span><br>cursor = db.cursor()<br><br><span class="hljs-comment"># 如果数据表已经存在使用 execute() 方法删除表。</span><br>cursor.execute(<span class="hljs-string">"DROP TABLE IF EXISTS EMPLOYEE"</span>)<br><br><span class="hljs-comment"># 创建数据表SQL语句</span><br>sql = <span class="hljs-string">"""CREATE TABLE EMPLOYEE (</span><br><span class="hljs-string">         FIRST_NAME  CHAR(20) NOT NULL,</span><br><span class="hljs-string">         LAST_NAME  CHAR(20),</span><br><span class="hljs-string">         AGE INT,  </span><br><span class="hljs-string">         SEX CHAR(1),</span><br><span class="hljs-string">         INCOME FLOAT )"""</span><br><br>cursor.execute(sql)<br><br><span class="hljs-comment"># 关闭数据库连接</span><br>db.close()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200617213425719.png" alt="image-20200617213425719"></p><h2 id="5、数据库插入操作">5、数据库插入操作</h2><p><strong>以下实例使用执行 SQL INSERT 语句向表 EMPLOYEE 插入记录</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">import</span> MySQLdb<br><br><span class="hljs-comment"># 打开数据库连接</span><br>db = MySQLdb.connect(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"123456"</span>, <span class="hljs-string">"student_info"</span>, charset=<span class="hljs-string">'utf8'</span> )<br><span class="hljs-comment">#db = MySQLdb.connect("ip地址", "用户", "密码", "数据库", charset='utf8' )</span><br><br><span class="hljs-comment"># 使用cursor()方法获取操作游标 </span><br>cursor = db.cursor()<br><br><span class="hljs-comment"># SQL 插入语句</span><br>sql = <span class="hljs-string">"""INSERT INTO EMPLOYEE(FIRST_NAME,</span><br><span class="hljs-string">         LAST_NAME, AGE, SEX, INCOME)</span><br><span class="hljs-string">         VALUES ('Mac', 'Mohan', 20, 'M', 2000)"""</span><br><span class="hljs-keyword">try</span>:<br>   <span class="hljs-comment"># 执行sql语句</span><br>   cursor.execute(sql)<br>   <span class="hljs-comment"># 提交到数据库执行</span><br>   db.commit()<br><span class="hljs-keyword">except</span>:<br>   <span class="hljs-comment"># Rollback in case there is any error</span><br>   db.rollback()<br><br><span class="hljs-comment"># 关闭数据库连接</span><br>db.close()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200617213609033.png" alt="image-20200617213609033"></p><h4 id="以上例子也可以写成如下形式：">以上例子也可以写成如下形式：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">import</span> MySQLdb<br><br><span class="hljs-comment"># 打开数据库连接</span><br>db = MySQLdb.connect(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"123456"</span>, <span class="hljs-string">"student_info"</span>, charset=<span class="hljs-string">'utf8'</span> )<br><span class="hljs-comment">#db = MySQLdb.connect("ip地址", "用户", "密码", "数据库", charset='utf8' )</span><br><br><span class="hljs-comment"># 使用cursor()方法获取操作游标 </span><br>cursor = db.cursor()<br><br><span class="hljs-comment"># SQL 插入语句</span><br>sql = <span class="hljs-string">"INSERT INTO EMPLOYEE(FIRST_NAME, \</span><br><span class="hljs-string">       LAST_NAME, AGE, SEX, INCOME) \</span><br><span class="hljs-string">       VALUES (%s, %s, %s, %s, %s )"</span> % \<br>       (<span class="hljs-string">'Mac'</span>, <span class="hljs-string">'Mohan'</span>, <span class="hljs-number">20</span>, <span class="hljs-string">'M'</span>, <span class="hljs-number">2000</span>)<br><span class="hljs-keyword">try</span>:<br>   <span class="hljs-comment"># 执行sql语句</span><br>   cursor.execute(sql)<br>   <span class="hljs-comment"># 提交到数据库执行</span><br>   db.commit()<br><span class="hljs-keyword">except</span>:<br>   <span class="hljs-comment"># 发生错误时回滚</span><br>   db.rollback()<br><br><span class="hljs-comment"># 关闭数据库连接</span><br>db.close()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200617213609033.png" alt="image-20200617213609033"></p><h2 id="6、数据库查询操作">6、数据库查询操作</h2><p><strong>Python查询Mysql使用 fetchone() 方法获取单条数据, 使用fetchall() 方法获取多条数据。</strong></p><ul><li><strong><code>fetchone():</code> 该方法获取下一个查询结果集。结果集是一个对象</strong></li><li><strong><code>fetchall():</code>接收全部的返回结果行.</strong></li><li><strong><code>rowcount:</code> 这是一个只读属性，并返回执行execute()方法后影响的行数。</strong></li></ul><h3 id="实例：">实例：</h3><p><strong>查询EMPLOYEE表中salary（工资）字段大于1000的所有数据：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">import</span> MySQLdb<br><br><span class="hljs-comment"># 打开数据库连接</span><br>db = MySQLdb.connect(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"123456"</span>, <span class="hljs-string">"student_info"</span>, charset=<span class="hljs-string">'utf8'</span> )<br><span class="hljs-comment">#db = MySQLdb.connect("ip地址", "用户", "密码", "数据库", charset='utf8' )</span><br><br><span class="hljs-comment"># 使用cursor()方法获取操作游标</span><br>cursor = db.cursor()<br><br><span class="hljs-comment"># SQL 查询语句</span><br>sql = <span class="hljs-string">"SELECT * FROM EMPLOYEE \</span><br><span class="hljs-string">       WHERE INCOME &gt; %s"</span> % (<span class="hljs-number">1000</span>)<br><span class="hljs-keyword">try</span>:<br>   <span class="hljs-comment"># 执行SQL语句</span><br>   cursor.execute(sql)<br>   <span class="hljs-comment"># 获取所有记录列表</span><br>   results = cursor.fetchall()<br>   <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> results:<br>      fname = row[<span class="hljs-number">0</span>]<br>      lname = row[<span class="hljs-number">1</span>]<br>      age = row[<span class="hljs-number">2</span>]<br>      sex = row[<span class="hljs-number">3</span>]<br>      income = row[<span class="hljs-number">4</span>]<br>      <span class="hljs-comment"># 打印结果</span><br>      print(<span class="hljs-string">"fname=%s,lname=%s,age=%s,sex=%s,income=%s"</span> % \<br>             (fname, lname, age, sex, income ))<br><span class="hljs-keyword">except</span>:<br>   print(<span class="hljs-string">"Error: unable to fecth data"</span>)<br><br><span class="hljs-comment"># 关闭数据库连接</span><br>db.close()<br></code></pre></td></tr></table></figure><h5 id="以上脚本执行结果如下：">以上脚本执行结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fname=Mac,lname=Mohan,age=<span class="hljs-number">20</span>,sex=M,income=<span class="hljs-number">2000.0</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="7、数据库更新操作">7、数据库更新操作</h2><p><strong>更新操作用于更新数据表的的数据，以下实例将 EMPLOYEE 表中的 SEX 字段为 ‘M’ 的 AGE 字段递增 1：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">import</span> MySQLdb<br><br><span class="hljs-comment"># 打开数据库连接</span><br>db = MySQLdb.connect(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"123456"</span>, <span class="hljs-string">"student_info"</span>, charset=<span class="hljs-string">'utf8'</span> )<br><span class="hljs-comment">#db = MySQLdb.connect("ip地址", "用户", "密码", "数据库", charset='utf8' )</span><br><br><span class="hljs-comment"># 使用cursor()方法获取操作游标 </span><br>cursor = db.cursor()<br><br><span class="hljs-comment"># SQL 更新语句</span><br>sql = <span class="hljs-string">"UPDATE EMPLOYEE SET AGE = AGE + 1 WHERE SEX = '%c'"</span> % (<span class="hljs-string">'M'</span>)<br><span class="hljs-keyword">try</span>:<br>   <span class="hljs-comment"># 执行SQL语句</span><br>   cursor.execute(sql)<br>   <span class="hljs-comment"># 提交到数据库执行</span><br>   db.commit()<br><span class="hljs-keyword">except</span>:<br>   <span class="hljs-comment"># 发生错误时回滚</span><br>   db.rollback()<br><br><span class="hljs-comment"># 关闭数据库连接</span><br>db.close()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200617214133953.png" alt="image-20200617214133953"></p><h2 id="8、删除操作">8、删除操作</h2><p><strong>删除操作用于删除数据表中的数据，以下实例演示了删除数据表 EMPLOYEE 中 AGE 大于 20 的所有数据：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-keyword">import</span> MySQLdb<br><br><span class="hljs-comment"># 打开数据库连接</span><br>db = MySQLdb.connect(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-string">"root"</span>, <span class="hljs-string">"123456"</span>, <span class="hljs-string">"student_info"</span>, charset=<span class="hljs-string">'utf8'</span> )<br><span class="hljs-comment">#db = MySQLdb.connect("ip地址", "用户", "密码", "数据库", charset='utf8' )</span><br><br><span class="hljs-comment"># 使用cursor()方法获取操作游标 </span><br>cursor = db.cursor()<br><br><span class="hljs-comment"># SQL 删除语句</span><br>sql = <span class="hljs-string">"DELETE FROM EMPLOYEE WHERE AGE &gt; %s"</span> % (<span class="hljs-number">20</span>)<br><span class="hljs-keyword">try</span>:<br>   <span class="hljs-comment"># 执行SQL语句</span><br>   cursor.execute(sql)<br>   <span class="hljs-comment"># 提交修改</span><br>   db.commit()<br><span class="hljs-keyword">except</span>:<br>   <span class="hljs-comment"># 发生错误时回滚</span><br>   db.rollback()<br><br><span class="hljs-comment"># 关闭连接</span><br>db.close()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200617214249962.png" alt="image-20200617214249962"></p><h2 id="9、执行事务">9、执行事务</h2><p><strong>事务机制可以确保数据一致性。</strong></p><p><strong>事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。</strong></p><ul><li><strong>原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</strong></li><li><strong>一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</strong></li><li><strong>隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</strong></li><li><strong>持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</strong></li></ul><p><strong>Python DB API 2.0 的事务提供了两个方法 commit 或 rollback。</strong></p><h3 id="实例：-2">实例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># SQL删除记录语句</span><br>sql = <span class="hljs-string">"DELETE FROM EMPLOYEE WHERE AGE &gt; %s"</span> % (<span class="hljs-number">20</span>)<br><span class="hljs-keyword">try</span>:<br>   <span class="hljs-comment"># 执行SQL语句</span><br>   cursor.execute(sql)<br>   <span class="hljs-comment"># 向数据库提交</span><br>   db.commit()<br><span class="hljs-keyword">except</span>:<br>   <span class="hljs-comment"># 发生错误时回滚</span><br>   db.rollback()<br></code></pre></td></tr></table></figure><p><strong>对于支持事务的数据库， 在Python数据库编程中，当游标建立之时，就自动开始了一个隐形的数据库事务。</strong></p><p><strong>commit()方法游标的所有更新操作，rollback（）方法回滚当前游标的所有操作。每一个方法都开始了一个新的事务。</strong></p><h2 id="10、错误处理">10、错误处理</h2><p><strong>DB API中定义了一些数据库操作的错误及异常，下表列出了这些错误和异常:</strong></p><table><thead><tr><th style="text-align:left">异常</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Warning</td><td style="text-align:left">当有严重警告时触发，例如插入数据是被截断等等。必须是 StandardError 的子类。</td></tr><tr><td style="text-align:left">Error</td><td style="text-align:left">警告以外所有其他错误类。必须是 StandardError 的子类。</td></tr><tr><td style="text-align:left">InterfaceError</td><td style="text-align:left">当有数据库接口模块本身的错误（而不是数据库的错误）发生时触发。 必须是Error的子类。</td></tr><tr><td style="text-align:left">DatabaseError</td><td style="text-align:left">和数据库有关的错误发生时触发。 必须是Error的子类。</td></tr><tr><td style="text-align:left">DataError</td><td style="text-align:left">当有数据处理时的错误发生时触发，例如：除零错误，数据超范围等等。 必须是DatabaseError的子类。</td></tr><tr><td style="text-align:left">OperationalError</td><td style="text-align:left">指非用户控制的，而是操作数据库时发生的错误。例如：连接意外断开、 数据库名未找到、事务处理失败、内存分配错误等等操作数据库是发生的错误。 必须是DatabaseError的子类。</td></tr><tr><td style="text-align:left">IntegrityError</td><td style="text-align:left">完整性相关的错误，例如外键检查失败等。必须是DatabaseError子类。</td></tr><tr><td style="text-align:left">InternalError</td><td style="text-align:left">数据库的内部错误，例如游标（cursor）失效了、事务同步失败等等。 必须是DatabaseError子类。</td></tr><tr><td style="text-align:left">ProgrammingError</td><td style="text-align:left">程序错误，例如数据表（table）没找到或已存在、SQL语句语法错误、 参数数量错误等等。必须是DatabaseError的子类。</td></tr><tr><td style="text-align:left">NotSupportedError</td><td style="text-align:left">不支持错误，指使用了数据库不支持的函数或API等。例如在连接对象上 使用.rollback()函数，然而数据库并不支持事务或者事务已关闭。 必须是DatabaseError的子类。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的上下文管理器</title>
      <link href="/posts/7aea.html"/>
      <url>/posts/7aea.html</url>
      
        <content type="html"><![CDATA[<h2 id="python-with语句上下文管理的两种实现方法">python with语句上下文管理的两种实现方法</h2><p><strong>在编程中会经常碰到这种情况：有一个特殊的语句块，在执行这个语句块之前需要先执行一些准备动作；当语句块执行完成后，需要继续执行一些收尾动作。例如，文件读写后需要关闭，数据库读写完毕需要关闭连接，资源的加锁和解锁等情况。</strong><br><strong>对于这种情况python提供了上下文管理器（Context Manager）的概念，可以通过上下文管理器来定义/控制代码块执行前的准备动作，以及执行后的收尾动作。</strong></p><h3 id="上下文管理器">上下文管理器</h3><p><strong>with语句:可以确保某些事情(如关闭资源、释放锁)一定会发生。</strong></p><p><strong>先创建一个<code>t.txt</code>文件，里面随便写点东西</strong></p><p><strong>然后编写代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    f = open(<span class="hljs-string">'t.txt'</span>)<br>    print(f.read())<br><span class="hljs-keyword">finally</span>:<br>    f.close()<br><br><span class="hljs-keyword">with</span> open(<span class="hljs-string">'t.txt'</span>) <span class="hljs-keyword">as</span> f:<br>    print(f.read())<br></code></pre></td></tr></table></figure><h5 id="输出结果">输出结果</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fewfwefwewef<br>fewfwefwewef<br></code></pre></td></tr></table></figure><h1>一、为何使用上下文管理器</h1><p><strong>在我看来，这和 Python 崇尚的优雅风格有关。</strong></p><ol><li><strong>可以以一种更加优雅的方式，操作（创建/获取/释放）资源，如文件操作、数据库连接；</strong></li><li><strong>可以以一种更加优雅的方式，处理异常；</strong></li></ol><p><strong>第一种，我们上面已经以资源的连接为例讲过了。</strong></p><p><strong>而第二种，会被大多数人所忽略。这里会重点讲一下。</strong></p><p><strong>大家都知道，处理异常，通常都是使用 <code>try...execept..</code> 来捕获处理的。这样做一个不好的地方是，在代码的主逻辑里，会有大量的异常处理代理，这会很大的影响我们的可读性。</strong></p><p><strong>好一点的做法呢，可以使用 <code>with</code> 将异常的处理隐藏起来。</strong></p><h2 id="1、不使用上下文管理器的情况">1、不使用上下文管理器的情况</h2><p><strong>通过try…finally语句执行异常处理和关闭句柄的动作。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">logger = open(<span class="hljs-string">"t.txt"</span>, <span class="hljs-string">"w"</span>)<br><span class="hljs-keyword">try</span>:<br>    logger.write(<span class="hljs-string">'Hello '</span>)<br>    logger.write(<span class="hljs-string">'World'</span>)<br><span class="hljs-keyword">finally</span>:<br>    logger.close()<br><br>print(logger.closed)<br></code></pre></td></tr></table></figure><h2 id="2、使用上下文管理器">2、使用上下文管理器</h2><p><strong>默认文件Python的内置file类型是支持上下文管理协议的。</strong><br><strong>使用上下文管理器with使得依据精简了很多。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON"><span class="hljs-keyword">with</span> open(<span class="hljs-string">"t.txt"</span>, <span class="hljs-string">"w"</span>) <span class="hljs-keyword">as</span> logger:<br>    logger.write(<span class="hljs-string">'Hello '</span>)<br>    logger.write(<span class="hljs-string">'World'</span>)<br><br>print(logger.closed)<br></code></pre></td></tr></table></figure><p><strong>或</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">import</span> codecs<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Open</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, filename, mode, encoding=<span class="hljs-string">'utf-8'</span>)</span>:</span><br>        self.fp = codecs.open(filename, mode, encoding)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">return</span> self.fp<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span><span class="hljs-params">(self, exc_type, exc_val, exc_tb)</span>:</span><br>        self.fp.close()<br><br><br>data = <span class="hljs-string">u'Hello World'</span><br><span class="hljs-keyword">with</span> Open(<span class="hljs-string">'t.txt'</span>,<span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(data)<br></code></pre></td></tr></table></figure><p><strong>以上三种方法都会在<code>t.txt</code>中写入<code>Hello World</code>数据。</strong></p><h1>二、实现上下文管理器</h1><h3 id="实现上下文管理器有两种方式实现。">实现上下文管理器有两种方式实现。</h3><ul><li><strong>方法一：类实现enter和exit方法。</strong></li><li><strong>方法二：contextlib模块装饰器和生成器实现。</strong></li></ul><p><strong>下面我们通过两种方法分别实现一个自定义的上下文管理器。</strong></p><h2 id="1、方法一：通过类实现-enter-和-exit-方法">1、方法一：通过类实现__enter__和__exit__方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">File</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, file_name, method)</span>:</span><br>        self.file_obj = open(file_name, method)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">return</span> self.file_obj<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span><span class="hljs-params">(self, type, value, traceback)</span>:</span><br>        self.file_obj.close()<br><br><span class="hljs-keyword">with</span> File(<span class="hljs-string">'t.txt'</span>, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> opened_file:<br>    opened_file.write(<span class="hljs-string">'Hola!'</span>)<br></code></pre></td></tr></table></figure><p><strong>以上这种方法会在<code>t.txt</code>中写入<code>Hola!</code>数据。</strong></p><p><strong>实现<code>__enter__</code>和<code>__exit__</code>方法后，就能通过with语句进行上下文管理。</strong></p><h3 id="a、底层都发生了什么？">a、底层都发生了什么？</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span>、<span class="hljs-keyword">with</span>语句先暂存了File类的__exit__方法，然后它调用File类的__enter__方法。<br><span class="hljs-number">2</span>、__enter__方法打开文件并返回给<span class="hljs-keyword">with</span>语句，打开的文件句柄被传递给opened_file参数。<br><span class="hljs-number">3</span>、<span class="hljs-keyword">with</span>语句调用之前暂存的__exit__方法，__exit__方法关闭了文件。<br></code></pre></td></tr></table></figure><h3 id="b、异常处理">b、异常处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">关于异常处理，<span class="hljs-keyword">with</span>语句会采取哪些步骤。<br><span class="hljs-number">1.</span> 它把异常的type,value和traceback传递给__exit__方法<br><span class="hljs-number">2.</span> 它让__exit__方法来处理异常 <br><span class="hljs-number">3.</span> 如果__exit__返回的是<span class="hljs-literal">True</span>，那么这个异常就被忽略。<br><span class="hljs-number">4.</span> 如果__exit__返回的是<span class="hljs-literal">True</span>以外的任何东西，那么这个异常将被<span class="hljs-keyword">with</span>语句抛出。<br></code></pre></td></tr></table></figure><h2 id="（1）异常抛出">（1）异常抛出</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#异常抛出，_exit__返回的是True以外的任何东西，那么这个异常将被with语句抛出</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">File</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, file_name, method)</span>:</span><br>        self.file_obj = open(file_name, method)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">return</span> self.file_obj<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span><span class="hljs-params">(self, type, value, traceback)</span>:</span><br>        self.file_obj.close()<br>        print(<span class="hljs-string">"type:"</span>,type)<br>        print(<span class="hljs-string">"value:"</span>,value)<br>        print(<span class="hljs-string">"traceback:"</span>,traceback)<br><br><br><span class="hljs-keyword">with</span> File(<span class="hljs-string">'t.txt'</span>, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> opened_file:<br>    opened_file.undefined_function(<span class="hljs-string">'Hola!'</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果-2">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">type: &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">AttributeError</span>'&gt;</span><br><span class="hljs-class"><span class="hljs-title">value</span>:</span> <span class="hljs-string">'_io.TextIOWrapper'</span> object has no attribute <span class="hljs-string">'undefined_function'</span><br>traceback: &lt;traceback object at <span class="hljs-number">0x000001BEB1AD7F00</span>&gt;<br>Traceback (most recent call last):<br>  File <span class="hljs-string">"G:/四期/python/Pytghon_MySQL/上下文管理器/666.py"</span>, line <span class="hljs-number">15</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    opened_file.undefined_function(<span class="hljs-string">'Hola!'</span>)<br>AttributeError: <span class="hljs-string">'_io.TextIOWrapper'</span> object has no attribute <span class="hljs-string">'undefined_function'</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="（2）异常忽略：">（2）异常忽略：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 异常忽略，__exit__返回的是True，那么这个异常就被忽略。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">File</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, file_name, method)</span>:</span><br>        self.file_obj = open(file_name, method)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">return</span> self.file_obj<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span><span class="hljs-params">(self, exception_type, exception_value, traceback)</span>:</span><br>        print(<span class="hljs-string">"Exception has been handled"</span>)<br>        self.file_obj.close()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><br><span class="hljs-keyword">with</span> File(<span class="hljs-string">'t.txt'</span>, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> opened_file:<br>    opened_file.undefined_function(<span class="hljs-string">'Hola!'</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果-3">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Exception has been handled<br></code></pre></td></tr></table></figure></blockquote><h2 id="2、方法二：contextlib模块装饰器和生成器实现">2、方法二：contextlib模块装饰器和生成器实现</h2><p><strong>这种方式实现更优雅，我个人更喜欢这种方式。</strong></p><p><strong>yield之前的代码由<code>__enter__</code>方法执行，yield之后的代码由<code>__exit__</code>方法执行。本质上还是<code>__enter__</code>和<code>__exit__</code>方法。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">import</span> codecs<br><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager<br><br><span class="hljs-meta">@contextmanager</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Open</span><span class="hljs-params">(filename,mode,encoding=<span class="hljs-string">'utf-8'</span>)</span>:</span><br>    fp = codecs.open(filename,mode,encoding)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">yield</span> fp<br>    <span class="hljs-keyword">finally</span>:<br>        fp.close()<br>data = <span class="hljs-string">u'上下文--管理器'</span><br><span class="hljs-keyword">with</span> Open(<span class="hljs-string">'t.txt'</span>,<span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(data)<br></code></pre></td></tr></table></figure><p><strong>以上这种方法会在<code>t.txt</code>中写入<code>上下文--管理器</code>数据。</strong></p><p><strong>或</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> closing<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenMyFile</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, path)</span>:</span><br>        print(<span class="hljs-string">"opening the txt"</span>)<br>        self.f = open(path, <span class="hljs-string">"w"</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write</span><span class="hljs-params">(self, string)</span>:</span><br>        self.f.write(string)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">"closing the txt"</span>)<br>        self.f.close()<br><br><br><span class="hljs-keyword">with</span> closing(OpenMyFile(<span class="hljs-string">"t.txt"</span>)) <span class="hljs-keyword">as</span> file:<br>    file.write(<span class="hljs-string">"this is demo4"</span>)<br><br><span class="hljs-comment"># 输出：</span><br>print(<span class="hljs-string">"opening the txt"</span>)<br>print(<span class="hljs-string">"closing the txt"</span>)<br></code></pre></td></tr></table></figure><p><strong>以上这种方法会在<code>t.txt</code>中写入<code>this is demo4</code>数据。</strong></p><h5 id="输出结果-4">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">opening the txt<br>closing the txt<br>opening the txt<br>closing the txt<br></code></pre></td></tr></table></figure></blockquote><h2 id="3、方法三（-contextmanager）">3、方法三（@contextmanager）</h2><p><strong>利用contextlib中的contextmanager装饰器。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager<br><br><br><span class="hljs-meta">@contextmanager</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">open_my_file</span><span class="hljs-params">(path)</span>:</span><br>    print(<span class="hljs-string">"opening the txt"</span>)<br>    f = open(<span class="hljs-string">"t.txt"</span>, <span class="hljs-string">"w"</span>)<br>    <span class="hljs-keyword">yield</span> f<br>    print(<span class="hljs-string">"closing the txt"</span>)<br>    f.close()<br><br><br><span class="hljs-keyword">with</span> open_my_file(<span class="hljs-string">"t.txt"</span>) <span class="hljs-keyword">as</span> file:<br>    file.write(<span class="hljs-string">"this is demo3"</span>)<br><br><span class="hljs-comment"># 输出：</span><br>print(<span class="hljs-string">"opening the txt"</span>)<br>print(<span class="hljs-string">"closing the txt"</span>)<br></code></pre></td></tr></table></figure><p><strong>以上这种方法会在<code>t.txt</code>中写入<code>this is demo3</code>数据。</strong></p><h5 id="输出结果-5">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">opening the txt<br>closing the txt<br>opening the txt<br>closing the txt<br></code></pre></td></tr></table></figure></blockquote><h2 id="4、with语句上多个下文关联">4、with语句上多个下文关联</h2><p><strong>直接通过一个with语句打开多个上下文，即可同时使用多个上下文变量，而不必需嵌套使用with语句。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">File</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, file_name, method)</span>:</span><br>        self.file_obj = open(file_name, method)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">return</span> self.file_obj<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span><span class="hljs-params">(self, exception_type, exception_value, traceback)</span>:</span><br>        self.file_obj.close()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><br><span class="hljs-keyword">with</span> File(<span class="hljs-string">'t.txt'</span>, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f1, File(<span class="hljs-string">'t.txt'</span>, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f2:<br>    print(f1, f2)<br></code></pre></td></tr></table></figure><h5 id="输出结果-6">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;_io.TextIOWrapper name=<span class="hljs-string">'t.txt'</span> mode=<span class="hljs-string">'w'</span> encoding=<span class="hljs-string">'cp936'</span>&gt; &lt;_io.TextIOWrapper name=<span class="hljs-string">'t.txt'</span> mode=<span class="hljs-string">'w'</span> encoding=<span class="hljs-string">'cp936'</span>&gt;<br></code></pre></td></tr></table></figure></blockquote><h1>总结</h1><p><strong>本文介绍了Python中的上下文管理器，以及如何结合with语句来使用上下文管理器。</strong></p><p><strong>总结一下with 语句的执行流程：</strong></p><ul><li><strong>执行context_expr 以获取上下文管理器对象</strong></li><li><strong>调用上下文管理器的 enter() 方法</strong><ul><li><strong>如果有 as var 从句，则将 enter() 方法的返回值赋给 var</strong></li></ul></li><li><strong>执行代码块 with_suite</strong></li><li><strong>调用上下文管理器的 exit() 方法，如果 with_suite 产生异常，那么该异常的 type、value 和 traceback 会作为参数传给 exit()，否则传三个 None</strong><ul><li><strong>如果 with_suite 产生异常，并且 exit() 的返回值等于 False，那么这个异常将被重新抛出到上层</strong></li><li><strong>如果 with_suite 产生异常，兵器 exit() 的返回值等于 True，那么这个异常就被忽略，继续执行后面的代码</strong></li></ul></li></ul><p><strong>在很多情况下，with语句可以简化代码，并增加代码的健壮性。</strong></p><h3 id="使用上下文管理器有三个好处：">使用上下文管理器有三个好处：</h3><ul><li><strong>提高代码的复用率；</strong></li><li><strong>提高代码的优雅度；</strong></li><li><strong>提高代码的可读性；</strong></li></ul><h3 id="With-语句的实际执行流程是这样的：">With 语句的实际执行流程是这样的：</h3><ul><li><strong>执行 context_exp 以获取上下文管理器</strong></li><li><strong>加载上下文管理器的 <code>__exit__()</code> 方法以备稍后调用</strong></li><li><strong>调用上下文管理器的 <code>__enter__()</code> 方法</strong></li><li><strong>如果有 as var 从句，则将 <code>__enter__()</code> 方法的返回值赋给 var</strong></li><li><strong>执行子代码块 with_suit</strong></li><li><strong>调用上下文管理器的 <code>__exit__()</code> 方法，如果 with_suit 的退出是由异常引发的，那么该异常的 type、value 和 traceback 会作为参数传给 <code>__exit__()</code>，否则传三个 None</strong></li><li><strong>如果 with_suit 的退出由异常引发，并且 <code>__exit__()</code> 的返回值等于 False，那么这个异常将被重新引发一次；如果 <code>__exit__()</code> 的返回值等于 True，那么这个异常就被无视掉，继续执行后面的代码</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python装饰器的应用场景</title>
      <link href="/posts/1351.html"/>
      <url>/posts/1351.html</url>
      
        <content type="html"><![CDATA[<h2 id="装饰器用于身份认证">装饰器用于身份认证</h2><p><strong>首先是最常见的身份认证的应用。这个很容易理解，举个最常见的例子，大家登录微信，需要输入用户名密码，然后点击确认，这样服务器端便会查询你的用户名是否存在、是否和密码匹配等等。如果认证通过，就可以顺利登录；反之，则提示你登录失败。</strong></p><p><strong>再比如一些网站，你不登录也可以浏览内容，但如果你想要发布文章或留言，在点击发布时，服务器端便会查询你是否登录。如果没有登录，就不允许这项操作等等。</strong></p><p><strong>如下是一个实现身份认证的简单示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">authenticate</span><span class="hljs-params">(func)</span>:</span><br><span class="hljs-meta">    @functools.wraps(func)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args, **kwargs)</span>:</span><br>        request = args[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># 如果用户处于登录状态</span><br>        <span class="hljs-keyword">if</span> check_user_logged_in(request):<br>            <span class="hljs-comment"># 执行函数 post_comment()</span><br>            <span class="hljs-keyword">return</span> func(*args, **kwargs)  <br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'Authentication failed'</span>)<br>    <span class="hljs-keyword">return</span> wrapper<br>   <br><span class="hljs-meta">@authenticate</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post_comment</span><span class="hljs-params">(request, ...)</span></span><br><span class="hljs-function">    ...</span><br></code></pre></td></tr></table></figure><p><strong>注意，对于函数来说，它也有自己的一些属性，例如 name 属性，代码中 @functools.wraps(func) 也是一个装饰器，如果不使用它，则 post_comment.name 的值为 wrapper。而使用它之后，则 post_comment.name 的值依然为 post_comment。</strong></p><p><strong>上面这段代码中，定义了装饰器 authenticate，函数 post_comment() 则表示发表用户对某篇文章的评论，每次调用这个函数前，都会先检查用户是否处于登录状态，如果是登录状态，则允许这项操作；如果没有登录，则不允许。</strong></p><h2 id="装饰器用于日志记录">装饰器用于日志记录</h2><p><strong>日志记录同样是很常见的一个案例。在实际工作中，如果你怀疑某些函数的耗时过长，导致整个系统的延迟增加，想在线上测试某些函数的执行时间，那么，装饰器就是一种很常用的手段。</strong></p><p><strong>我们通常用下面的方法来表示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> functools<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log_execution_time</span><span class="hljs-params">(func)</span>:</span><br><span class="hljs-meta">    @functools.wraps(func)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args, **kwargs)</span>:</span><br>        start = time.perf_counter()<br>        res = func(*args, **kwargs)<br>        end = time.perf_counter()<br>        print(<span class="hljs-string">'&#123;&#125; took &#123;&#125; ms'</span>.format(func.__name__, (end - start) * <span class="hljs-number">1000</span>))<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-keyword">return</span> wrapper<br>   <br><span class="hljs-meta">@log_execution_time</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_similarity</span><span class="hljs-params">(items)</span>:</span><br>    ...<br></code></pre></td></tr></table></figure><p><strong>这里，装饰器 log_execution_time 记录某个函数的运行时间，并返回其执行结果。如果你想计算任何函数的执行时间，在这个函数上方加上@log_execution_time即可。</strong></p><h2 id="装饰器用于输入合理性检查">装饰器用于输入合理性检查</h2><p><strong>在大型公司的机器学习框架中，调用机器集群进行模型训练前，往往会用装饰器对其输入（往往是很长的 json 文件）进行合理性检查。这样就可以大大避免输入不正确对机器造成的巨大开销。</strong></p><p><strong>它的写法往往是下面的格式：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validation_check</span><span class="hljs-params">(input)</span>:</span><br><span class="hljs-meta">    @functools.wraps(func)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args, **kwargs)</span>:</span><br>        ... <span class="hljs-comment"># 检查输入是否合法</span><br>   <br><span class="hljs-meta">@validation_check</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">neural_network_training</span><span class="hljs-params">(param1, param2, ...)</span>:</span><br>    ...<br></code></pre></td></tr></table></figure><p><strong>其实在工作中，很多情况下都会出现输入不合理的现象。因为我们调用的训练模型往往很复杂，输入的文件有成千上万行，很多时候确实也很难发现。</strong></p><p><strong>试想一下，如果没有输入的合理性检查，很容易出现“模型训练了好几个小时后，系统却报错说输入的一个参数不对，成果付之一炬”的现象。这样的“惨案”，大大减缓了开发效率，也对机器资源造成了巨大浪费。</strong></p><h2 id="缓存装饰器">缓存装饰器</h2><p><strong>关于缓存装饰器的用法，其实十分常见，这里以 <a href="http://c.biancheng.net/python/" target="_blank" rel="noopener">Python</a> 内置的 LRU cache 为例来说明。</strong></p><p><strong>LRU cache，在 Python 中的表示形式是 @lru_cache。@lru_cache 会缓存进程中的函数参数和结果，当缓存满了以后，会删除最近最久未使用的数据。</strong></p><p><strong>正确使用缓存装饰器，往往能极大地提高程序运行效率。举个例子，大型公司服务器端的代码中往往存在很多关于设备的检查，比如使用的设备是安卓还是 iPhone，版本号是多少。这其中的一个原因，就是一些新的功能，往往只在某些特定的手机系统或版本上才有（比如 <a href="http://c.biancheng.net/android/" target="_blank" rel="noopener">Android</a> v200+）。</strong></p><p><strong>这样一来，我们通常使用缓存装饰器来包裹这些检查函数，避免其被反复调用，进而提高程序运行效率，比如写成下面这样：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@lru_cache</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check</span><span class="hljs-params">(param1, param2, ...)</span> # 检查用户设备类型，版本号等等</span><br><span class="hljs-function">    ...</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的装饰器（3）</title>
      <link href="/posts/1341.html"/>
      <url>/posts/1341.html</url>
      
        <content type="html"><![CDATA[<h1>Python @函数装饰器及用法（超级详细）</h1><p><strong>前面章节中，我们已经讲解了 Python 内置的 3 种函数装饰器，分别是 ＠staticmethod、＠classmethod 和 @property，其中 staticmethod()、classmethod() 和 property() 都是 Python 的内置函数。</strong></p><p><strong>那么，函数装饰器的工作原理是怎样的呢？假设用 funA() 函数装饰器去装饰 funB() 函数，如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#funA 作为装饰器函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funA</span><span class="hljs-params">(fn)</span>:</span><br>    <span class="hljs-comment">#...</span><br>    fn() <span class="hljs-comment"># 执行传入的fn参数</span><br>    <span class="hljs-comment">#...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'...'</span><br><span class="hljs-meta">@funA</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funB</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-comment">#...</span><br></code></pre></td></tr></table></figure><p><strong>实际上，上面程序完全等价于下面的程序：</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funA</span></span>(<span class="hljs-keyword">fn</span>)<span class="hljs-symbol">:</span><br>    <span class="hljs-comment">#...</span><br>    <span class="hljs-keyword">fn</span>() <span class="hljs-comment"># 执行传入的fn参数</span><br>    <span class="hljs-comment">#...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'...'</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funB</span></span>()<span class="hljs-symbol">:</span><br>    <span class="hljs-comment">#...</span><br>funB = funA(funB)<br></code></pre></td></tr></table></figure><p><strong>通过比对以上 2 段程序不难发现，使用函数装饰器 A() 去装饰另一个函数 B()，其底层执行了如下 2 步操作：</strong></p><ul><li><strong>将 B 作为参数传给 A() 函数；</strong></li><li><strong>将 A() 函数执行完成的返回值反馈回 B。</strong></li></ul><h3 id="举个实例：">举个实例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#funA 作为装饰器函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funA</span><span class="hljs-params">(fn)</span>:</span><br>    print(<span class="hljs-string">"xgp的博客"</span>)<br>    fn() <span class="hljs-comment"># 执行传入的fn参数</span><br>    print(<span class="hljs-string">"https://wsdlxgp.top/"</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"装饰器函数的返回值"</span><br><span class="hljs-meta">@funA</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funB</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">"学习 Python"</span>)<br></code></pre></td></tr></table></figure><h4 id="程序执行流程为：">程序执行流程为：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">xgp的博客<br>学习 Python<br>https://wsdlxgp.top/<br></code></pre></td></tr></table></figure><p><strong>在此基础上，如果在程序末尾添加如下语句：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(funB)<br></code></pre></td></tr></table></figure><h5 id="其输出结果为：">其输出结果为：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">装饰器函数的返回值<br></code></pre></td></tr></table></figure><p><strong>显然，被“＠函数”修饰的函数不再是原来的函数，而是被替换成一个新的东西（取决于装饰器的返回值），即如果装饰器函数的返回值为普通变量，那么被修饰的函数名就变成了变量名；同样，如果装饰器返回的是一个函数的名称，怎么被修饰的函数名依然表示一个函数。</strong></p><blockquote><p><strong>实际上，所谓函数装饰器，就是通过装饰器函数，在不修改原函数的前提下，来对函数的功能进行合理的扩充。</strong></p></blockquote><h2 id="1、带参数的函数装饰器">1、带参数的函数装饰器</h2><p><strong>在分析 funA() 函数装饰器和 funB() 函数的关系时，细心的读者可能会发现一个问题，即当 funB() 函数无参数时，可以直接将 funB 作为 funA() 的参数传入。但是，如果被修饰的函数本身带有参数，那应该如何传值呢？</strong></p><p><strong>比较简单的解决方法就是在函数装饰器中嵌套一个函数，该函数带有的参数个数和被装饰器修饰的函数相同。例如：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funA</span><span class="hljs-params">(fn)</span>:</span><br>    <span class="hljs-comment"># 定义一个嵌套函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say</span><span class="hljs-params">(arc)</span>:</span><br>        print(<span class="hljs-string">"kubernetes教程:"</span>,arc)<br>    <span class="hljs-keyword">return</span> say<br><span class="hljs-meta">@funA</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funB</span><span class="hljs-params">(arc)</span>:</span><br>    print(<span class="hljs-string">"funB():"</span>, a)<br>funB(<span class="hljs-string">"https://wsdlxgp.top/categories/Kubernetes/"</span>)<br></code></pre></td></tr></table></figure><h5 id="程序执行结果为：">程序执行结果为：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">kubernetes教程: https://wsdlxgp.top/categories/Kubernetes/<br></code></pre></td></tr></table></figure><p><strong>这里有必要给读者分析一下这个程序，其实，它和如下程序是等价的：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funA</span><span class="hljs-params">(fn)</span>:</span><br>    <span class="hljs-comment"># 定义一个嵌套函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say</span><span class="hljs-params">(arc)</span>:</span><br>        print(<span class="hljs-string">"kubernetes教程:"</span>,arc)<br>    <span class="hljs-keyword">return</span> say<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funB</span><span class="hljs-params">(arc)</span>:</span><br>    print(<span class="hljs-string">"funB():"</span>, a)<br>   <br>funB = funA(funB)<br>funB(<span class="hljs-string">"https://wsdlxgp.top/categories/Kubernetes/"</span>)<br></code></pre></td></tr></table></figure><p><strong>如果运行此程序会发现，它的输出结果和上面程序相同。</strong></p><p><strong>显然，通过 funB() 函数被装饰器 funA() 修饰，funB 就被赋值为 say。这意味着，虽然我们在程序显式调用的是 funB() 函数，但其实执行的是装饰器嵌套的 say() 函数。</strong></p><p><strong>但还有一个问题需要解决，即如果当前程序中，有多个（≥ 2）函数被同一个装饰器函数修饰，这些函数带有的参数个数并不相等，怎么办呢？</strong></p><p><strong>最简单的解决方式是用*args 和 **kwargs 作为装饰器内部嵌套函数的参数，*args 和 **kwargs 表示接受任意数量和类型的参数。举个例子：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funA</span><span class="hljs-params">(fn)</span>:</span><br>    <span class="hljs-comment"># 定义一个嵌套函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say</span><span class="hljs-params">(*args,**kwargs)</span>:</span><br>        fn(*args,**kwargs)<br>    <span class="hljs-keyword">return</span> say<br><span class="hljs-meta">@funA</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">funB</span><span class="hljs-params">(arc)</span>:</span><br>    print(<span class="hljs-string">"xgp的博客："</span>,arc)<br><span class="hljs-meta">@funA</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">other_funB</span><span class="hljs-params">(name,arc)</span>:</span><br>    print(name,arc)<br>funB(<span class="hljs-string">"https://wsdlxgp.top/"</span>)<br>other_funB(<span class="hljs-string">"kubernetes教程："</span>,<span class="hljs-string">"https://wsdlxgp.top/categories/Kubernetes/"</span>)<br></code></pre></td></tr></table></figure><h5 id="运行结果为：">运行结果为：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">xgp的博客： https://wsdlxgp.top/<br>kubernetes教程： https://wsdlxgp.top/categories/Kubernetes/<br></code></pre></td></tr></table></figure><h2 id="2、函数装饰器可以嵌套">2、函数装饰器可以嵌套</h2><p><strong>上面示例中，都是使用一个装饰器的情况，但实际上，Python 也支持多个装饰器，比如：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@funA</span><br><span class="hljs-meta">@funB</span><br><span class="hljs-meta">@funC</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-comment">#...</span><br></code></pre></td></tr></table></figure><p><strong>上面程序的执行顺序是里到外，所以它等效于下面这行代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fun = funA( funB ( funC (fun) ) )<br></code></pre></td></tr></table></figure><blockquote><p><strong>这里不再给出具体实例，有兴趣的读者可自行编写程序进行测试。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的装饰器（2）</title>
      <link href="/posts/1339.html"/>
      <url>/posts/1339.html</url>
      
        <content type="html"><![CDATA[<h1>Python 函数装饰器</h1><p><strong>装饰器(Decorators)是 Python 的一个重要部分。简单地说：他们是修改其他函数的功能的函数。他们有助于让我们的代码更简短，也更Pythonic（Python范儿）。大多数初学者不知道在哪儿使用它们，所以我将要分享下，哪些区域里装饰器可以让你的代码更简洁。 首先，让我们讨论下如何写你自己的装饰器。</strong></p><p><strong>这可能是最难掌握的概念之一。我们会每次只讨论一个步骤，这样你能完全理解它。</strong></p><h2 id="1、一切皆对象">1、一切皆对象</h2><p><strong>首先我们来理解下 Python 中的函数:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hi</span><span class="hljs-params">(name=<span class="hljs-string">"yasoob"</span>)</span>:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"hi "</span> + name<br> <br>print(hi())<br><span class="hljs-comment"># output: 'hi yasoob'</span><br> <br><span class="hljs-comment"># 我们甚至可以将一个函数赋值给一个变量，比如</span><br>greet = hi<br><span class="hljs-comment"># 我们这里没有在使用小括号，因为我们并不是在调用hi函数</span><br><span class="hljs-comment"># 而是在将它放在greet变量里头。我们尝试运行下这个</span><br> <br>print(greet())<br><span class="hljs-comment"># output: 'hi yasoob'</span><br> <br><span class="hljs-comment"># 如果我们删掉旧的hi函数，看看会发生什么！</span><br><span class="hljs-keyword">del</span> hi<br>print(hi())<br><span class="hljs-comment">#outputs: NameError</span><br> <br>print(greet())<br><span class="hljs-comment">#outputs: 'hi yasoob'</span><br></code></pre></td></tr></table></figure><h2 id="2、在函数中定义函数">2、在函数中定义函数</h2><p><strong>刚才那些就是函数的基本知识了。我们来让你的知识更进一步。在 Python 中我们可以在一个函数中定义另一个函数：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hi</span><span class="hljs-params">(name=<span class="hljs-string">"yasoob"</span>)</span>:</span><br>    print(<span class="hljs-string">"now you are inside the hi() function"</span>)<br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span><span class="hljs-params">()</span>:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"now you are in the greet() function"</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">welcome</span><span class="hljs-params">()</span>:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"now you are in the welcome() function"</span><br> <br>    print(greet())<br>    print(welcome())<br>    print(<span class="hljs-string">"now you are back in the hi() function"</span>)<br> <br>hi()<br><span class="hljs-comment">#output:now you are inside the hi() function</span><br><span class="hljs-comment">#       now you are in the greet() function</span><br><span class="hljs-comment">#       now you are in the welcome() function</span><br><span class="hljs-comment">#       now you are back in the hi() function</span><br> <br><span class="hljs-comment"># 上面展示了无论何时你调用hi(), greet()和welcome()将会同时被调用。</span><br><span class="hljs-comment"># 然后greet()和welcome()函数在hi()函数之外是不能访问的，比如：</span><br> <br>greet()<br><span class="hljs-comment">#outputs: NameError: name 'greet' is not defined</span><br></code></pre></td></tr></table></figure><p><strong>那现在我们知道了可以在函数中定义另外的函数。也就是说：我们可以创建嵌套的函数。现在你需要再多学一点，就是函数也能返回函数。</strong></p><h2 id="3、从函数中返回函数">3、从函数中返回函数</h2><p><strong>其实并不需要在一个函数里去执行另一个函数，我们也可以将其作为输出返回出来：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hi</span><span class="hljs-params">(name=<span class="hljs-string">"yasoob"</span>)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span><span class="hljs-params">()</span>:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"now you are in the greet() function"</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">welcome</span><span class="hljs-params">()</span>:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"now you are in the welcome() function"</span><br> <br>    <span class="hljs-keyword">if</span> name == <span class="hljs-string">"yasoob"</span>:<br>        <span class="hljs-keyword">return</span> greet<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> welcome<br> <br>a = hi()<br>print(a)<br><span class="hljs-comment">#outputs: &lt;function greet at 0x7f2143c01500&gt;</span><br> <br><span class="hljs-comment">#上面清晰地展示了`a`现在指向到hi()函数中的greet()函数</span><br><span class="hljs-comment">#现在试试这个</span><br> <br>print(a())<br><span class="hljs-comment">#outputs: now you are in the greet() function</span><br></code></pre></td></tr></table></figure><p><strong>再次看看这个代码。在 if/else 语句中我们返回 greet 和 welcome，而不是 greet() 和 welcome()。为什么那样？这是因为当你把一对小括号放在后面，这个函数就会执行；然而如果你不放括号在它后面，那它可以被到处传递，并且可以赋值给别的变量而不去执行它。 你明白了吗？让我再稍微多解释点细节。</strong></p><p><strong>当我们写下 <code>a = hi()</code>，hi() 会被执行，而由于 <code>name</code> 参数默认是 <code>yasoob</code>，所以函数 greet 被返回了。如果我们把语句改为 <code>a = hi(name = &quot;ali&quot;)</code>，那么 welcome 函数将被返回。我们还可以打印出 <code>hi()()</code>，这会输出 <code>now you are in the greet() function</code>。</strong></p><h2 id="4、将函数作为参数传给另一个函数">4、将函数作为参数传给另一个函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"hi yasoob!"</span><br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doSomethingBeforeHi</span><span class="hljs-params">(func)</span>:</span><br>    print(<span class="hljs-string">"I am doing some boring work before executing hi()"</span>)<br>    print(func())<br> <br>doSomethingBeforeHi(hi)<br><span class="hljs-comment">#outputs:I am doing some boring work before executing hi()</span><br><span class="hljs-comment">#        hi yasoob!</span><br></code></pre></td></tr></table></figure><p><strong>现在你已经具备所有必需知识，来进一步学习装饰器真正是什么了。装饰器让你在一个函数的前后去执行代码。</strong></p><h2 id="5、你的第一个装饰器">5、你的第一个装饰器</h2><p><strong>在上一个例子里，其实我们已经创建了一个装饰器！现在我们修改下上一个装饰器，并编写一个稍微更有用点的程序：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a_new_decorator</span><span class="hljs-params">(a_func)</span>:</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapTheFunction</span><span class="hljs-params">()</span>:</span><br>        print(<span class="hljs-string">"I am doing some boring work before executing a_func()"</span>)<br> <br>        a_func()<br> <br>        print(<span class="hljs-string">"I am doing some boring work after executing a_func()"</span>)<br> <br>    <span class="hljs-keyword">return</span> wrapTheFunction<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a_function_requiring_decoration</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">"I am the function which needs some decoration to remove my foul smell"</span>)<br> <br>a_function_requiring_decoration()<br><span class="hljs-comment">#outputs: "I am the function which needs some decoration to remove my foul smell"</span><br> <br>a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)<br><span class="hljs-comment">#now a_function_requiring_decoration is wrapped by wrapTheFunction()</span><br> <br>a_function_requiring_decoration()<br><span class="hljs-comment">#outputs:I am doing some boring work before executing a_func()</span><br><span class="hljs-comment">#        I am the function which needs some decoration to remove my foul smell</span><br><span class="hljs-comment">#        I am doing some boring work after executing a_func()</span><br></code></pre></td></tr></table></figure><p><strong>你看明白了吗？我们刚刚应用了之前学习到的原理。这正是 python 中装饰器做的事情！它们封装一个函数，并且用这样或者那样的方式来修改它的行为。现在你也许疑惑，我们在代码里并没有使用 @ 符号？那只是一个简短的方式来生成一个被装饰的函数。这里是我们如何使用 @ 来运行之前的代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@a_new_decorator</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a_function_requiring_decoration</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-string">"""Hey you! Decorate me!"""</span><br>    print(<span class="hljs-string">"I am the function which needs some decoration to "</span><br>          <span class="hljs-string">"remove my foul smell"</span>)<br> <br>a_function_requiring_decoration()<br><span class="hljs-comment">#outputs: I am doing some boring work before executing a_func()</span><br><span class="hljs-comment">#         I am the function which needs some decoration to remove my foul smell</span><br><span class="hljs-comment">#         I am doing some boring work after executing a_func()</span><br> <br><span class="hljs-comment">#the @a_new_decorator is just a short way of saying:</span><br>a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)<br></code></pre></td></tr></table></figure><p><strong>希望你现在对 Python 装饰器的工作原理有一个基本的理解。如果我们运行如下代码会存在一个问题：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">print(a_function_requiring_decoration.__name__)<br><span class="hljs-comment"># Output: wrapTheFunction</span><br></code></pre></td></tr></table></figure><p><strong>这并不是我们想要的！Ouput输出应该是&quot;a_function_requiring_decoration&quot;。这里的函数被warpTheFunction替代了。它重写了我们函数的名字和注释文档(docstring)。幸运的是Python提供给我们一个简单的函数来解决这个问题，那就是functools.wraps。我们修改上一个例子来使用functools.wraps：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a_new_decorator</span><span class="hljs-params">(a_func)</span>:</span><br><span class="hljs-meta">    @wraps(a_func)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapTheFunction</span><span class="hljs-params">()</span>:</span><br>        print(<span class="hljs-string">"I am doing some boring work before executing a_func()"</span>)<br>        a_func()<br>        print(<span class="hljs-string">"I am doing some boring work after executing a_func()"</span>)<br>    <span class="hljs-keyword">return</span> wrapTheFunction<br> <br><span class="hljs-meta">@a_new_decorator</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a_function_requiring_decoration</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-string">"""Hey yo! Decorate me!"""</span><br>    print(<span class="hljs-string">"I am the function which needs some decoration to "</span><br>          <span class="hljs-string">"remove my foul smell"</span>)<br> <br>print(a_function_requiring_decoration.__name__)<br><span class="hljs-comment"># Output: a_function_requiring_decoration</span><br></code></pre></td></tr></table></figure><p><strong>现在好多了。我们接下来学习装饰器的一些常用场景。</strong></p><h3 id="蓝本规范">蓝本规范:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator_name</span><span class="hljs-params">(f)</span>:</span><br><span class="hljs-meta">    @wraps(f)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorated</span><span class="hljs-params">(*args, **kwargs)</span>:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> can_run:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"Function will not run"</span><br>        <span class="hljs-keyword">return</span> f(*args, **kwargs)<br>    <span class="hljs-keyword">return</span> decorated<br> <br><span class="hljs-meta">@decorator_name</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">return</span>(<span class="hljs-string">"Function is running"</span>)<br> <br>can_run = <span class="hljs-literal">True</span><br>print(func())<br><span class="hljs-comment"># Output: Function is running</span><br> <br>can_run = <span class="hljs-literal">False</span><br>print(func())<br><span class="hljs-comment"># Output: Function will not run</span><br></code></pre></td></tr></table></figure><p><strong>注意：<code>@wraps</code>接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。</strong></p><h1>使用场景</h1><p><strong>现在我们来看一下装饰器在哪些地方特别耀眼，以及使用它可以让一些事情管理起来变得更简单。</strong></p><h2 id="1、授权-Authorization">1、授权(Authorization)</h2><p><strong>装饰器能有助于检查某个人是否被授权去使用一个web应用的端点(endpoint)。它们被大量使用于Flask和Django web框架中。这里是一个例子来使用基于装饰器的授权：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">requires_auth</span><span class="hljs-params">(f)</span>:</span><br><span class="hljs-meta">    @wraps(f)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorated</span><span class="hljs-params">(*args, **kwargs)</span>:</span><br>        auth = request.authorization<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> auth <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> check_auth(auth.username, auth.password):<br>            authenticate()<br>        <span class="hljs-keyword">return</span> f(*args, **kwargs)<br>    <span class="hljs-keyword">return</span> decorated<br></code></pre></td></tr></table></figure><h2 id="2日志-Logging">2日志(Logging)</h2><p><strong>日志是装饰器运用的另一个亮点。这是个例子：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logit</span><span class="hljs-params">(func)</span>:</span><br><span class="hljs-meta">    @wraps(func)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">with_logging</span><span class="hljs-params">(*args, **kwargs)</span>:</span><br>        print(func.__name__ + <span class="hljs-string">" was called"</span>)<br>        <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>    <span class="hljs-keyword">return</span> with_logging<br> <br><span class="hljs-meta">@logit</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addition_func</span><span class="hljs-params">(x)</span>:</span><br>   <span class="hljs-string">"""Do some math."""</span><br>   <span class="hljs-keyword">return</span> x + x<br> <br> <br>result = addition_func(<span class="hljs-number">4</span>)<br><span class="hljs-comment"># Output: addition_func was called</span><br></code></pre></td></tr></table></figure><p>我敢肯定你已经在思考装饰器的一个其他聪明用法了。</p><hr><h1>带参数的装饰器</h1><p><strong>来想想这个问题，难道@wraps不也是个装饰器吗？但是，它接收一个参数，就像任何普通的函数能做的那样。那么，为什么我们不也那样做呢？ 这是因为，当你使用@my_decorator语法时，你是在应用一个以单个函数作为参数的一个包裹函数。记住，Python里每个东西都是一个对象，而且这包括函数！记住了这些，我们可以编写一下能返回一个包裹函数的函数。</strong></p><h2 id="1、在函数中嵌入装饰器">1、在函数中嵌入装饰器</h2><p><strong>我们回到日志的例子，并创建一个包裹函数，能让我们指定一个用于输出的日志文件。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logit</span><span class="hljs-params">(logfile=<span class="hljs-string">'out.log'</span>)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logging_decorator</span><span class="hljs-params">(func)</span>:</span><br><span class="hljs-meta">        @wraps(func)</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapped_function</span><span class="hljs-params">(*args, **kwargs)</span>:</span><br>            log_string = func.__name__ + <span class="hljs-string">" was called"</span><br>            print(log_string)<br>            <span class="hljs-comment"># 打开logfile，并写入内容</span><br>            <span class="hljs-keyword">with</span> open(logfile, <span class="hljs-string">'a'</span>) <span class="hljs-keyword">as</span> opened_file:<br>                <span class="hljs-comment"># 现在将日志打到指定的logfile</span><br>                opened_file.write(log_string + <span class="hljs-string">'\n'</span>)<br>            <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>        <span class="hljs-keyword">return</span> wrapped_function<br>    <span class="hljs-keyword">return</span> logging_decorator<br> <br><span class="hljs-meta">@logit()</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myfunc1</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">pass</span><br> <br>myfunc1()<br><span class="hljs-comment"># Output: myfunc1 was called</span><br><span class="hljs-comment"># 现在一个叫做 out.log 的文件出现了，里面的内容就是上面的字符串</span><br> <br><span class="hljs-meta">@logit(logfile='func2.log')</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myfunc2</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">pass</span><br> <br>myfunc2()<br><span class="hljs-comment"># Output: myfunc2 was called</span><br><span class="hljs-comment"># 现在一个叫做 func2.log 的文件出现了，里面的内容就是上面的字符串</span><br></code></pre></td></tr></table></figure><h1>装饰器类</h1><p><strong>现在我们有了能用于正式环境的logit装饰器，但当我们的应用的某些部分还比较脆弱时，异常也许是需要更紧急关注的事情。比方说有时你只想打日志到一个文件。而有时你想把引起你注意的问题发送到一个email，同时也保留日志，留个记录。这是一个使用继承的场景，但目前为止我们只看到过用来构建装饰器的函数。</strong></p><p><strong>幸运的是，类也可以用来构建装饰器。那我们现在以一个类而不是一个函数的方式，来重新构建logit。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">logit</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, logfile=<span class="hljs-string">'out.log'</span>)</span>:</span><br>        self.logfile = logfile<br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span><span class="hljs-params">(self, func)</span>:</span><br><span class="hljs-meta">        @wraps(func)</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapped_function</span><span class="hljs-params">(*args, **kwargs)</span>:</span><br>            log_string = func.__name__ + <span class="hljs-string">" was called"</span><br>            print(log_string)<br>            <span class="hljs-comment"># 打开logfile并写入</span><br>            <span class="hljs-keyword">with</span> open(self.logfile, <span class="hljs-string">'a'</span>) <span class="hljs-keyword">as</span> opened_file:<br>                <span class="hljs-comment"># 现在将日志打到指定的文件</span><br>                opened_file.write(log_string + <span class="hljs-string">'\n'</span>)<br>            <span class="hljs-comment"># 现在，发送一个通知</span><br>            self.notify()<br>            <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>        <span class="hljs-keyword">return</span> wrapped_function<br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">notify</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-comment"># logit只打日志，不做别的</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p><strong>这个实现有一个附加优势，在于比嵌套函数的方式更加整洁，而且包裹一个函数还是使用跟以前一样的语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@logit()</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myfunc1</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p><strong>现在，我们给 logit 创建子类，来添加 email 的功能(虽然 email 这个话题不会在这里展开)。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">email_logit</span><span class="hljs-params">(logit)</span>:</span><br>    <span class="hljs-string">'''</span><br><span class="hljs-string">    一个logit的实现版本，可以在函数调用时发送email给管理员</span><br><span class="hljs-string">    '''</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, email=<span class="hljs-string">'admin@myproject.com'</span>, *args, **kwargs)</span>:</span><br>        self.email = email<br>        super(email_logit, self).__init__(*args, **kwargs)<br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">notify</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-comment"># 发送一封email到self.email</span><br>        <span class="hljs-comment"># 这里就不做实现了</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p><strong>从现在起，@email_logit 将会和 @logit 产生同样的效果，但是在打日志的基础上，还会多发送一封邮件给管理员。</strong></p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">原文地址：https://eastlakeside.gitbooks.io/interpy-zh/content/decorators/<br></code></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的装饰器（1）</title>
      <link href="/posts/1338.html"/>
      <url>/posts/1338.html</url>
      
        <content type="html"><![CDATA[<h1>一、Python 函数装饰器</h1><blockquote><p><strong>是修改函数的一种快捷方式</strong><br><strong>是代码的编写更加便利和灵活</strong><br><strong>能够提高代码的可读性和可维护性</strong></p><p><strong>本质上是一个函数，</strong><br><strong>这个函数接受其他函数作为参数，</strong><br><strong>并将其以一个新的修改后的函数进行替换</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hi</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">'Hi'</span>)<br><br>hello = say_hi<br>hello()<br></code></pre></td></tr></table></figure><h5 id="输出结果">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Hi<br></code></pre></td></tr></table></figure></blockquote><h2 id="实例一">实例一</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">import</span> random<br><br>n = random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)<br><span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span><span class="hljs-params">(n)</span>:</span><br>        print(<span class="hljs-string">'&#123;0&#125;是一个偶数。'</span>.format(n))<br><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span><span class="hljs-params">(n)</span>:</span><br>        print(<span class="hljs-string">'&#123;0&#125;是一个奇数。'</span>.format(n))<br><br>display(n)<br></code></pre></td></tr></table></figure><h4 id="多次执行才可见如下效果">多次执行才可见如下效果</h4><blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">1</span>是一个奇数。<br><span class="hljs-number">3</span>是一个奇数。<br><span class="hljs-number">5</span>是一个奇数。<br><span class="hljs-number">2</span>是一个偶数。<br><span class="hljs-number">4</span>是一个偶数。<br></code></pre></td></tr></table></figure></blockquote><h2 id="实例二">实例二</h2><p><strong>函数里面嵌套函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outer</span><span class="hljs-params">(x, y)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span><span class="hljs-params">()</span>:</span><br>        <span class="hljs-keyword">return</span> x + y<br>    <span class="hljs-keyword">return</span> inner<br><br>f = outer(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>print(f())<br></code></pre></td></tr></table></figure><h4 id="输出结果-2">输出结果</h4><blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="1、装饰器底层原理">1、装饰器底层原理</h2><h3 id="（1）简单的">（1）简单的</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greeting</span><span class="hljs-params">(f)</span>:</span><br>    f()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hi</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">'Hi'</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hello</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">'Hello'</span>)<br><br><br>greeting(say_hi)<br>greeting(say_hello)<br></code></pre></td></tr></table></figure><h4 id="输出结果-3">输出结果</h4><blockquote><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Hi</span><br><span class="hljs-attribute">Hello</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="（2）复杂的">（2）复杂的</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hi</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">'Hi'</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bread</span><span class="hljs-params">(f)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args, **kwargs)</span>:</span><br>        print(<span class="hljs-string">'开始调用&#123;0&#125;。'</span>.format(f.__name__))<br>        f()<br>        print(<span class="hljs-string">'完成&#123;0&#125;的调用。'</span>.format(f.__name__))<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@bread</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hi</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">'Hi'</span>)<br><br>say_hi_copy = bread(say_hi)<br>say_hi_copy()<br></code></pre></td></tr></table></figure><h4 id="输出结果-4">输出结果</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">开始调用wrapper。<br>开始调用say_hi。<br>Hi<br>完成say_hi的调用。<br>完成wrapper的调用。<br></code></pre></td></tr></table></figure></blockquote><h3 id="第二种方法">第二种方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bread</span><span class="hljs-params">(f)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args, **kwargs)</span>:</span><br>        print(<span class="hljs-string">'开始调用&#123;0&#125;。'</span>.format(f.__name__))<br>        f()<br>        print(<span class="hljs-string">'完成&#123;0&#125;的调用。'</span>.format(f.__name__))<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@bread</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hi</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">'Hi'</span>)<br><br>say_hi()<br></code></pre></td></tr></table></figure><h4 id="输出结果-5">输出结果</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">开始调用say_hi。<br>Hi<br>完成say_hi的调用。<br></code></pre></td></tr></table></figure></blockquote><h1>小练习（授权）</h1><p><strong>假定我们现在有一个特殊栈</strong><br><strong>这个栈不但实现了先进后出的数据结构，</strong><br><strong>还会检查操作栈的用户是否具有相应的授权</strong><br><strong>只有管理员才能够进行栈的操作</strong></p><h2 id="方法一">方法一</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_is_admin</span><span class="hljs-params">(f)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args, **kwargs)</span>:</span><br>        <span class="hljs-keyword">if</span> kwargs.get(<span class="hljs-string">'username'</span>) != <span class="hljs-string">'admin'</span>:<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'你没有权限进行此项操作。'</span>)<br>        <span class="hljs-keyword">return</span> f(*args, **kwargs)<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span><br>        self.storage = []<br><br><span class="hljs-meta">    @check_is_admin</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">put</span><span class="hljs-params">(self, username, elem)</span>:</span><br>        <span class="hljs-comment"># check_is_admin(username=username)</span><br>        self.storage.append(elem)<br><br><span class="hljs-meta">    @check_is_admin</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span><span class="hljs-params">(self, username)</span>:</span><br>        <span class="hljs-comment"># check_is_admin(username=username)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.storage:<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'栈里没有数据。'</span>)<br>        <span class="hljs-keyword">return</span> self.storage.pop()<br><br><br>stack = Stack()<br>stack.put(username=<span class="hljs-string">'admin'</span>, elem=<span class="hljs-number">3</span>)<br>print(stack.get(username=<span class="hljs-string">'admin'</span>))<br></code></pre></td></tr></table></figure><h4 id="输出结果-6">输出结果</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="方法二">方法二</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">import</span> time<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">benchmark</span><span class="hljs-params">(func)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args,**kwargs)</span>:</span><br>        <span class="hljs-comment"># 获取当前时间</span><br>        t = time.time()<br>        res = func(*args,**kwargs)<br>        print(func.__name__,time.time() - t)<br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@benchmark</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(a,b)</span>:</span><br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> a + b<br><br>print(add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><h4 id="输出结果-7">输出结果</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">add <span class="hljs-number">1.0012609958648682</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中生成器和迭代器的区别</title>
      <link href="/posts/1337.html"/>
      <url>/posts/1337.html</url>
      
        <content type="html"><![CDATA[<h1>Python中生成器和迭代器的区别(代码在Python3.5下测试)：</h1><h2 id="1、Num01–-迭代器">1、Num01–&gt;迭代器</h2><h4 id="定义：">定义：</h4><blockquote><p><strong>对于list、string、tuple、dict等这些容器对象,使用for循环遍历是很方便的。在后台for语句对容器对象调用iter()函数。iter()是python内置函数。</strong><br><strong>iter()函数会返回一个定义了next()方法的迭代器对象，它在容器中逐个访问容器内的元素。next()也是python内置函数。在没有后续元素时，next()会抛出一个StopIteration异常，通知for语句循环结束。</strong></p><p><strong>迭代器是用来帮助我们记录每次迭代访问到的位置，当我们对迭代器使用next()函数的时候，迭代器会向我们返回它所记录位置的下一个位置的数据。实际上，在使用next()函数的时候，调用的就是迭代器对象的_next_方法（Python3中是对象的_next_方法，Python2中是对象的next()方法）。所以，我们要想构造一个迭代器，就要实现它的_next_方法。但这还不够，python要求迭代器本身也是可迭代的，所以我们还要为迭代器实现_iter_方法，而_iter_方法要返回一个迭代器，迭代器自身正是一个迭代器，所以迭代器的_iter_方法返回自身self即可。</strong></p></blockquote><h4 id="一些术语的解释：">一些术语的解释：</h4><blockquote><p><strong>1，迭代器协议：对象需要提供next()方法，它要么返回迭代中的下一项，要么就引起一个StopIteration异常，以终止迭代。</strong></p><p><strong>2，可迭代对象：实现了迭代器协议对象。list、tuple、dict都是Iterable（可迭代对象），但不是Iterator（迭代器对象）。但可以使用内建函数iter()，把这些都变成Iterable（可迭代器对象）。</strong></p><p><strong>3，for item in Iterable 循环的本质就是先通过iter()函数获取可迭代对象Iterable的迭代器，然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item，当遇到StopIteration的异常后循环结束</strong></p></blockquote><h3 id="Python自带容器对象案例：">Python自带容器对象案例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 随便定义一个list</span><br>listArray=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-comment"># 使用iter()函数</span><br>iterName=iter(listArray)<br>print(iterName)<br><span class="hljs-comment"># 结果如下：是一个列表list的迭代器</span><br><span class="hljs-comment"># &lt;list_iterator object at 0x0000017B0D984278&gt;</span><br><br>print(next(iterName))<br>print(next(iterName))<br>print(next(iterName))<br>print(next(iterName))<span class="hljs-comment">#没有迭代到下一个元素，直接抛出异常</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># Traceback (most recent call last):</span><br><span class="hljs-comment">#   File "Test07.py", line 32, in &lt;module&gt;</span><br><span class="hljs-comment"># StopIteration</span><br></code></pre></td></tr></table></figure><h4 id="Python中一个实现了-iter-方法和-next-方法的类对象，就是迭代器，如下案例是计算菲波那切数列的案例">Python中一个实现了**<code>_iter_</code><strong>方法和</strong><code>_next_</code>**方法的类对象，就是迭代器，如下案例是计算菲波那切数列的案例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fib</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, max)</span>:</span><br>        super(Fib, self).__init__()<br>        self.max = max<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span><br>        self.a = <span class="hljs-number">0</span><br>        self.b = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span><span class="hljs-params">(self)</span>:</span><br>        fib = self.a<br>        <span class="hljs-keyword">if</span> fib &gt; self.max:<br>            <span class="hljs-keyword">raise</span> StopIteration<br>        self.a, self.b = self.b, self.a + self.b<br>        <span class="hljs-keyword">return</span> fib<br><br><span class="hljs-comment"># 定义一个main函数，循环遍历每一个菲波那切数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-comment"># 20以内的数</span><br>    fib = Fib(<span class="hljs-number">20</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> fib:<br>        print(i)<br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></table></figure><h4 id="解释说明：">解释说明：</h4><blockquote><p><strong>在本类的实现中，定义了一个_iter_(self)方法，这个方法是在for循环遍历时被iter()调用，返回一个迭代器。因为在遍历的时候，是直接调用的python内置函数iter()，由iter()通过调用_iter_(self)获得对象的迭代器。有了迭代器，就可以逐个遍历元素了。而逐个遍历的时候，也是使用内置的next(）函数通过调用对象的_next_(self)方法对迭代器对象进行遍历。所以要实现_iter_(self)和_next_(self)这两个方法。</strong></p><p><strong>而且因为实现了_next_(self)方法，所以在实现_iter_(self)的时候，直接返回self就可以。</strong></p><p><strong>总结一句话就是：</strong><br><strong>在循环遍历自定义容器对象时,会使用python内置函数iter()调用遍历对象的_iter_(self)获得一个迭代器,之后再循环对这个迭代器使用next()调用迭代器对象的_next_(self)。</strong></p><p><strong>注意点：<em>iter</em>(self)只会被调用一次,而_next_(self)会被调用 n 次，直到出现StopIteration异常。</strong></p></blockquote><h2 id="2、Num02–-生成器">2、Num02–&gt;生成器</h2><h4 id="作用：">作用：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;延迟操作。也就是在需要的时候才产生结果，不是立即产生结果。<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="注意事项：">注意事项：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;生成器是只能遍历一次的。<br>&gt;生成器是一类特殊的迭代器。<br></code></pre></td></tr></table></figure><h4 id="分类：">分类：</h4><h3 id="第一类：">第一类：</h3><p><strong>生成器函数：还是使用 def 定义函数，但是，使用yield而不是return语句返回结果。yield语句一次返回一个结果，在每个结果中间，挂起函数的状态，以便下次从它离开的地方继续执行。</strong></p><h4 id="如下案例加以说明：">如下案例加以说明：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 菲波那切数列</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Fib</span><span class="hljs-params">(max)</span>:</span><br>    n, a, b = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> n &lt; max:<br>        <span class="hljs-keyword">yield</span> b<br>        a, b = b, a + b<br>        n = n + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'亲！没有数据了...'</span><br><span class="hljs-comment"># 调用方法，生成出10个数来</span><br>f=Fib(<span class="hljs-number">10</span>)<br><span class="hljs-comment"># 使用一个循环捕获最后return 返回的值，保存在异常StopIteration的value中</span><br><span class="hljs-keyword">while</span>  <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        x=next(f)<br>        print(<span class="hljs-string">"f:"</span>,x)<br>    <span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> e:<br>        print(<span class="hljs-string">"生成器最后的返回值是："</span>,e.value)<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h3 id="第二类：">第二类：</h3><p><strong>生成器表达式：类似于列表推导，只不过是把一对大括号[]变换为一对小括号()。但是，生成器表达式是按需产生一个生成器结果对象，要想拿到每一个元素，就需要循环遍历。</strong></p><h4 id="如下案例加以说明：-2">如下案例加以说明：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 一个列表</span><br>xiaoke=[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-comment"># 生成器generator，类似于list，但是是把[]改为()</span><br>gen=(a <span class="hljs-keyword">for</span> a  <span class="hljs-keyword">in</span> xiaoke)<br><span class="hljs-keyword">for</span>  i  <span class="hljs-keyword">in</span> gen:<br>    print(i)<br><span class="hljs-comment">#结果是：</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><br><span class="hljs-comment"># 为什么要使用生成器？因为效率。</span><br><span class="hljs-comment"># 使用生成器表达式取代列表推导式可以同时节省 cpu 和 内存(RAM)。</span><br><span class="hljs-comment"># 如果你构造一个列表(list)的目的仅仅是传递给别的函数,</span><br><span class="hljs-comment"># 比如 传递给tuple()或者set(), 那就用生成器表达式替代吧!</span><br><br><span class="hljs-comment"># 本案例是直接把列表转化为元组</span><br>kk=tuple(a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> xiaoke)<br>print(kk)<br><span class="hljs-comment">#结果是：</span><br>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># python内置的一些函数，可以识别这是生成器表达式，外面有一对小括号，就是生成器</span><br>result1=sum(a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>))<br>print(result1)<br><span class="hljs-comment"># 列表推导式</span><br>result2=sum([a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>)])<br>print(result2)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python生成器（send，close，throw）方法详解</title>
      <link href="/posts/1336.html"/>
      <url>/posts/1336.html</url>
      
        <content type="html"><![CDATA[<h1>一、Python生成器send()方法</h1><p><strong>我们知道，通过调用 next() 或者 <code>__next()__</code> 方法，可以实现从外界控制生成器的执行。除此之外，通过 send() 方法，还可以向生成器中传值。</strong></p><p><strong>值得一提的是，send() 方法可带一个参数，也可以不带任何参数（用 None 表示）。其中，当使用不带参数的 send() 方法时，它和 next() 函数的功能完全相同。例如：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intNum</span><span class="hljs-params">()</span>:</span><br>  print(<span class="hljs-string">"开始执行"</span>)<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):<br>    <span class="hljs-keyword">yield</span> i<br>    print(<span class="hljs-string">"继续执行"</span>)<br>num = intNum()<br>print(num.send(<span class="hljs-literal">None</span>))<br>print(num.send(<span class="hljs-literal">None</span>))<br></code></pre></td></tr></table></figure><h5 id="输出结果">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">开始执行<br><span class="hljs-number">0</span><br>继续执行<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>注意，虽然 send(None) 的功能是 next() 完全相同，但更推荐使用 next()，不推荐使用 send(None)。</strong></p></blockquote><p><strong>这里重点讲解一些带参数的 send(value) 的用法，其具备 next() 函数的部分功能，即将暂停在 yield 语句出的程序继续执行，但与此同时，该函数还会将 value 值作为 yield 语句返回值赋值给接收者。</strong></p><p><em><strong>注意，带参数的 send(value) 无法启动执行生成器函数。也就是说，程序中第一次使用生成器调用 next() 或者 send() 函数时，不能使用带参数的 send() 函数。</strong></em></p><h2 id="举个例子：">举个例子：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span><br>    bar_a = <span class="hljs-keyword">yield</span> <span class="hljs-string">"hello"</span><br>    bar_b = <span class="hljs-keyword">yield</span> bar_a<br>    <span class="hljs-keyword">yield</span> bar_b<br><br>f = foo()<br>print(f.send(<span class="hljs-literal">None</span>))<br>print(f.send(<span class="hljs-string">"xgp"</span>))<br>print(f.send(<span class="hljs-string">"https://wsdlxgp.top/"</span>))<br></code></pre></td></tr></table></figure><h3 id="分析一下此程序的执行流程：">分析一下此程序的执行流程：</h3><p><strong>1) 首先，构建生成器函数，并利用器创建生成器（对象）f 。</strong></p><p><strong>2) 使用生成器 f 调用无参的 send() 函数，其功能和 next() 函数完全相同，因此开始执行生成器函数，即执行到第一个 yield “hello” 语句，该语句会返回 “hello” 字符串，然后程序停止到此处（注意，此时还未执行对 bar_a 的赋值操作）。</strong></p><p><strong>3) 下面开始使用生成器 f 调用有参的 send() 函数，首先它会将暂停的程序开启，同时还会将其参数“xgp”赋值给当前 yield 语句的接收者，也就是 bar_a 变量。程序一直执行完 yield bar_a 再次暂停，因此会输出“xgp”。</strong></p><p><strong>4） 最后依旧是调用有参的 send() 函数，同样它会启动餐厅的程序，同时将参数“<a href="https://wsdlxgp.top/%E2%80%9D%E4%BC%A0%E7%BB%99">https://wsdlxgp.top/”传给</a> bar_b，然后执行完 yield bar_b 后（输出 <a href="https://wsdlxgp.top/%EF%BC%89%EF%BC%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%86%8D%E6%AC%A1%E6%9A%82%E5%81%9C%E3%80%82">https://wsdlxgp.top/），程序执行再次暂停。</a></strong></p><h5 id="因此，该程序的执行结果为：">因此，该程序的执行结果为：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">hello<br>xgp<br>https://wsdlxgp.top/<br></code></pre></td></tr></table></figure></blockquote><h1>二、Python生成器close()方法</h1><p><strong>当程序在生成器函数中遇到 yield 语句暂停运行时，此时如果调用 close() 方法，会阻止生成器函数继续执行，该函数会在程序停止运行的位置抛出 GeneratorExit 异常。</strong></p><h3 id="举个例子：-2">举个例子：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span><br>  <span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">except</span> GeneratorExit:<br>    print(<span class="hljs-string">'捕获到 GeneratorExit'</span>)<br>f = foo()<br>print(next(f))<br>f.close()<br></code></pre></td></tr></table></figure><h5 id="输出结果-2">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span><br>捕获到 GeneratorExit<br></code></pre></td></tr></table></figure></blockquote><p><strong>注意，虽然通过捕获 GeneratorExit 异常，可以继续执行生成器函数中剩余的代码，带这部分代码中不能再包含 yield 语句，否则程序会抛出 RuntimeError 异常。例如：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">except</span> GeneratorExit:<br>        print(<span class="hljs-string">'捕获到 GeneratorExit'</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>  <span class="hljs-comment"># 抛出 RuntimeError 异常</span><br>f = foo()<br>print(next(f))<br>f.close()<br></code></pre></td></tr></table></figure><h5 id="输出结果-3">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span><br>捕获到 GeneratorExit<br>Traceback (most recent call last):<br>  File <span class="hljs-string">"G:/四期/python/Pytghon_MySQL/生成器/xxx.py"</span>, line <span class="hljs-number">9</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    f.close()<br>RuntimeError: generator ignored GeneratorExit<br></code></pre></td></tr></table></figure></blockquote><p><strong>另外，生成器函数一旦使用 close() 函数停止运行，后续将无法再调用 next() 函数或者 <code>__next()__</code>方法启动执行，否则会抛出 StopIteration 异常。例如：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">"c.biancheng.net"</span><br>print(<span class="hljs-string">"生成器停止执行"</span>)<br>f = foo()<br>print(next(f))  <span class="hljs-comment"># 输出 "c.biancheng.net"</span><br>f.close()<br>next(f)  <span class="hljs-comment"># 原本应输出"生成器停止执行"</span><br></code></pre></td></tr></table></figure><h5 id="输出结果-4">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">Traceback (most recent call last):<br>  File <span class="hljs-string">"G:/四期/python/Pytghon_MySQL/生成器/xxx.py"</span>, line <span class="hljs-number">10</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    next(f)  <span class="hljs-comment"># 原本应输出"生成器停止执行"</span><br>StopIteration<br>生成器停止执行<br>c.biancheng.net<br></code></pre></td></tr></table></figure></blockquote><h1>三、Python生成器throw()方法</h1><p><strong>生成器 throw() 方法的功能是，在生成器函数执行暂停处，抛出一个指定的异常，之后程序会继续执行生成器函数中后续的代码，直到遇到下一个 yield 语句。需要注意的是，如果到剩余代码执行完毕没有遇到下一个 yield 语句，则程序会抛出 StopIteration 异常。</strong></p><h3 id="举个例子：-3">举个例子：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">except</span> ValueError:<br>        print(<span class="hljs-string">'捕获到 ValueError'</span>)<br>f = foo()<br>print(next(f))<br>f.throw(ValueError)<br></code></pre></td></tr></table></figure><h5 id="输出结果-5">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">Traceback (most recent call last):<br>  File <span class="hljs-string">"G:/四期/python/Pytghon_MySQL/生成器/xxx.py"</span>, line <span class="hljs-number">8</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    f.throw(ValueError)<br>StopIteration<br><span class="hljs-number">1</span><br>捕获到 ValueError<br></code></pre></td></tr></table></figure></blockquote><p><strong>显然，一开始生成器函数在 yield 1 处暂停执行，当执行 throw() 方法时，它会先抛出 ValueError 异常，然后继续执行后续代码找到下一个 yield 语句，该程序中由于后续不再有 yield 语句，因此程序执行到最后，会抛出一个 StopIteration 异常。</strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的生成器（2）</title>
      <link href="/posts/1335.html"/>
      <url>/posts/1335.html</url>
      
        <content type="html"><![CDATA[<h1>A：Python迭代器，生成器详解</h1><p><strong>本质上，生成器也是一种迭代器。但生成器只能迭代一次，因为值是在迭代过程生成，而所有的值没有保存在内存。这里先介绍下迭代器的概念，迭代器分为3部分：</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200616231912743.png" alt="image-20200616231912743"></p><ul><li><strong>可迭代对象： python中的任意对象，只要它定义了可以返回一个迭代器iter方法，或者支持下标索引的<code>getitem</code>方法，那它就是一个可迭代对象。简单来说可迭代对象就是可以提供迭代器的任意对象。</strong></li><li><strong>迭代器： python中的任意对象有<code>next</code>方法就是一个迭代器。</strong></li><li><strong>迭代： 简单来说就是从某个地方取出一个元素的过程，像使用循环遍历一个列表这个过程就叫迭代。</strong></li></ul><p><strong>了解迭代器的概念，我们再来细究生成器的原理：生成器是只能迭代一次的迭代器。大多数时候生成器都是通过函数来实现的。使用生成器“生成”一个值可以通过for循环，或者将它们传递给可以进行迭代的函数和结构。 （注：这个过程并不是return返回一个值，而是“生成”一个值，且所有值不保存在内存里面）</strong></p><h1>A：生成器协议</h1><p><strong>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</strong></p><p><strong>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</strong></p><p><strong>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</strong></p><p><strong>调用一个生成器函数，返回的是一个迭代器对象。</strong></p><h2 id="1、生成器实现的协议-迭代器协议">1、生成器实现的协议:迭代器协议</h2><h3 id="（1）迭代器协议">（1）迭代器协议:</h3><ul><li><strong>对象需要提供next的方法,</strong></li><li><strong>它要么返回迭代中的-项,</strong></li><li><strong>要么就引起一个StopIteration异常，来终止迭代</strong></li></ul><h3 id="（2）使用了迭代器进行访问数据的工具">（2）使用了迭代器进行访问数据的工具</h3><p><strong>for循环:sum()、max()、min()、len()等函数</strong></p><h3 id="（3）以下实例使用-yield-实现斐波那契数列：">（3）以下实例使用 yield 实现斐波那契数列：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-keyword">import</span> sys<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(n)</span>:</span> <span class="hljs-comment"># 生成器函数 - 斐波那契</span><br>    a, b, counter = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> (counter &gt; n): <br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">yield</span> a<br>        a, b = b, a + b<br>        counter += <span class="hljs-number">1</span><br>f = fibonacci(<span class="hljs-number">10</span>) <span class="hljs-comment"># f 是一个迭代器，由生成器返回生成</span><br> <br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">print</span> (next(f), end=<span class="hljs-string">" "</span>)<br>    <span class="hljs-keyword">except</span> StopIteration:<br>        sys.exit()<br></code></pre></td></tr></table></figure><p><strong>执行以上程序，输出结果如下：</strong></p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span> <span class="hljs-number">34</span> <span class="hljs-number">55</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="2、生成器的创建方式也比迭代器简单很多，大体分为以下-2-步：">2、生成器的创建方式也比迭代器简单很多，大体分为以下 2 步：</h2><ul><li><strong>定义一个以 yield 关键字标识返回值的函数；</strong></li><li><strong>调用刚刚创建的函数，即可创建一个生成器</strong></li></ul><h3 id="举个例子：">举个例子：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intNum</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">"开始执行"</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):<br>        <span class="hljs-keyword">yield</span> i<br>        print(<span class="hljs-string">"继续执行"</span>)<br>num = intNum()<br></code></pre></td></tr></table></figure><p><strong>由此，我们就成功创建了一个 num 生成器对象。显然，和普通函数不同，number() 函数的返回值用的是 yield 关键字，而不是 return 关键字，此类函数又成为生成器函数。</strong></p><p><strong>和 return 相比，yield 除了可以返回相应的值，还有一个更重要的功能，即每当程序执行完该语句时，程序就会暂停执行。不仅如此，即便调用生成器函数，Python解释器也不会执行函数中的代码，它只会返回一个生成器（对象）。</strong></p><h2 id="3、要想使生成器函数得以执行，或者想使执行完-yield-语句立即暂停的程序得以继续执行，有以下-2-种方式：">3、要想使生成器函数得以执行，或者想使执行完 yield 语句立即暂停的程序得以继续执行，有以下 2 种方式：</h2><ul><li><strong>通过生成器（上面程序中的 num）调用 next() 内置函数或者 next() 方法；</strong></li><li><strong>通过 for 循环遍历生成器。</strong></li></ul><h4 id="例如，在上面程序的基础上，添加如下语句：">例如，在上面程序的基础上，添加如下语句：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#调用 next() 内置函数</span><br>print(next(num))<br><span class="hljs-comment">#调用 __next__() 方法</span><br>print(num.__next__())<br><span class="hljs-comment">#通过for循环遍历生成器</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> num:<br>    print(i)<br></code></pre></td></tr></table></figure><h5 id="程序执行结果为：">程序执行结果为：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">开始执行<br><span class="hljs-number">0</span><br>继续执行<br><span class="hljs-number">1</span><br>继续执行<br><span class="hljs-number">2</span><br>继续执行<br><span class="hljs-number">3</span><br>继续执行<br><span class="hljs-number">4</span><br>继续执行<br></code></pre></td></tr></table></figure></blockquote><h4 id="这里有必要给读者分析一个程序的执行流程："><strong>这里有必要给读者分析一个程序的执行流程：</strong></h4><p><strong>1) 首先，在创建有 num 生成器的前提下，通过其调用 next() 内置函数，会使 Python 解释器开始执行 intNum() 生成器函数中的代码，因此会输出“开始执行”，程序会一直执行到<code>yield i</code>，而此时的 i==0，因此 Python 解释器输出“0”。由于受到 yield 的影响，程序会在此处暂停。</strong></p><p><strong>2) 然后，我们使用 num 生成器调用 next() 方法，该方法的作用和 next() 函数完全相同（事实上，next() 函数的底层执行的也是 next() 方法），它会是程序继续执行，即输出“继续执行”，程序又会执行到<code>yield i</code>，此时 i==1，因此输出“1”，然后程序暂停。</strong></p><p><strong>3) 最后，我们使用 for 循环遍历 num 生成器，之所以能这么做，是因为 for 循环底层会不断地调用 next() 函数，使暂停的程序继续执行，因此会输出后续的结果。</strong></p><blockquote><p><strong>注意，在 Python 2.x 版本中不能使用 next() 方法，可以使用 next() 内置函数，另外生成器还有 next() 方法（即以 num.next() 的方式调用）。</strong></p></blockquote><h2 id="4、除此之外，还可以使用-list-函数和-tuple-函数，直接将生成器能生成的所有值存储成列表或者元组的形式。">4、除此之外，还可以使用 list() 函数和 tuple() 函数，直接将生成器能生成的所有值存储成列表或者元组的形式。</h2><h3 id="例如：">例如：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">num = intNum()<br>print(list(num))<br>num = intNum()<br>print(tuple(num))<br></code></pre></td></tr></table></figure><h5 id="程序执行结果为：-2">程序执行结果为：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">开始执行<br>继续执行<br>继续执行<br>继续执行<br>继续执行<br>继续执行<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>开始执行<br>继续执行<br>继续执行<br>继续执行<br>继续执行<br>继续执行<br>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure></blockquote><p><strong>通过输出结果可以判断出，list() 和 tuple() 底层实现和 for 循环的遍历过程是类似的。</strong></p><blockquote><p><strong>相比迭代器，生成器最明显的优势就是节省内存空间，即它不会一次性生成所有的数据，而是什么时候需要，什么时候生成。</strong></p></blockquote><h1>小练习</h1><p><strong>假设现在有一个列表，</strong><br><strong>列表中包含多个整数，</strong><br><strong>我们对列表进行过滤，</strong><br><strong>在过滤的结果中，只保留列表中的偶数的数字。</strong></p><h2 id="方法一">方法一</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vim">#conding=utf-<span class="hljs-number">8</span><br>def get_even_num(<span class="hljs-keyword">list</span>):<br>    <span class="hljs-keyword">res</span> = []<br>    <span class="hljs-keyword">for</span> item in lis<span class="hljs-variable">t:</span><br>        <span class="hljs-keyword">res</span>.<span class="hljs-keyword">append</span>(item)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">res</span><br><br>def main():<br>    <span class="hljs-keyword">list</span> = <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)<br>    <span class="hljs-keyword">for</span> i in get_even_num(<span class="hljs-keyword">list</span>):<br>        <span class="hljs-keyword">print</span>(i,end=<span class="hljs-string">' '</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></table></figure><h5 id="输出结果">输出结果</h5><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="方法二">方法二</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#conding=utf-8</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_even_num</span><span class="hljs-params">(list)</span>:</span><br>    <span class="hljs-comment"># res = []</span><br>    <span class="hljs-comment"># for item in list:</span><br>    <span class="hljs-comment">#     res.append(item)</span><br>    <span class="hljs-comment"># return res</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> list:<br>        <span class="hljs-keyword">if</span> item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">yield</span> item<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    list = range(<span class="hljs-number">5</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> get_even_num(list):<br>        print(i,end=<span class="hljs-string">' '</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></table></figure><h5 id="输出结果-2">输出结果</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="或者"><strong>或者</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#conding=utf-8</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_even_num</span><span class="hljs-params">(list)</span>:</span><br>    <span class="hljs-keyword">return</span> [item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> list <span class="hljs-keyword">if</span> item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    list = range(<span class="hljs-number">5</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> get_even_num(list):<br>        print(i,end=<span class="hljs-string">' '</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></table></figure><h5 id="输出结果-3">输出结果</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的生成器（1）</title>
      <link href="/posts/1334.html"/>
      <url>/posts/1334.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200616232351368.png" alt="image-20200616232351368"></p><h1>A：概述</h1><p><strong>可迭代对象、迭代器和生成器这三个概念很容易混淆，前两者通常不会区分的很明显，只是用法上有区别。生成器在某种概念下可以看做是特殊的迭代器，它比迭代实现上更加简洁。三者关系如图：</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200616232203966.png" alt="image-20200616232203966"></p><h1>B：可迭代对象</h1><p><strong>先说下上面三者的基础：可迭代对象（Iterable Object），简单的来理解就是可以使用 <code>for</code> 来循环遍历的对象。比如常见的 list、set和dict。可以用以下方法来测试对象是否是可迭代</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Iterable<br><span class="hljs-meta">&gt;&gt;&gt; </span>isinstance(<span class="hljs-string">'abc'</span>, Iterable)     <span class="hljs-comment"># str是否可迭代</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>isinstance([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], Iterable)   <span class="hljs-comment"># list是否可迭代</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>isinstance(<span class="hljs-number">123</span>, Iterable)       <span class="hljs-comment"># 整数是否可迭代</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h1>C：Python迭代器概念</h1><ul><li><strong>迭代是Python最强大的功能之一，是访问集合元素的一种方式。</strong></li><li><strong>迭代器是一个可以记住遍历的位置的对象。</strong></li><li><strong>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</strong></li><li><strong>迭代器有两个基本的方法：iter() 和 next()。</strong></li></ul><h2 id="操作一">操作一</h2><h3 id="（1）字符串，列表或元组对象都可用于创建迭代器："><strong>（1）字符串，<strong>列表或元组对象都可用于创建迭代器</strong>：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>list=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>it = iter(list)    <span class="hljs-comment"># 创建迭代器对象</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> (next(it))   <span class="hljs-comment"># 输出迭代器的下一个元素</span><br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> (next(it))<br><span class="hljs-number">2</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><h3 id="（2）迭代器对象可以使用常规for语句进行遍历：">（2）迭代器对象可以使用常规for语句进行遍历：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br>list=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>it = iter(list)    <span class="hljs-comment"># 创建迭代器对象</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> it:<br>    <span class="hljs-keyword">print</span> (x, end=<span class="hljs-string">" "</span>)<br></code></pre></td></tr></table></figure><h3 id="（3）执行以上程序，输出结果如下：">（3）执行以上程序，输出结果如下：</h3><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="（4）也可以使用-next-函数：">（4）也可以使用 next() 函数：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-keyword">import</span> sys         <span class="hljs-comment"># 引入 sys 模块</span><br> <br>list=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>it = iter(list)    <span class="hljs-comment"># 创建迭代器对象</span><br> <br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">print</span> (next(it))<br>    <span class="hljs-keyword">except</span> StopIteration:<br>        sys.exit()<br></code></pre></td></tr></table></figure><h5 id="执行以上程序，输出结果如下：">执行以上程序，输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="操作二">操作二</h2><p><strong>其实你对所有的可迭代对象调用 <code>dir()</code> 方法时，会发现他们都实现了 <code>__iter__</code> 方法。这样就可以通过 <code>iter(object)</code> 来返回一个迭代器。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>y = iter(x)<br><span class="hljs-meta">&gt;&gt;&gt; </span>type(x)<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">list</span>'&gt;</span><br><span class="hljs-class">&gt;&gt;&gt; <span class="hljs-title">type</span><span class="hljs-params">(y)</span></span><br><span class="hljs-class">&lt;<span class="hljs-title">class</span> '<span class="hljs-title">list_iterator</span>'&gt;</span><br></code></pre></td></tr></table></figure><p><strong>可以看到调用 <code>iter()</code> 之后，变成了一个 <code>list_iterator</code> 的对象。会发现增加了 <code>__next__</code> 方法。所有实现了 <code>__iter__</code> 和 <code>__next__</code> 两个方法的对象，都是迭代器。</strong></p><p><strong>迭代器是带状态的对象，它会记录当前迭代所在的位置，以方便下次迭代的时候获取正确的元素。<code>__iter__</code>返回迭代器自身，<code>__next__</code>返回容器中的下一个值，如果容器中没有更多元素了，则抛出StopIteration异常。</strong></p><h2 id="操作三">操作三</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>y = iter(x)<br><span class="hljs-meta">&gt;&gt;&gt; </span>next(y)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>next(y)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>next(y)<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>next(y)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>StopIteration<br></code></pre></td></tr></table></figure><p><strong>具体的实现我没有深入研究。但是我大胆的猜测一下…联系操作系统中 <code>printf(fmt,...)</code> 的实现方式，其中是定义一个 <code>va_list</code> 来用于保存需要打印的 <code>...</code> 信息的。然后实现了<code>va_start()</code> <code>va_end()</code> <code>va_arg()</code> 三个方法来不停地迭代式的打印信息。感兴趣可以自己了解。</strong></p><p><strong>那回到<code>Iterator</code> ，如何判断对象是否是迭代器，和判断是否是可迭代对象的方法差不多，只要把 <code>Iterable</code> 换成 <code>Iterator</code>。</strong></p><p><strong>Python的<code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的，举个栗子，下面的代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> x:<br>    ...<br></code></pre></td></tr></table></figure><h3 id="实际上执行时是">实际上执行时是</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200616231912743.png" alt="image-20200616231912743"></p><p><strong>也就是先将可迭代对象转化为<code>Iterator</code>，再去迭代。应该是处于对内存的节省考虑。因为迭代器只有在你调用 <code>next()</code> 才会实际计算下一个值。</strong></p><h2 id="（2）itertools-库提供了很多常见迭代器的使用">（2）<code>itertools</code> 库提供了很多常见迭代器的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> count     <span class="hljs-comment"># 计数器</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>counter = count(start=<span class="hljs-number">13</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>next(counter)<br><span class="hljs-number">13</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>next(counter)<br><span class="hljs-number">14</span><br></code></pre></td></tr></table></figure><h2 id="（3）无限循环序列：">（3）无限循环序列：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> cycle<br><span class="hljs-meta">&gt;&gt;&gt; </span>colors = cycle([<span class="hljs-string">'red'</span>, <span class="hljs-string">'white'</span>, <span class="hljs-string">'blue'</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>next(colors)<br><span class="hljs-string">'red'</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>next(colors)<br><span class="hljs-string">'white'</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>next(colors)<br><span class="hljs-string">'blue'</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>next(colors)<br><span class="hljs-string">'red'</span><br></code></pre></td></tr></table></figure><h1>E：创建一个迭代器</h1><p><strong>把一个类作为一个迭代器使用需要在类中实现两个方法 iter() 与 next() 。</strong></p><p><strong>如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为 init(), 它会在对象初始化的时候执行。</strong></p><p><strong>更多内容查阅：<a href="https://www.runoob.com/python3/python3-class.html" target="_blank" rel="noopener">Python3 面向对象</a></strong></p><p><strong>iter() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 next() 方法并通过 StopIteration 异常标识迭代的完成。</strong></p><p><strong>next() 方法（Python 2 里是 next()）会返回下一个迭代器对象。</strong></p><p><strong>创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyNumbers</span>:</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span><br>    self.a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> self<br> <br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span><span class="hljs-params">(self)</span>:</span><br>    x = self.a<br>    self.a += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> x<br> <br>myclass = MyNumbers()<br>myiter = iter(myclass)<br> <br>print(next(myiter))<br>print(next(myiter))<br>print(next(myiter))<br>print(next(myiter))<br>print(next(myiter))<br></code></pre></td></tr></table></figure><h5 id="执行输出结果为：">执行输出结果为：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="StopIteration">StopIteration</h3><p><strong>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 next() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。</strong></p><p><strong>在 20 次迭代后停止执行：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyNumbers</span>:</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span><br>    self.a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> self<br> <br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span><span class="hljs-params">(self)</span>:</span><br>    <span class="hljs-keyword">if</span> self.a &lt;= <span class="hljs-number">20</span>:<br>      x = self.a<br>      self.a += <span class="hljs-number">1</span><br>      <span class="hljs-keyword">return</span> x<br>    <span class="hljs-keyword">else</span>:<br>      <span class="hljs-keyword">raise</span> StopIteration<br> <br>myclass = MyNumbers()<br>myiter = iter(myclass)<br> <br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> myiter:<br>  print(x)<br></code></pre></td></tr></table></figure><h5 id="执行输出结果为：-2">执行输出结果为：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">6</span><br><span class="hljs-number">7</span><br><span class="hljs-number">8</span><br><span class="hljs-number">9</span><br><span class="hljs-number">10</span><br><span class="hljs-number">11</span><br><span class="hljs-number">12</span><br><span class="hljs-number">13</span><br><span class="hljs-number">14</span><br><span class="hljs-number">15</span><br><span class="hljs-number">16</span><br><span class="hljs-number">17</span><br><span class="hljs-number">18</span><br><span class="hljs-number">19</span><br><span class="hljs-number">20</span><br></code></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的迭代器</title>
      <link href="/posts/1333.html"/>
      <url>/posts/1333.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200616232351368.png" alt="image-20200616232351368"></p><h1>A：概述</h1><p><strong>可迭代对象、迭代器和生成器这三个概念很容易混淆，前两者通常不会区分的很明显，只是用法上有区别。生成器在某种概念下可以看做是特殊的迭代器，它比迭代实现上更加简洁。三者关系如图：</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200616232203966.png" alt="image-20200616232203966"></p><h1>B：可迭代对象</h1><p><strong>先说下上面三者的基础：可迭代对象（Iterable Object），简单的来理解就是可以使用 <code>for</code> 来循环遍历的对象。比如常见的 list、set和dict。可以用以下方法来测试对象是否是可迭代</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Iterable<br><span class="hljs-meta">&gt;&gt;&gt; </span>isinstance(<span class="hljs-string">'abc'</span>, Iterable)     <span class="hljs-comment"># str是否可迭代</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>isinstance([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], Iterable)   <span class="hljs-comment"># list是否可迭代</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>isinstance(<span class="hljs-number">123</span>, Iterable)       <span class="hljs-comment"># 整数是否可迭代</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h1>C：Python迭代器概念</h1><ul><li><strong>迭代是Python最强大的功能之一，是访问集合元素的一种方式。</strong></li><li><strong>迭代器是一个可以记住遍历的位置的对象。</strong></li><li><strong>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</strong></li><li><strong>迭代器有两个基本的方法：iter() 和 next()。</strong></li></ul><h2 id="操作一">操作一</h2><h3 id="（1）字符串，列表或元组对象都可用于创建迭代器："><strong>（1）字符串，<strong>列表或元组对象都可用于创建迭代器</strong>：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>list=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>it = iter(list)    <span class="hljs-comment"># 创建迭代器对象</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> (next(it))   <span class="hljs-comment"># 输出迭代器的下一个元素</span><br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">print</span> (next(it))<br><span class="hljs-number">2</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><h3 id="（2）迭代器对象可以使用常规for语句进行遍历：">（2）迭代器对象可以使用常规for语句进行遍历：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br>list=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>it = iter(list)    <span class="hljs-comment"># 创建迭代器对象</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> it:<br>    <span class="hljs-keyword">print</span> (x, end=<span class="hljs-string">" "</span>)<br></code></pre></td></tr></table></figure><h3 id="（3）执行以上程序，输出结果如下：">（3）执行以上程序，输出结果如下：</h3><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="（4）也可以使用-next-函数：">（4）也可以使用 next() 函数：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br><span class="hljs-keyword">import</span> sys         <span class="hljs-comment"># 引入 sys 模块</span><br> <br>list=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>it = iter(list)    <span class="hljs-comment"># 创建迭代器对象</span><br> <br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">print</span> (next(it))<br>    <span class="hljs-keyword">except</span> StopIteration:<br>        sys.exit()<br></code></pre></td></tr></table></figure><h5 id="执行以上程序，输出结果如下：">执行以上程序，输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="操作二">操作二</h2><p><strong>其实你对所有的可迭代对象调用 <code>dir()</code> 方法时，会发现他们都实现了 <code>__iter__</code> 方法。这样就可以通过 <code>iter(object)</code> 来返回一个迭代器。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>y = iter(x)<br><span class="hljs-meta">&gt;&gt;&gt; </span>type(x)<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">list</span>'&gt;</span><br><span class="hljs-class">&gt;&gt;&gt; <span class="hljs-title">type</span><span class="hljs-params">(y)</span></span><br><span class="hljs-class">&lt;<span class="hljs-title">class</span> '<span class="hljs-title">list_iterator</span>'&gt;</span><br></code></pre></td></tr></table></figure><p><strong>可以看到调用 <code>iter()</code> 之后，变成了一个 <code>list_iterator</code> 的对象。会发现增加了 <code>__next__</code> 方法。所有实现了 <code>__iter__</code> 和 <code>__next__</code> 两个方法的对象，都是迭代器。</strong></p><p><strong>迭代器是带状态的对象，它会记录当前迭代所在的位置，以方便下次迭代的时候获取正确的元素。<code>__iter__</code>返回迭代器自身，<code>__next__</code>返回容器中的下一个值，如果容器中没有更多元素了，则抛出StopIteration异常。</strong></p><h2 id="操作三">操作三</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>y = iter(x)<br><span class="hljs-meta">&gt;&gt;&gt; </span>next(y)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>next(y)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>next(y)<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>next(y)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>StopIteration<br></code></pre></td></tr></table></figure><p><strong>具体的实现我没有深入研究。但是我大胆的猜测一下…联系操作系统中 <code>printf(fmt,...)</code> 的实现方式，其中是定义一个 <code>va_list</code> 来用于保存需要打印的 <code>...</code> 信息的。然后实现了<code>va_start()</code> <code>va_end()</code> <code>va_arg()</code> 三个方法来不停地迭代式的打印信息。感兴趣可以自己了解。</strong></p><p><strong>那回到<code>Iterator</code> ，如何判断对象是否是迭代器，和判断是否是可迭代对象的方法差不多，只要把 <code>Iterable</code> 换成 <code>Iterator</code>。</strong></p><p><strong>Python的<code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的，举个栗子，下面的代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> x:<br>    ...<br></code></pre></td></tr></table></figure><h3 id="实际上执行时是">实际上执行时是</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200616231912743.png" alt="image-20200616231912743"></p><p><strong>也就是先将可迭代对象转化为<code>Iterator</code>，再去迭代。应该是处于对内存的节省考虑。因为迭代器只有在你调用 <code>next()</code> 才会实际计算下一个值。</strong></p><h2 id="操作四">操作四</h2><p><strong>先新建test.txt文件，里面瞎写点东西</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> open(<span class="hljs-string">'test.txt'</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>        print(line.rstrip())<br></code></pre></td></tr></table></figure><h5 id="输出结果">输出结果</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">test<br>dfasd<br>asdfasdf<br>asdgfdg<br></code></pre></td></tr></table></figure><h2 id="1、itertools-库提供了很多常见迭代器的使用">1、<code>itertools</code> 库提供了很多常见迭代器的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> count     <span class="hljs-comment"># 计数器</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>counter = count(start=<span class="hljs-number">13</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>next(counter)<br><span class="hljs-number">13</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>next(counter)<br><span class="hljs-number">14</span><br></code></pre></td></tr></table></figure><h2 id="2、无限循环序列：">2、无限循环序列：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> cycle<br><span class="hljs-meta">&gt;&gt;&gt; </span>colors = cycle([<span class="hljs-string">'red'</span>, <span class="hljs-string">'white'</span>, <span class="hljs-string">'blue'</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>next(colors)<br><span class="hljs-string">'red'</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>next(colors)<br><span class="hljs-string">'white'</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>next(colors)<br><span class="hljs-string">'blue'</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>next(colors)<br><span class="hljs-string">'red'</span><br></code></pre></td></tr></table></figure><h2 id="3、dir方法">3、dir方法</h2><p><strong><code>dir()</code> 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。如果参数包含方法<code>__dir__()</code>，该方法将被调用。如果参数不包含<code>__dir__()</code>，该方法将最大限度地收集参数信息 。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">f = open(<span class="hljs-string">'test.txt'</span>)<br>print(dir(f))<br></code></pre></td></tr></table></figure><h5 id="输出结果-2">输出结果</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">'_CHUNK_SIZE'</span>, <span class="hljs-string">'__class__'</span>, <span class="hljs-string">'__del__'</span>, <span class="hljs-string">'__delattr__'</span>, <span class="hljs-string">'__dict__'</span>, <span class="hljs-string">'__dir__'</span>, <span class="hljs-string">'__doc__'</span>, <span class="hljs-string">'__enter__'</span>, <span class="hljs-string">'__eq__'</span>, <span class="hljs-string">'__exit__'</span>, <span class="hljs-string">'__format__'</span>, <span class="hljs-string">'__ge__'</span>, <span class="hljs-string">'__getattribute__'</span>, <span class="hljs-string">'__gt__'</span>, <span class="hljs-string">'__hash__'</span>, <span class="hljs-string">'__init__'</span>, <span class="hljs-string">'__init_subclass__'</span>, <span class="hljs-string">'__iter__'</span>, <span class="hljs-string">'__le__'</span>, <span class="hljs-string">'__lt__'</span>, <span class="hljs-string">'__ne__'</span>, <span class="hljs-string">'__new__'</span>, <span class="hljs-string">'__next__'</span>, <span class="hljs-string">'__reduce__'</span>, <span class="hljs-string">'__reduce_ex__'</span>, <span class="hljs-string">'__repr__'</span>, <span class="hljs-string">'__setattr__'</span>, <span class="hljs-string">'__sizeof__'</span>, <span class="hljs-string">'__str__'</span>, <span class="hljs-string">'__subclasshook__'</span>, <span class="hljs-string">'_checkClosed'</span>, <span class="hljs-string">'_checkReadable'</span>, <span class="hljs-string">'_checkSeekable'</span>, <span class="hljs-string">'_checkWritable'</span>, <span class="hljs-string">'_finalizing'</span>, <span class="hljs-string">'buffer'</span>, <span class="hljs-string">'close'</span>, <span class="hljs-string">'closed'</span>, <span class="hljs-string">'detach'</span>, <span class="hljs-string">'encoding'</span>, <span class="hljs-string">'errors'</span>, <span class="hljs-string">'fileno'</span>, <span class="hljs-string">'flush'</span>, <span class="hljs-string">'isatty'</span>, <span class="hljs-string">'line_buffering'</span>, <span class="hljs-string">'mode'</span>, <span class="hljs-string">'name'</span>, <span class="hljs-string">'newlines'</span>, <span class="hljs-string">'read'</span>, <span class="hljs-string">'readable'</span>, <span class="hljs-string">'readline'</span>, <span class="hljs-string">'readlines'</span>, <span class="hljs-string">'reconfigure'</span>, <span class="hljs-string">'seek'</span>, <span class="hljs-string">'seekable'</span>, <span class="hljs-string">'tell'</span>, <span class="hljs-string">'truncate'</span>, <span class="hljs-string">'writable'</span>, <span class="hljs-string">'write'</span>, <span class="hljs-string">'write_through'</span>, <span class="hljs-string">'writelines'</span>]<br></code></pre></td></tr></table></figure><blockquote><p><strong>迭代器本身是一个底层的特性和概念，在程序中并不常用，但它为生成器这一更有趣的特性提供了基础。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python的SaltStack</title>
      <link href="/posts/1332.html"/>
      <url>/posts/1332.html</url>
      
        <content type="html"><![CDATA[<h2 id="SaltStack">SaltStack</h2><h3 id="Ansible和SaltStack的区别">Ansible和SaltStack的区别</h3><ul><li><p><strong>Ansible安装部署简单。默认情况下，SaltStack需要安装客户端接收服务器发送过来的命令。Ansible不需要在被控服务器上部署任何的客户端，直接使用ssh通道进行远程命令的执行或者下发配置。</strong></p></li><li><p><strong>SaltStack响应速度快。默认情况下，Ansible使用的是标准的SSH协议，而SaltStack使用ZeroMQ进行通信和传输。因此，仅仅从响应速度来讲，SaltStack比Ansible快很多，甚至快十几倍。在一般运维场景下，Ansible的响应速度完全可以满足需求。</strong></p></li><li><p><strong>Ansible更安全。Ansible使用标准的SSH连接传输数据，不需要在远程主机上启动守护进程。此外，标准的SSH数据传输本身就是加密传输，远程主机不易被攻击。</strong></p></li><li><p><strong>对Windows的支持。SaltStack对Windows的支持比较友好，Ansible从1.7版本开始加入了对Windows的支持。由于Windows默认没有SSH，而Ansible有依赖SSH进行通信，所以在Windows下Ansible需要依赖PowerShell来实现远程管理。Ansible必须使用Linux系统运行控制端。</strong></p></li><li><p><strong>Ansible自身运维比较简单。SaltStack需要在Master和Minion主机启动一个守护进程，自身需要检测守护进程的运行状态，增加了运维成本。Ansible和服务器之间用SSH进行通信，服务器上值需要运行SSH进程就可以进行运维操作。因此，从工具本身的运维角度来说，Ansible要比SaltStack简单很多。</strong></p></li></ul><h1>一、安装SaltStack</h1><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200522142601976.png" alt="image-20200522142601976"></p><h2 id="1、实验环境：">1、实验环境：</h2><table><thead><tr><th>角色</th><th>主机名</th><th>id(minion id)</th><th>IP</th></tr></thead><tbody><tr><td>Master</td><td>python</td><td>SN-2020-03-01</td><td>192.168.1.80</td></tr><tr><td>minion</td><td>192.168.1.40</td><td>SN-2020-03-11</td><td>192.168.1.40</td></tr></tbody></table><h3 id="2、安装EPEL-都要">2、安装EPEL(都要)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install epel<br>或<br>yum install epel-release -y<br></code></pre></td></tr></table></figure><h3 id="3、安装SaltStack">3、安装SaltStack</h3><h4 id="（1）主服务器安装（主控端）">（1）主服务器安装（主控端）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install salt-master<br>chkconfig salt-master on<br>service salt-master start<br></code></pre></td></tr></table></figure><h4 id="（2）从服务器安装（被控端）">（2）从服务器安装（被控端）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install salt-minion<br>chkconfig salt-minion on<br>service salt-minion start<br></code></pre></td></tr></table></figure><h3 id="4、SaltStack防火墙配置-master">4、SaltStack防火墙配置(master)</h3><p><strong>在主控端添加TCP 4505、TCP 4506的规则，而在被控端无须配置防火墙，原理是被控端直接与主控端的zeromq建立长链接，接收广播到的任务信息并执行，具体操作是添加两条iptables规则:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]#  iptables -I INPUT -m state --state new -m tcp -p tcp --dport 4505 -j ACCEPT<br>[root@python ~]# iptables -I INPUT -m state --state new -m tcp -p tcp --dport 4506 -j ACCEPT<br></code></pre></td></tr></table></figure><h3 id="5、更新Saltstack配置及安装校验">5、更新Saltstack配置及安装校验</h3><p><strong>Saltstack分两种角色，一种为master（主控端），另一种为minion（被控端），安装完毕后需要对两种角色的配置文件进行修改。下面具体说明：</strong></p><h4 id="（1）master主控端配置">（1）master主控端配置</h4><h4 id="1）更新主控端关键项配置">1）更新主控端关键项配置</h4><blockquote><p>/etc/salt/master</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# vim test.ping<br><span class="hljs-meta">#</span><span class="bash"> 绑定Master通信IP</span><br>interface: 192.168.79.143  # 15行<br><span class="hljs-meta">#</span><span class="bash"> 自动认证，避免手动运行salt-key来确认证书信任</span><br>auto_accept: True         #215<br><span class="hljs-meta">#</span><span class="bash"> 指定saltstack文件根目录的位置</span><br>file_roots:               #406<br>  base:<br>    - /srv/salt<br></code></pre></td></tr></table></figure><p><strong>当/etc/salt/master没有配置auto_accept: True时，需要通过salt-key命令来进行证书认证操作，具体操作如下：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">salt-key -L:显示已经或未认证的被控端id,Accepted Keys为已认证清单，Unaccepted Kys为未认证的清单<br>salt-key -D:删除所有认证主机id证书<br>salt-key -d id:删除单个id证书<br>salt-key -A:接受所有id证书请求<br>salt-key -a id:接受单个id证书请求<br></code></pre></td></tr></table></figure><h4 id="2）重启saltstack-salt-master服务，使新配置生效">2）重启saltstack salt-master服务，使新配置生效</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service salt-master restart<br></code></pre></td></tr></table></figure><h4 id="（2）minion被控制端配置">（2）minion被控制端配置</h4><h4 id="1）更新被控端关键项配置">1）更新被控端关键项配置</h4><blockquote><p><strong>/etc/salt/minion</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@192 ~]# vim test.ping<br><span class="hljs-meta">#</span><span class="bash"> 指定master主机IP地址</span><br>master: 192.168.79.143    # 15行<br><span class="hljs-meta">#</span><span class="bash"> 修改被控制端主机识别ID，建议使用操作系统主机名来配置</span><br>id: XGP<br></code></pre></td></tr></table></figure><h4 id="2）重启saltstack-salt-minion服务，使新配置生效">2）重启saltstack salt-minion服务，使新配置生效</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service salt-minion restart<br></code></pre></td></tr></table></figure><h4 id="（3）校验安装结果">（3）校验安装结果</h4><p><strong>通过test模块的ping方法，可以确认指定被控端设备与主控端是否建立信任关系，及连通性是否正常，探测所有被控端采用“*”来代替“SN-2020-03-20”即可。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@192 ~]# salt 'XGP' test.ping<br>XGP:<br>    True<br></code></pre></td></tr></table></figure><h1>二、使用saltstack远程执行命令</h1><p><strong>saltstack的一个比较突出的优势是，具备执行远程命令的功能，可以帮助运维人员完成集中化的操作平台。</strong></p><h2 id="1、salt命令格式">1、salt命令格式</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">salt '&lt;操作目标&gt;' &lt;方法&gt;[参数]<br></code></pre></td></tr></table></figure><p><strong>示例：查看被控主机的内存使用情况</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# salt 'XGP' cmd.run 'free -m'<br>XGP:<br>                  total        used        free      shared  buff/cache   available<br>    Mem:            976         500          94           2         381         260<br>    Swap:          2047         267        1780<br></code></pre></td></tr></table></figure><h2 id="2、常用的具体参数">2、常用的具体参数</h2><p><strong>针对&lt;操作目标&gt;，saltstack提供了多种方法对被控端主机（id）进行过滤。</strong></p><h3 id="（1）-E-–pcre">（1）-E,–pcre</h3><p><strong>通过正则表达式进行匹配。示例：监控SN-2020字符开头的主机id名是否连通，如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# salt -E '^XG*' test.ping<br>XGP:<br>    True<br></code></pre></td></tr></table></figure><h3 id="（2）-L-–list">（2）-L,–list</h3><p><strong>以主机名id列表的形式进行过滤，格式与Python的列表相似，即不同的主机id名称使用逗号进行分隔。示例：获取主机id名为XGP；获取完整操作系统发行版本名称。如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@python ~]<span class="hljs-comment"># salt -L 'XGP' grains.item osfullname</span><br>XGP:<br>    ----------<br>    osfullname:<br>        CentOS Linux<br></code></pre></td></tr></table></figure><h3 id="（3）-G-–grain">（3）-G,–grain</h3><p><strong>根据被控主机的grain信息进行匹配过滤，格式为’<grain value>:<glob expression>’，例如：过滤内核为Linux的主机可以写成‘kernel:Linux’，如果同时需要正则表达式的支持，可切换成–grain-pcre参数来执行。示例：获取主机发行版本号为7.5的Python版本号。</glob></grain></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# salt -G 'osrelease:6.5' cmd.run 'python -V'<br><br>saltstack_web1group_1:    Python 2.6.6<br>saltstack_web1group_2:    Python 2.6.6<br></code></pre></td></tr></table></figure><h3 id="（4）-I-–pillar">（4）-I,–pillar</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# salt -I 'httpd:root:/data' test.ping<br><br>saltstack_web1group_1:    True<br>saltstack_web1group_2:    True<br><span class="hljs-meta">#</span><span class="bash">其中pillar属性配置文件如下：httpd:root: /data</span><br></code></pre></td></tr></table></figure><h3 id="（5）-N-–nodegroup">（5）-N,–nodegroup</h3><p><strong>根据主控端master配置文件中的分组名称进行过滤。如下所示：</strong></p><blockquote><p>/etc/salt/master</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@python ~]<span class="hljs-comment"># vim /etc/salt/master </span><br>nodegroups:                   <span class="hljs-comment">#710</span><br>  group1: <span class="hljs-string">'L@XGP，WSD'</span>             <span class="hljs-comment">#如果有多个可用逗号隔开</span><br>  group2: <span class="hljs-string">'L@XGP'</span><br>        <br>[root@python ~]<span class="hljs-comment"># service salt-master restart</span><br>Redirecting to /bin/systemctl restart salt-master.service<br><br>[root@python ~]<span class="hljs-comment"># salt -N group1 test.ping</span><br>XGP:<br>    <span class="hljs-literal">True</span><br>[root@python ~]<span class="hljs-comment"># salt -N group2 test.ping</span><br>XGP:<br>    <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="（6）-C-–compound">（6）-C,–compound</h3><p><strong>根据条件运算符not、and、or去匹配不同规则的主机信息。示例：探测SN-2020开头，并且操作系统版本为CentOS的主机连通性。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# salt -C 'E@XG* and G@os:CentOS' test.ping<br>XGP:<br>    True<br></code></pre></td></tr></table></figure><p><strong>其中，not语句不能作为第一个条件执行，不过可以通过以下方式来规避。示例：探测非SN-2023开头的主机连通性。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt -C '* and not E@^SN-2023*' test.ping</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h5 id="（7）-S-–ipcidr">（7）-S,–ipcidr</h5><p><strong>根据被控主机的IP地址或IP子网进行匹配，示例如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt -S 192.168.0.0/16 test.ping</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt -S 192.168.79.164 test.ping</span><br></code></pre></td></tr></table></figure><h1>三、saltstack常用模块及API</h1><p><strong>saltstack提供了非常丰富的功能模块，设计操作系统的基础功能、常用工具支持等。使用sys模块可以列出当前版本支持的模块。</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt '*' sys.list_modules</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    - acl<br>    - aliases<br>    - alternatives<br>    - archive<br>    - artifactory<br>    &lt;!--省略部分输出--&gt;<br></code></pre></td></tr></table></figure><p><strong>APId的原理是通过调用master client模块，实例化一个LocalClient对象，再调用cmd()方法实现的。以下是API实现test.ping的示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> salt.client<br><br>clinet = salt.client.LocalClient()<br>result  = client.cmd(<span class="hljs-string">'*'</span>, <span class="hljs-string">'test.ping'</span>)<br>print(result)<br></code></pre></td></tr></table></figure><p><strong>结果以一个标准的Python字典形式的字符串返回，可以通过eval()函数转换成Python的字典类型，方便后续的业务u逻辑处理。程序运行结果如下：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">&#123;'SN-2020-03-20':True&#125;<br></code></pre></td></tr></table></figure><h2 id="1、Archive模块">1、Archive模块</h2><p><strong>功能：实现系统层面的压缩包调用，支持gunzip、gzip、rar、tar、unrar、unzip等。</strong></p><h4 id="示例：">示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 采用gzip解压 /tmp/data.txt文件</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt 'SN-2020-03-20' archive.gzip  /tmp/data.txt</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br><br><span class="hljs-comment"># 采用tar压缩 /tmp/data.txt文件</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt 'SN-2020-03-20' archive.tar cvf /tmp/data.txt.tar /tmp/data.txt</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    - tar: Removing leading `/<span class="hljs-string">' from member names</span><br><span class="hljs-string">    - /tmp/data.txt</span><br></code></pre></td></tr></table></figure><h4 id="调用API：">调用API：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">client.cmd(<span class="hljs-string">'SN-2020-03-20'</span>,<span class="hljs-string">'archive.gzip'</span>,[<span class="hljs-string">'/tmp/data.txt'</span>])<br></code></pre></td></tr></table></figure><h2 id="2、cmd模块">2、cmd模块</h2><p><strong>实现远程的命令行调用执行（默认具备root操作权限，慎用！）</strong></p><h4 id="示例：-2">示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取所有被控主机的内存情况</span><br>salt <span class="hljs-string">'*'</span> cmd.run <span class="hljs-string">"free -m"</span><br><br><span class="hljs-comment"># 在SN-2020-03-20主机运行test.sh脚本，</span><br>salt <span class="hljs-string">'SN-2020-03-20'</span> cmd.script salt://script/test.sh<br>    <br><span class="hljs-comment"># 其中script/test.sh脚本存放在file_roots指定的目录:/srv/salt</span><br>mkdir -p /srv/salt/script<br>vim /srv/salt/script/test.sh<br><span class="hljs-comment"># 该命令会做2个动作：</span><br><span class="hljs-comment"># 1.首先同步test.sh到minion的cache目录（如：同步到</span><br><span class="hljs-comment"># /var/cache/salt/minion/files/base/script/test.sh）；</span><br><span class="hljs-comment"># 2.其次运行该脚本。</span><br></code></pre></td></tr></table></figure><h4 id="调用API：-2">调用API：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">client.cmd(<span class="hljs-string">'SN-2020-03-20'</span>,<span class="hljs-string">'cmd.run'</span>,[<span class="hljs-string">'free -m'</span>])<br></code></pre></td></tr></table></figure><h2 id="3、cp模块">3、cp模块</h2><p><strong>实现远程文件、目录的复制，以及下载URL文件等操作。</strong></p><h4 id="示例：-3">示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将指定被控主机的/etc/hosts文件复制到被控主机本地的salt的cache目录（/var/cache/salt/minion/localfiles/）</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt '*' cp.cache_local_file /etc/hosts</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    /var/cache/salt/minion/localfiles/etc/hosts<br><br><span class="hljs-comment"># 将主服务器file_roots指定位置下的目录复制到被控主机，空目录不复制</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt "SN-2020-03-20" cp.get_dir salt://ccc /tmp</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    - /tmp/ccc/ccc.txt<br><br><span class="hljs-comment"># 将主服务器file_roots指定位置下的文件复制到被控主机</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt "SN-2020-03-20" cp.get_file salt://test.sh /tmp/test.sh</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    /tmp/test.sh<br><br><span class="hljs-comment"># 下载URL内容到被控主机指定位置</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt "SN-2020-03-20" cp.get_url https://slashdot.org/ /tmp/index.html</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    /tmp/index.html<br></code></pre></td></tr></table></figure><h4 id="调用API：-3">调用API：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">client.cmd(<span class="hljs-string">'SN-2020-03-20'</span>, <span class="hljs-string">'cp.get_file, ['</span>salt://path/to/file<span class="hljs-string">' ,'</span>/minion/dest<span class="hljs-string">'])</span><br></code></pre></td></tr></table></figure><h2 id="4、cron模块">4、cron模块</h2><p><strong>实现被控主机的crontab操作。</strong></p><h4 id="示例：-4">示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看指定被控主机、root用户的crontab清单</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt "SN-2020-03-20" cron.raw_cron root</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    <span class="hljs-comment"># Lines below here are managed by Salt, do not edit</span><br>    * * * * * /usr/bin/date<br><br><span class="hljs-comment"># 为指定的被控主机、root用户添加/usr/bin/date任务作业    </span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt "SN-2020-03-20" cron.set_job root '*' '*' '*' '*' '*' /usr/bin/date</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    new<br><br><span class="hljs-comment"># 删除指定的被控主机、root用户crontab的/usr/bin/date任务作业</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt "SN-2020-03-20" cron.rm_job root /usr/bin/date</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    removed<br></code></pre></td></tr></table></figure><h4 id="调用API：-4">调用API：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">client.cmd(<span class="hljs-string">'SN-03-2020-20'</span>, <span class="hljs-string">'cron.set_job'</span>, [<span class="hljs-string">'root'</span>,<span class="hljs-string">'*'</span>,<span class="hljs-string">'*'</span>,<span class="hljs-string">'*'</span>,<span class="hljs-string">'*'</span>,<span class="hljs-string">'*'</span>,<span class="hljs-string">'/usr/bin/date'</span>])<br></code></pre></td></tr></table></figure><h2 id="5、dnsutil模块">5、dnsutil模块</h2><p><strong>实现被控主机通用DNS相关操作。</strong></p><h4 id="示例：-5">示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加指定被控主机hosts的主机配置项</span><br>salt <span class="hljs-string">'*'</span> dnsutil.hosts_append /etc/hosts <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> ad1.yk.com,ad2,yk.com<br><br><span class="hljs-comment"># 删除指定被控主机hosts的主机配置项</span><br>salt <span class="hljs-string">'*'</span> dnsutil.hosts_remove /etc/hosts ad1.yk.com<br></code></pre></td></tr></table></figure><h4 id="调用API：-5">调用API：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">client.cmd(<span class="hljs-string">'*'</span>, <span class="hljs-string">'dnsutil.hosts_append'</span>, [<span class="hljs-string">'/etc/hosts'</span>,<span class="hljs-string">'127.0.0.1'</span>,<span class="hljs-string">'ad1.yk.com'</span>])<br></code></pre></td></tr></table></figure><h2 id="6、file模块">6、file模块</h2><p><strong>被控主机文件常见的操作，包括文件读写、权限、查找、校验等。</strong></p><h4 id="示例：-6">示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 校验所有被控主机/etc/fstab文件的MD5，一致则返回True</span><br><br><span class="hljs-comment"># 修改所有别空主机文件的属组、用户权限，等价于chown test:root /tmp/test.sh</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt "SN-2020-03-20" file.chown /tmp/test.sh test root</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    <span class="hljs-literal">None</span><br><br><span class="hljs-comment"># 复制被控主机本地文件到本地的文件</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt "SN-2020-03-20" file.copy /tmp/ccc/ccc.txt /tmp/c.txt</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    <span class="hljs-literal">True</span><br><br><span class="hljs-comment"># 检查所有被控主机/etc目录是否存在，存在则返回True，检查文件是否存在使用file.file_exists方法</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt "SN-2020-03-20" file.directory_exists /etc</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    <span class="hljs-literal">True</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt "SN-2020-03-20" file.file_exists /etc/passwd</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    <span class="hljs-literal">True</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># </span><br><br><span class="hljs-comment"># 获取所有被控主机/etc/passwd的stats信息</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt "SN-2020-03-20" file.stats /etc/passwd</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    ----------<br>    atime:<br>        <span class="hljs-number">1585115927.94</span><br>    ctime:<br>        <span class="hljs-number">1572940727.67</span><br>    gid:<br>        <span class="hljs-number">0</span><br>    group:<br>        root<br>    inode:<br>        <span class="hljs-number">19172097</span><br>    mode:<br>        <span class="hljs-number">0644</span><br>    mtime:<br>        <span class="hljs-number">1572940727.67</span><br>    size:<br>        <span class="hljs-number">2349</span><br>    target:<br>        /etc/passwd<br>    type:<br>        file<br>    uid:<br>        <span class="hljs-number">0</span><br>    user:<br>        root<br><br><span class="hljs-comment"># 获取所有被控主机/etc/passwd的权限mode，如：755,644</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt "SN-2020-03-20" file.get_mode /etc/passwd</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    <span class="hljs-number">0644</span><br><br><span class="hljs-comment"># 修改所有被控主机/etc/passwd的权限mode为644</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt "SN-2020-03-20" file.set_mode /etc/passwd 644</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    <span class="hljs-number">0644</span><br><br><span class="hljs-comment"># 在所有被控主机创建目录</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt "SN-2020-03-20" file.mkdir /opt/test</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    <span class="hljs-literal">None</span><br><br><span class="hljs-comment"># 将所有被控主机/etc/httpd/httpd.conf文件的LogLevel参数warn值修改为info</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt "SN-2020-03-20" file.sed /tmp/date.log "内容" "content"</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    ----------<br>    pid:<br>        <span class="hljs-number">15581</span><br>    retcode:<br>        <span class="hljs-number">0</span><br>    stderr:<br>    stdout:<br><br><span class="hljs-comment"># 给所有被控主机的/tmp/test/test.conf文件追加内容“maxclient 100”</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt "SN-2020-03-20" file.append /tmp/date.log "追加内容"</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    Wrote <span class="hljs-number">1</span> lines to <span class="hljs-string">"/tmp/date.log"</span><br><br><span class="hljs-comment"># 删除所有被控主机的/tmp/foo文件</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt "SN-2020-03-20" file.remove /tmp/c.txt</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h4 id="调用API：-6">调用API：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">client.cmd(<span class="hljs-string">'*'</span>, <span class="hljs-string">'file.remove'</span>, [<span class="hljs-string">'/tmp/foo'</span>])<br></code></pre></td></tr></table></figure><h2 id="7、iptables模块">7、iptables模块</h2><p><strong>被控主机ilptables支持。</strong></p><h4 id="示例：-7">示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在所有被控主机追加、插入iptables规则，其中INPUT为输入链</span><br>salt <span class="hljs-string">'*'</span> iptables.append filter INPUT rule=<span class="hljs-string">'-m state --state RELATED,ESTABLISHED -j ACCEPT'</span><br><br>salt <span class="hljs-string">'*'</span> iptables.insert filter INPUT position=<span class="hljs-number">3</span> rule=<span class="hljs-string">'-m state --state RELATED,ESTABLISHED -j ACCEPT'</span><br><br><span class="hljs-comment"># 在所有被控主机删除指定链编号为3（position=3）或者指定存在的规则</span><br>salt <span class="hljs-string">'*'</span> iptables.delete filter INPUT position=<span class="hljs-number">3</span><br>salt <span class="hljs-string">'*'</span> iptables.delete filter INPUT rule=<span class="hljs-string">'-m state --state RELATED,ESTABLISHED -j ACCEPT'</span><br><br><span class="hljs-comment"># 保存所有被控主机规则到本地硬盘（/etc/sysconfig/iptables）</span><br>salt <span class="hljs-string">'*'</span> iptables.save /etc/sysconfig/iptables<br></code></pre></td></tr></table></figure><h4 id="调用API：-7">调用API：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">client.cmd(<span class="hljs-string">'SN-2020-03-20'</span>, <span class="hljs-string">'iptables.append'</span>, [<span class="hljs-string">'filter'</span>, <span class="hljs-string">'INPUT'</span>, <span class="hljs-string">'rule=\'-p tcp--sport 80 -j ACCEPT\''</span>])<br></code></pre></td></tr></table></figure><h2 id="8、network模块">8、network模块</h2><p><strong>返回被控主机网络信息。</strong></p><h4 id="示例：-8">示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在指定被控主机“SN-2020-03-20”获取dig、ping、traceroute目录域名信息</span><br>salt <span class="hljs-string">'SN-2020-03-20'</span> network.dig www.qq.com<br>salt <span class="hljs-string">'SN-2020-03-20'</span> network.ping www.qq.com<br>salt <span class="hljs-string">'SN-2020-03-20'</span> network.traceroute www.qq.com<br><br><span class="hljs-comment"># 获取指定被控主机“SN-2020-03-20”的MAC地址</span><br>salt <span class="hljs-string">'SN-2020-03-20'</span> network.hwaddr ens33<br><br><span class="hljs-comment"># 检测指定被控主机“SN-2020-03-20”是否属于10.0.0.0/16子网范围，属于则返回True</span><br>salt <span class="hljs-string">'SN-2020-03-20'</span> network.in_subnet <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">16</span><br><br><span class="hljs-comment"># 获取指定被控主机“SN-2020-03-20”的网卡配置信息</span><br>salt <span class="hljs-string">'SN-2020-03-20'</span> network.interfaces<br><br><span class="hljs-comment"># 获取指定被控主机“SN-2020-03-20”的IP地址配置信息</span><br>salt <span class="hljs-string">'SN-2020-03-20'</span> network.ip_addrs<br><br><span class="hljs-comment"># 获取指定被控主机“SN-2020-03-20”的子网信息</span><br>salt <span class="hljs-string">'SN-2020-03-20'</span> network.subnets<br></code></pre></td></tr></table></figure><h4 id="调用API：-8">调用API：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">client.cmd(<span class="hljs-string">'SN-2020-03-20'</span>,<span class="hljs-string">'network.subnets'</span>)<br></code></pre></td></tr></table></figure><h2 id="9、pkg包管理模块">9、pkg包管理模块</h2><p><strong>被控主机程序包管理，如yum、apt-get等。</strong></p><h4 id="示例：-9">示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 为所有被控主机安装PHP环境，根据不同系统发行版调用不同的安装工具进行部署，如Redhat平台的yum，等价于yum -y install php</span><br>salt <span class="hljs-string">'*'</span> pkg.install php<br><br><span class="hljs-comment"># 卸载所有被控主机的PHP环境</span><br>salt <span class="hljs-string">'*'</span> pkg.remove php<br><br><span class="hljs-comment"># 升级所有被控主机的软件包</span><br>salt <span class="hljs-string">'*'</span> pkg.upgrade<br></code></pre></td></tr></table></figure><h4 id="调用API：-9">调用API：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pypthon">client.cm(&#39;SN-2020-03-20&#39;,&#39;pgk.remove&#39;, [&#39;php&#39;])<br></code></pre></td></tr></table></figure><h2 id="10、Service服务模块">10、Service服务模块</h2><p><strong>被控主机程序包的服务管理。</strong></p><h4 id="示例：-10">示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 开启（enable）、禁用（disable）nginx开机自启动服务</span><br>salt <span class="hljs-string">'*'</span> service.enable nginx<br>salt <span class="hljs-string">'*'</span> service.disable nginx<br><br><span class="hljs-comment"># 针对nginx服务的reload、restart、start、stop、status操作</span><br>salt <span class="hljs-string">'*'</span> service.reload nginx<br>salt <span class="hljs-string">'*'</span> service.restart nginx<br>salt <span class="hljs-string">'*'</span> service.start nginx<br>salt <span class="hljs-string">'*'</span> service.stop nginx<br>salt <span class="hljs-string">'*'</span> service.staus nginx<br></code></pre></td></tr></table></figure><h4 id="API调用：">API调用：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">client.cmd(<span class="hljs-string">'SN-2020-03-20'</span>, <span class="hljs-string">'service.stop'</span>, [<span class="hljs-string">'nginx'</span>])<br></code></pre></td></tr></table></figure><h2 id="11、其他模块">11、其他模块</h2><p><strong>通过上面介绍的10个常用的模块，基本上已经覆盖了日常的运维操作。saltstack还提供了其他模块，如下所示：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tex">user：系统用户模块<br>group：系统组模块<br>partition：系统分区模块<br>puppet：puppet管理模块<br>system：系统重启、关机模块<br>timezone：时区管理模块<br>nginx：NGINX管理模块<br>mount：文件系统挂载模块<br>……<br></code></pre></td></tr></table></figure><p><strong>更多的模块介绍请查阅官网。</strong></p><h1>四、grains组件</h1><p><strong>grains是saltstack最重要的组件之一，grains的作用是手机被控主机的基本信息，这些信息通常都是一些静态类的数据，包括CPU、内核、操作系统、虚拟化等，在服务器端可以根据这些信息进行灵活定制，管理员可以利用这些信息对不同业务进行个性化配置。官网提供的用来区分不同操作系统的示例如下（采用jinja模板）：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;% <span class="hljs-keyword">if</span> grains[<span class="hljs-string">'os'</span>] == <span class="hljs-string">'Ubuntu'</span> %&#125;<br>host: &#123;&#123; grains[<span class="hljs-string">'host'</span>] &#125;&#125;<br>&#123;% <span class="hljs-keyword">elif</span> grains[<span class="hljs-string">'os'</span>] == <span class="hljs-string">'CentOSu'</span> %&#125;<br>host: &#123;&#123; grains[<span class="hljs-string">'fqdn'</span>] &#125;&#125;<br>&#123;% endif %&#125;<br></code></pre></td></tr></table></figure><p><strong>示例中CentOS发行版主机将被“host: {{ grains['fqdn'] }}”匹配，同时，命令行的匹配操作系统发行版本为CentOS的被控端可以通过-G参数来过滤，如salt -G ‘os:CentOS’ test.ping。</strong></p><h2 id="1、grains常用操作命令">1、grains常用操作命令</h2><p><strong>匹配内核版本为3.10.0-957.el7.x86_64的主机：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt -G 'kernelrelease:3.10.0-957.el7.x86_64' cmd.run 'uname -a'</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    Linux <span class="hljs-number">192.168</span><span class="hljs-number">.79</span><span class="hljs-number">.146</span> <span class="hljs-number">3.10</span><span class="hljs-number">.0</span><span class="hljs-number">-957.</span>el7.x86_64 <span class="hljs-comment">#1 SMP Thu Nov 8 23:39:32 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br></code></pre></td></tr></table></figure><p><strong>获取所有主机的grains项信息：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt 'SN-2020-03-20' grains.ls</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    - SSDs<br>    - biosreleasedate<br>    - biosversion<br>    - cpu_flags<br>    - cpu_model<br>    - cpuarch<br>    - domain<br>    - fqdn<br>    - fqdn_ip4<br>    - fqdn_ip6<br>    - gpus<br>    - host<br>    - hwaddr_interfaces<br>    - id<br>    - init<br>    - ip4_interfaces<br>    - ip6_interfaces<br>    - ip_interfaces<br>    - ipv4<br>    - ipv6<br>    - kernel<br>    - kernelrelease<br>    - locale_info<br>    - localhost<br>    - lsb_distrib_id<br>    - machine_id<br>    - manufacturer<br>    - master<br>    - mdadm<br>    - mem_total<br>    - nodename<br>    - num_cpus<br>    - num_gpus<br>    - os<br>    - os_family<br>    - osarch<br>    - oscodename<br>    - osfinger<br>    - osfullname<br>    - osmajorrelease<br>    - osrelease<br>    - osrelease_info<br>    - path<br>    - productname<br>    - ps<br>    - pythonexecutable<br>    - pythonpath<br>    - pythonversion<br>    - saltpath<br>    - saltversion<br>    - saltversioninfo<br>    - selinux<br>    - serialnumber<br>    - server_id<br>    - shell<br>    - systemd<br>    - virtual<br>    - zmqversion<br></code></pre></td></tr></table></figure><p><strong>当然，也可以获取主机单项grains数据，如获取操作系统发行版本，执行命令：<code>salt 'SN-2020-03-20' grains.item os</code>，结果如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt 'SN-2020-03-20' grains.item os</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    ----------<br>    os:<br>        CentOS<br></code></pre></td></tr></table></figure><p><strong>如果要获取主机id为“SN-2020-03-20”的所有grains键及值信息，执行以下命令：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">salt <span class="hljs-string">'SN-2020-03-20'</span> grains.items<br></code></pre></td></tr></table></figure><h2 id="2、定义grains数据">2、定义grains数据</h2><p><strong>定义grains数据的方法有两种，其中一种为在被控主机定制配置文件，另一种是通过主</strong><br><strong>控端扩展模块API实现，区别是模块更灵活。可以通过Python编程动态定义，而配置文件</strong><br><strong>只适合相对固定的键与值，下面分别举例说明。</strong></p><h3 id="（1）被控端主机定制grains数据">（1）被控端主机定制grains数据</h3><p><strong>SSH登录一台被控机，如：SN-2020-03-20，配置文件定制的路径为/etc/salt/minion.d/hostinfo.conf，具体操作如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@192 ~]# vim /etc/salt/minion.d/hostinfo.conf<br>grains:<br>  roles:<br>    - webserver<br>    - redis<br>  deployment: datacenter4<br>  cabinet: 13<br>[root@192 ~]# service salt-minion restart<br></code></pre></td></tr></table></figure><p><strong>重启被控主机salt-minion服务，使配置生效。验证结果在主控机运行：<code>salt 'SN-2020-03-20' grains.item roles deployment cabinet</code>，观察配置的键和值，如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt 'SN-2020-03-20' grains.item roles deployment cabinet</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    ----------<br>    cabinet:<br>        <span class="hljs-number">13</span><br>    deployment:<br>        datacenter4<br>    roles:<br>        - webserver<br>        - redis<br></code></pre></td></tr></table></figure><h3 id="（2）主控端主机定制grains数据">（2）主控端主机定制grains数据</h3><h4 id="实现步骤：">实现步骤：</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. 首先在主控端编写Python代码，<br>2. 然后将Python文件同步到被控主机，<br>3. 最后刷新生效。<br></code></pre></td></tr></table></figure><p><strong>在主控端base目录（默认的base配置在/srv/salt）下生成_grains目录，编写Python代码，事项获取主控机系统允许最大打开文件数的grains数据。</strong></p><blockquote><p><strong>/srv/salt/_grains/sysprocess.py</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os,sys,commands<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grains_openfile</span><span class="hljs-params">()</span>:</span><br>    grains = &#123;&#125;<br>    _open_file = <span class="hljs-number">65536</span><br>    getulimit = <span class="hljs-number">0</span> <br><br>    <span class="hljs-keyword">try</span>:<br>        getulimit = commands.getstatusoutout(<span class="hljs-string">'source /etc/profile;ulimit -n'</span>)<br>true<span class="hljs-keyword">if</span> getulimit[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>:<br>        _open_file = int(getulimit[<span class="hljs-number">1</span>])<br><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">pass</span><br>    <br>    grains[<span class="hljs-string">'max_open_file'</span>] = _open_file<br>    <span class="hljs-keyword">return</span> grains<br></code></pre></td></tr></table></figure><h4 id="上面代码说明：">上面代码说明：</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. grains_open_file()：定义一个获取最大打开文件数的函数，函数名称没有要求，符合Python的函数命名规则即可；<br>2. grains&#123;&#125;：初始化一个grains字典，变量名一定要用grains，以便SaltStack识别；<br>3. grains['max_open_file']=_open_file：将获取的“ulimit -n”的结果赋值给grains['max_open_file']，其中“max_open_file”就是grains的项，“_open_file”就是grains的值。<br></code></pre></td></tr></table></figure><p><strong>最后同步模块到指定被控端主机，并刷新生效。因为grains比较适合采集静态类数据，比如：硬件、内核信息等。当有动态类的功能需求是，需要执行刷新，具体操作如下：</strong></p><h4 id="1）-同步模块">1） 同步模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt 'SN-2020-03-20' saltutil.sync_all</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    ----------<br>    beacons:<br>    grains:<br>        - grains.sysprocess<br>    modules:<br>    output:<br>    renderers:<br>    returners:<br>    sdb:<br>    states:<br>    utils:<br></code></pre></td></tr></table></figure><p><strong>文件被同步到控端主机的minion cache目录下，如下所示：</strong></p><blockquote><p><strong>/var/cache/salt/minion/extmods/grains/为扩展模块文件最终存放位置，刷新模块后将在同路径下生成字节码pyc；</strong></p><p><strong>/var/cache/salt/minion/files/base/_grains/为临时存放位置。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># ll /var/cache/salt/minion/extmods/grains/</span><br>总用量 <span class="hljs-number">8</span><br>-rw-------. <span class="hljs-number">1</span> root root <span class="hljs-number">362</span> <span class="hljs-number">3</span>月  <span class="hljs-number">27</span> <span class="hljs-number">14</span>:<span class="hljs-number">22</span> sysprocess.py<br>    <br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># ll /var/cache/salt/minion/files/base/_grains/</span><br>总用量 <span class="hljs-number">4</span><br>-rw-------. <span class="hljs-number">1</span> root root <span class="hljs-number">362</span> <span class="hljs-number">3</span>月  <span class="hljs-number">27</span> <span class="hljs-number">14</span>:<span class="hljs-number">22</span> sysprocess.py<br></code></pre></td></tr></table></figure><h4 id="2）刷新模块">2）刷新模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt 'SN-2020-03-20' sys.reload_modules</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>在被控端主机的/var/cache/salt/minion/extmods/grains/位置多了一个编译后的字节码文件sysprocess.pyc。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># ll /var/cache/salt/minion/extmods/grains/</span><br>总用量 <span class="hljs-number">8</span><br>-rw-------. <span class="hljs-number">1</span> root root <span class="hljs-number">362</span> <span class="hljs-number">3</span>月  <span class="hljs-number">27</span> <span class="hljs-number">14</span>:<span class="hljs-number">22</span> sysprocess.py<br>-rw-------. <span class="hljs-number">1</span> root root <span class="hljs-number">646</span> <span class="hljs-number">3</span>月  <span class="hljs-number">27</span> <span class="hljs-number">14</span>:<span class="hljs-number">22</span> sysprocess.pyc<br>    <br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># ll /var/cache/salt/minion/files/base/_grains/</span><br>总用量 <span class="hljs-number">4</span><br>-rw-------. <span class="hljs-number">1</span> root root <span class="hljs-number">362</span> <span class="hljs-number">3</span>月  <span class="hljs-number">27</span> <span class="hljs-number">14</span>:<span class="hljs-number">22</span> sysprocess.py<br></code></pre></td></tr></table></figure><h4 id="3）校验数据">3）校验数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt 'SN-2020-03-20' grains.item max_open_file</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    ----------<br>    max_open_file:<br>        <span class="hljs-number">65536</span><br></code></pre></td></tr></table></figure><h1>五、pillar组件</h1><p><strong>pillar也是Saltstack最重要的组件之一其作用是定义与被控主机相关的任何数据，定义好的数据可以被其他组件使用，如模板、state,、API等。在pillar中定义的数据与不同业务特性的被控主机相关联，这样不同被控主机只能看到自己匹配的数据，因此pillar安全性很高，适用于一些比较敏感的数据，这也是区别于grains最关键的一点。如定义不同业务组主机的用户id、组id、读写权限、程序包等信息。定义的规范是采用Python字典形式，即键/值。最上层的键一般为主机的id或组名称。下面详细描述如何进行pillar的定义和使用。</strong></p><h2 id="1、pillar的定义">1、pillar的定义</h2><h3 id="1）主配置文件定义">1）主配置文件定义</h3><p><strong>Saltstack默认将主控端配置文件中的所有数据都定义到pillar中，而且对所有被控主机开放，可通过修改<code>/etc/salt/master</code>配置中的<code>pillar opts:</code> Ture或False来定义是否开启或禁用这项功能，修改后执行<code>salt '*' pillar.data</code>来观察效果。以主机“SN2013-08-022”为例，执行salt ‘SN2013-08-022’ pillar.data。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt 'SN-2020-03-20' pillar.data</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    ----------<br>    appname:<br>        website<br>    flow:<br>        ----------<br>        maxconn:<br>            <span class="hljs-number">30000</span><br>        maxmem:<br>            <span class="hljs-number">6</span>G<br></code></pre></td></tr></table></figure><h3 id="2）SLS文件定义">2）SLS文件定义</h3><p><strong>pillar支持在sls文件中定义数据，格式须符合YAM L规范，与Saltstack的state组件十分相似，新人容易将两者混淆，两者文件的配置格式、入口文件top.sls都是一致的。下面详细介绍pillar使用sls定义的配置过程。</strong></p><h4 id="1-定义pillar的主目录">1. 定义pillar的主目录</h4><p><strong>修改主配置文件<code>/etc/salt/master</code>的pillar_roots参数，定义pillar的主目录，格式如下：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">pillar_roots:<br>  base:<br>    - /srv/pillar<br></code></pre></td></tr></table></figure><p><strong>同时创建pillar目录，执行命令：<code>install -d /srv/pillar</code>。</strong></p><h4 id="2-定义入口文件top-sls">2. 定义入口文件top.sls</h4><p><strong>入口文件的作用一般是定义pillar的数据覆盖被控主机的有效范围，“*”代表任意主机，其中包括了一个data.sls文件，具体内容如下：</strong></p><blockquote><p>/srv/pillar/top.sls</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">base:<br>  '*':<br>    - data<br></code></pre></td></tr></table></figure><blockquote><p>/srv/pillar/data.sls</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini">appname: website<br>flow:<br>  maxconn: 30000<br>  maxmem: 6G<br></code></pre></td></tr></table></figure><h4 id="3-校验pillar">3. 校验pillar</h4><p><strong>通过查看&quot; SN2020-03-20”主机的pillar数据，可以看到多出了data.sls数据项，原因是我们定义top.sls时使用‘*’覆盖了所有主机，这样当查看’‘ SN2020-03-20”的pillar数据时可以看到我们定义的数据。</strong></p><p><strong>如果结果不符合预期，可以尝试刷新被控主机pillar数据，运行salt ’*’ saltutil.refresh_pillar即可。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt '*' saltutil.refresh_pillar</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    <span class="hljs-literal">True</span><br><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt 'SN-2020-03-20' pillar.data appname flow</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    ----------<br>    appname:<br>        website<br>    flow:<br>        ----------<br>        maxconn:<br>            <span class="hljs-number">30000</span><br>        maxmem:<br>            <span class="hljs-number">6</span>G<br></code></pre></td></tr></table></figure><h2 id="2、pillar的使用">2、pillar的使用</h2><p><strong>完成pillar配置后，接下来介绍使用方法。</strong></p><p><strong>我们可以在state、模块文件中引用，模块格式为“”，例如：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">&#123;&#123; pillar['appname'] &#125;&#125; #一级字典<br>&#123;&#123; pillar['flow']['maxconn'] &#125;&#125; #二级字典<br></code></pre></td></tr></table></figure><p><strong>PythonAPI格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pypthon">pillar[&#39;flow&#39;][&#39;maxconn&#39;]<br>pillar.get(&#39;flow:appname&#39;, &#123;&#125;)<br></code></pre></td></tr></table></figure><h3 id="1、操作主机">1、操作主机</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt -I 'appname:website' test.ping</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="2、结合grains处理数据的差异性">2、结合grains处理数据的差异性</h3><p><strong>首先通过结合grains的id信息来区分不同id的maxcpu的值，其次进行引用观察匹配的信息，将data.sls修改成如下形式.其中，“if … else…endfi”为jinja2的模板语法，更多信息请访问Jinja2官网语法介绍，网址为http://jinja.pocoo.</strong><br><strong>org/docs/templates/。</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini">appname: website<br>flow:<br>  maxconn: 30000<br>  maxmem: 6G<br>  &#123;% if grains['id'] == 'SN-2020-03-20' %&#125;<br>  maxcpu: 8<br>  &#123;% else %&#125;<br>  maxcpu: 4<br>  &#123;% endif %&#125;<br></code></pre></td></tr></table></figure><p><strong>通过查看被控主机的pillar数据，可以看到maxcpu的差异，如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt 'SN-2020-03-20' pillar.data flow</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    ----------<br>    flow:<br>        ----------<br>        maxconn:<br>            <span class="hljs-number">30000</span><br>        maxcpu:<br>            <span class="hljs-number">8</span><br>        maxmem:<br>            <span class="hljs-number">6</span>G<br><br>            [root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt 'SN-2020-03-21' pillar.data flow</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    ----------<br>    flow:<br>        ----------<br>        maxconn:<br>            <span class="hljs-number">30000</span><br>        maxcpu:<br>            <span class="hljs-number">4</span><br>        maxmem:<br>            <span class="hljs-number">6</span>G<br></code></pre></td></tr></table></figure><h1>六、state介绍</h1><p><strong>state是Saltstack最核心的功能。通过预先定制好的sls (salt state file)文件对被控主机进行状态管理，支持包括程序包(pkg)、文件(file)、网络配置(network)、系统服务(service)，系统用户(user)等，更多状态对象见http://docs.sai <a href="http://tstack.com/ref/states/all/index.html%E3%80%82" target="_blank" rel="noopener">tstack.com/ref/states/all/index.html。</a></strong></p><h2 id="1、state的定义">1、state的定义</h2><p><strong>state的定义是通过sls文件进行描述的，支持YAML语法，定义的规则如下：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-formula">$ID:</span><br><span class="hljs-formula">  $</span>State:<br>    - <span class="hljs-formula">$state: states</span><br></code></pre></td></tr></table></figure><p><strong>其中：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-formula">$ID：定义state的名称，通常采用与描述的对象保持一致的方法，如apache, nginx等;</span><br><span class="hljs-formula">$</span>State：须管理对象的类型<br><span class="hljs-formula">$state:states：定制对象的状态。</span><br></code></pre></td></tr></table></figure><p><strong>官网提供的示例如下：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apache:</span><br>  <span class="hljs-attr">pkg:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">installed</span><br>  <span class="hljs-attr">service:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">running</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">require</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">pkg:</span> <span class="hljs-string">apache</span><br></code></pre></td></tr></table></figure><p><strong>上述代码检查apache软件包是否已安装状态，如果未安装，将通过yum或apt进行安装；检查服务apache进程是否处于运行状态。下面详细进行说明:</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">第1行用于定义state的名称，此示例为apache，当然也可以取其他相关的名称。<br><br>第2行和第4行表示state声明开始，使用了pkg和service这两个状态对象。pkg使用系统本地的软件包管理器(yum或apt)管理将要安装的软件，service管理系统守护进程。<br><br>第3行和第5行是要执行的方法。这些方法定义了pache软件包和服务目标状态，此示例要求软件包应当处于已安装状态，服务必须运行，如未安装将会被安装并启动。<br><br>第6行是关键字require，它确保了apache服务只有在成功安装软件包后才会启动。<br></code></pre></td></tr></table></figure><h2 id="2、state的使用">2、state的使用</h2><p><strong>state的入口文件与pillar一样，文件名称都是top.sls，但state要求sls文件必须存放在saltstack base定义的目录下，默认为/srv/salt。state描述配置.sls支持jinjia模板、grains、pillar引用等。在state的逻辑层次定义完成后，再通过salt ‘*’ state.highstate执行生效。</strong></p><p><strong>下面结合grains与pillar，实现一个根据不同操作系统类型部署apache环境的任务。</strong></p><h3 id="（1）定义pillar">（1）定义pillar</h3><blockquote><p><strong>/srv/pillar/top.sls</strong></p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">base:</span><br>  <span class="hljs-string">'*'</span><span class="hljs-string">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">apache</span><br></code></pre></td></tr></table></figure><p><strong>在top.sls中引用二级配置有两种方式：一种是直接引用，如直接引用apache.sls；另一种是创建apache目录，再引用目录中的init.sls文件，两者的效果是一样的。为了规范起见，我们采用二级配置形式。同理，state的top.sls也采用如此方式。</strong></p><h4 id="1）创建apache目录：">1）创建apache目录：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /srv/pillar/apache<br></code></pre></td></tr></table></figure><h4 id="2）在apache目录创建init-sls">2）在apache目录创建init.sls</h4><p><strong>内容如下：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">pkgs:</span><br>  <span class="hljs-string">&#123;%</span> <span class="hljs-string">if</span> <span class="hljs-string">grains['os_family']</span> <span class="hljs-string">==</span> <span class="hljs-string">'Debian'</span> <span class="hljs-string">%&#125;</span><br>true<span class="hljs-attr">apache:</span> <span class="hljs-string">apache2</span><br>  <span class="hljs-string">&#123;%</span> <span class="hljs-string">elif</span> <span class="hljs-string">grains['os_family']</span> <span class="hljs-string">==</span> <span class="hljs-string">'RedHat'</span> <span class="hljs-string">%&#125;</span><br>true<span class="hljs-attr">apache:</span> <span class="hljs-string">httpd</span><br>  <span class="hljs-string">&#123;%</span> <span class="hljs-string">elif</span> <span class="hljs-string">grains['os']</span> <span class="hljs-string">==</span> <span class="hljs-string">'Arch'</span> <span class="hljs-string">%&#125;</span><br>true<span class="hljs-attr">apache:</span> <span class="hljs-string">apache</span><br>  <span class="hljs-string">&#123;%</span> <span class="hljs-string">endif</span> <span class="hljs-string">%&#125;</span><br></code></pre></td></tr></table></figure><h4 id="3）测试pillar数据">3）测试pillar数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt 'SN-2020-03-20' pillar.data pkgs</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>    ----------<br>    pkgs:<br>        ----------<br>        apache:<br>            httpd<br></code></pre></td></tr></table></figure><h3 id="（2）定义state">（2）定义state</h3><blockquote><p><strong>/srv/salt/top.sls</strong></p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">base:</span><br>  <span class="hljs-string">'*'</span><span class="hljs-string">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">apache</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>/srv/salt/apache/init.sls</strong></p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apache:</span><br>  <span class="hljs-attr">pkg:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">installed</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#123;&#123;</span> <span class="hljs-string">pillar['pkgs']['apache']</span> <span class="hljs-string">&#125;&#125;</span><br>  <span class="hljs-string">service：</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">running</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#123;&#123;</span> <span class="hljs-string">pillar['pkgs']['apache']</span> <span class="hljs-string">&#125;&#125;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">require:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">pgk:</span> <span class="hljs-string">&#123;&#123;</span> <span class="hljs-string">pillar['pkgs']['apache']</span> <span class="hljs-string">&#125;&#125;</span><br></code></pre></td></tr></table></figure><p><strong>在配置中，{{ pillar\['pkgs']['apache'] }}将引用匹配到操作系统发行版对应的pillar数据，我的环境为CentOS，故将匹配为httpd，检查目标主机是否已经安装，没有则进行安装( yum -y install httpd)。同时检查apache服务是否已经启动，没有则启动(/etc/init.d/httpd start)。</strong></p><h3 id="（3）执行state">（3）执行state</h3><p><strong>执行state及返回信息如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># salt 'SN-2020-03-20' state.highstate</span><br>SN<span class="hljs-number">-2020</span><span class="hljs-number">-03</span><span class="hljs-number">-20</span>:<br>----------<br>          ID: apache<br>    Function: pkg.installed<br>        Name: httpd<br>      Result: <span class="hljs-literal">True</span><br>     Comment: The following packages were installed/updated: httpd<br>     Started: <span class="hljs-number">17</span>:<span class="hljs-number">24</span>:<span class="hljs-number">45.296375</span><br>    Duration: <span class="hljs-number">38108.261</span> ms<br>     Changes:   <br>              ----------<br>              httpd:<br>                  ----------<br>                  new:<br>                      <span class="hljs-number">2.4</span><span class="hljs-number">.6</span><span class="hljs-number">-90.</span>el7.centos<br>                  old:<br>----------<br>          ID: apache<br>    Function: service.running<br>        Name: httpd<br>      Result: <span class="hljs-literal">False</span><br>     Comment: The following requisites were <span class="hljs-keyword">not</span> found:<br>                                 require:<br>                                     pgk: httpd<br>     Started: <br>    Duration: <br>     Changes:   <br><br>Summary<br>------------<br>Succeeded: <span class="hljs-number">1</span> (changed=<span class="hljs-number">1</span>)<br>Failed:    <span class="hljs-number">1</span><br>------------<br>Total states run:     <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>可以看出，结果返回两种对象类型结果，分别为pkg与service，执行的结果是自动部署apache 2.4.6-90环境，但是启动apache服务失败，因为“<code>/etc/init.d/httpd start</code>”无法执行，只能手动启动了。</strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python中Ansible模块的Playbook理解</title>
      <link href="/posts/1331.html"/>
      <url>/posts/1331.html</url>
      
        <content type="html"><![CDATA[<h1>Playbook</h1><p><strong>在上一节中，我们详细介绍了Ansible提供的一些常用模块。可以看到，Ansible中的每个模块专注于某一方面的功能。虽然每个模块实现的功能都比较简单，但是，将各个模块组合起来就可以实现比较复杂的功能。在Ansible中，将各个模块组合起来的文件是一个YAML格式的配置文件。这个配置文件，在Ansible中称为Playbook。</strong></p><p><strong>在这一节中，我们将循序渐进地介绍Ansible中的Playbook，我们将首先介绍Playbook的定义，然后介绍如何使用Playbook完成远程服务器部署，之后详细介绍Playbook的基本语法，使用Playbook的基本讲法就能够完成大部分的部署任务。</strong></p><p><strong>在这一节中，找们将介绍如何使用Playbook的基本语法完成nginx与MongoDB的部署，最后，我们介绍了部分Playbook的高级语法。</strong></p><h2 id="1、Playbook的定义"><strong>1、Playbook的定义</strong></h2><p><strong>Playbook不同于其他使用单个模块操作远程服务器，Playbook的功能更加强大。如果只使用Playbook的基本功能，那么，Playbook是一个非常简单的配、管理和部署系统。此外，Playbook也可以实现各种高级功能，如指定任务的执行顺序，委派其他主机来执行某一个任务，与监控服务器和负载均衡组件进行交互等。</strong></p><p><strong>有一个非常恰当的比喻,，Ansible中的模块类似于Linux下的命令，Ansible中的Playbook类似于Linux下的Shell脚本文件。Shell脚本文件将各个Linux命令组合起来，以此实现复杂的功能，Playbook将各个模块组合起来也可以实现复杂的部署功能。在shell脚本中，除了调用Linux命令以外，还有一些基本的语法，如变量定义、if语句、for循环等。在Playbook中，一方面通过YAML格式进行定义提高Playbook的可读性、可维护性，降低工程师的学习负担；另一方面，Ansible提供了若干可以应用在Playbook中的选项，以便工程师实现更加高级的功能。</strong></p><p><strong>一个Playbook可以包含一到多个Play，每一个Play是一个完整的部署任务。在Play中，我们需要指定对哪些远程服务器执行操作，以及对这些远程服务器执行哪些操作。</strong></p><p><strong>下面是一个名为first_playbook.yml的Playbook。在这个Playbook中，我们定义了两个Play，前者用来在数据库服务器上部署MongoDB，后者用来在web服务器上部署“应用”。这里只是为了对Playbook进行演示，并没有真的部署应用。</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">[root@python</span> <span class="hljs-string">~]#</span> <span class="hljs-string">vim</span> <span class="hljs-string">first_playbook.yml</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span> <span class="hljs-string">dbservers</span><br>  <span class="hljs-attr">become:</span> <span class="hljs-literal">yes</span><br>  <span class="hljs-attr">become_method:</span> <span class="hljs-string">sudo</span><br>  <span class="hljs-attr">tasks:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">install</span> <span class="hljs-string">mongodb</span><br>    <span class="hljs-attr">yum:</span> <span class="hljs-string">name=mongodb-server</span> <span class="hljs-string">state=present</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span> <span class="hljs-string">webservers</span><br>  <span class="hljs-attr">tasks:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">copy</span> <span class="hljs-string">file</span><br>    <span class="hljs-attr">copy:</span> <span class="hljs-string">src=/tmp/data.txt</span> <span class="hljs-string">dest=/tmp/data.txt</span><br>    <br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">change</span> <span class="hljs-string">mode</span><br>    <span class="hljs-attr">file:</span> <span class="hljs-string">dest=/tmp/data.txt</span> <span class="hljs-string">mode=655</span> <span class="hljs-string">owner=root</span> <span class="hljs-string">group=root</span><br></code></pre></td></tr></table></figure><p><strong>这个Playbook中包含了两个Play。一个Playbook可以包含一到多个Play，所以即使Playbook中值包含一个Play，也需要使用列表的形式进行定义。在YAML语法中，“- hosts”前面的“-”表示定义列表。</strong></p><p><strong>在Ansible中，一个Play必须包含以下两项：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. hosts：需要对哪些远程服务器执行操作<br>2. tasks：需要在这些服务器上执行的任务列表<br></code></pre></td></tr></table></figure><p><strong>例如，对web服务器进行部署时，我们仅仅使用了hosts和tasks两个选项。前者表示对哪些服务器执行操作，后者表示对服务器执行哪些操作。在部署数据库服务器时需要安装软件，因此使用了become与become_method两个选项，用来表示使用管理员的身份去安装MongoDB数据库。</strong></p><p><strong>一个Play可以包含一到多个task，因此task也必须以YAML的列表形式进行定义。可以看到，在这个例子中，对数据库服务器进行操作时仅包含了一个task，对web服务器进行部署时包含了两个task。</strong></p><p><strong>在Ansible中，task有两种定义形式：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. action：module options<br>2. module：options<br></code></pre></td></tr></table></figure><p><strong>前一种形式是Ansible的旧版本语法，第2种形式是新版本的语法，直接使用模块的名称作为键，使用模块的参数作为值。如下所示：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">install</span> <span class="hljs-string">httpd</span><br>  <span class="hljs-attr">yum:</span> <span class="hljs-string">name=httpd</span> <span class="hljs-string">update_cache=yes</span> <span class="hljs-string">state=present</span><br></code></pre></td></tr></table></figure><p><strong>在安装Apache的例子中，“name=httpd update_cache=yes state=present”是一个完整的字符串，而不是一个字典。只是字符串的值是一个“key=value”形式的参数。</strong></p><p><strong>在参数较多时，为了增加Playbook的可读性，我们也可以像下面这样定义一个task：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">install</span> <span class="hljs-string">httpd</span><br>  <span class="hljs-attr">yum:</span> <span class="hljs-string">&gt;</span><br>    <span class="hljs-string">name=httpd</span><br>    <span class="hljs-string">update_cache=yes</span><br>    <span class="hljs-string">state=present</span><br></code></pre></td></tr></table></figure><p><strong>在Ansible中，当参数较长时，除了使用“&gt;”进行折叠换行以外，也可以使用缩进字块的形式：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">install</span> <span class="hljs-string">httpd</span><br>  <span class="hljs-attr">yum:</span> <br>    <span class="hljs-attr">name:</span> <span class="hljs-string">httpd</span><br>    <span class="hljs-attr">update_cache:</span> <span class="hljs-literal">yes</span><br>    <span class="hljs-attr">state:</span> <span class="hljs-string">present</span><br></code></pre></td></tr></table></figure><p><strong>虽然从字面来看，这两种指定参数的方式相差不大。但是，从YAML的语法来说，这是完全不同的两个方法。前者是一个比较长的字符串，后者是一个字典。</strong></p><p><strong>task的定义中，name是可选的。所以，像下面这样定义task也是完全合法的：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">yum:</span> <span class="hljs-string">name=httpd</span> <span class="hljs-string">update_cache=yes</span> <span class="hljs-string">state=present</span><br></code></pre></td></tr></table></figure><p><strong>name的作用在于，执行Playbook时作为注释进行显示，以便使用者知道当前执行到哪一步。因此，在定义task时，一般都会定义name字段。</strong></p><p><strong>在实际工作中，虽然一个Playbook可以包含多个Play，但是为了Playbook的可读性和可维护性，我们一般只会在Playbook中编写一个Play。例如，对于这里的例子，我们可以将first_playbook.yml这个Playbook拆分成两个Playbook，分别名为db.yml与web.yml。其中，db.yml文件包含了与数据库服务器相关的部署任务，web.yml文件包含了与web服务器相关的部署任务。</strong></p><p><strong>当我们需要部署数据库服务器和web服务器时，可以先执行db.yml文件，再执行web.yml文件。除此之外，Ansible还提供了一种便捷方式来处理这种情况。例如，我们可以编写一个名为all.yml的Playbook，它的内容如下：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">include:</span> <span class="hljs-string">db.yml</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">include:</span> <span class="hljs-string">web.yml</span><br></code></pre></td></tr></table></figure><p><strong>include选项是Ansible提供的，用于在一个Playbook中导入其他Playbook。在Ansible中，只需要使用include选项导入其他Playbook文件，执行这个Playbook时，被导入的Playbook便会依次执行。</strong></p><p><strong>上面详细介绍了Ansible的Playbook定义，这个Playbook定义虽然比较简单，但是，是一个比较完整的Playbook例子。在实际工作中使用的Playbook也不会比这个Playbook复杂很多。</strong></p><p><strong>我们接下来将介绍如何使用ansible-playbook命令执行Playbook，然后再介绍Playbook的其他语法。</strong></p><h2 id="2、ansible拆分playbook-yml">2、ansible拆分playbook.yml</h2><h4 id="查看一下所需文件是否正确">查看一下所需文件是否正确</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# cat hosts <br>127.0.0.1<br>[webservers]<br>192.168.1.60<br>[dbservers]<br>192.168.1.80<br>[common:children]<br>dbservers<br>webservers<br>[root@python ~]# cat /etc/ansible/ansible.cfg <br>[defaults]<br>remote_user = root<br>remote_port = 22<br>inventory = /root/hosts<br></code></pre></td></tr></table></figure><h3 id="拆分playbook-yml">拆分playbook.yml</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# cat db.yml <br>---<br>- hosts: dbservers<br>  become: yes<br>  become_method: sudo<br>  tasks:<br>  - name: install mongodb<br>    yum: name=mongodb-server state=present  #mongodb-server 可欢成其他服务如（git）<br>[root@python ~]# cat web.yml <br>---<br>- hosts: webservers<br>  tasks:<br>  - name: copy file<br>    copy: src=/tmp/data.txt dest=/opt/data.txt <br>  - name: change mode<br>    file: dest=/opt/data.txt mode=655 owner=root group=root<br>[root@python ~]# cat all.yml <br>---<br>- include: db.yml<br>- include: web.yml<br>[root@python ~]# touch /tmp/data.txt<br>[root@python ~]# touch /opt/data.txt<br></code></pre></td></tr></table></figure><h2 id="3、使用Ansible-playbook执行Playbook">3、使用Ansible-playbook执行Playbook</h2><p><strong>上一小节中，我们简单地介绍了Playbook的定义。那么，当我们有了一个Playbook文件以后，如何执行这个文件完成应用部署呢？我们知道，Ansible安装完成以后存在多个可执行的命令行工具，其中，ansible-playbook便是用于执行Playbook的命令行工具。</strong></p><p><strong>ansible-playbook的执行方式如下:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ansible-playbook first_playbook.yml<br></code></pre></td></tr></table></figure><p><strong>ansible-playbook命令也有若干命令行选项，其中,有部分选项与ansible命令相同。Ansible中也存在一些ansible-playbook特有的命令行选项。</strong></p><p><strong>ansible-playbook命令与ansible命令相同的命令行选项:</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">-T --timeout：建立SSH连接的超时时间<br>--key-file --private-key：建立SSH连接的私钥文件<br>-i --inventory-file：指定Inventory文件，默认是/etc/ansible/hosts<br>-f --forks：并发执行的进程数，默认为5<br>--list-hosts：playbooks匹配的服务器列表。<br></code></pre></td></tr></table></figure><p><strong>ansible-playbook也有一个名为–list-hosts的选项，该选项的作用是列出匹配的服务器列表。例如，在我们这个 Playbook的例子中，hosts文件的内容如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1<br>[webservers]<br>192.168.1.60<br>[dbservers]<br>192.168.1.80<br>[common:children]<br>dbservers<br>webservers<br></code></pre></td></tr></table></figure><p><strong>我们知道，Ansible中的Play定义了需要对哪些服务器执行哪些操作，也就是说，每一个Play都可以指定匹配的远程服务器。在我们这个Playbook的例子中，对数据库服务器安装MongoDB，对web服务器部署“应用“。因此，ansible-playbook命令与ansible命令的–list-hosts选项输出的结果将会大不相同。ansible-playbook命令的–list-hosts选项输出的结果如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible-playbook all.yml --list-hosts<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200520151225728.png" alt="image-20200520151225728"></p><p><strong>ansible-playbook命令有一些特有的选项，如下所示：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">--list-tasks：列出任务列表<br>--step：每执行一个任务后停止，等待用户确认<br>--syntax-check：检查Playbook语法<br>-C --check：检查当前这个Playbook是否会修改远程服务器，相当于预测Playbook的执行结果。<br></code></pre></td></tr></table></figure><p><strong>这里的几个选项，除了–step以外，其他几个选项都不会执行Playbook中的任务。这些选项存在主要是为了便于调试Playbook。例如，–list-tasks选项，该选项用来显示当前Playbook中的任务列表。当Playbook比较大时，可以通过这个方式快速查看任务列表。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]#  ansible-playbook  all.yml --list-tasks<br>playbook: all.yml<br><br>  play #1 (dbservers): dbserversTAGS: []<br>    tasks:<br>      install mongodbTAGS: []<br><br>  play #2 (webservers): webserversTAGS: []<br>    tasks:<br>      copy fileTAGS: []<br>      change modeTAGS: []<br></code></pre></td></tr></table></figure><p><strong>当我们查看任务列表时，任务的名称就是task的name字段。因此，name的定义需要具有较好的描述性，让使用者通过名字就能知道该任务需要做什么事情。</strong></p><p><strong>–step选项类似于编程语言中的单步调试。当我们使–step选项执行Playbook时，ansible-playbook在每一个任务之前都会停住，等侍用户输入yes,、no或continue。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible-playbook all.yml --step<br>[DEPRECATION WARNING]: 'include' for playbook includes. You should use <br>'import_playbook' instead. This feature will be removed in version 2.12. <br>Deprecation warnings can be disabled by setting deprecation_warnings=False in <br>ansible.cfg.<br><br>PLAY [dbservers] ***************************************************************<br>Perform task: TASK: Gathering Facts (N)o/(y)es/(c)ontinue: y<br><br>Perform task: TASK: Gathering Facts (N)o/(y)es/(c)ontinue: *********************<br><br>TASK [Gathering Facts] *********************************************************<br>ok: [192.168.1.80]<br>Perform task: TASK: install mongodb (N)o/(y)es/(c)ontinue: y<br><br>Perform task: TASK: install mongodb (N)o/(y)es/(c)ontinue: *********************<br><br>TASK [install mongodb] *********************************************************<br>changed: [192.168.1.80]<br><br>PLAY [webservers] **************************************************************<br>Perform task: TASK: Gathering Facts (N)o/(y)es/(c)ontinue: y<br><br>Perform task: TASK: Gathering Facts (N)o/(y)es/(c)ontinue: *********************<br><br>TASK [Gathering Facts] *********************************************************<br>ok: [192.168.1.60]<br>Perform task: TASK: copy file (N)o/(y)es/(c)ontinue: y<br><br>Perform task: TASK: copy file (N)o/(y)es/(c)ontinue: ***************************<br><br>TASK [copy file] ***************************************************************<br>changed: [192.168.1.60]<br>Perform task: TASK: change mode (N)o/(y)es/(c)ontinue: y<br><br>Perform task: TASK: change mode (N)o/(y)es/(c)ontinue: *************************<br><br>TASK [change mode] *************************************************************<br>changed: [192.168.1.60]<br><br>PLAY RECAP *********************************************************************<br>192.168.1.60               : ok=3    changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   <br>192.168.1.80               : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0<br></code></pre></td></tr></table></figure><p><strong>输入yes以后，任务将会继续执行，并在下一个任务时停止，等待用户继续输入。当我们输入continue时，Ansible会执行完当前这个Play，当执行到下一个Play时再停止，并等待用户输入。</strong></p><h1>二、Playbook的详细语法</h1><p><strong>到目前为止，我们已经学习了如何编写Playbook以及如何运行Playbook。但是，我们仅仅介绍了最简单的Playbook。在这一节中，我们将会介绍Playbook是如何通过不同的选项提供丰富多样的功能。灵活使用这些选项，能够编写出形式各异的Playbook，以此应对自动部署中的各种情况。</strong></p><p><strong>在定义Play时，只有hosts与tasks是必选选项，其他选项都是根据需要添加的。在这一小节中。我们将介绍Playbook提供的不同功能，以Playbook的功能为线索，介绍Play与task中可以使用的选项。</strong></p><h3 id="（1）权限"><strong>（1）权限</strong></h3><p><strong>在Ansible中，默认使用当前用户连接远程服务器执行操作。我们也可以在anaible.cfg文件中配置连接远程服务器的默认用户。此外，如果是不同的用户使用不同类型的远程服务器，那么也可以在Playbook的Play定义中指定连接远程服务器的用户。例如，我们可以指定执行Play的用户：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span> <span class="hljs-string">webservers</span><br>  <span class="hljs-attr">remote_user:</span> <span class="hljs-string">root</span><br></code></pre></td></tr></table></figure><p><strong>用户可以细分每一个task，如下所示：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span> <span class="hljs-string">werbservers</span><br>  <span class="hljs-attr">remote_user:</span> <span class="hljs-string">root</span><br>  <span class="hljs-attr">tasks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">test</span> <span class="hljs-string">connection</span><br>      <span class="hljs-attr">ping:</span><br>        <span class="hljs-attr">remote_user:</span> <span class="hljs-string">yourname</span><br></code></pre></td></tr></table></figure><p><strong>很多时候，我们需要的不是以某个特定用户连接远程服务器，而是在需要更高级别的权限时，使用管理员身份去执行操作。在ansible中，可以通过become与become_ method选项实现：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span> <span class="hljs-string">werbservers</span><br>  <span class="hljs-attr">remote_user:</span> <span class="hljs-string">root</span><br>  <span class="hljs-attr">become:</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><p><strong>与remote_user选项类似，我们也可以为单个任务使用管理员权限，如下所示：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span> <span class="hljs-string">werbservers</span><br>  <span class="hljs-attr">remote_user:</span> <span class="hljs-string">yourname</span><br>  <span class="hljs-attr">tasks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">installed</span> <span class="hljs-string">nginx</span><br>      <span class="hljs-attr">service:</span> <span class="hljs-string">name=nginx</span> <span class="hljs-string">state=started</span><br>      <span class="hljs-attr">become:</span> <span class="hljs-literal">yes</span><br>      <span class="hljs-attr">become_method:</span> <span class="hljs-string">sudo</span><br></code></pre></td></tr></table></figure><h3 id="实例">实例</h3><p><strong>先修改远程服务器中test的权限为（0:0）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@192 ~]# vim /etc/passwd<br>test:x:0:0::/home/test:/bin/bash<br>[root@python ~]# chown test:root /etc/ansible/*<br>[root@python ~]# su test<br>[test@python root]$ cd <br>[test@python ~]$ vim hosts<br>[db]<br>192.168.1.60<br><br>[test@python ~]$ vim db.yml<br><br>---<br>- hosts: db<br>  remote_user: root             #远程服务器登陆的用户<br>  tasks:<br>    - name: installed nginx<br>      become: yes<br>      become_method: sudo<br>      ping:<br>        remote_user: root         #远程服务器登陆的用户<br>[test@python ~]$ vim /etc/ansible/ansible.cfg <br><br>[defaults]<br>inventory = /home/test/hosts<br></code></pre></td></tr></table></figure><h4 id="执行一下">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">[test@python ~]$ sudo ansible-playbook db.yml --step<br><br>We trust you have received the usual lecture from the local System<br>Administrator. It usually boils down to these three things:<br><br>    #1) Respect the privacy of others.<br>    #2) Think before you type.<br>    #3) With great power comes great responsibility.<br><br>[sudo] password for test: <br><br>PLAY [db] **********************************************************************<br>Perform task: TASK: Gathering Facts (N)o/(y)es/(c)ontinue: y<br><br>Perform task: TASK: Gathering Facts (N)o/(y)es/(c)ontinue: *********************<br><br>TASK [Gathering Facts] *********************************************************<br>Enter passphrase for key '/root/.ssh/id_rsa': <br>ok: [192.168.1.60]<br>Perform task: TASK: installed nginx (N)o/(y)es/(c)ontinue: <br><br>Perform task: TASK: installed nginx (N)o/(y)es/(c)ontinue: *********************<br><br>PLAY RECAP *********************************************************************<br>192.168.1.60               : ok=1    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0<br></code></pre></td></tr></table></figure><h3 id="（2）通知">（2）通知</h3><p><strong>在Ansible中，模块是幂等的。例如，我们要在远程服务器上创建一个用户，如果该用户已经存在，那么Ansible不会将该用户删除以后重新创建，而是直接返回成功，并通过changed字段表示是否对远程服务器进行了修改。</strong></p><p><strong>考虑这样一种需求：我们要通过Ansible修改Apache的配置文件，并重启Apache服务，使得新的配置文件生效。由于Ansible的模块是幂等的，当我们修改Apache的配置文件时，如果配置文件的内容已经与我们想要修改成的内容一样（例如，不小心将Ansible执行了两次的情况），那么，Ansible就什么也不做。既然Apache的配置文件并没有真的被修改，那么我们也不应该去重启Apache的服务器。在Ansible中，通过notify与handler机制来实现这里的功能。</strong></p><p><strong>在下面的例子中，我们首先尝试安装Apache，然后修改Apache的配置文件。如果配置文件被修改，则通过notify选项通知handler进行后续处理。</strong></p><p><strong>handler是Ansible提供的条件机制，与tasks比较类似，都是去执行某些操作。但是，handler只有在被notify触发以后才会执行，如果没有被触发则不会执行。在Playbook中，如果task后面存在notify选项，那么，当Ansible识别到task改变了系统的状态，就会通过notify去触发handler。</strong></p><p><strong>Ansibie是通过什么条件判断notify触发的是哪一个handler呢？很简单，在Ansible中，task使用handler的名字作为参数，以此来触发特定的handler。例如，在我们这里的例子中，notify触发的是“restart apache&quot;这个handler, handlers中也存在一个名为&quot; restart apache“的handler。</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span> <span class="hljs-string">webservers</span><br>  <span class="hljs-attr">tasks:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ensure</span> <span class="hljs-string">apache</span> <span class="hljs-string">is</span> <span class="hljs-string">at</span> <span class="hljs-string">the</span> <span class="hljs-string">latest</span> <span class="hljs-string">version</span><br>    <span class="hljs-attr">yum:</span> <span class="hljs-string">name=httpd</span> <span class="hljs-string">state=latest</span><br>    <br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">write</span> <span class="hljs-string">the</span> <span class="hljs-string">apache</span> <span class="hljs-string">config</span> <span class="hljs-string">file</span><br>    <span class="hljs-attr">template:</span> <span class="hljs-string">src=/srv/httpd.j2</span> <span class="hljs-string">dest=/etc/httpd.conf</span><br>    <span class="hljs-attr">notify:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">restart</span> <span class="hljs-string">apache</span><br>    <br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ensure</span> <span class="hljs-string">apache</span> <span class="hljs-string">is</span> <span class="hljs-string">running</span><br>    <span class="hljs-attr">service:</span> <span class="hljs-string">name=httpd</span> <span class="hljs-string">state=started</span><br>    <br>  <span class="hljs-attr">handlers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">restart</span> <span class="hljs-string">apache</span><br>      <span class="hljs-attr">service:</span> <span class="hljs-string">name=httpd</span> <span class="hljs-string">state=restarted</span><br></code></pre></td></tr></table></figure><p><strong>需要注意的是，handler只会在所有task执行完后执行。并且，即便一个handler被触发多次，它也只会执行一次。handler并不是在被触发时立即执行，而是按照Play中定义的顺序执行。一般情况下，handler都位于Play的最后，即在所有任务执行完成以后再执行。</strong></p><p><strong>Ansible官方文档提到handler的唯一用途，就是重启服务与服务器，正如找们这个例子所演示的。</strong></p><p><strong>在这个例子中，我们还用到T了template模块。template模块用以渲染Jinja模板。</strong></p><h3 id="（3）变量">（3）变量</h3><p><strong>在Inventory管理章节，我们已经介绍了如何定义变量。在Ansible中，还有其他几种定义变量的方式。对于简单的Playbook，最直接的方式是将变量定义在Playbook的vars选项中。如下所示：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span> <span class="hljs-string">dbservers</span><br>  <span class="hljs-attr">vars:</span><br>    <span class="hljs-attr">mysql_port:</span> <span class="hljs-number">3307</span><br></code></pre></td></tr></table></figure><p><strong>在Playbook中定义变量，可以在模板渲染时使用。例如：Ansible官方给出的例子中，MySQL配置文件的部分模板如下：</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">datadir</span>=/var/lib/mysql<br><span class="hljs-attr">socket</span>=/var/lib/mysql/mysql.sock<br><span class="hljs-attr">user</span>=mysql<br><span class="hljs-attr">port</span>=&#123;&#123; mysql_port &#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>当变量较少的时候，定义在vars选项中完全没有问题。当变量较多时，可以将变量保存在一个独立的文件中，并通过vars_files选项引用该文件。如下所示：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span> <span class="hljs-string">all</span><br>  <span class="hljs-attr">vars:</span><br>    <span class="hljs-attr">favcolor:</span> <span class="hljs-string">blue</span><br>  <span class="hljs-attr">vars_files:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">/vars/external_vars.yml</span><br>    <br>  <span class="hljs-attr">tasks:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">this</span> <span class="hljs-string">is</span> <span class="hljs-string">just</span> <span class="hljs-string">a</span> <span class="hljs-string">placeholer</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">/bin/echo</span> <span class="hljs-string">foo</span><br></code></pre></td></tr></table></figure><p><strong>保存变量的文件是一个简单的YAML格式的字典，如下所示：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-comment"># in th above example, this would be vars/external_vars.yml</span><br><span class="hljs-attr">somevar:</span> <span class="hljs-string">somevalue</span><br><span class="hljs-attr">password:</span> <span class="hljs-string">magic</span><br></code></pre></td></tr></table></figure><p><strong>在shell脚本中，我们可以通过获取上一条命令的返回码判断命令是否执行成功。在Ansible中，我们也可以获取任务的执行结果，将任务的执行结果保存在一个变最中，并在之后引用这个变量。这样的变量在Ansible中使用register选项获取，也称为注册变量。</strong></p><p><strong>例如，在下面这个例子中，我们首先执行/usr/bin/foo命令，并通过register选项获取命令的执行结果，将结果保存在foo_result中。在之后的task中，使用这个变量名引用/usr/bin/foo命令的执行结果。</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span> <span class="hljs-string">web_servers</span><br>  <span class="hljs-attr">tasks:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">shell:</span> <span class="hljs-string">/usr/bin/foo</span><br>    <span class="hljs-attr">register:</span> <span class="hljs-string">foo_result</span><br>    <span class="hljs-attr">ignore_errors:</span> <span class="hljs-literal">True</span><br>    <br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">shell:</span> <span class="hljs-string">/usr/bin/bar</span><br>    <span class="hljs-attr">when:</span> <span class="hljs-string">foo_result</span> <span class="hljs-string">==</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>这个例子还涉及了两个新的选项，分别是ignore_errors与when。前者表示忽略当前task中的错误，后者是一个条件语句，只有条件为真时才会执行这个task。</strong></p><h3 id="（4）Facts变量"><strong>（4）Facts变量</strong></h3><p><strong>在Ansible中，还有一些特殊的变量，这些变量不需要我们进行任何设置就可以直接使用，这样的变量称为Facts变量。Facts变量是Ansible执行远程部署之前从远程服务器中获取的系统信息，包括服务器的名称、IP地址、操作系统、分区信息、硬件信息等。Facts变量可以配合Playbook实现更加个性化的功能需求。例如，将MongoDB数据库的数据保存在/var/mongo-&lt;hostname&gt;/目录下。</strong></p><p><strong>我们可以通过setup模块查看Facts变量的列表，如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ansible all -m setup<br></code></pre></td></tr></table></figure><p><strong>有了Facts变量以后，如何在Ansible中使用它们呢？答案是直接使用。我们可以在Playbook中直接通过变量的名字引用变量，也可以在Jinja2模板中通过变量的名字引用变量。下面是一个名为test_facts.yml的Playbook。在这个Playbook中，我们输出了操作系统的类型，并且只有在操作系统为“RedHat&quot;类操作系统时才会执行安装操作。</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span> <span class="hljs-string">dbservers</span><br>  <span class="hljs-attr">tasks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">shell:</span> <span class="hljs-string">echo</span> <span class="hljs-string">&#123;&#123;</span> <span class="hljs-string">ansible_os_family</span> <span class="hljs-string">&#125;&#125;</span><br>      <span class="hljs-attr">register:</span> <span class="hljs-string">myecho</span><br>      <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">debug:</span> <span class="hljs-string">var=myecho.stdout_lines</span><br>    <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">install</span> <span class="hljs-string">git</span> <span class="hljs-string">on</span> <span class="hljs-string">Red</span> <span class="hljs-string">Hat</span> <span class="hljs-string">Linux</span><br>      <span class="hljs-attr">yum:</span> <span class="hljs-string">name=git</span> <span class="hljs-string">state=installed</span><br>      <span class="hljs-attr">when:</span> <span class="hljs-string">ansible_os_family</span> <span class="hljs-string">==</span> <span class="hljs-string">"RedHat"</span><br></code></pre></td></tr></table></figure><p><strong>setup模块为了输出结果的可读性，对模块的输出进行了归类和整理。因此，当我们要访问复杂变量的子属性时，需要使用嵌套结构。例如，我们可以通过下面两种方式访问Ansible中的ipv4地址：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">ansible_ens33['ipv4']['address']</span><br><span class="hljs-string">ansible_ens33.ipv4.address</span><br></code></pre></td></tr></table></figure><p><strong>访问复杂的变量的Playbook：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span> <span class="hljs-string">dbservers</span><br>  <span class="hljs-attr">gather_facts:</span> <span class="hljs-literal">yes</span><br>  <span class="hljs-attr">tasks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">shell:</span> <span class="hljs-string">echo</span> <span class="hljs-string">&#123;&#123;</span> <span class="hljs-string">ansible_ens33['ipv4']['address']</span> <span class="hljs-string">&#125;&#125;</span><br>      <span class="hljs-attr">register:</span> <span class="hljs-string">myecho</span><br>      <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">debug:</span> <span class="hljs-string">var=myecho.stdout_lines</span><br>    <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">shell:</span> <span class="hljs-string">echo</span> <span class="hljs-string">&#123;&#123;</span> <span class="hljs-string">ansible_ens33.ipv4.address</span> <span class="hljs-string">&#125;&#125;</span><br>      <span class="hljs-attr">register:</span> <span class="hljs-string">myecho</span><br>      <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">debug:</span> <span class="hljs-string">var=myecho.stdout_lines</span><br></code></pre></td></tr></table></figure><p><strong>在实际工作中，我们一般会在Jinja2模板中引用Facts变量。使用方式与这里的例子一样，为了节省篇幅就不再赘述了。</strong></p><p><strong>在Playbook中，可以通过gather_ facts选项控制是否收集远程服务器的信息。该选项默认取值为yes，如果确定不需要用到远程服务器的信息，可以将该选项设置为no，以此提高Ansible部署的效率。如下所示：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span> <span class="hljs-string">dbservers</span><br>  <span class="hljs-attr">gather_factes:</span> <span class="hljs-literal">no</span><br>  <span class="hljs-attr">tasks:</span><br></code></pre></td></tr></table></figure><h3 id="（5）循环"><strong>（5）循环</strong></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Mysql</span> <span class="hljs-string">package</span><br>  <span class="hljs-attr">yum:</span> <span class="hljs-string">name=&#123;&#123;</span> <span class="hljs-string">item</span> <span class="hljs-string">&#125;&#125;</span> <span class="hljs-string">state=installed</span><br>  <span class="hljs-attr">with_items:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">mysql-server</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">MySQL-python</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">libselinux-python</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">libsemanage-python</span><br></code></pre></td></tr></table></figure><h3 id="（6）条件"><strong>（6）条件</strong></h3><p><strong>有时候，一个任务是否执行取决于一个变量的取值，或者上一个任务的执行结果，这个时候找们就需要条件语句。再或者说，在循环的时候想要跳过一些特定的元素，在服务器部署时只对某些特定的操作系统进行操作。所有这些行为都可以使用条件语句解决。Ansible的Playbook不是一门编程语言，因此没有相应的条件语句，不过Ansible提供了一个类似的选项。</strong></p><p><strong>在Playbook中可以通过when选项执行条件语句，when就类似于编程语言中的if语句。</strong></p><p><strong>下面是一个简单的when选项使用示例：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 查看Linux系统版本：cat /etc/redhat-release</span><br><span class="hljs-attr">tasks:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"系统关机"</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">/sbin/shutdown</span> <span class="hljs-string">-t</span> <span class="hljs-string">now</span><br>    <span class="hljs-attr">when:</span> <span class="hljs-string">ansible_os_family</span> <span class="hljs-string">==</span> <span class="hljs-string">"RedHat"</span><br></code></pre></td></tr></table></figure><p><strong>when选项也支持多个条件语句，下面是一个YAML格式的多条件：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tasks:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"shutdown CentOS 7 systems"</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">/sbin/shutdown</span> <span class="hljs-string">-t</span> <span class="hljs-string">now</span><br>    <span class="hljs-attr">when:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ansible_distribution</span> <span class="hljs-string">==</span> <span class="hljs-string">"CentOS"</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ansible_distribution_major_version</span> <span class="hljs-string">==</span> <span class="hljs-string">"7"</span><br></code></pre></td></tr></table></figure><p><strong>对于更复杂的条件可以使用and、or与括号进行定义：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tasks:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">"shutdown CentOS 7 and Debian 6 systems"</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">/sbin/shutdown</span> <span class="hljs-string">-t</span> <span class="hljs-string">now</span><br>    <span class="hljs-attr">when:</span> <span class="hljs-string">(ansible_distribution</span> <span class="hljs-string">==</span> <span class="hljs-string">"CentOS"</span> <span class="hljs-string">and</span> <span class="hljs-string">ansible_distribution_major_version</span> <span class="hljs-string">==</span> <span class="hljs-string">"7"</span><span class="hljs-string">)</span> <span class="hljs-string">or</span> <span class="hljs-string">(ansible_distribution</span> <span class="hljs-string">==</span> <span class="hljs-string">"Debian"</span> <span class="hljs-string">and</span> <span class="hljs-string">ansible_distribution_major_version</span> <span class="hljs-string">==</span> <span class="hljs-string">"6"</span><span class="hljs-string">)</span><br></code></pre></td></tr></table></figure><p><strong>在when选项中可以读取变量的取值，例如：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">vars:</span><br>  <span class="hljs-attr">epic:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-attr">tasks:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">shell:</span> <span class="hljs-string">echo</span> <span class="hljs-string">"This certainly is epic!"</span><br>    <span class="hljs-attr">when:</span> <span class="hljs-string">epic</span><br></code></pre></td></tr></table></figure><p><strong>when选项可以与循环一起使用，以实现过滤的功能：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tasks:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">command:</span> <span class="hljs-string">echo</span> <span class="hljs-string">&#123;&#123;</span> <span class="hljs-string">item</span> <span class="hljs-string">&#125;&#125;</span><br>    <span class="hljs-attr">with_items:</span> <span class="hljs-string">[0,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-number">6</span><span class="hljs-string">,</span> <span class="hljs-number">8</span><span class="hljs-string">,</span> <span class="hljs-number">10</span><span class="hljs-string">]</span><br>    <span class="hljs-attr">when:</span> <span class="hljs-string">item</span> <span class="hljs-string">&gt;</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="（7）任务执行策略"><strong>（7）任务执行策略</strong></h3><p><strong>在Ansible中，Playbook的执行是以task为单位进行的。Ansible默认使用5个进程对远程服务器执行任务。在默认情况的任务执行策略( linear)中，Ansible首先执行task1，并且等到所有服务器执行完task1以后再开始执行task2，以此类推。从Ansible 2.0开始，Ansible支持名为free的任务执行策略，允许执行较快的远程服务器提前完成Play的部署，不用等待其他远程服务器一起执行task。如下所示：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span> <span class="hljs-string">all</span><br>  <span class="hljs-attr">strategy:</span> <span class="hljs-string">free</span><br>  <span class="hljs-attr">tasks:</span><br>   <span class="hljs-string">……</span><br></code></pre></td></tr></table></figure><p><strong>在这一节中，我们比较详细地介绍了Ansible中的Playbook选项。在Ansible中，Play与task都有很多选项，每个选项可以实现不同的功能。Ansibie官方并没有通过功能的形式介绍不同的选项给出一个完整的选项列表。我们也可以参考https://github.com/lorin/ansible-quickref快速了解Play与task中的选项，以及各个选项的含义。</strong></p><h2 id="4、案例：使用Playbook部署nginx"><strong>4、案例：使用Playbook部署nginx</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo<br>//下载源<br></code></pre></td></tr></table></figure><p><strong>在这个例子中，我们使用Ansible配置一台服务器运行nginx进程。部署nginx的Playbook如下：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span> <span class="hljs-string">webservers</span><br>  <span class="hljs-attr">become:</span> <span class="hljs-literal">yes</span><br>  <span class="hljs-attr">become_method:</span> <span class="hljs-string">sudo</span><br>  <span class="hljs-attr">vars:</span><br>    <span class="hljs-attr">worker_prosess:</span> <span class="hljs-number">4</span><br>    <span class="hljs-attr">worker_connections:</span> <span class="hljs-number">768</span><br>    <span class="hljs-attr">max_open_files:</span> <span class="hljs-number">65506</span><br>  <span class="hljs-attr">tasks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">install</span> <span class="hljs-string">nginx</span><br>      <span class="hljs-attr">yum:</span> <span class="hljs-string">name=nginx</span> <span class="hljs-string">update_cache=yes</span> <span class="hljs-string">state=present</span><br>      <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">copy</span> <span class="hljs-string">nginx</span> <span class="hljs-string">config</span> <span class="hljs-string">file</span><br>      <span class="hljs-attr">template:</span> <span class="hljs-string">src=/root/test_ansible/nginx.conf.j2</span> <span class="hljs-string">dest=/etc/nginx/nginx.conf</span><br>      <span class="hljs-attr">notify:</span> <span class="hljs-string">restart</span> <span class="hljs-string">nginx</span><br>      <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">copy</span> <span class="hljs-string">index.html</span><br>      <span class="hljs-attr">template:</span><br>        <span class="hljs-attr">src:</span> <span class="hljs-string">/root/test_ansible/index.html.j2</span><br>        <span class="hljs-attr">dest:</span> <span class="hljs-string">/usr/share/nginx/www/index.html</span><br>        <span class="hljs-attr">mode:</span> <span class="hljs-number">0644</span><br>      <span class="hljs-attr">notify:</span> <span class="hljs-string">restart</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">handlers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">restart</span> <span class="hljs-string">nginx</span><br>      <span class="hljs-attr">service:</span> <span class="hljs-string">name=nginx</span> <span class="hljs-string">state=restarted</span><br></code></pre></td></tr></table></figure><p><strong>在这个Playbook中，我们首先通过hosts选项指定了要对哪些远程服务器执行操作。随后，我们通过become与become_method选项声明了部署时使用sudo权限。接下来，我们在vars字段中定义了三个变量，这三个变量将用在nginx的配置文件中。我们在tasks选项下定义了部署nginx服务的任务列表，包括软件安装、模板渲染、定制s首页和重启nginx进程。</strong></p><p><strong>为了避免配置文件在没有任何修改的情况下重启了nginx进程，这里使用了Ansible的handler机制。在这个Playbook中，存在两个notify选项，以及一个handler选项。无论是nginx的配置文件，还是定制首页发生了修改，我们都会重启nginx进程。由于我们使用了Ansible的handlers机制，因此，在没有任何修改的情况下，Ansible并不会重启nginx进程。使用handler机制还有一个好处，notify多次，handler也只会执行一次，避免了反复多次重启nginx进程。</strong></p><p><strong>在这个部署nginx服务的Playbook中，我们用到了nginx.conf.j2这个配置模板。这个模板使用的是Jinja2的语法，所以后缀名为j2。模板的内容如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# mkdir test_ansible<br>[root@python ~]# vim /root/test_ansible/nginx.conf.j2<br>worker_processes  &#123;&#123; worker_prosess &#125;&#125;;<br>worker_rlimit_nofile &#123;&#123; max_open_files &#125;&#125;;<br><br>events &#123;<br>    worker_connections  &#123;&#123; worker_connections &#125;&#125;;<br>&#125;<br><br>http &#123;<br>trueserver &#123;<br>        listen       80;<br>truetrue<br>truetruelisten443 ssl;<br>truetrue<br>        server_name  localhost;<br>truetrue<br>        location / &#123;<br>            root   /usr/share/nginx/www;<br>            index  index.html index.htm;<br>truetruetrue<br>truetruetruetr_files $uri $uri/ =404;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Ansible会使用我们在Playbook的vars字段中定义的变量，将Jinja2模板渲染成真实的配置文件。</strong></p><p><strong>我们的Playbook还用到了一个名为index.html.j2的模板，该模板用于渲染网站首页。index.html.j2的内容如下：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html">[root@python ~]# vim /root/test_ansible/index.html.j2<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span><br>true<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>truetrue<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>wellcome to ansible<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>true<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>true<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>truetrue<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>nginx, configured by ansible<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>truetrue<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>如果你能看到这个页面，说明ansible自动部署nginx成功了！<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>truetrue<br>truetrue<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; ansible_hostname &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>true<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>在index.html.j2中，我们用到了一个名为ansible_hostname的变量。这个变量是Facts变量，是Ansible在执行Playbook之前从远程服务器获取到的信息。因此，我们不需要定义，直接使用即可。</strong></p><p><strong>有了Playbook以后，使用ansible-playbook命令进行部署。如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@python ~]<span class="hljs-comment"># pip install Jinja2</span><br>[root@python ~]<span class="hljs-comment"># vim /etc/ansible/ansible.cfg </span><br><br>[defaults]<br>inventory = /root/hosts<br><br>[root@bogon ~]<span class="hljs-comment"># ansible-playbook nginx.yml</span><br><br>PLAY [webservers] **********************************************************************************************************<br><br>TASK [Gathering Facts] *****************************************************************************************************<br>ok: [<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>]<br><br>TASK [install nginx] *******************************************************************************************************<br>ok: [<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>]<br><br>TASK [copy nginx config file] **********************************************************************************************<br>ok: [<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>]<br><br>TASK [copy index.html] *****************************************************************************************************<br>ok: [<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>]<br><br>PLAY RECAP *****************************************************************************************************************<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>                  : ok=<span class="hljs-number">4</span>    changed=<span class="hljs-number">0</span>    unreachable=<span class="hljs-number">0</span>    failed=<span class="hljs-number">0</span>    skipped=<span class="hljs-number">0</span>    rescued=<span class="hljs-number">0</span>    ignored=<span class="hljs-number">0</span>   <br><br>[root@bogon ~]<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p><strong>如果安装失败，可能是端口被占用，可以停止使用该端口的服务，或者更改nginx端口。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@bogon ~]<span class="hljs-comment"># netstat -ntlp</span><br>Active Internet connections (only servers)<br>Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    <br>tcp        <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">111</span>             <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:*               LISTEN      <span class="hljs-number">1</span>/systemd           <br>tcp        <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">6000</span>            <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:*               LISTEN      <span class="hljs-number">7470</span>/X              <br>tcp        <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.122</span><span class="hljs-number">.1</span>:<span class="hljs-number">53</span>        <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:*               LISTEN      <span class="hljs-number">7654</span>/dnsmasq        <br>tcp        <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">22</span>              <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:*               LISTEN      <span class="hljs-number">7337</span>/sshd           <br>tcp        <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">631</span>           <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:*               LISTEN      <span class="hljs-number">7340</span>/cupsd          <br>tcp        <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6010</span>          <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:*               LISTEN      <span class="hljs-number">31653</span>/sshd: root@pt <br>tcp        <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6011</span>          <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:*               LISTEN      <span class="hljs-number">31653</span>/sshd: root@pt <br>tcp        <span class="hljs-number">0</span>      <span class="hljs-number">0</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6012</span>          <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:*               LISTEN      <span class="hljs-number">31653</span>/sshd: root@pt <br>tcp6       <span class="hljs-number">0</span>      <span class="hljs-number">0</span> :::<span class="hljs-number">111</span>                  :::*                    LISTEN      <span class="hljs-number">1</span>/systemd           <br>tcp6       <span class="hljs-number">0</span>      <span class="hljs-number">0</span> :::<span class="hljs-number">80</span>                   :::*                    LISTEN      <span class="hljs-number">17867</span>/httpd         <br>tcp6       <span class="hljs-number">0</span>      <span class="hljs-number">0</span> :::<span class="hljs-number">6000</span>                 :::*                    LISTEN      <span class="hljs-number">7470</span>/X              <br>tcp6       <span class="hljs-number">0</span>      <span class="hljs-number">0</span> :::<span class="hljs-number">22</span>                   :::*                    LISTEN      <span class="hljs-number">7337</span>/sshd           <br>tcp6       <span class="hljs-number">0</span>      <span class="hljs-number">0</span> ::<span class="hljs-number">1</span>:<span class="hljs-number">631</span>                 :::*                    LISTEN      <span class="hljs-number">7340</span>/cupsd          <br>tcp6       <span class="hljs-number">0</span>      <span class="hljs-number">0</span> ::<span class="hljs-number">1</span>:<span class="hljs-number">6010</span>                :::*                    LISTEN      <span class="hljs-number">31653</span>/sshd: root@pt <br>tcp6       <span class="hljs-number">0</span>      <span class="hljs-number">0</span> ::<span class="hljs-number">1</span>:<span class="hljs-number">6011</span>                :::*                    LISTEN      <span class="hljs-number">31653</span>/sshd: root@pt <br>tcp6       <span class="hljs-number">0</span>      <span class="hljs-number">0</span> ::<span class="hljs-number">1</span>:<span class="hljs-number">6012</span>                :::*                    LISTEN      <span class="hljs-number">31653</span>/sshd: root@pt <br>[root@bogon ~]<span class="hljs-comment"># systemctl stop httpd.service</span><br></code></pre></td></tr></table></figure><h3 id="第二台服务器启动一下nginx">第二台服务器启动一下nginx</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@192 ~]# nginx -t<br>nginx: the configuration file /etc/nginx/nginx.conf syntax is ok<br>nginx: configuration file /etc/nginx/nginx.conf test is successful<br>[root@192 ~]# nginx<br>nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)<br>nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)<br>nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)<br>nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)<br>nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)<br>nginx: [emerg] still could not bind()<br></code></pre></td></tr></table></figure><h4 id="浏览器访问一下">浏览器访问一下</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200521170355706.png" alt="image-20200521170355706"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python自动化管理Ansible</title>
      <link href="/posts/5017.html"/>
      <url>/posts/5017.html</url>
      
        <content type="html"><![CDATA[<h1>一、Ansible介绍</h1><p><strong>Ansible是一个简单的自动化运维工具，可完成配置管理、应用部署、服务编排以及其他各种IT需求。Ansible也是一款基于Python语言实现的开源软件，其依赖Jinja2、paramiko和PYYAML这几个Python库。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">Ansible的作者是Michael Dehaan，Michael Dehaan同时也是知名软件Cobber的作者和Func的共同作者。Michael Dehaan与2012年创建了AnsibleWorks公司，之后改名为Ansible公司。Ansible公司与2015年10月被红帽公司（Red Hat）收购。<br></code></pre></td></tr></table></figure><p><strong>在这一小节，我们将首先介绍Ansible的优点，然后比较Ansible与Fabric之间的差异。</strong></p><h2 id="1、Ansible的优点">1、Ansible的优点</h2><p><strong>Ansible作为配置工具，通常与Puppet、Chef、Saltstack进行比较，如下所示：</strong></p><table><thead><tr><th>工具</th><th>发布时间</th><th>语言</th><th>架构</th><th>协议</th></tr></thead><tbody><tr><td>Puppet</td><td>2005年</td><td>Ruby</td><td>C/S</td><td>http</td></tr><tr><td>Chef</td><td>2008年</td><td>Ruby</td><td>C/S</td><td>http</td></tr><tr><td>Saltstack</td><td>2012年</td><td>Python</td><td>C/S（可无Client）</td><td>ssh/zmq/raet</td></tr><tr><td>Ansible</td><td>2013年</td><td>Python</td><td>无Client</td><td>ssh</td></tr></tbody></table><p><strong>从发布时间来看，Ansible完全没有优势，那么，是什么特性让Ansible进入了工程师的视野，并且逐步获得青睐呢？我们需要了解一下Ansible有哪些优点。</strong></p><h3 id="Ansible具有以下几个优点："><strong>Ansible具有以下几个优点：</strong></h3><h4 id="（1）部署简单">（1）部署简单</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">只需要在主控端部署Ansible环境，被控端无须做任何操作。换句话说，在安装Ansible时，远程服务器无烦安装任何依赖。因此，相对于其他配置管理器，Ansible安装部署非常简单，省去了客户端的安装。在数千台规模的大型数据中心意味着少了一些路由和安全策略的配置，省去了很多不必要的麻烦。<br></code></pre></td></tr></table></figure><h4 id="（2）基于ssh进行配置管理，充分利用现成的机制">（2）基于ssh进行配置管理，充分利用现成的机制</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">Ansible不依赖与客户端，直接使用ssh进行配置管理，在Ansible早期版本中，默认使用paramiko进行配置管理，从Ansible1.3版本开始，Ansible默认使用OpenSSH实现个服务器间通信。<br></code></pre></td></tr></table></figure><h4 id="（3）Ansible不需要守护进程">（3）Ansible不需要守护进程</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">因为Ansible依赖OpenSSH进行通信，不需要安装客户端，因此服务端也不需要像其他配置管理一样使用一个守护进程。Ansible的安装和维护都变得更加简单，系统更加安全可靠。<br></code></pre></td></tr></table></figure><h4 id="（4）日志集中存储">（4）日志集中存储</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">所有操作日志都存储在Ansible发起服务器，可以采用自定义的格式，这样可以很方便地知晓哪些服务器操作有问题，哪些已经成功，也便于日后追溯。<br></code></pre></td></tr></table></figure><h4 id="（5）Ansible简单易用">（5）Ansible简单易用</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">Ansible和其他配置管理工具一样，运行一个部署命令就可以完成应用部署，使用非常简单。此外，Ansible使用YAML语法管理配置，YAML本身是一种可读性非常强的标记语言，工程师几乎像阅读英文一样阅读YAML的配置文件。因为Ansible使用YAML管理配置，所以使用Ansible不需要使用者具有任何编程背景。运维自动化工具本身是用来简化运维工作的，如果本身比较复杂（如Puppet），甚至需要一定的程序开发能力，那么就会增加使用者的使用难度和犯错的概率。<br></code></pre></td></tr></table></figure><h4 id="（6）Ansible功能强大">（6）Ansible功能强大</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">Ansible通过模块来实现各种功能，目前，Ansible已经有了950多个模块，工程师也可以使用任何语言编写自定义的Ansible模块。<br></code></pre></td></tr></table></figure><h4 id="（7）Ansible设计优秀，便于分享">（7）Ansible设计优秀，便于分享</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">Ansible使用role组织Playbook，并提供了分享role的平台（galaxy.ansible.com），便于大家分享和复用。充分使用role，可以编写可读性更强的配置文件。使用开源的role，能够有效节省编写Playbook的时间。<br></code></pre></td></tr></table></figure><h4 id="（8）Ansible对云计算和大数据平台都有很好的支持">（8）Ansible对云计算和大数据平台都有很好的支持</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">从Ansible的模块列表可以看到，Ansible包含了大量与云服务、AWS、OpenStack、Docker等相关的模块。并且，Ansible便于扩展，当出现新事务时可以根据需要编写自定义的模块。<br></code></pre></td></tr></table></figure><p><strong>Ansible作为自动化系统运维的一大利器，在构建整个体系过程中有着举足轻重的地位。其简单易用、易于安装、功能强大、便于分享、内含大量模板等都是它的魅力所在，再加上易封装、接口调用方便，Ansible正在被越来越多的大公司采用。</strong></p><h2 id="2、Ansible与Fabric之间的比较">2、Ansible与Fabric之间的比较</h2><p><strong>简单来说，Fabric像是一个工具箱，提供了很多好用的工具，用于在远程服务器执行命令。而Ansible则提供了一套简单的流程，只需要按照它的流程来做就能轻松完成任务。这就像是库和框架的关系一样，其中，Fabric是库，Ansible是框架。</strong></p><h3 id="（1）Fabric与Ansible之间的共同点">（1）Fabric与Ansible之间的共同点</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">1.都是基于paramiko开发；<br>2.都使用ssh和远程服务器通讯，不需要在远程服务器上安装客户端。<br></code></pre></td></tr></table></figure><h3 id="（2）Fabric与Ansible之间的主要区别">（2）Fabric与Ansible之间的主要区别</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. Fabric简单，Ansible复杂。因此，Fabric学习成本低，Ansible的学习成本高；<br>2. Fabric通过ssh执行简单的命令，Ansible将模块拷贝到远程服务器后执行，执行完成以后删除模块；<br>3. 使用Fabric需要具有Python编程背景，使用Ansible则不需要；<br>4. Fabric对常用的管理操作和ssh连接操作进行了封装，工程师通过编写简单的代码就能完成要做的事情。Ansible不需要工程师编写任何代码，直接编写YAML格式的配置文件来描述要做的事情；<br>5. Fabric提供了基本的接口，业务逻辑需要用户自己实现；Ansible提供了大量的模块，用户只需要学习模块的用法即可完成复杂的任务。<br></code></pre></td></tr></table></figure><h1>二、Ansible使用入门</h1><p><strong>在这一小节我们介绍Ansible的安装与基本使用，然后在接下来的章节中介绍Ansible的高级用法。</strong></p><h3 id="ansible使用原则：">ansible使用原则：</h3><ul><li><strong>确定要操作哪些服务器（服务器列表）</strong></li><li><strong>确定对这些服务器进行什么样的操作（命令</strong>）</li></ul><h3 id="关于hosts文件：">关于hosts文件：</h3><ul><li><strong>默认读取/etc/ansible/hosts文件</strong></li><li><strong>通过命令行参数-i指定hosts文件</strong></li><li><strong>通过/etc/ansible/ansible.cfg里面的inventory选项指定hosts文件</strong></li></ul><h2 id="1、安装Ansible"><strong>1、安装Ansible</strong></h2><p><strong>Ansible不需要安装客户端，因此，相对于其他配置管理工具，Ansible的安装简单得多，只需要在控制端安装Ansible即可。Ansible使用Python语言开发，我们可以直接使用pip进行安装，也可以使用Linux下的包管理工具(如yumI、apt-get)进行安装。如下所示:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# pip3 install ansible<br></code></pre></td></tr></table></figure><p><strong>检查Ansible是否安装成功，如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible --version<br>ansible 2.9.9<br>  config file = /etc/ansible/ansible.cfg<br>  configured module search path = [u'/root/.ansible/plugins/modules', u'/usr/share/ansible/plugins/modules']<br>  ansible python module location = /usr/lib/python2.7/site-packages/ansible<br>  executable location = /usr/bin/ansible<br>  python version = 2.7.5 (default, Aug  7 2019, 00:51:29) [GCC 4.8.5 20150623 (Red Hat 4.8.5-39)]<br></code></pre></td></tr></table></figure><p><strong>Ansible依赖Python与SSH，因此服务器需要安装SSH和Python 2.5或2.5以上版本的Python。SSH和Python是大多数操作系统中默认安装的软件，这进一步降低了Ansible安装部署的难度。除了SSH和Python以外，服务器端不需要再预装任何软件。在控制端（Ansible命令运行的那台机器）需要安装Python 2.6或更高版本的Python程序，且Ansible的控制端只能运行在Linux下。</strong><br><strong>与其他库和工具不同的是，Ansible包含了多个工具。安装完Ansible以后，控制端会增加以下几个可执行程序：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">ansible<br>ansible-doc<br>ansible-playbook<br>ansible-vault<br>ansible-console<br>ansible-galaxy<br>ansible-pull<br></code></pre></td></tr></table></figure><p><strong>这些可执行程序将在之后使用时进行详细介绍。</strong></p><h2 id="2、Ansible的架构">2、Ansible的架构</h2><p><strong>为了更好的理解Ansible，在介绍Ansible的使用之前，我们先看一下Ansible的架构图，如下所示：</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200520221310187.png" alt="image-20200520221310187"></p><p><strong>在Ansible中，用户通过编排引擎操作主机。其中，主机可以通过配置文件配置，调用云计算的接口获取，或者访问CMDB中的数据库。Ansible的编排引擎有Inventory、API、Modules（模块）和Plugins组成。Ansible的典型用法是：工程师将需要远程服务器执行的操作写在Ansible Playbook中，然后使用Ansible执行Playbook中的操作。</strong></p><h2 id="3、Ansible的运行环境"><strong>3、Ansible的运行环境</strong></h2><p><strong>使用Ansible操作远程服务器时，首先需要确定的是操作哪些服务器，然后再确定对这些服务器执行哪些操作。</strong></p><p><strong>Ansible会默认读取/etc/ansible/hosts文件中配置的远程服务器列表。在我们这一小节，/etc/ansible/hosts文件内容如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# mkdir /etc/ansible<br>[root@python ~]# vim /etc/ansible/hosts<br><br>[test]<br>127.0.0.1<br>192.168.1.80<br></code></pre></td></tr></table></figure><p><strong>Ansible中存在一个名为ping的模块，该模块并不是测试服务器的网络是否连接，而是尝试建立SSH连接，以便验证用户的SSH是否已经正确配置。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible test -m ping<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200518155344725.png" alt="image-20200518155344725"></p><h2 id="修改test的权限">修改test的权限</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# chmod  755 /etc/sudoers<br>[root@python ~]# vim /etc/sudoers<br>test    ALL=(ALL)       ALL                   #92行左右添加<br>[root@python ~]# vim /etc/ansible/hosts<br><br>[test]<br>127.0.0.1 ansible_user=root ansible_port=22<br>192.168.1.80<br></code></pre></td></tr></table></figure><h3 id="再次测试一下">再次测试一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@python ~]# ansible test -m ping<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200518160500524.png" alt="image-20200518160500524"></p><h5 id="常见错误解决方案如下：">常见错误解决方案如下：</h5><h6 id="（1）ansible管理节点生成ssh-key">（1）ansible管理节点生成ssh-key</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># ssh-keygen</span><br></code></pre></td></tr></table></figure><p><strong>执行成功后，将会在~/.ssh目录下生成2个文件：id_rsa和id_rsa.pub</strong></p><h6 id="（2）添加目标节点的ssh认证信息">（2）添加目标节点的ssh认证信息</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># ssh-copy-id root@47.100.98.242</span><br>[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># ssh-copy-id root@192.168.79.133</span><br></code></pre></td></tr></table></figure><h6 id="（3）测试">（3）测试</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># ansible test -m ping</span><br>192.168.79.133 | SUCCESS =&gt; &#123;<br>    <span class="hljs-string">"ansible_facts"</span>: &#123;<br>        <span class="hljs-string">"discovered_interpreter_python"</span>: <span class="hljs-string">"/usr/bin/python"</span><br>    &#125;,<br>    <span class="hljs-string">"changed"</span>: false,<br>    <span class="hljs-string">"ping"</span>: <span class="hljs-string">"pong"</span><br>&#125;<br>47.100.98.242 | SUCCESS =&gt; &#123;<br>    <span class="hljs-string">"ansible_facts"</span>: &#123;<br>        <span class="hljs-string">"discovered_interpreter_python"</span>: <span class="hljs-string">"/usr/bin/python"</span><br>    &#125;,<br>    <span class="hljs-string">"changed"</span>: false,<br>    <span class="hljs-string">"ping"</span>: <span class="hljs-string">"pong"</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Ansible默认使用当前用户和默认的22端口号与远程服务器建立SSH连接。如果需要使用其他用户，或者使用非默认的SSH端口号，可以在host之后增加用户名和端口号的配置。如下所示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pypthon">[root@192 ~]# cat &#x2F;etc&#x2F;ansible&#x2F;hosts<br>[test]<br>192.168.79.133 ansible_user&#x3D;test ansible_port&#x3D;22<br>47.100.98.242 ansible_user&#x3D;laoyu ansible_port&#x3D;80<br></code></pre></td></tr></table></figure><p><strong>一般情况下，工作环境的服务器ssh用户名和ssh端口号都是相同的。如果我们有很多的远程服务器，每一台服务器都需要配置ansible_user或ansible_port参数，如果依然使用前面的配置方式进行配置，会显得非常冗余。对于这种情况，可以在Ansible配置文件中修改相应的配置。</strong></p><p><strong>Ansible默认使用/etc/ansible/ansible.cfg文件，我们可以在ansible.cfg中设定一些默认值，这样就需要对同样的内容输入多次。如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># cat /etc/ansible/ansible.cfg</span><br>[defaults]<br>remote_port = <span class="hljs-number">2090</span><br>remote_user = test<br></code></pre></td></tr></table></figure><h2 id="4、Ansible的ad-hoc模式">4、Ansible的ad-hoc模式</h2><p><strong>ping模块是Ansible中最简单的模块，而command模块则是工程师最熟悉的模块。command模块的作用非常简单，就是在服务器中执行shell命令。在Ansible中，通过-m参数指定模块名称，通过-a参数指定模块的参数。因此，使用command模块在远程服务器执行shell命令的语句如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible test -m command -a "hostname"<br>127.0.0.1 | CHANGED | rc=0 &gt;&gt;<br>python<br>192.168.1.80 | CHANGED | rc=0 &gt;&gt;<br>python<br>[root@python ~]# ansible test -m command -a "whoami"<br>192.168.1.80 | CHANGED | rc=0 &gt;&gt;<br>root<br>127.0.0.1 | CHANGED | rc=0 &gt;&gt;<br>root<br></code></pre></td></tr></table></figure><p><strong>command是Ansible中的默认模块，当我们省略-m参数时，默认使用command模块。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible test -m command -a "whoami"<br>192.168.1.80 | CHANGED | rc=0 &gt;&gt;<br>root<br>127.0.0.1 | CHANGED | rc=0 &gt;&gt;<br>root<br></code></pre></td></tr></table></figure><p><strong>大部分情况下，Ansible的模块包含多个参数，参数使用“key=value”的形式表示，各个参数之间使用空格分隔。如下所示：</strong></p><h3 id="（1）创建ansible-cfg文件">（1）创建ansible.cfg文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# vim /etc/ansible/ansible.cfg<br>[defaults]<br>remote_port = 22<br>remote_user = root<br></code></pre></td></tr></table></figure><h4 id="再次测试一下-2">再次测试一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible test -m ping<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200518155344725.png" alt="image-20200518155344725"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible test -m command -a "hostname"<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200518162026972.png" alt="image-20200518162026972"></p><h3 id="（2）将本地文件拷贝到服务器">（2）将本地文件拷贝到服务器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# cd /tmp/<br>[root@python tmp]# mkdir abc<br>[root@python tmp]# cd abc/<br>[root@python abc]# ls<br>nginx.conf  restart.sh     #要拷贝的文件<br></code></pre></td></tr></table></figure><h4 id="进行拷贝">进行拷贝</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python abc]# ansible test -m copy -a "src=/tmp/abc/nginx.conf dest=/opt/nginx.conf"<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200518162720950.png" alt="image-20200518162720950"></p><h4 id="查看一下是否有拷贝的文件">查看一下是否有拷贝的文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python abc]# ls /opt/ | grep nginx.conf<br>nginx.conf<br></code></pre></td></tr></table></figure><h3 id="1-创建剧本（拷贝）">&lt;1&gt;创建剧本（拷贝）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python abc]# vim test_playbook.yml<br><br>---<br>- hosts: test<br>  become: yes               #是否支持root权限<br>  become_method: sudo<br>  tasks:                    #任务<br>  - name: copy file         #描叙<br>    copy: src=/opt/nginx.conf dest=/tmp/abc/nginx.conf #拷贝的<br><br>  - name: package install   #描叙<br>    yum: name=&#123;&#123;item&#125;&#125; state=present        #安装的<br>    with_items:<br>      - tmux<br></code></pre></td></tr></table></figure><h4 id="执行一下">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python abc]# ansible-playbook test_playbook.yml<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200518164022081.png" alt="image-20200518164022081"></p><h4 id="查看是否有拷贝的文件">查看是否有拷贝的文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python abc]# ls | grep nginx.conf <br>nginx.conf<br></code></pre></td></tr></table></figure><h3 id="（3）在远程服务器中安装软件">（3）在远程服务器中安装软件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python abc]# ansible test -m yum -a "name=tmux state=present" -become<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200518163338271.png" alt="image-20200518163338271"></p><h2 id="5、使用playbook控制服务器">5、使用playbook控制服务器</h2><p><strong>前面通过Ansible命令执行操作的方式，称为ad-hoc。我们可以使用ad-hoc来执行非常简单的操作，也可以使用ad-hoc的方式来学习模块的使用方式。但是，在实际的生产环境中，我们一般将远程服务器需要做的事情写在一个YAML配置文件中。</strong></p><p><strong>例如，将本地文件拷贝到远程服务器并修改文件所有者，然后安装软件的功能，写在YAML的配置文件中以后，其内容如下：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">[root@192</span> <span class="hljs-string">~]#</span> <span class="hljs-string">cat</span> <span class="hljs-string">test_playbook.yml</span><br><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span> <span class="hljs-string">test</span><br>  <span class="hljs-attr">become:</span> <span class="hljs-literal">yes</span><br>  <span class="hljs-attr">become_method:</span> <span class="hljs-string">sudo</span><br>  <span class="hljs-attr">tasks:</span><br>true<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">copy</span> <span class="hljs-string">file</span><br>      <span class="hljs-attr">copy:</span> <span class="hljs-string">src=~/s.txt</span> <span class="hljs-string">dest=/opt/s.txt</span><br>true<br>true<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">change</span> <span class="hljs-string">mode</span><br>      <span class="hljs-attr">file:</span> <span class="hljs-string">dest=/opt/s.txt</span> <span class="hljs-string">mode=500</span> <span class="hljs-string">owner=root</span> <span class="hljs-string">group=root</span><br>true<br>true<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ensure</span> <span class="hljs-string">packages</span> <span class="hljs-string">installed</span><br>      <span class="hljs-attr">yum:</span> <span class="hljs-string">name=&#123;&#123;item&#125;&#125;</span> <span class="hljs-string">state=present</span><br>true  <span class="hljs-attr">with_items:</span><br>true    <span class="hljs-bullet">-</span> <span class="hljs-string">git</span><br>true    <span class="hljs-bullet">-</span> <span class="hljs-string">tmux</span><br></code></pre></td></tr></table></figure><p><strong>这个YAML文件称为Ansible Playbook。Playbook中首先包含了一些声明信息，如hosts关键字声明该Playbook应用的服务器列表，become和become_method表示在远程服务器通过sudo执行操作。Playbook最后包含了若干个task，每一个task对应于前面的一条ad-hoc命令。具体执行时，多个task按序执行。如果你不能完全理解YAML文件，现在只需要对Ansible的执行方式有一个认识即可。后续小节将会详细讲解如何编写Ansible Playbook。</strong></p><p><strong>有了Playbook以后，通过ansible-playbook命令执行，如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># ansible-playbook test_palybook.yml</span><br>PLAY [test] ****************************************************************************************************************<br><br>TASK [Gathering Facts] *****************************************************************************************************<br>ok: [<span class="hljs-number">47.100</span><span class="hljs-number">.98</span><span class="hljs-number">.242</span>]<br>ok: [<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>]<br><br>TASK [copy file] ***********************************************************************************************************<br>ok: [<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>]<br>ok: [<span class="hljs-number">47.100</span><span class="hljs-number">.98</span><span class="hljs-number">.242</span>]<br><br>TASK [change mode] *********************************************************************************************************<br>ok: [<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>]<br>ok: [<span class="hljs-number">47.100</span><span class="hljs-number">.98</span><span class="hljs-number">.242</span>]<br><br>TASK [ensure packages installed] *******************************************************************************************<br>[DEPRECATION WARNING]: Invoking <span class="hljs-string">"yum"</span> only once <span class="hljs-keyword">while</span> using a loop via squash_actions <span class="hljs-keyword">is</span> deprecated. Instead of using a <br>loop to supply multiple items <span class="hljs-keyword">and</span> specifying `name: <span class="hljs-string">"&#123;&#123;item&#125;&#125;"</span>`, please use `name: [<span class="hljs-string">'git'</span>, <span class="hljs-string">'tmux'</span>]` <span class="hljs-keyword">and</span> remove the loop. <br>This feature will be removed <span class="hljs-keyword">in</span> version <span class="hljs-number">2.11</span>. Deprecation warnings can be disabled by setting deprecation_warnings=<span class="hljs-literal">False</span> <span class="hljs-keyword">in</span><br> ansible.cfg.<br>[DEPRECATION WARNING]: Invoking <span class="hljs-string">"yum"</span> only once <span class="hljs-keyword">while</span> using a loop via squash_actions <span class="hljs-keyword">is</span> deprecated. Instead of using a <br>loop to supply multiple items <span class="hljs-keyword">and</span> specifying `name: <span class="hljs-string">"&#123;&#123;item&#125;&#125;"</span>`, please use `name: [<span class="hljs-string">'git'</span>, <span class="hljs-string">'tmux'</span>]` <span class="hljs-keyword">and</span> remove the loop. <br>This feature will be removed <span class="hljs-keyword">in</span> version <span class="hljs-number">2.11</span>. Deprecation warnings can be disabled by setting deprecation_warnings=<span class="hljs-literal">False</span> <span class="hljs-keyword">in</span><br> ansible.cfg.<br>changed: [47.100.98.242] =&gt; (item=['git', 'tmux'])<br>changed: [127.0.0.1] =&gt; (item=['git', 'tmux'])<br><br>PLAY RECAP *****************************************************************************************************************<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>                  : ok=<span class="hljs-number">4</span>    changed=<span class="hljs-number">1</span>    unreachable=<span class="hljs-number">0</span>    failed=<span class="hljs-number">0</span>    skipped=<span class="hljs-number">0</span>    rescued=<span class="hljs-number">0</span>    ignored=<span class="hljs-number">0</span>   <br><span class="hljs-number">47.100</span><span class="hljs-number">.98</span><span class="hljs-number">.242</span>              : ok=<span class="hljs-number">4</span>    changed=<span class="hljs-number">1</span>    unreachable=<span class="hljs-number">0</span>    failed=<span class="hljs-number">0</span>    skipped=<span class="hljs-number">0</span>    rescued=<span class="hljs-number">0</span>    ignored=<span class="hljs-number">0</span>   <br><br>[root@desktop-kh5f5dc ~]<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p><strong>上面这条命令的效果与上一小节中多条ad-hoc命令的效果是一样的。关于YAML的语法，如何编写playbook以及模块的使用方式等，将在本章的后续小节中进行详细讲解。在这一小节中，我们只需要知道Ansible有两种操作远程服务器的方式，分别是：ad-hoc与Playbook。</strong></p><h1>三、Inventory管理</h1><p><strong>在Ansible中，将可管理的服务器的集合称为Inventory。因此，Inventory管理便是服务器管理。这一节中，我们将会详细讨论Inventory管理。</strong></p><h2 id="1、hosts文件位置">1、hosts文件位置</h2><p><strong>我们已经演示了Ansible如何对远程服务器执行操作，可以看到，Ansible在执行操作是，首先需要确定对哪些服务器执行操作。默认情况下，Ansible读取/etc/ansible/hosts文件中的服务器配置，获取需要操作的服务器列表。Ansible定义与获取服务器列表的方式比这个要灵活得多。</strong></p><p><strong>在Ansible中，有3种方式制定hosts文件，分别是：</strong></p><blockquote><ul><li><strong>默认读取/etc/ansible/hosts文件；</strong></li></ul><ol start="2"><li><strong>通过命令行参数-i指定hosts文件；</strong></li><li><strong>通过ansible.cfg文件中的inventory选项（老版本的Ansible中通过hostfile选项指定）指定hosts文件。</strong></li></ol></blockquote><p><strong>例如：当前系统中除了/etc/ansible/hosts文件以外，在test用户的home目录下也存在一个名为hosts的文件，该hosts文件的内容如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[test]<br>127.0.0.1<br>192.168.1.80<br></code></pre></td></tr></table></figure><p><strong>使用/etc/ansible/hosts文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible test --list-hosts<br>  hosts (2):<br>    127.0.0.1<br>    192.168.1.80<br></code></pre></td></tr></table></figure><p><strong>-i选项指定hosts文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible test -i hosts --list-hosts<br>  hosts (2):<br>    127.0.0.1<br>    192.168.1.80<br></code></pre></td></tr></table></figure><p><strong>修改ansible.cfg文件，添加inventory选项，指定hosts文件的路径</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# vim /etc/ansible/ansible.cfg <br><br>[defaults]<br>remote_user = root<br>remote_port = 22<br>inventory = /etc/ansible/hosts<br></code></pre></td></tr></table></figure><h2 id="2、灵活定义hosts文件内容">2、灵活定义hosts文件内容</h2><h3 id="（1）分组定义服务器">（1）分组定义服务器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# vim /etc/ansible/hosts <br><br>[demo]<br>127.0.0.1<br>[xgp]<br>192.168.1.80<br>[wsd]<br>192.168.1.60<br></code></pre></td></tr></table></figure><h4 id="1）查看单个分组的服务器列表">1）查看单个分组的服务器列表</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible demo --list-hosts<br>  hosts (1):<br>    127.0.0.1<br>[root@python ~]# ansible xgp --list-hosts<br>  hosts (1):<br>    192.168.1.80<br>[root@python ~]# ansible wsd --list-hosts<br>  hosts (1):<br>    192.168.1.60<br>[root@python ~]# ansible all --list-hosts<br>  hosts (3):<br>    127.0.0.1<br>    192.168.1.80<br>    192.168.1.60<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200519163251885.png" alt="image-20200519163251885"></p><h4 id="2）查看多个分组的服务器列表（冒号分隔组名）">2）查看多个分组的服务器列表（冒号分隔组名）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible xgp:wsd -i hosts --list-hosts<br>  hosts (2):<br>    192.168.1.80<br>    192.168.1.60<br></code></pre></td></tr></table></figure><h4 id="3）使用all和星号匹配服务器">3）使用all和星号匹配服务器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible '*' -i hosts --list-hosts<br>[root@python ~]# ansible 'all' -i hosts --list-hosts<br>  hosts (3):<br>    127.0.0.1<br>    192.168.1.60<br>    192.168.1.80<br></code></pre></td></tr></table></figure><h3 id="（2）Ansible定义组匹配服务器">（2）Ansible定义组匹配服务器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# vim hosts<br>[demo]<br>127.0.0.1<br>[xgp]<br>192.168.1.80<br>[wsd]<br>192.168.1.60<br>[common:children]<br>xgp<br>wsd<br></code></pre></td></tr></table></figure><h4 id="查看服务器列表">查看服务器列表</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible common -i hosts --list-hosts<br>  hosts (2):<br>    192.168.1.80<br>    192.168.1.60<br></code></pre></td></tr></table></figure><h3 id="（3）批量定义服务器">（3）批量定义服务器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# vim hosts<br><br>[demo]<br>127.0.0.1<br>[xgp]<br>192.168.1.80<br>[1:3].xgp.top<br>[wsd]<br>192.168.1.60<br>[a:d].xgp.top<br>[common:children]<br>xgp<br>wsd<br></code></pre></td></tr></table></figure><h4 id="查看服务列表">查看服务列表</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible xgp:wsd -i hosts --list-hosts<br>  hosts (9):<br>    192.168.1.80<br>    1.xgp.top<br>    2.xgp.top<br>    3.xgp.top<br>    192.168.1.60<br>    a.xgp.top<br>    b.xgp.top<br>    c.xgp.top<br>    d.xgp.top<br></code></pre></td></tr></table></figure><h2 id="3、灵活匹配hosts文件内容">3、灵活匹配hosts文件内容</h2><p><strong>Ansible还支持通配符和正则表达式等更灵活的方式来匹配服务器。</strong></p><p><strong>Ansible官方给出了ansible命令的语法格式：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible &lt;pattern_goes_here&gt; -m &lt;module_name&gt; -a &lt;arguments&gt;<br></code></pre></td></tr></table></figure><p><strong>例如：重启所有web服务器中的Apache进程：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ansible webservers -m service -a <span class="hljs-string">"name=httpd state=restarted"</span><br>ansible web*.duxuejun.com =-m service -a <span class="hljs-string">"name=httpd state=restarted"</span><br></code></pre></td></tr></table></figure><p><strong>远程服务器匹配规则：</strong></p><table><thead><tr><th>匹配规则</th><th>含义</th></tr></thead><tbody><tr><td>192.168.1.10 或者 <a href="http://web.duxuejun.com" target="_blank" rel="noopener">web.duxuejun.com</a></td><td>匹配目标IP地址或服务器名称，如果含有多个IP或服务器，使用“:”分隔</td></tr><tr><td>webservers</td><td>匹配目标为webservers，多个分组使用“:”分隔</td></tr><tr><td>all或者&quot;*&quot;</td><td>匹配所有的服务器</td></tr><tr><td>webservers:!dbservers</td><td>匹配在webservers中，不在dbservers组中的服务器</td></tr><tr><td>webservers:&amp;dbservers</td><td>匹配同时在webservers组以及dbservers组中的服务器</td></tr><tr><td>*.duxujun.com或192.168.*</td><td>使用通配符进行匹配</td></tr><tr><td>webservers[0],webservers[1:],webservers[-1]</td><td>使用索引或切片操作的方式匹配组中的服务器</td></tr><tr><td>~(web|db).*.duxuejun.com</td><td>以~开头的匹配，表示使用正则表达式匹配</td></tr></tbody></table><h2 id="4、Inventory行为参数">4、Inventory行为参数</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">参数</span>                             <span class="hljs-string">默认值                说明</span><br><span class="hljs-attr">ansible_ssh_host</span>                <span class="hljs-string">主机的名字            ssh的目的主机或ip</span><br><span class="hljs-attr">ansible_ssh_port</span>                <span class="hljs-string">22                  ssh目的端口</span><br><span class="hljs-attr">ansible_ssh_user</span>                <span class="hljs-string">root                ssh登陆使用的用户名</span><br><span class="hljs-attr">ansible_ssh_pass</span>                <span class="hljs-string">none                ssh认证所使用的密码</span><br><span class="hljs-attr">ansible_connection</span>              <span class="hljs-string">smart               Ansible使用何种连接模式连接到主机</span><br><span class="hljs-attr">ansible_ssh_private_key_file</span>    <span class="hljs-string">none                ssh认证所使用的私钥</span><br><span class="hljs-attr">ansible_shell_type</span>              <span class="hljs-string">sh                  命令所使用的shell</span><br><span class="hljs-attr">ansible_python_interpreter</span>      <span class="hljs-string">/usr/bin/python     主机上的python解释器</span><br><span class="hljs-meta">ansible_*_interpreter</span>           <span class="hljs-string">none                类似python解释器的其他语言版</span><br></code></pre></td></tr></table></figure><h2 id="5、改变行为参数的默认值">5、改变行为参数的默认值</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">可以在ansible.cfg文件的[defaults]部分更改一些行为参数的默认值</span>              <span class="hljs-string"></span><br><span class="hljs-meta">ansible.cfg文件</span>  <span class="hljs-string">inventory文件     </span><br><span class="hljs-attr">ansible_ssh_user</span>                <span class="hljs-string">remote_user</span><br><span class="hljs-attr">ansible_ssh_port</span>                <span class="hljs-string">remote_port</span><br><span class="hljs-attr">ansible_ssh_private_key_file</span>    <span class="hljs-string">private_key_file</span><br><span class="hljs-attr">ansible_shell_type</span>              <span class="hljs-string">executable</span><br></code></pre></td></tr></table></figure><h2 id="6、定义服务器变量">6、定义服务器变量</h2><p><strong>在hosts文件中，除了定义行为参数以外，还可以定义普通的变量，以便在不同的服务器中使用不同的配置。比如：可以在2台服务器中分别启动MySQL，1台服务器的MySQL的端口是3306，另一台服务器MySQL的端口是3307。定义普通参数和定义行为参数的方法是一样的，只是行为参数的名字有Ansible预先定义，普通参数的名称有我们自己定义。在Ansible中，参数名必须为字母、数字和下划线的组合，并且首字符必须为字母。</strong></p><h3 id="（1）变量的取值不同"><strong>（1）变量的取值不同</strong></h3><p><strong>假定，我们在/etc/ansible/hosts文件中为不同的服务器定义一个相同的变量名，但是取值不同。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# vim hosts<br><br>[test]<br>192.168.1.60 ansible_port=22<br>192.168.1.80 ansible_port=22<br></code></pre></td></tr></table></figure><p><strong>在测试环境中，我们可以通过echo方式显示变量的值。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible  test -i ./hosts -a 'echo &#123;&#123;ansible_port&#125;&#125;' <br>192.168.1.60 | CHANGED | rc=0 &gt;&gt;<br>22<br>192.168.1.80 | CHANGED | rc=0 &gt;&gt;<br>22<br></code></pre></td></tr></table></figure><h3 id="（2）变量的取值相同">（2）变量的取值相同</h3><p><strong>如果test组下的两个服务器mysql_port变量取值相同，我们也可以通过组的名称加上“:vars”后缀来定义变量，如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# vim hosts<br><br>[test]<br>192.168.1.40<br>192.168.1.80<br><br>[test:vars]<br>ansible_port = 22<br></code></pre></td></tr></table></figure><p><strong>随着业务的发展，管理的hosts文件越来越大，使用的变量越来越多了，依然使用一个hosts文件管理服务器和变量的话，就会逐渐变得难以管理。</strong></p><p><strong>Ansible提供了更好的方法来管理服务器和群组的变量，即：为每个服务器和群组创建独立的变量文件。其定义方式是，将组的变量存放在一个名为group_vars命令下，目录下的文件名与组的名称相同，文件的扩展名可以是.yml或.yaml，也可以没有任何扩展名。服务器的变量存放在一个名为host_vars目录下，该目录下的文件名为服务器的名称。</strong></p><p><strong>Ansible将依次在Playbook所在的目录、hosts文件所在的目录和/etc/ansible目录下寻找group_vars目录和host_vars目录。目前，假设group_vars目录和host_var目录都位于/etc/ansible目录下。</strong></p><p><strong>对于我们前面定义mysql_port变量的例子，将变量存放在独立的文件以后，/etc/ansible目录的结构如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@192 ansible]# tree<br>.<br>├── ansible.cfg<br>├── group_vars<br>│   └── test.yaml<br>├── hosts<br>└── host_vars<br>    └── 127.0.0.1.yaml<br></code></pre></td></tr></table></figure><p><strong>其中，test.yaml文件定义了hosts文件中test组的变量，127.0.0.1.yaml文件定义了hosts文件中127.0.0.1这台服务器使用的变量。如：test.yaml文件的内容如下：</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">[root@192</span> <span class="hljs-string">ansible]#</span> <span class="hljs-string">cat</span> <span class="hljs-string">group_vars/test.yaml</span> <br><span class="hljs-attr">ansible_port:</span> <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p><strong>注意：我们在hosts文件中定义变量时，使用的是“var = value”格式定义。将变量保存在一个独立的文件时，使用的是“var:value”格式定义。这是因为Ansible解析这两个文件时，认为hosts是一个ini格式的文件，而保存变量的文件是一个YAML格式的文件。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible  test -i ./hosts -a 'echo &#123;&#123;ansible_port&#125;&#125;' <br>192.168.1.40 | CHANGED | rc=0 &gt;&gt;<br>22<br>192.168.1.80 | CHANGED | rc=0 &gt;&gt;<br>22<br></code></pre></td></tr></table></figure><h1>四、YAML语法</h1><h2 id="1、YAML语法规则">1、YAML语法规则</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. YAML文件第一行为“---”，表示这是一个YAML文件；<br>2. YAML中字段大小写敏感；<br>3. YAML与Python一样，通过缩进来表示层级关系；<br>4. YAML的缩进不允许使用Tab键，只允许使用空格，且空格的数目不重要，只要相同层级的元素左侧对齐即可；<br>5. “#”表示注释，从这个字符一直到行尾都会被解析器忽略<br></code></pre></td></tr></table></figure><h2 id="2、YAML支持的3中格式数据">2、YAML支持的3中格式数据</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. 对象：键值对的集合，有称为映射，类似于Python中的字典；<br>2. 数组：一组按次序排列的值，有称为序列（sequence），类似于Python的列表；<br>3. 纯量（scalars）：单个的、不可再分的值，比如：字符串、布尔值与数字。<br></code></pre></td></tr></table></figure><h2 id="3、安装PyYAML库">3、安装PyYAML库</h2><p><strong>Python标准库没有包含解析YAML格式的库，需要安装第三方的PyYAML库。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip3 install -i https://pypi.douban.com/simple/ PyYAML<br></code></pre></td></tr></table></figure><h2 id="4、定义与解析YAML文件"><strong>4、定义与解析YAML文件</strong></h2><h3 id="（1）数组格式"><strong>（1）数组格式</strong></h3><p><strong>使用YAML表示数组非常容易，只需要用“-”将元素按序列出即可。假设我们有下面这样一个YAML文件，文件的内容保存在一个名为data.yaml的文件中，如下所示：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-comment"># 一个美味的水果列表</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">Apple</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">Orange</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">Strawberry</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">Mango</span><br></code></pre></td></tr></table></figure><h4 id="解析结果：">解析结果：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> yaml                                                                <br><br>In [<span class="hljs-number">2</span>]: <span class="hljs-keyword">with</span> open(<span class="hljs-string">'data.yaml'</span>) <span class="hljs-keyword">as</span> f: <br>   ...:     print(yaml.load(f)) <br>   ...:                                                                            <br>[<span class="hljs-string">'Apple'</span>, <span class="hljs-string">'Orange'</span>, <span class="hljs-string">'Strawberry'</span>, <span class="hljs-string">'Mango'</span>]<br></code></pre></td></tr></table></figure><h3 id="（2）对象">（2）对象</h3><p><strong>在YAML中，对象以“key:value”的形式进行定义，如下所示：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-comment"># 一个职工的记录</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">爱运维</span><br><span class="hljs-attr">job:</span> <span class="hljs-string">devops</span><br><span class="hljs-attr">skill:</span> <span class="hljs-string">Elite</span><br><span class="hljs-attr">age:</span> <span class="hljs-number">23</span><br><span class="hljs-attr">knowoop:</span> <span class="hljs-literal">True</span><br><span class="hljs-attr">likes_emacs:</span> <span class="hljs-literal">TRUE</span><br><span class="hljs-attr">users_cvs:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h4 id="解析结果：-2">解析结果：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">3</span>]: <span class="hljs-keyword">with</span> open(<span class="hljs-string">'dev.yaml'</span>) <span class="hljs-keyword">as</span> f: <br>   ...:     print(yaml.load(f)) <br>   ...:<br>&#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'爱运维'</span>, <span class="hljs-string">'job'</span>: <span class="hljs-string">'devops'</span>, <span class="hljs-string">'skill'</span>: <span class="hljs-string">'Elite'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">23</span>, <span class="hljs-string">'knowoop'</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">'likes_emacs'</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">'users_cvs'</span>: <span class="hljs-literal">False</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>YAML中可以使用多种方式制定布尔值，如以上YAML文件中的“True”、“TRUE”、“false”，转换为Python代码后，对变量的取值进行了格式化。</strong></p><h3 id="（3）对象和数组嵌套">（3）对象和数组嵌套</h3><p><strong>YAML中的对象和数组是可以任意嵌套的，如下所示：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-comment"># 一个职工的记录</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">爱运维</span><br><span class="hljs-attr">job:</span> <span class="hljs-string">devops</span><br><span class="hljs-attr">skill:</span> <span class="hljs-string">Elite</span><br><span class="hljs-attr">age:</span> <span class="hljs-number">23</span><br><span class="hljs-attr">knowoop:</span> <span class="hljs-literal">True</span><br><span class="hljs-attr">likes_emacs:</span> <span class="hljs-literal">TRUE</span><br><span class="hljs-attr">users_cvs:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">foods:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Apple</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Orange</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Strawberry</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Mango</span><br><span class="hljs-attr">languages:</span><br>    <span class="hljs-attr">ruby:</span> <span class="hljs-string">Elite</span><br>    <span class="hljs-attr">python:</span> <span class="hljs-string">Elite</span><br>    <span class="hljs-attr">shell:</span> <span class="hljs-string">Lame</span><br></code></pre></td></tr></table></figure><h3 id="（4）注意事项">（4）注意事项</h3><p><strong>在YAML中定义字符串的时候，不需要使用单引号或者双引号，直接将字符串写在文件中即可。如下所示：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">str:</span> <span class="hljs-string">this</span> <span class="hljs-string">is</span> <span class="hljs-string">a</span> <span class="hljs-string">string</span><br></code></pre></td></tr></table></figure><p><strong>如果字符串中包含了特殊字符，需要使用双引号包含起来。比如：字符串中包含冒号。冒号是YAML中的特殊字符，因此需要使用双引号包含起来。</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">foo:</span> <span class="hljs-string">"somebody said I should put a colon here: so I did"</span><br></code></pre></td></tr></table></figure><p><strong>如果字符串内容比较长，可以使用“&gt;”来折叠换行。</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">that:</span> <span class="hljs-string">&gt;</span><br>    <span class="hljs-string">Foo</span><br>    <span class="hljs-string">Bar</span><br></code></pre></td></tr></table></figure><p><strong>将以上YAML文件转换为Python的内部对象后，“Foo”和“Bar”都是字符串的一部分。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">'that'</span>: <span class="hljs-string">'Foo Bar\n'</span>&#125;<br></code></pre></td></tr></table></figure><h1>五、Ansible模块</h1><h2 id="1、Ansible的模块工作原理">1、Ansible的模块工作原理</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. 将模块拷贝到远程服务器<br>2. 执行模块定义的操作，完成对服务器的修改<br>3. 在远程服务器删除模块<br></code></pre></td></tr></table></figure><p><strong>Ansible中的模块是幂等的，也就是说，多次执行相同的操作，只有第一次会起作用。这也是在编写自定义的Ansible模块的时候需要注意的。</strong></p><h2 id="2、模块列表与帮助信息"><strong>2、模块列表与帮助信息</strong></h2><p><strong>Ansible模块非常多，如果以模块的功能进行分类的话，可以分为以下模块：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs txt">云模块<br>命令模块<br>数据库模块<br>文件模块<br>资产模块<br>消息模块<br>监控模块<br>网络模块<br>通知模块<br>包管理模块<br>源码控制模块<br>系统模块<br>单元模块<br>web设施模块<br>Windows模块<br>……<br></code></pre></td></tr></table></figure><p><strong>查看Ansible模块帮助信息，如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@python ~]<span class="hljs-comment"># ansible-doc -l</span><br></code></pre></td></tr></table></figure><p><strong>查看指定模块的帮助信息，如下所示</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@python ~]<span class="hljs-comment"># ansible file</span><br>[WARNING]: Could <span class="hljs-keyword">not</span> match supplied host pattern, ignoring: file<br>[WARNING]: No hosts matched, nothing to do<br>usage: ansible [-h] [--version] [-v] [-b] [--become-method BECOME_METHOD] [--become-user BECOME_USER] [-K] [-i INVENTORY]<br>               [--list-hosts] [-l SUBSET] [-P POLL_INTERVAL] [-B SECONDS] [-o] [-t TREE] [-k]<br>               [--private-key PRIVATE_KEY_FILE] [-u REMOTE_USER] [-c CONNECTION] [-T TIMEOUT]<br>               [--ssh-common-args SSH_COMMON_ARGS] [--sftp-extra-args SFTP_EXTRA_ARGS] [--scp-extra-args SCP_EXTRA_ARGS]<br>               [--ssh-extra-args SSH_EXTRA_ARGS] [-C] [--syntax-check] [-D] [-e EXTRA_VARS] [--vault-id VAULT_IDS]<br>               [--ask-vault-<span class="hljs-keyword">pass</span> | --vault-password-file VAULT_PASSWORD_FILES] [-f<br></code></pre></td></tr></table></figure><h2 id="3、常用的Ansible模块">3、常用的Ansible模块</h2><p><strong>Ansible提供的功能越丰富，所需要的模块也就越多。默认情况下，模块存储在/usr/share/ansible目录中。</strong></p><h3 id="（1）ping">（1）ping</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible test -m ping<br>192.168.1.40 | SUCCESS =&gt; &#123;<br>    "ansible_facts": &#123;<br>        "discovered_interpreter_python": "/usr/bin/python"<br>    &#125;, <br>    "changed": false, <br>    "ping": "pong"<br>&#125;<br>Enter passphrase for key '/root/.ssh/id_rsa': <br>192.168.1.80 | SUCCESS =&gt; &#123;<br>    "ansible_facts": &#123;<br>        "discovered_interpreter_python": "/usr/bin/python"<br>    &#125;, <br>    "changed": false, <br>    "ping": "pong"<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（2）远程命令模块">（2）远程命令模块</h3><h4 id="1）command模块">1）command模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ansible test -m command -a <span class="hljs-string">'hostname'</span><br>ansible test -m command -a <span class="hljs-string">'/sbin/shutdown -t now'</span><br>ansible test -a <span class="hljs-string">'hostname'</span><br></code></pre></td></tr></table></figure><p><strong>command模块在执行Linux命令时，不能使用管道。如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ansible test -m command -a <span class="hljs-string">'cat /etc/passwd | wc -l'</span><br></code></pre></td></tr></table></figure><p><strong>执行后报错如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.40</span> | FAILED | rc=<span class="hljs-number">1</span> &gt;&gt;<br>cat：无效选项 -- l<br>Try <span class="hljs-string">'cat --help'</span> <span class="hljs-keyword">for</span> more information.non-zero <span class="hljs-keyword">return</span> code<br><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.80</span> | FAILED | rc=<span class="hljs-number">1</span> &gt;&gt;<br>cat：无效选项 -- l<br>Try <span class="hljs-string">'cat --help'</span> <span class="hljs-keyword">for</span> more information.non-zero <span class="hljs-keyword">return</span> code<br></code></pre></td></tr></table></figure><h4 id="2）raw模块">2）raw模块</h4><p><strong>如果执行的命令需要使用管道，可以使用raw模块，如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@python ~]<span class="hljs-comment">#  ansible test -m raw -a 'cat /etc/passwd | wc -l'</span><br><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.80</span> | CHANGED | rc=<span class="hljs-number">0</span> &gt;&gt;<br><span class="hljs-number">45</span><br>Shared connection to <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.80</span> closed.<br><br><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.40</span> | CHANGED | rc=<span class="hljs-number">0</span> &gt;&gt;<br><span class="hljs-number">44</span><br>Shared connection to <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.40</span> closed.<br></code></pre></td></tr></table></figure><p><strong>raw模块相当于使用ssh直接执行Linux命令，不会进入到Ansible的模块的子系统中。</strong></p><h4 id="3）shell模块">3）shell模块</h4><p><strong>除了使用raw模块以外，也可以使用shell模块，如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@python ~]<span class="hljs-comment"># ansible test -m shell -a 'cat /etc/passwd | wc -l'</span><br><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.40</span> | CHANGED | rc=<span class="hljs-number">0</span> &gt;&gt;<br><span class="hljs-number">44</span><br><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.80</span> | CHANGED | rc=<span class="hljs-number">0</span> &gt;&gt;<br><span class="hljs-number">45</span><br></code></pre></td></tr></table></figure><p><strong>shell模块还可以执行远程服务器上的shell脚本，其中，脚本文件的路径需要使用绝对路径，如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible test -m shell -a '/home/test/test.sh'<br></code></pre></td></tr></table></figure><h4 id="统计某个文件有多少行">统计某个文件有多少行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible common -m raw -a 'cat /etc/passwd | wc -l'<br>192.168.1.40 | CHANGED | rc=0 &gt;&gt;<br>43<br>Shared connection to 192.168.1.40 closed.<br><br>192.168.1.80 | CHANGED | rc=0 &gt;&gt;<br>45<br>Shared connection to 192.168.1.80 closed.<br><br>[root@python ~]# ansible common -m shell -a 'cat /etc/passwd | wc -l'<br>192.168.1.40 | CHANGED | rc=0 &gt;&gt;<br>43<br>192.168.1.80 | CHANGED | rc=0 &gt;&gt;<br>45<br></code></pre></td></tr></table></figure><p><strong>引用文件的方式</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# vim test.sh <br><br><span class="hljs-meta">#</span><span class="bash">!/usr/bin/bash</span><br>cat /etc/passwd | wc -l<br>[root@python ~]# ansible common -m script -a 'test.sh'<br>192.168.1.40 | CHANGED =&gt; &#123;<br>    "changed": true, <br>    "rc": 0, <br>    "stderr": "Shared connection to 192.168.1.40 closed.\r\n", <br>    "stderr_lines": [<br>        "Shared connection to 192.168.1.40 closed."<br>    ], <br>    "stdout": "43\r\n", <br>    "stdout_lines": [<br>        "43"<br>    ]<br>&#125;<br>192.168.1.80 | CHANGED =&gt; &#123;<br>    "changed": true, <br>    "rc": 0, <br>    "stderr": "Shared connection to 192.168.1.80 closed.\r\n", <br>    "stderr_lines": [<br>        "Shared connection to 192.168.1.80 closed."<br>    ], <br>    "stdout": "45\r\n", <br>    "stdout_lines": [<br>        "45"<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="（3）file">（3）file</h5><p><strong>file模块主要用于对远程服务器上的文件（包括链接和目录）进行操作，包括修改文件的权限、修改文件的所有者、创建文件、删除文件等。</strong></p><h4 id="file模块使用示例："><strong>file模块使用示例：</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个目录</span><br>ansible test -m file -a <span class="hljs-string">'path=/tmp/dd state=directory mode=0o755'</span><br><br><span class="hljs-comment"># 修改文件的权限</span><br>ansible test -m file -a <span class="hljs-string">"path=/tmp/dd state=touch mode='u=rw,g=r,o=r'"</span><br><br><span class="hljs-comment"># 创建一个软链接</span><br>ansible test -m file -a <span class="hljs-string">'src=/tmp/dd dest=/tmp/dd1 state=link owner=root group=root'</span><br><br><span class="hljs-comment"># 修改一个文件的所有者</span><br>ansible test -m file -a <span class="hljs-string">"path=/tmp/dd owner=root group=root mode=0o644"</span> -become<br></code></pre></td></tr></table></figure><h4 id="file模块中重要选项："><strong>file模块中重要选项：</strong></h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. path: 指定文件/目录的路径<br>2. recurse: 递归设置文件属性，只对目录有效<br>3. group: 定义文件/目录的组<br>4. mode: 定义文件/目录的权限<br>5. owner: 定义文件/目录的所有者<br>6. src: 要被链接的源文件路径，只应用于state为link的情况<br>7. dest: 被链接到的路径，只应用于state为link的情况<br>8. force: 在两种情况下会强制创建软链接，一种情况是源文件不存在，但之后会建立的情况；另一种情况是目标软链接已经存在，需要先取消了之前的软链接，然后再创建新的软链接，默认取值为no<br>9. state: 该选项有多个取值，包括directory、file、link、hard、touch、absent。各个取值的含义如下：取值为directory，如果目录不存在，创建目录；取值为file时，即使文件不存在也不会被创建；取值为link时，创建软链接；取值为hard时，创建硬链接；取值为touch时，如果文件不存就创建一个新文件，如果文件或目录已经存在，更新其最后访问时间和修改时间；取值为absent时，删除目录、文件或者链接<br></code></pre></td></tr></table></figure><h4 id="1-创建文件">&lt;1&gt;创建文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible  common -m file -a 'path=/opt/test.md state=touch'<br></code></pre></td></tr></table></figure><h5 id="查看一下">查看一下</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200520213902203.png" alt="image-20200520213902203"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200520213917288.png" alt="image-20200520213917288"></p><h4 id="2-创建目录">&lt;2&gt;创建目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible  common -m file -a 'path=/opt/test mode=0755 state=directory'<br></code></pre></td></tr></table></figure><h5 id="查看一下-2">查看一下</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200520214344689.png" alt="image-20200520214344689"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200520214401233.png" alt="image-20200520214401233"></p><h4 id="3-创建并删除文件">&lt;3&gt;创建并删除文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible  common -m file -a 'path=/opt/abc mode=0640 state=touch'<br>//创建<br></code></pre></td></tr></table></figure><h5 id="查看一下-3"><strong>查看一下</strong></h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200520215349872.png" alt="image-20200520215349872"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200520215415349.png" alt="image-20200520215415349"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible  common -m file -a 'path=/opt/abc mode=0640 state=absent'<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200520215645645.png" alt="image-20200520215645645"></p><h4 id="4-创建并改变文件所有者">&lt;4&gt;创建并改变文件所有者</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible  common -m file -a 'path=/opt/abc mode=0640 state=touch'<br><br>[root@python ~]# ansible  common -m file -a 'path=/opt/abc mode=0640 owner=test group=root' -become<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200520220049916.png" alt="image-20200520220049916"></p><h3 id="（4）copy">（4）copy</h3><p><strong>copy模块用来将主控节点的文件或者目录拷贝到远程服务器上，类似于Linux下的scp命令。但是，copy模块比scp命令更强大，在拷贝文件到远程服务器上的同时，也可以设置文件在远程服务器上的权限和所有者。</strong></p><p><strong>copy模块的使用示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 拷贝文件到远程服务器</span><br>ansible test -m copy -a <span class="hljs-string">'src=test.sh dest=/tmp/test.sh'</span><br><br><span class="hljs-comment"># 拷贝文件到远程服务器，如果远程服务器已经存在这个文件，则备份文件</span><br>ansible test -m copy -a <span class="hljs-string">'src=test.sh dest=/tmp/test.sh backup=yes force=yes'</span><br><br><span class="hljs-comment"># 拷贝文件到远程服务器，并且修改文件的所有者和权限</span><br>ansible test -m copy -a <span class="hljs-string">'src=tes.sh dest=/tmp/tes.sh owner=root group=root mode=644 force=yes'</span> -become<br></code></pre></td></tr></table></figure><p><strong>copy模块中重要选项：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. src：要复制到远程服务器的文件地址，可以是绝对路径，也可以是相对路径。如果路径时一个目录，将递归复制。在这种情况下，如果使用“/”结尾，则复制目录里的内容；如果没有用“/”来结尾，则将包含目录在内的整个内容复制，类似于rsync<br>2. dest：文件要复制到的目的地，必须是一个绝对路径，如果源文件是一个目录，那么dest指向的也必须是一个目录<br>3. force：默认取值为yes，表示目标主机包含该文件，但是内容不同时，会强制覆盖；如果该选项设置为no，只有当目标主机的目标位置不存在该文件时，才会进行复制<br>4. backup：默认取值为no，如果取值为yes，那么在覆盖之前将原文件进行备份<br>5. directory_mode：递归设定目录权限，默认为系统默认权限<br>6. others：所有file模块里的选项都可以在这里使用<br></code></pre></td></tr></table></figure><h3 id="（5）user-group"><strong>（5）user/group</strong></h3><p><strong>user模块请求的是useradd、userdel、usermod这三个指令，group模块请求的是groupadd、groupdel、groupmod这三个指令。</strong></p><p><strong>user/group模块的使用示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个用户</span><br>ansible test -m user -a <span class="hljs-string">'name=John comment="John Doe" uid=1239 group=root'</span> -become<br><br><span class="hljs-comment"># 删除一个用户</span><br>ansible test -m user -a <span class="hljs-string">'name=John state=absent'</span> -become<br><br><span class="hljs-comment"># 创建一个用户，并且产生一对密钥</span><br>ansible test -m user -a <span class="hljs-string">'name=John comment="John Doe" generate_ssh_key=yes ssh_key_bits=2048'</span> -become<br><br><span class="hljs-comment"># 创建群组</span><br>ansible test -m group -a <span class="hljs-string">'name=ansible state=present gid=1234'</span> -become<br><br><span class="hljs-comment"># 删除群组</span><br>ansible test -m group -a <span class="hljs-string">'name=ansible state=absent'</span> -become<br></code></pre></td></tr></table></figure><p><strong>user/group模块重要选项：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. name：需要操作的用户名或群组名<br>2. comment：用户的描述信息<br>3. createhome：创建用户时，是否创建家目录，默认为yes<br>4. home：指定用户的家目录，需要与createhome选项配合使用<br>5. group：指定用户的属组<br>6. uid：设置用户的id<br>7. gid：设置群组的id<br>8. password：设置用户的密码<br>9. state：是创建用户或群组，还是删除用户后群组，取值包括present和absent<br>10. expires：用户的过期时间<br>11. shell：指定用户的shell环境<br></code></pre></td></tr></table></figure><h3 id="（6）yum"><strong>（6）yum</strong></h3><p><strong>yum模块可以帮助我们在远程主机上通过yum源管理软件包。</strong></p><p><strong>yum模块使用示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 安装软件包</span><br>ansible test -m yum -a <span class="hljs-string">'name=nginx disable_gpg_check=yes'</span><br>ansible test -m yum -a <span class="hljs-string">'name=nginx state=present disable_gpg_check=yes'</span><br>ansible test -m yum -a <span class="hljs-string">'name=nginx state=installed disable_gpg_check=yes'</span><br>ansible test -m yum -a <span class="hljs-string">'name=nginx state=latest disable_gpg_check=yes'</span><br><br><span class="hljs-comment"># 卸载软件包</span><br>ansible test70 -m yum -a <span class="hljs-string">'name=nginx state=absent'</span><br>ansible test70 -m yum -a <span class="hljs-string">'name=nginx state=removed'</span><br></code></pre></td></tr></table></figure><p><strong>yum模块重要选项：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. name：必须参数，用于指定需要管理的软件包，比如nginx<br>2. state：用于指定软件包的状态 ，默认值为present，表示确保软件包已经安装，除了present，其他可用值有installed、latest、absent、removed，其中installed与present等效，latest表示安装yum中最新的版本，absent和removed等效，表示删除对应的软件包<br>3. disable_gpg_check：用于禁用对rpm包的公钥gpg验证，默认值为no，表示不禁用验证，设置为yes表示禁用验证，即不验证包，直接安装，在对应的yum源没有开启gpg验证的情况下，需要将此参数的值设置为yes，否则会报错而无法进行安装<br>4. enablerepo：用于指定安装软件包时临时启用的yum源，假如你想要从A源中安装软件，但是你不确定A源是否启用了，你可以在安装软件包时将此参数的值设置为yes，即使A源的设置是未启用，也可以在安装软件包时临时启用A源<br>5. disablerepo：用于指定安装软件包时临时禁用的yum源，某些场景下需要此参数，比如，当多个yum源中同时存在要安装的软件包时，你可以使用此参数临时禁用某个源，这样设置后，在安装软件包时则不会从对应的源中选择安装包<br>6. enablerepo参数和disablerepo参数可以同时使用<br></code></pre></td></tr></table></figure><h3 id="（7）get-url"><strong>（7）get_url</strong></h3><p><strong>从互联网上下载数据到本地，作用类似于Linux下的curl命令。get_url模块比curl命令更加灵活，可以控制下载以后的数据所有者、权限以及检查下载数据的checksum等。</strong></p><p><strong>get_url模块使用示例：</strong></p><blockquote><p><strong>为了进行get_url测试，使用命令“python -m http.server”启动一个下载服务器，将下载服务器中的文件地址传给url选项。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 下载文件到远程服务器</span><br>ansible test -m get_url -a <span class="hljs-string">'url=http://localhost:8000/data.tar.gz dest=/tmp/data.tar.gz'</span><br><br><span class="hljs-comment"># 下载文件到远程服务器，并且修改文件的权限</span><br>ansible test -m get_url -a <span class="hljs-string">'url=http://localhost:8000/data.tar.gz dest=/tmp/data.tar.gz mode=0777'</span><br><br><span class="hljs-comment"># 下载文件到远程服务器，并且检查文件的MD5校验是否与控制端的MD5校验相同</span><br>[root@bogon ~]<span class="hljs-comment"># md5sum s.txt</span><br>d41d8cd98f00b204e9800998ecf8427e  s.txt<br>[root@bogon ~]<span class="hljs-comment"># ansible 127.0.0.1 -m get_url -a 'url=http://localhost:8000/s.txt dest=/tmp/s.txt checksum=md5:d41d8cd98f00b204e9800998ecf8427e'</span><br>127.0.0.1 | CHANGED =&gt; &#123;<br>    <span class="hljs-string">"ansible_facts"</span>: &#123;<br>        <span class="hljs-string">"discovered_interpreter_python"</span>: <span class="hljs-string">"/usr/bin/python"</span><br>    &#125;,<br>    <span class="hljs-string">"changed"</span>: true,<br>    <span class="hljs-string">"checksum_dest"</span>: null,<br>    <span class="hljs-string">"checksum_src"</span>: <span class="hljs-string">"da39a3ee5e6b4b0d3255bfef95601890afd80709"</span>,<br>    <span class="hljs-string">"dest"</span>: <span class="hljs-string">"/tmp/s.txt"</span>,<br>    <span class="hljs-string">"elapsed"</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">"gid"</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">"group"</span>: <span class="hljs-string">"root"</span>,<br>    <span class="hljs-string">"md5sum"</span>: <span class="hljs-string">"d41d8cd98f00b204e9800998ecf8427e"</span>,<br>    <span class="hljs-string">"mode"</span>: <span class="hljs-string">"0644"</span>,<br>    <span class="hljs-string">"msg"</span>: <span class="hljs-string">"OK (0 bytes)"</span>,<br>    <span class="hljs-string">"owner"</span>: <span class="hljs-string">"root"</span>,<br>    <span class="hljs-string">"secontext"</span>: <span class="hljs-string">"unconfined_u:object_r:admin_home_t:s0"</span>,<br>    <span class="hljs-string">"size"</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">"src"</span>: <span class="hljs-string">"/root/.ansible/tmp/ansible-tmp-1584171703.8607588-137457225931919/tmpG3otIP"</span>,<br>    <span class="hljs-string">"state"</span>: <span class="hljs-string">"file"</span>,<br>    <span class="hljs-string">"status_code"</span>: <span class="hljs-number">200</span>,<br>    <span class="hljs-string">"uid"</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">"url"</span>: <span class="hljs-string">"http://localhost:8000/s.txt"</span><br>&#125;<br>[root@bogon ~]<span class="hljs-comment"># ansible 127.0.0.1 -m get_url -a 'url=http://localhost:8000/s.txt dest=/tmp/s.txt checksum=md5:d41d8cd98f00b204e9800998ecf84270'</span><br>127.0.0.1 | FAILED! =&gt; &#123;<br>    <span class="hljs-string">"ansible_facts"</span>: &#123;<br>        <span class="hljs-string">"discovered_interpreter_python"</span>: <span class="hljs-string">"/usr/bin/python"</span><br>    &#125;,<br>    <span class="hljs-string">"changed"</span>: false,<br>    <span class="hljs-string">"checksum_dest"</span>: <span class="hljs-string">"da39a3ee5e6b4b0d3255bfef95601890afd80709"</span>,<br>    <span class="hljs-string">"checksum_src"</span>: <span class="hljs-string">"da39a3ee5e6b4b0d3255bfef95601890afd80709"</span>,<br>    <span class="hljs-string">"dest"</span>: <span class="hljs-string">"/tmp/s.txt"</span>,<br>    <span class="hljs-string">"elapsed"</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">"msg"</span>: <span class="hljs-string">"The checksum for /tmp/s.txt did not match d41d8cd98f00b204e9800998ecf84277e; it was d41d8cd98f00b204e9800998ecf8427e."</span>,<br>    <span class="hljs-string">"src"</span>: <span class="hljs-string">"/root/.ansible/tmp/ansible-tmp-1584171717.7448506-78799482489470/tmpyczfH3"</span>,<br>    <span class="hljs-string">"url"</span>: <span class="hljs-string">"http://localhost:8000/s.txt"</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>get_url模块重要选项：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. dest：必传选项，指定将文件下载的绝对路径<br>2. url：必传选项，文件的下载地址（网址）<br>3. url_username: 用于http基本认证的用户名<br>4. url_password： 用于http基本认证的密码<br>5. validate_certs： 如果否，SSL证书将不会验证。这只应在使用自签名证书的个人控制站点上使用<br>6. owner： 指定属主<br>7. group： 指定属组<br>8. mode： 指定权限<br>9. checksum：文件的校验码<br>10. headers：传递给下载服务器的HTTP Headers<br>11. backup：如果本地已经存在同名文件，备份文件<br>12. timeout：下载的超时时间<br></code></pre></td></tr></table></figure><h3 id="（8）unarchive"><strong>（8）unarchive</strong></h3><p><strong>unarchive模块用于解压文件，其作用类似于Linux下的tar命令。默认情况下，unarchive的作用是将控制节点的压缩包拷贝到远程服务器，然后进行解压。</strong></p><p><strong>unarchive模块使用示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先创建一个目录</span><br>ansible test - m file -a <span class="hljs-string">'path=/tmp/data state=directory'</span><br><br><span class="hljs-comment"># 解压本地文件</span><br>ansible test - m unarchive -a <span class="hljs-string">'src=data.tar.gz dest=/tmp/data list_files=yes'</span><br><br><span class="hljs-comment"># 将本地文件拷贝到远程服务器</span><br>ansible test -m copy -a <span class="hljs-string">'src=data.tar.bz2 dest=/tmp/data.tar.bz2'</span><br><br><span class="hljs-comment"># 解压远程的文件</span><br>ansible test -m unarchive -a <span class="hljs-string">'src=/tmp/data.tar.bz2 dest=/tmp remote_src=yes'</span><br></code></pre></td></tr></table></figure><p><strong>unarchive模块重要选项：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. remote_src：该选项可以取值为yes或no，用来表示解压的文件存在远程服务器中，还是存在控制节点所在的服务器中。默认取值为no，表示在解压文件之前，先将控制节点的文件复制到远程主机中，然后在进行解压<br>2. src：指定压缩文件的路径，该选项的取值取决于remote_src的取值。如果remote_src取值为yes，则src指定的是远程服务器中压缩包的地址；如果remote_src的取值为no，则src指向的是控制节点中的路径<br>3. dest：该选项指定的是远程服务器上的绝对路径，表示压缩文件解压的路径<br>4. list_files：默认情况下该选项取值为no，如果该选项取值为yes，也会解压文件，并且在ansible的返回值中列出压缩包里的文件<br>5. exclude：解压文件时排除exclude选项指定的文件或目录列表<br>6. keep_newer：默认取值为False，如果该选项取值为True，那么当目标地址中存在同名的文件，并且文件比压缩包中的文件更新时，不进行覆盖<br>7. owner：文件或目录解压以后的所有者<br>8. group：文件或目录解压以后所属的群组<br>9. mode：文件或目录解压以后的权限<br></code></pre></td></tr></table></figure><h3 id="（9）git"><strong>（9）git</strong></h3><p><strong>git模块非常好理解，就是在远程服务器执行git相关的操作。该模块一般应用于需要源码安装软件时，从github这样的源码托管网站将软件下载到本地，然后执行命令进行源码安装。需要注意的是，该模块依赖于git软件，因此在使用该模块前应该使用yum模块先安装git软件。</strong></p><p><strong>git模块的使用示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#将requests克隆到/tmp/requests目录下</span><br>ansible test -m git -a <span class="hljs-string">'repo=https://github.com/psf/requests.git dest=/tmp/requests version=HEAD'</span><br><br><span class="hljs-comment"># 从源码安装requests</span><br>ansible test -a <span class="hljs-string">'python setup.py install chdir=/tmp/requests'</span> -become<br><br><span class="hljs-comment"># 验证requests是否安装成功</span><br>ansible test -a <span class="hljs-string">"python -c 'import requests'"</span><br></code></pre></td></tr></table></figure><p><strong>git模块常用选项：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. repo：远程git库的地址，可以是一个git协议、ssh协议或http协议的git库地址<br>2. dest：必选选项，git库clone到本地服务器以后保存的绝对路径<br>3. version：克隆远程git库的版本，取值可以为HEAD、分支的名称、tag的名称，也可以是一个commit的hash值<br>4. force：默认取值为no，当该选项取值为yes时，如果本地的git库有修改，将会抛弃本地的修改<br>5. accept_hostkey：当该选项取值为yes时，如果git库的服务器不在know_hosts中，则添加到konw_hosts中，key_file指定克隆远程git库地址是使用的私钥<br></code></pre></td></tr></table></figure><h3 id="（10）stat"><strong>（10）stat</strong></h3><p><strong>stat模块用于获取远程服务器上的文件信息，其作用类似于Linux下的stat命令。stat模块可以获取atime、ctime、mtime、checksum、size、uid、gid等信息。</strong></p><p><strong>stat只有path这一个必选选项，用来指定文件或目录的路径。stat模块的使用方法如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取文件的详细信息</span><br>ansible test -m stat -a <span class="hljs-string">'path=/etc/passwd'</span><br></code></pre></td></tr></table></figure><h3 id="（11）cron"><strong>（11）cron</strong></h3><p><strong>顾名思义，cron是管理Linux下计划任务的模块。</strong></p><p><strong>cron模块的使用示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 增加一个crontab任务</span><br>ansible test -m cron -a <span class="hljs-string">'backup=yes name="测试计划任务" minute=*/2 hour=* job="ls /tmp &gt;/dev/null"'</span><br><br><span class="hljs-comment"># 进入服务器，查看新增的crontab任务</span><br>crontab -l<br></code></pre></td></tr></table></figure><p><strong>该模块包含以下重要选项：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. backup：取值为yes或no，默认为no，表示修改之前先做备份<br>2. state：取值为present或absent，用来确认该任务计划是创建还是删除<br>3. name：该任务的描述<br>4. job：添加或删除任务，主要取决于state的取值<br>5. user：操作哪一个用户的crontab<br>6. cron_file：如果指定该选项，则用该文件替换远程主机上cron.d命令下的用户任务计划<br>7. month weekday 打印minute hour：取值与crontab类似。例如：对于minute的取值范围0~59，也可以选择“*”表示每分钟运行，或者“*/5”表示每5分钟运行<br></code></pre></td></tr></table></figure><h3 id="（12）service"><strong>（12）service</strong></h3><p><strong>service模块的作用类似于Linux下的service命令，用来启动、停止、重启服务。</strong></p><p><strong>service模块的使用示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 安装Apache，默认情况下，Apache安装完成以后就会启动</span><br>ansible test -m yum -a <span class="hljs-string">'name=httpd state=present'</span> -become<br><br><span class="hljs-comment"># 停止Apache</span><br>ansible test -m service -a <span class="hljs-string">'name=httpd state=stopped'</span><br><br><span class="hljs-comment"># 重启Apache</span><br>ansible <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> -m service -a <span class="hljs-string">'name=httpd state=restarted'</span><br></code></pre></td></tr></table></figure><p><strong>service模块的常用选项：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. name：服务的名称，该选项为必选项<br>2. state：可以取值为started、stopped、restarted和reload。其中，started和stopped是幂等的，也就是说，如果服务已经启动了，执行started不会执行任何操作<br>3. sleep：重启的过程中，先停止服务，然后sleep几秒在启动<br>4. pattern：定义一个模式，ansible首先通过status命令查看服务的状态，依次判断服务是否在运行。如果通过status查看服务状态时没有响应，ansible会尝试匹配ps命令的输出，当匹配到相应模式时，认为服务已经启动，否则认为服务没有启动<br>5. enabled：取值为yes或no，用来设置服务是否开机启动<br></code></pre></td></tr></table></figure><h3 id="（13）sysctl"><strong>（13）sysctl</strong></h3><p><strong>该模块的作用与Linux下的sysctl命令相似，用于控制Linux的内核参数。</strong></p><p><strong>sysctl模块使用示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置overcommit_memory参数的值为1</span><br>ansible test -m sysctl -a <span class="hljs-string">'name=vm.overcommit_memory value=1'</span> -become<br></code></pre></td></tr></table></figure><p><strong>sysctl模块的常用选项：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. name：需要设置的参数<br>2. value：需要设置的值<br>3. sysctl_file：sysctl.conf文件的绝对路径，默认路径是/etc/sysctl.conf<br>4. reload：该选项可以取值为yes或no，默认为yes，用于表示设置完成以后是否需要执行sysctl -p操作<br></code></pre></td></tr></table></figure><h3 id="（14）setup"><strong>（14）setup</strong></h3><p><strong>setup模块用于收集远程主机的信息</strong></p><p><strong>setup模块的使用示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取IP地址</span><br>ansible test -m setup -a <span class="hljs-string">'filter=ansible_default_ipv4'</span><br><br><span class="hljs-comment"># 获取内存信息</span><br>ansible test -m setup -a <span class="hljs-string">'filter=ansible_memory_mb'</span><br><br><span class="hljs-comment"># 获取主机完整信息</span><br>ansible test -m setup<br></code></pre></td></tr></table></figure><h3 id="（15）mount"><strong>（15）mount</strong></h3><p><strong>在远程服务器上挂载磁盘，当进行挂盘操作是，如果挂载点指定的路径不存在，将创建该路径。</strong></p><p><strong>mount模块使用示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 挂载/dev/vda盘到/mnt/data目录</span><br>ansible test -m mount -a <span class="hljs-string">'name=/mnt/data src=/dev/vda fstype=ext4 state=mounted'</span><br></code></pre></td></tr></table></figure><p><strong>mount模块常用选项：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. name：挂载点的路径<br>2. state：可以取值为present、absent、mounted、unmounted，其中，mounted与unmounted用来处理磁盘的挂载和卸载，并且会正确配置fstab文件，present与absent只会设置fstab文件，不会去操作磁盘<br>3. fstype：指定文件系统类型，当state取值为present或mounted时，该选项为必填选项<br>4. src：挂载的设备<br></code></pre></td></tr></table></figure><h3 id="（16）synchronize"><strong>（16）synchronize</strong></h3><p><strong>synchronize模块是对rsync命令的封装，以便对常见的rsync任务进行处理。我们也可以使用command模块调用rsync命令执行相应的操作。rsync是一个比较复杂的命令，相对来说，使用synchronize简单一些。</strong></p><p><strong>synchronize模块的使用示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#  同步本地目录到远程服务器</span><br>ansible test -m synchronize -a <span class="hljs-string">'src=test dest=/tmp'</span><br></code></pre></td></tr></table></figure><p><strong>synchronize模块的常用选项：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. src：需要同步到远程服务器的文件和目录<br>2. dest：远程服务器保存数据的路径<br>3. archive：默认取值为yes，相当于同时开启recursive、links、perms、times、owner、group、-D等选项<br>4. compress：默认为yes，表示在文件同步过程中是否启用压缩<br>5. delete：默认为no，当取值为yes时，表示删除dest中存在而src中不存在的文件<br></code></pre></td></tr></table></figure><h4 id="4、模块的返回值"><strong>4、模块的返回值</strong></h4><p><strong>Ansible通过模块来执行具体的操作，由于模块的功能千差万别，所以执行模块操作后，Ansible会根据不同的需要返回不同的结果。虽然如此，Ansible中也有一些常见的返回值。如下所示：</strong></p><table><thead><tr><th><strong>返回值的名称</strong></th><th><strong>返回值的含义</strong></th></tr></thead><tbody><tr><td><strong>changed</strong></td><td><strong>几乎所有的Ansible模块都会返回该变量，表示模块是否对远程主机执行了修改操作</strong></td></tr><tr><td><strong>failed</strong></td><td><strong>如果模块未能执行完成，将返回failed为True</strong></td></tr><tr><td><strong>msg</strong></td><td><strong>模块执行失败的原因，常见的错误如ssh连接失败，没有权限执行模块等</strong></td></tr><tr><td><strong>rc</strong></td><td><strong>与命令行工具相关的模块会返回rc，表示执行Linux命令的返回码</strong></td></tr><tr><td><strong>stdout</strong></td><td><strong>与rc类似，返回的是标准输出的结果</strong></td></tr><tr><td><strong>stderr</strong></td><td><strong>与rc类似，返回的是错误输出的结果</strong></td></tr><tr><td><strong>backup_file</strong></td><td><strong>所有存在backup选项的模块，用来返回备份文件的路径</strong></td></tr><tr><td><strong>results</strong></td><td><strong>应用在Playbook中存在循环的情况，返回多个结果</strong></td></tr></tbody></table><p><strong>错误的</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ansible  test -i hosts -a 'echo &#123;&#123;ansible_port&#125;&#125;'192.168.1.60 | CHANGED | rc=0 &gt;&gt;<br>22<br>192.168.1.80 | CHANGED | rc=0 &gt;&gt;<br>22<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> StorageClass </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python自动化管理sshy与paramiko</title>
      <link href="/posts/d003.html"/>
      <url>/posts/d003.html</url>
      
        <content type="html"><![CDATA[<h1>Python自动化管理sshy介绍</h1><h4 id="ssh优势："><strong>ssh优势：</strong></h4><ul><li><strong>安全传输文件</strong></li><li><strong>登录</strong></li><li><strong>批量执行命令</strong></li></ul><p><strong>对于一名刚开始接触Linux系统管理的工程师来说，他眼里的系统管理的步骤可能是：使用SSH登录服务器，修改应用相关的配置文件，执行一些Linux命令，重启相应的进程，最后退出服务器。如果还有更多的服务器，那么，就重复上述过程。</strong></p><p><strong>上面这一系列步骤是Linux系统管理的基础知识，是系统管理的基本功。但是，在实际工作中，一般不会手动对</strong><br><strong>服务器进行操作，而是使用程序进行自动化管理。即使服务器的数量很少，也推荐大家编写程序进行自动化。相对于手动管理服务器，自动化管理有许多优点。例如：</strong></p><h3 id="1）效率高："><strong>1）效率高：</strong></h3><p><strong>自动化操作效率比手动操作效率高。这里的效率高可以从两方面来理解：一方面是程序执行的效率比手动操作的效率高；另一方面是指对工程师来说，使用程序可以提高自身的工作效率，减少不必要的时间浪费。即使只有一台服务器，手动操作虽然可以很快完成，但其操作效率也不能与程序相提并论。如果管理的是服务器集群，显然，人工操作非常不现实，不但效率低下.而且枯操乏味，费时费力。程序的好处是一次编写，多次运行。虽然在编写程序的时候，花费的时间可能比单次手动操作的时间多，但是，只要程序编写完成，就可以多次反复地运行，节省大量时间。</strong></p><h3 id="2）不容易犯错："><strong>2）不容易犯错：</strong></h3><p><strong>俗话说“人无完人”，如果一直使用人工管理的方式管理服务器集群，那么，出错是不可避免的。工程师会有情绪的变化，也会有身体健康状况等问题，但程序不会。只要程序编写完成，并且考虑到了相应的异常，程序总是能够严格一致地执行管理操作。</strong></p><h3 id="3）享受乐趣："><strong>3）享受乐趣：</strong></h3><p><strong>从事计算机行业有一个天然的好处，那就是不用进行重复性的工作。有任何重复性的工作，找们都可以通过编写程序消灭掉。消灭重复性的工作，不但节省工作时间，还能够获得更多的乐趣和成就感。以管理服务器集群为例，看到自己编写的程序、指挥成百上千的服务器按照既定的需求执行操作，是不是有种指点江山、挥斥方遒的感觉？</strong></p><p><strong>这一章将会讨论如何使用Python批量管理服务器。首先，我们将会介绍批量管理服务器的基础知识，即SSH协议；随后，本章会介绍一个Python编写的批处理工具；然后将会介绍如何在Python程序中对远程服务器进行操作；在本章的最后，我们会介绍一个非常强大的系统管理工具，即Fabric,这一部分是本章的重点和难点。</strong></p><h1>一、使用SSH协议访问远程服务器</h1><p><strong>SSH ( Secure Shell)是一种由IETF的网络工作小组制定、创建在应用层和传输层基础上的安全协议，为计算机上的Shell提供安全的传输和使用环境。</strong></p><h2 id="1、SSH协议">1、SSH协议</h2><p><strong>在互联网早期，通信都是明文的，如rsh、 FTP、POP和Telnet。一旦通信报文被截获，内容就泄漏无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议。将登录信息全部加密，成为互联网安全的一个基本解决方案。这个方案迅速在全世界获得推广，目前已经成为Linux系统的标准配。</strong></p><p><strong>SSH只是一种协议，存在多种实现，既有商业实现也有开源实现。目前。在Linux下广泛使用的是OpenSSH，它是一款应用广泛的开源软件。本文即将介绍的paramiko是SSH协议的一种Python实现。</strong></p><p><strong>SSH除了提供安全的传输和登录以外，还可以进行批量命令执行，使用非常方便。正是由于SSH简单好用的特点，本章介绍的几个工具，以及稍后即将介绍的Ansible,都依赖SSH进行远程服务器的管理。使用SSH的好处非常明显，既充分利用了现成的机制，又省去了在远程服务器安装代理(Agent)程序。因此，诸多自动化工其都依赖SSH。</strong></p><h2 id="2、OpenSSH实现">2、OpenSSH实现</h2><p><strong>OpenSSH (OpenBSD Secure Shell)是OpenBSD的一个子项目，是SSH协议的开源实现。在服务端，OpenSSH启动sshd守护进程，该进程默认监听22端口。客户端使用用户名和密码连接服务端，连接成功以后，OpenSSH返回给用户一个Shell，用户可以使用该Shell在远程服务器执行命令。</strong></p><p><strong>在Debian系统中，OpenSSH的服务端默认读取/etc/ssh/sshd_config中的配置。在生产环境中，为了防止黑客攻击，一般会修改ssh服务的默认端口号，修改ssh服务默认端口号就是在/etc/ssh/sshd_config中完成的。我们也可以通过该配置文件禁止用户使用密码进行认证，只能使用密钥认证。修改完配置文件以后，执行下面的命令重启OpenSSH的守护进程才能生效：</strong></p><p><strong>对于一名刚开始接触Linux系统管理的工程师来说，他眼里的系统管理的步骤可能是：使用SSH登录服务器，修改应用相关的配置文件，执行一些Linux命令，重启相应的进程，最后退出服务器。如果还有更多的服务器，那么，就重复上述过程。</strong></p><p><strong>上面这一系列步骤是Linux系统管理的基础知识，是系统管理的基本功。但是，在实际工作中，一般不会手动对</strong><br><strong>服务器进行操作，而是使用程序进行自动化管理。即使服务器的数量很少，也推荐大家编写程序进行自动化。相对于手动管理服务器，自动化管理有许多优点。例如：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/etc/init.d/ssh restart<br></code></pre></td></tr></table></figure><h4 id="OpenSSH的客户端是一个名为ssh可执行程序，我们可以使用ssh命令连接远程服务器。如下所示"><strong>OpenSSH的客户端是一个名为ssh可执行程序，我们可以使用ssh命令连接远程服务器。如下所示:</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ssh xgp@localhost <br>The authenticity of host 'localhost (::1)' can't be established.<br>ECDSA key fingerprint is bf:c7:de:84:e1:28:f4:d4:7e:41:49:9f:54:dc:e9:83.<br>Are you sure you want to continue connecting (yes/no)? yes<br>xgp@localhost's password: <br>[xgp@python ~]$<br></code></pre></td></tr></table></figure><h4 id="如果服务器端不是使用默认的22端口，可以通过SSH命令的-p参数指定建立连接的端口号，格式如下所示：">如果服务器端不是使用默认的22端口，可以通过SSH命令的-p参数指定建立连接的端口号，格式如下所示：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh username@remote_host -p 端口号<br></code></pre></td></tr></table></figure><h4 id="我们也可以不进入交互式的Shell，直接使用ssh命令在远程服务器中执行Linux命令，如下所示：">我们也可以不进入交互式的Shell，直接使用ssh命令在远程服务器中执行Linux命令，如下所示：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ssh root@192.168.1.80 'date'<br>root@192.168.79.129's password: <br>2020年 05月 15日 星期五 15:55:08 CST<br>s<br>[root@python ~]#<br></code></pre></td></tr></table></figure><h2 id="3、配置ssh的方法：">3、配置ssh的方法：</h2><ul><li><strong>编辑/etc/ssh/ssh_config</strong></li><li><strong>编辑~/.ssh/config</strong></li></ul><p><strong>ssh会读取/etc/ssh/ssh_config文件中的配置。例如，远程服务器使用的不是默认的22端口号，我们只需要在/etc/ssh/ssh_config进行简单的配置，就可以在连接远程服务器时省去指定端口号的参数。除了修/etc/ssh/ssh_config文件以外，更常见的做法是修改用户home目录下的~/.ssh/config文件。</strong></p><h3 id="查看ssh-config文件">查看ssh_config文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# find / -name ssh_config          #查看找ssh_config 文件<br>/etc/ssh/ssh_config<br>[root@python ~]# cat /etc/ssh/ssh_config | awk #<br>Usage: awk [POSIX or GNU style options] -f progfile [--] file ...<br>Usage: awk [POSIX or GNU style options] [--] 'program' file ...<br>POSIX options:GNU long options: (standard)<br>true-f progfile--file=progfile<br>true-F fs--field-separator=fs<br>true-v var=val--assign=var=val<br>Short options:GNU long options: (extensions)<br>true-b--characters-as-bytes<br>true-c--traditional<br>true-C--copyright<br>true-d[file]--dump-variables[=file]<br>true-e 'program-text'--source='program-text'<br>true-E file--exec=file<br>true-g--gen-pot<br>true-h--help<br>true-L [fatal]--lint[=fatal]<br>true-n--non-decimal-data<br>true-N--use-lc-numeric<br>true-O--optimize<br>true-p[file]--profile[=file]<br>true-P--posix<br>true-r--re-interval<br>true-S--sandbox<br>true-t--lint-old<br>true-V--version<br><br>To report bugs, see node `Bugs' in `gawk.info', which is<br>section `Reporting Problems and Bugs' in the printed version.<br><br>gawk is a pattern scanning and processing language.<br>By default it reads standard input and writes standard output.<br><br>Examples:<br>truegawk '&#123; sum += $1 &#125;; END &#123; print sum &#125;' file<br>truegawk -F: '&#123; print $1 &#125;' /etc/passwd<br></code></pre></td></tr></table></figure><p><strong>例如，我们经常要使用某一个用户名、端口号访问某一台远程服务器。为了省去记住服务器ip的负担，很多工程师会编写一个Shell脚本，在脚本中保存用户名、端口号和ip地址。在下次登录时，可以省去输入的烦恼。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# vim /opt/login.sh<br><span class="hljs-meta">#</span><span class="bash">!/usr/bin/bash</span><br><br>ssh test@127.0.0.1 -p 22<br><br>[root@python ~]# useradd test<br>[root@python ~]# passwd test<br>更改用户 test 的密码 。<br>新的 密码：<br>无效的密码： 密码少于 8 个字符<br>重新输入新的 密码：<br>passwd：所有的身份验证令牌已经成功更新。<br>[root@python ~]# sh /opt/login.sh <br>The authenticity of host '127.0.0.1 (127.0.0.1)' can't be established.<br>ECDSA key fingerprint is bf:c7:de:84:e1:28:f4:d4:7e:41:49:9f:54:dc:e9:83.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added '127.0.0.1' (ECDSA) to the list of known hosts.<br>test@127.0.0.1's password: <br>[test@python ~]$<br></code></pre></td></tr></table></figure><p><strong>对于这里的需求，还有更好的解决方案。命令会读取~/.ssh/config文件中配置，因此，我们可以在~/.ssh/config文件中提前配置好访问远程服务器的信息。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# cp /etc/ssh/ssh_config -p  ~/.ssh/config<br>[root@python ~]# vim  ~/.ssh/config <br><br>Host python<br>  ForwardAgent yes<br>  StrictHostKeyChecking no<br>  port 22<br>  User test<br>  Controlpath ~/.ssh/ssh-%r@%h:%p.sock<br><br>Host *<br>  StrictHostKeyChecking no<br>  HostName %h<br>  Port  22<br>  User  test<br>  Controlpath ~/.ssh/ssh-%r@%h:%p.sock<br></code></pre></td></tr></table></figure><p><strong>配置完成后，直接在命令行执行ssh host2就可以使用用户名test，以及端口号2092登录到10.166.224.14中。此外，我们还使用通配符的方式定义了ssh默认用户名与端口号。假设我们要使用用户名laoyu、端口号2092访问10.166.226.153，有了前面的配置以后，可以在命令行直接进行登录。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ssh python<br>Warning: Permanently added 'python,fe80::c64e:c937:2ea8:6676%ens33' (ECDSA) to the list of known hosts.<br>test@python's password: <br>Permission denied, please try again.<br>test@python's password: <br>Last login: Fri May 15 14:34:54 2020 from localhost<br>[test@python ~]$<br></code></pre></td></tr></table></figure><p><strong>可以看到，我们只需要在~/.ssh/config文件中进行简单的配置就能够有效提高工作效率。</strong></p><h2 id="4、使用密钥登录远程服务器">4、使用密钥登录远程服务器</h2><ul><li><strong>ssh使用密码</strong></li><li><strong>ssh不使用密码，使用密钥</strong></li></ul><p><strong>在上面的例子中，我们没有指定认证的方式，默认使用密码进行认证。在生产环境中一般不使用密码认证，一方面是因为密码认证没有密钥认证安全；另一方面，密码认证每次登录时都需要输入密码，比较繁琐。使用密钥认证，省去了输入密码的烦恼。因此，在生产环境中，一般会使用密钥进行登录。</strong></p><p><strong>密钥登录的原理也很简单，即事先将用户的公钥储存在远程服务器上（~/.ssh/authorized_keys文件)。使用密钥登录时，远程服务器会向用户发送一段随机字符串，SSH使用用户的私钥加密字符串后发送给远程服务器。远程服务器用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录Shell，不再要求密码。</strong></p><p><strong>OpenSSH除了提供服务端的sshd、客户端的SSH程序以外，还提供了若干与密钥认证相关的工其。其中，ssh-keygen是用来生成密钥对的工具。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ssh-keygen<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200515151959697.png" alt="image-20200515151959697"></p><p><strong>ssh-keygen执行完以后，用户的~/.ssh目录下会存在一个名为id_ rsa的私钥文件与一个名为id_rsa.pub的公钥文件。</strong></p><p><strong>接下来要做的是将公钥保存到远程服务器的~/.ssh/authorized_keys文件中。可以使用下面的命令将公钥保存到远程服务器的authorized_keys文件中：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]#  ssh root@192.168.1.80 'mkdir -p .ssh &amp;&amp; cat &gt;&gt;.ssh/authorized_keys' &lt;~/.ssh/id_rsa.pub <br>The authenticity of host '192.168.1.80 (192.168.1.80)' can't be established.<br>ECDSA key fingerprint is SHA256:UbtfIBIs2tGQU1m/SIvSZX72VUQ+r1fH/aIMxVbdobg.<br>ECDSA key fingerprint is MD5:56:10:49:b1:ae:f6:3c:d3:5e:2d:c5:d9:38:2c:45:e7.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added '192.168.1.80' (ECDSA) to the list of known hosts.<br>root@192.168.1.80's password: <br>[root@python ~]#<br></code></pre></td></tr></table></figure><p><strong>上面的命令是使用Shell脚本的方式将公钥保存到远程服务器，除此之外，OpenSSH专门提供了一个名为ssh-copy-id的工具。我们可以使用该工具将公钥保存到远程服务器中，这种方式比前面Shell脚本的方式更加方便。如下所示:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# <br>[root@python ~]# ssh-copy-id -i ~/.ssh/id_rsa.pub 192.168.1.80<br>/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed<br>/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys<br>root@192.168.1.80's password: <br><br>Number of key(s) added: 1<br><br>Now try logging into the machine, with:   "ssh '192.168.1.80'"<br>and check to make sure that only the key(s) you wanted were added.<br><br>[root@python ~]# rm -rf  ~/.ssh/config<br>[root@python ~]# ssh 192.168.1.80<br>Last login: Fri May 15 15:16:23 2020 from 192.168.1.80<br>[root@python ~]#<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200515152149576.png" alt="image-20200515152149576"></p><p><strong>配置私钥认证以后，就可以直接使用私钥进行登录。ssh命令会默认读取~/.ssh/id_rsa这个私钥文件。如果私钥文件保存在其他位置，或者是其他名称，可以使用-t参放指定私钥文件的地址。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh test@192.168.1.80 -p 22 -i ~/私钥文件所在的位置（含文件名）<br></code></pre></td></tr></table></figure><p><strong>使用私钥登录时需要注意，私钥文件与远程服务器中authorized_keys文件的权限都必须为600，否则登录会出错，这也是工程师使用私钥登录时最容易遇到的错误。</strong></p><h3 id="测试登陆一下">测试登陆一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# vim ~/.ssh/config <br><br>Host python<br>  ForwardAgent yes<br>  StrictHostKeyChecking no<br>  HostName 192.168.1.80<br>  Port 22<br>  User test<br>  Controlpath ~/.ssh/ssh-%r@%h:%p.sock<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200515150740257.png" alt="image-20200515150740257"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ssh python<br>test@192.168.1.80's password: <br>Last login: Fri May 15 14:49:17 2020 from fe80::c64e:c937:2ea8:6676%ens33<br>[test@python ~]$<br></code></pre></td></tr></table></figure><h3 id="查看公钥是否一致">查看公钥是否一致</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ssh 192.168.1.80<br>Last login: Fri May 15 15:16:23 2020 from 192.168.1.80<br><br>[root@python ~]# cat ~/.ssh/authorized_keys        #远程的<br>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCWLJAYWCpbRPQX8gDbr2mIyXMw/qEKd46u4QhcaDPY7CeGd/buIGsWsuz+DAcnowk095rIwspGGHOdt54s+aeXGXcsRh7Hpuf0Py20Krim+v2LIUQW8vQSJDj1HiQUSnNQNPT3HAm0aqQp8u2EZ0StLYtf/uYSbg6rSzW08mKwhBQkrP0olWb+hD4ak3LxA05OI/WnanGKqtqjLg+4MbgGK96fY53dKvwrdt9NWiuof3pLgTw9fTvPU6CD+cH4LmRg8IVhthlBRhrXPA7oa8gvupTvpMYdNPPUSBsVR2rBcimrUFwdOpzb6T30C7o566noRd3t3nNxkQ/HrKalo9Bn root@python<br><br>[root@python ~]# exit<br>登出<br>Connection to python closed.<br><br>[root@python ~]# cat ~/.ssh/id_rsa.pub              #本地的<br>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCWLJAYWCpbRPQX8gDbr2mIyXMw/qEKd46u4QhcaDPY7CeGd/buIGsWsuz+DAcnowk095rIwspGGHOdt54s+aeXGXcsRh7Hpuf0Py20Krim+v2LIUQW8vQSJDj1HiQUSnNQNPT3HAm0aqQp8u2EZ0StLYtf/uYSbg6rSzW08mKwhBQkrP0olWb+hD4ak3LxA05OI/WnanGKqtqjLg+4MbgGK96fY53dKvwrdt9NWiuof3pLgTw9fTvPU6CD+cH4LmRg8IVhthlBRhrXPA7oa8gvupTvpMYdNPPUSBsVR2rBcimrUFwdOpzb6T30C7o566noRd3t3nNxkQ/HrKalo9Bn root@python<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200515152641675.png" alt="image-20200515152641675"></p><h1>二、使用ssh-agent管理私钥</h1><p><strong>OpenSSH还提供了一个名为ssh-agent的程序，该程序可以简化SSH私钥的管理操作。ssh-agent是个长时间持续运行的守护进程(daemon)，它的唯一目的就是对私钥进行高速缓存。</strong></p><h3 id="使用ssh-agent有以下几个好处："><strong>使用ssh-agent有以下几个好处：</strong></h3><p><strong>（1）如果我们使用了一个加密的私钥，那么，使用这个私钥时将需要输入密码才能使用私钥文件。如果我们使用加密的私钥并且没有使用ssh-agent，那么将不得不在每次使用这个私钥时都输入密码。如果使用ssh-agent管理私钥，只需要在私钥加入到ssh-agent的那一刻输入密码，在之后的使用中都不用输入私钥的密码；</strong></p><p><strong>（2）如果我们有多台远程服务器与多个私钥文件，使用ssh-agent以后，不用在每次登录服务器时都使用-i参数指定使用哪一个私钥文件。ssh-agent将会尝试使用不同的私钥文件建立连接。直至成功；</strong></p><p><strong>（3）使用ssh-agent可以实现私钥转发功能。假设现在有三台服务器，分别是A, B, C。其中，A是我们的控制节点，我们可以在A上直接访问B，但是我们无法直接访问C。如果要访问C，就只能先登最B，再从B登录C。对于这种情况，是否需要在B中保存用户的私钥呢？对于这里的情况，我们可以使用agent forwarding。使用agent forwarding以后，不用将私钥保存到B服务器上，只需要在A中保存私钥，在B和C中保存公钥，便可在A中访问B与C这两台服务器。为了使用agent forwarding，我们必须使用ssh-agent管理私钥。</strong></p><p><strong>如果在Windows下使用Xshell进行SSH访问，要启动ssh-agent非常简单，只需要在“连接“–&gt;&quot;SSH“中勾选“使用密码处理的Xagent (SSH代理)”即可。</strong></p><h3 id="（1）先把原先的密钥删除并生成新的密钥">（1）先把原先的密钥删除并生成新的密钥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python .ssh]# cd ~/.ssh/<br>[root@python .ssh]# rm -rf id*<br>[root@python .ssh]# ssh-keygen <br>Generating public/private rsa key pair.<br>Enter file in which to save the key (/root/.ssh/id_rsa): <br>Enter passphrase (empty for no passphrase): <br>Enter same passphrase again: <br>Your identification has been saved in /root/.ssh/id_rsa.<br>Your public key has been saved in /root/.ssh/id_rsa.pub.<br>The key fingerprint is:<br>dc:57:da:10:e5:1a:8b:15:e3:98:61:d4:02:9f:56:8f root@python<br>The key's randomart image is:<br>+--[ RSA 2048]----+<br>|        .o+.=..  |<br>|         o.B.B   |<br>|          *.E +  |<br>|       . o o O   |<br>|        S o = .  |<br>|           .     |<br>|                 |<br>|                 |<br>|                 |<br>+-----------------+<br>[root@python .ssh]# ssh-copy-id -i id_rsa.pub 192.168.1.80<br>/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed<br>/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys<br>root@192.168.1.80's password: <br><br>Number of key(s) added: 1<br><br>Now try logging into the machine, with:   "ssh '192.168.1.80'"<br>and check to make sure that only the key(s) you wanted were added.<br><br>[root@python .ssh]# ssh 192.168.1.80<br>Enter passphrase for key '/root/.ssh/id_rsa': <br>Last login: Fri May 15 15:28:54 2020 from fe80::c64e:c937:2ea8:6676%ens33<br>[root@python ~]# exit<br>登出<br>Connection to 192.168.1.80 closed.<br></code></pre></td></tr></table></figure><p><em><strong>现在登陆需要私钥</strong></em></p><h4 id="（2）使用ssh-agent保存密钥">（2）使用ssh-agent保存密钥</h4><p><strong>在Linux下，直接执行ssh-agent命令启动ssh-agent即可。启动以后，使用ssh-add命令将私钥添加到ssh-agent中。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ssh-agent bash<br>[root@python ~]# ssh-add ~/.ssh/id_rsa<br>Enter passphrase for /root/.ssh/id_rsa: <br>Identity added: /root/.ssh/id_rsa (/root/.ssh/id_rsa)<br>[root@python ~]#<br></code></pre></td></tr></table></figure><p><strong>私钥添加完成后，可以执行ssh_add -L命令查看哪些私钥已经被添加到ssh-agent中。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ssh-add -L<br>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDsP4VSOhnnCfidbg7e0OAQFcW5wAgPHld9S8KDTWv3X0/LNilYM3RkXQZ10XQ8Mw34i9rXa3SfqaHk6QYHXjNEUv6PEA/rKWY3kLXH9VUVHry4iwt9kVg9PowfccKLXPi8iWpqS7tk5ZEAnxihBtQattMTC44iz9X6hJDEn1r3r3YplJJGilIR+NaYJrM3ltxUBVuoJ82MfHOomhirc37ihLEwNbqRBMPYC4u1SoXDkagFsh0+HcuE0436yEByFxFw87jPmrjl7bgFsPahQsydrXySXOVdCzQJ8WuzJa1RvKr0xmgCjhZKExUYnMGAN9M79UBAyzZf2vUrwvvpPqWd /root/.ssh/id_rsa<br></code></pre></td></tr></table></figure><p><strong>启动ssh-agent以后，当我们尝试与远程服务器建立连接时，ssh客户端将会尝试使用存储在ssh-agent中的私钥与远程服务器进行认证。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# ssh 192.168.1.80<br>Last login: Fri May 15 15:38:28 2020 from 192.168.1.80<br>[root@python ~]# exit<br>登出<br>Connection to 192.168.1.80 closed.<br></code></pre></td></tr></table></figure><p><em><strong>现在因为本地保持了私钥，所以不需要输入私钥了</strong></em></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200515154547748.png" alt="image-20200515154547748"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的网络</title>
      <link href="/posts/5943.html"/>
      <url>/posts/5943.html</url>
      
        <content type="html"><![CDATA[<h1>一、端口扫描</h1><p><strong>仅仅知道网络上的主机是否可达还不够，很多情况下，我们需要的是一个端口扫描器。使用端口扫描器吋以进行安全检测与攻击防范。例如，在2017年5月12日，全球范围内爆发了基于Windows网络共享协议的永恒之蓝（Wannacry)勒索蠕虫。仅仅五个小时，包 括美国、中国、俄罗斯以及整个欧洲在内的100多个国家都不问程度地遭受永恒之蓝病毒攻击，尤其是高校、大型企业内网和政府机构专网，被攻击的电脑被勒索支付高额赎金才能解密恢复文件，对重要数据造成严重损失。永恒之蓝利用Windows系统的445端口进行蠕虫攻击，部分运营商已经在主干网络上封禁了 445端口，但是教育网以及大量企业内网并没有此限制，从而导致了永恒之蓝勒索蠕虫的泛滥。</strong></p><p><strong>所以作为工程师，一方面需要在日常维护养成良好的习惯，如配置防火墙、进行网络隔离、关闭不必要的服务、及时更新补丁；另一方面可以掌握一些安全相关的工具，在日常中进行安全防范，在紧急悄况下进行安全检测。在这一小节，我们将介绍如何使用Python进行端口扫描。有了端口扫描器，我们可以快速了解主机打开了哪些不必要的端口，以便及时消灭安全隐患。</strong><br><strong>在这一小节中，我们将使用Python语言编写一个端口扫描器，然后介绍大名鼎鼎的端 口扫描工具nmap，最后，通过python-nmap在Python代码中调用nmap进行端口扫描。</strong></p><h2 id="1、使用nmap扫描端口">1、使用nmap扫描端口</h2><p><strong>Python-nmap模块是对nmap命令的封装。nmap是知名的网络探测和安全扫描程序, 是Network Mapper的简称。nmap可以进行主机发现（Host Discovery)、端口扫描（Port Scanning)、版本侦测（Version Detection〉、操作系统侦测（Operating System Detection)，nmap是网络管理员必用的软件之一。nmap因为功能强大、跨平台、开源、文档丰富等诸多优点，在安全领域使用非常广泛。</strong><br><strong>在使用之前，需要先安装nmap。如下所示：</strong></p><h3 id="（1）安装namp">（1）安装namp</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-bash-4.2# yum -y install nmap<br></code></pre></td></tr></table></figure><p><strong>nmap的使用非常灵活，功能又很强大，因此nmap有很多命令行选项。使用nmap时， 首先需要确定要对哪些主机进行扫描，然后确定怎么进行扫描（如使用何种技术，对哪些端 口进行扫描）。</strong><br><strong>nmap具有非常灵活的方式指定需要扫描的主机，我们可以使用nmap命令的-sL选项 来进行测试。-sL选项仅仅打印IP列表，不会进行任何操作。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">Starting Nmap 6.40 ( http://nmap.org ) at 2020-05-14 16:57 CST<br>Nmap scan report for 192.168.0.0 (192.168.0.0)<br>Nmap scan report for 192.168.0.1 (192.168.0.1)<br>Nmap scan report for 192.168.0.2 (192.168.0.2)<br>Nmap scan report for 192.168.0.3 (192.168.0.3)<br>Nmap done: 4 IP addresses (0 hosts up) scanned in 2.01 seconds<br>-bash-4.2# nmap -sL 192.168.1.80/30<br><br>Starting Nmap 6.40 ( http://nmap.org ) at 2020-05-14 16:57 CST<br>Nmap scan report for 192.168.1.80 (192.168.1.80)<br>Nmap scan report for 192.168.1.81 (192.168.1.81)<br>Nmap scan report for 192.168.1.82 (192.168.1.82)<br>Nmap scan report for 192.168.1.83 (192.168.1.83)<br>Nmap done: 4 IP addresses (0 hosts up) scanned in 2.01 seconds<br></code></pre></td></tr></table></figure><p><strong>nmap提供了非常灵活的方式来指定主机，包括同时指定多个IP、通过网段指定主机、通过通配符指定主机等。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">nmap -sL 47.100.98.242 14.215.177.39<br>nmap -sL 47.100.98.*<br>nmap -sL 47.100.98.242,243,245<br>nmap -sL 47.100.98.242-250<br>nmap -sL 47.100.98.* --exclude 47.100.98.242<br>nmap -sL 47.100.98.242/30<br></code></pre></td></tr></table></figure><p><strong>除了上面指定主机的方式，我们也可以将IP地址保存到文本中，通过-iL选项读取文件中的IP地址。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">-bash-4.2# vim ip.list <br><br>192.168.1.80<br>127.0.0.1<br><br>-bash-4.2# nmap -iL ip.list<br><br>Starting Nmap 6.40 ( http://nmap.org ) at 2020-05-14 21:32 CST<br>Nmap scan report for 192.168.1.80 (192.168.1.80)<br>Host is up (0.0000050s latency).<br>Not shown: 997 closed ports<br>PORT     STATE SERVICE<br>22/tcp   open  ssh<br>111/tcp  open  rpcbind<br>8888/tcp open  sun-answerbook<br><br>Nmap scan report for localhost (127.0.0.1)<br>Host is up (0.0000060s latency).<br>Not shown: 995 closed ports<br>PORT     STATE SERVICE<br>22/tcp   open  ssh<br>25/tcp   open  smtp<br>111/tcp  open  rpcbind<br>631/tcp  open  ipp<br>8888/tcp open  sun-answerbook<br></code></pre></td></tr></table></figure><h3 id="（2）扫描连续端口">（2）扫描连续端口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-bash-4.2# nmap -p20-25 47.100.98.242<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200514170033706.png" alt="image-20200514170033706"></p><h3 id="（3）不进行端口扫描，仅仅判断主机是否可达">（3）不进行端口扫描，仅仅判断主机是否可达</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">nmap -sL ip<br>nmap -sn ip<br></code></pre></td></tr></table></figure><h4 id="测试">测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">-bash-4.2# nmap -sL 192.168.1.80<br><br>Starting Nmap 6.40 ( http://nmap.org ) at 2020-05-14 17:03 CST<br>Nmap scan report for 192.168.1.80 (192.168.1.80)<br>Nmap done: 1 IP address (0 hosts up) scanned in 2.01 seconds<br>-bash-4.2# nmap -sn 192.168.1.80<br><br>Starting Nmap 6.40 ( http://nmap.org ) at 2020-05-14 17:03 CST<br>Nmap scan report for 192.168.1.80 (192.168.1.80)<br>Host is up.<br>Nmap done: 1 IP address (1 host up) scanned in 2.01 seconds<br></code></pre></td></tr></table></figure><h3 id="（4）主机发现">（4）主机发现</h3><p><strong>端口扫描是nmap的重点，除此之外，我们也可以使用nmap检查网络上所有在线的主机，实现类似前边小节中列出网络上所有活跃的主机的功能。使用-sP或-sn选项可以告诉nmap不要进行端口扫描，仅仅判断主机是否可达。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@bogon ~]# nmap -sP 47.100.98.*<br>Starting Nmap 6.40 ( http://nmap.org ) at 2020-03-01 00:25 CST<br>Nmap done: 256 IP addresses (0 hosts up) scanned in 206.44 seconds<br>    <br>[root@bogon ~]# nmap -sn 47.100.98.*<br>Starting Nmap 6.40 ( http://nmap.org ) at 2020-03-01 00:35 CST<br>Nmap done: 256 IP addresses (0 hosts up) scanned in 205.38 seconds<br></code></pre></td></tr></table></figure><h3 id="（5）端口扫描">（5）端口扫描</h3><p><strong>端口扫描是nmap最基本，也是最核心的功能，用于确定目标主机TCP/UDP端口的开放情况。不添加任何参数便是对主机进行端口扫描。默认情况下，nmap将会扫描1000个最常用的端口号。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@192 ~]# nmap 10.166.224.140<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200514170803473.png" alt="image-20200514170803473"></p><p><strong>在进行端口扫描时，nmap提供了大M的参数控制端口扫描。包括端口扫描协议、端口扫描类型、扫描的端口号。如下所示：</strong></p><blockquote><p><strong>端口扫描协议：T (TCP)、U (UDP)、S (SCTP&gt;、P (IP);</strong></p><p><strong>端口扫描类型：-sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans;</strong></p><p><strong>扫描的端口号：-p 80,443 -p 80-160</strong></p></blockquote><p><strong>nmap中的端口扫描协议、扫描类型和端口号相关的选项，可以结合起来使用。如下所示：</strong></p><blockquote><p><strong>-p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9</strong></p></blockquote><p><strong>nmap通过探测将端口划分为6个状态，下表给出了每个状态的含义。</strong></p><table><thead><tr><th>端口状态</th><th>状态含义</th></tr></thead><tbody><tr><td>open</td><td>端口是开放的</td></tr><tr><td>closed</td><td>端口是关闭的</td></tr><tr><td>filtered</td><td>端口被防火墙IDS/IPS屏蔽，无法确认其状态</td></tr><tr><td>unfiltered</td><td>端口没有被屏蔽，但是否开放需要进一步确定</td></tr><tr><td>open|filtered</td><td>端口是开放的或被屏蔽</td></tr><tr><td>closed|filtered</td><td>端口是关闭的或被屏蔽</td></tr></tbody></table><p><strong>在进行端口扫描时，可以使用不同的端口扫描类型。常见的端口扫描类型如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">TCP SYNC SCAN:半开放扫描，这种类沏的扫描为发送一个SYN包，启动一个TCP会话，并等待响应的数据包。如果收到的是一个reset包，表明端口是关闭的; 如果收到的是一个SYNC&#x2F;ACK包，则表示端口是打开的。<br>TCP NULL SCAN: NULL扫描把TCP头中的所有标志位都设置为NULL。如果收到的是一个RST包，则表示相应的端口是关闭的。<br>TCP FIN SCAN : TCP FIN扫描发送一个表示结束一个活跃的TCP连接的FIN包， 让对方关闭连接。如果收到了一个RST包，则表示相应的端口是关闭的。 TCPXMASSCAN: TCPXMAS扫描发送PSH、FIN、URG和TCP标志位被设置为1的数据包，如果收到一个RST包，则表示相砬端口是关闭的。<br></code></pre></td></tr></table></figure><h3 id="（6）版本侦测">（6）版本侦测</h3><p><strong>nmap在进行端口扫描时，还可以进行版本侦测。版本监测功能用于确定开放端口上运行的应用程序及版本信息。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">-bash-4.2# nmap -sV 10.166.224.140<br><br>Starting Nmap 6.40 ( http://nmap.org ) at 2020-05-14 17:06 CST<br>Nmap scan report for 10.166.224.140 (10.166.224.140)<br>Host is up (0.00038s latency).<br>All 1000 scanned ports on 10.166.224.140 (10.166.224.140) are filtered<br><br>Service detection performed. Please report any incorrect results at http://nmap.org/submit/ .<br>Nmap done: 1 IP address (1 host up) scanned in 6.13 seconds<br></code></pre></td></tr></table></figure><h3 id="（7）操作系统监测">（7）操作系统监测</h3><p><strong>操作系统侦测用于监测主机运行的操作系统类型及设备类型等信息。nmap拥有丰富的系统数据库，可以识别2600多种操作系统与设备类型。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">-bash-4.2# nmap -sO 192.168.1.80<br><br>Starting Nmap 6.40 ( http://nmap.org ) at 2020-05-14 17:05 CST<br>Nmap scan report for 192.168.1.80 (192.168.1.80)<br>Host is up (0.000018s latency).<br>Not shown: 249 closed protocols<br>PROTOCOL STATE         SERVICE<br>1        open          icmp<br>2        open|filtered igmp<br>6        open          tcp<br>17       open          udp<br>103      open|filtered pim<br>136      open|filtered udplite<br>255      open|filtered unknown<br><br>Nmap done: 1 IP address (1 host up) scanned in 3.21 seconds<br></code></pre></td></tr></table></figure><h2 id="2、使用python-nmap进行端口扫描">2、使用python-nmap进行端口扫描</h2><p><strong>我们在上一小节中，花f较多的篇幅介绍nmap。Python的Python-nmap仅仅趋对nmap的封装，因此，要使用Python-nmap,必须先了解nmap。Python-nmap相对于nmap, 主要的改进在于对输出结果的处理。Python-nmap将nmap的输出结果保存到宇典之中，我们只需要通过Python的字典就可以获取到nmap的输出信息，不用像Shell脚本一样通过字符串处理和正则表达式来解析nmap的结果。Python-nmap将nmap的强大功能与Python语言优秀的表达能力进行了完美的结合，使用Python语言丰富的数据结构保存结果，以便后续继续进行处理，如使用Python-nmap生成相关的报告。</strong></p><p><strong>Python-nmap是开源的库，因此，在使用之前需要手动进行安装。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip3 install python-nmap<br></code></pre></td></tr></table></figure><p><strong>Python-nmap的使用非常简单，我们只要创建一个PortScarmer对象，并调用对象的 scan方法就能够完成基本的nmap端口扫描。如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python">-bash<span class="hljs-number">-4.2</span><span class="hljs-comment"># ipython</span><br>Python <span class="hljs-number">3.8</span><span class="hljs-number">.1</span> (default, Mar  <span class="hljs-number">9</span> <span class="hljs-number">2020</span>, <span class="hljs-number">12</span>:<span class="hljs-number">35</span>:<span class="hljs-number">12</span>) <br>Type <span class="hljs-string">'copyright'</span>, <span class="hljs-string">'credits'</span> <span class="hljs-keyword">or</span> <span class="hljs-string">'license'</span> <span class="hljs-keyword">for</span> more information<br>IPython <span class="hljs-number">7.13</span><span class="hljs-number">.0</span> -- An enhanced Interactive Python. Type <span class="hljs-string">'?'</span> <span class="hljs-keyword">for</span> help.<br><br>In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> nmap                                              <br><br>In [<span class="hljs-number">2</span>]: nm = nmap.PortScanner()                                  <br><br>In [<span class="hljs-number">3</span>]: nm.scan(<span class="hljs-string">'192.168.1.80'</span>,<span class="hljs-string">'22-1000'</span>)                        <br>Out[<span class="hljs-number">3</span>]: <br>&#123;<span class="hljs-string">'nmap'</span>: &#123;<span class="hljs-string">'command_line'</span>: <span class="hljs-string">'nmap -oX - -p 22-1000 -sV 192.168.1.80'</span>,<br>  <span class="hljs-string">'scaninfo'</span>: &#123;<span class="hljs-string">'tcp'</span>: &#123;<span class="hljs-string">'method'</span>: <span class="hljs-string">'syn'</span>, <span class="hljs-string">'services'</span>: <span class="hljs-string">'22-1000'</span>&#125;&#125;,<br>  <span class="hljs-string">'scanstats'</span>: &#123;<span class="hljs-string">'timestr'</span>: <span class="hljs-string">'Thu May 14 17:13:44 2020'</span>,<br>   <span class="hljs-string">'elapsed'</span>: <span class="hljs-string">'8.15'</span>,<br>   <span class="hljs-string">'uphosts'</span>: <span class="hljs-string">'1'</span>,<br>   <span class="hljs-string">'downhosts'</span>: <span class="hljs-string">'0'</span>,<br>   <span class="hljs-string">'totalhosts'</span>: <span class="hljs-string">'1'</span>&#125;&#125;,<br> <span class="hljs-string">'scan'</span>: &#123;<span class="hljs-string">'192.168.1.80'</span>: &#123;<span class="hljs-string">'hostnames'</span>: [&#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'192.168.1.80'</span>,<br>     <span class="hljs-string">'type'</span>: <span class="hljs-string">'PTR'</span>&#125;],<br>   <span class="hljs-string">'addresses'</span>: &#123;<span class="hljs-string">'ipv4'</span>: <span class="hljs-string">'192.168.1.80'</span>&#125;,<br>   <span class="hljs-string">'vendor'</span>: &#123;&#125;,<br>   <span class="hljs-string">'status'</span>: &#123;<span class="hljs-string">'state'</span>: <span class="hljs-string">'up'</span>, <span class="hljs-string">'reason'</span>: <span class="hljs-string">'localhost-response'</span>&#125;,<br>   <span class="hljs-string">'tcp'</span>: &#123;<span class="hljs-number">22</span>: &#123;<span class="hljs-string">'state'</span>: <span class="hljs-string">'open'</span>,<br>     <span class="hljs-string">'reason'</span>: <span class="hljs-string">'syn-ack'</span>,<br>     <span class="hljs-string">'name'</span>: <span class="hljs-string">'ssh'</span>,<br>     <span class="hljs-string">'product'</span>: <span class="hljs-string">'OpenSSH'</span>,<br>     <span class="hljs-string">'version'</span>: <span class="hljs-string">'6.6.1'</span>,<br>     <span class="hljs-string">'extrainfo'</span>: <span class="hljs-string">'protocol 2.0'</span>,<br>     <span class="hljs-string">'conf'</span>: <span class="hljs-string">'10'</span>,<br>     <span class="hljs-string">'cpe'</span>: <span class="hljs-string">'cpe:/a:openbsd:openssh:6.6.1'</span>&#125;,<br>    <span class="hljs-number">111</span>: &#123;<span class="hljs-string">'state'</span>: <span class="hljs-string">'open'</span>,<br>     <span class="hljs-string">'reason'</span>: <span class="hljs-string">'syn-ack'</span>,<br>     <span class="hljs-string">'name'</span>: <span class="hljs-string">'rpcbind'</span>,<br>     <span class="hljs-string">'product'</span>: <span class="hljs-string">''</span>,<br>     <span class="hljs-string">'version'</span>: <span class="hljs-string">'2-4'</span>,<br>     <span class="hljs-string">'extrainfo'</span>: <span class="hljs-string">'RPC #100000'</span>,<br>     <span class="hljs-string">'conf'</span>: <span class="hljs-string">'10'</span>,<br>     <span class="hljs-string">'cpe'</span>: <span class="hljs-string">''</span>&#125;&#125;&#125;&#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>当我们创建PortScanner对象时，Python-nmap会检査系统中是否已经安装了 nmap，如果没有安装，抛出PortScannerError异常。调用PortScanner对象的scan方法进行扫描以后就可以通过该类的其他方法获取本次扫描的信息。如命令行参数、主机列表、扫描的方法等。如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">4</span>]: nm.command_line()                                        <br>Out[<span class="hljs-number">4</span>]: <span class="hljs-string">'nmap -oX - -p 22-1000 -sV 192.168.1.80'</span><br><br>In [<span class="hljs-number">5</span>]: nm.scaninfo()                                            <br>Out[<span class="hljs-number">5</span>]: &#123;<span class="hljs-string">'tcp'</span>: &#123;<span class="hljs-string">'method'</span>: <span class="hljs-string">'syn'</span>, <span class="hljs-string">'services'</span>: <span class="hljs-string">'22-1000'</span>&#125;&#125;<br><br>In [<span class="hljs-number">6</span>]: nm.all_hosts()    <span class="hljs-comment">#所有主机                                       </span><br>Out[<span class="hljs-number">6</span>]: [<span class="hljs-string">'192.168.1.80'</span>]<br></code></pre></td></tr></table></figure><p><strong>Python-nmap还提供了以主机地址为键，获取单台主机的详细信息。包括获取主机网络状态、所有的协议、所有打开的端口号，端口号对应的服务等。如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">8</span>]: nm[<span class="hljs-string">'192.168.1.80'</span>].state()                               <br>Out[<span class="hljs-number">8</span>]: <span class="hljs-string">'up'</span><br><br>In [<span class="hljs-number">9</span>]: nm[<span class="hljs-string">'192.168.1.80'</span>].all_protocols()                       <br>Out[<span class="hljs-number">9</span>]: [<span class="hljs-string">'tcp'</span>]<br><br>In [<span class="hljs-number">10</span>]: nm.scan(<span class="hljs-string">'47.100.98.242,127.0.0.2'</span>,<span class="hljs-string">'21-25'</span>)              <br>Out[<span class="hljs-number">10</span>]: <br>&#123;<span class="hljs-string">'nmap'</span>: &#123;<span class="hljs-string">'command_line'</span>: <span class="hljs-string">'nmap -oX - -p 21-25 -sV 47.100.98.242,127.0.0.2'</span>,<br>  <span class="hljs-string">'scaninfo'</span>: &#123;<span class="hljs-string">'error'</span>: [<span class="hljs-string">'Failed to resolve "47.100.98.242,127.0.0.2".\nWARNING: No targets were specified, so 0 hosts scanned.\n'</span>],<br>   <span class="hljs-string">'warning'</span>: [<span class="hljs-string">'WARNING: No targets were specified, so 0 hosts scanned.\n'</span>],<br>   <span class="hljs-string">'tcp'</span>: &#123;<span class="hljs-string">'method'</span>: <span class="hljs-string">'syn'</span>, <span class="hljs-string">'services'</span>: <span class="hljs-string">'21-25'</span>&#125;&#125;,<br>  <span class="hljs-string">'scanstats'</span>: &#123;<span class="hljs-string">'timestr'</span>: <span class="hljs-string">'Thu May 14 17:22:06 2020'</span>,<br>   <span class="hljs-string">'elapsed'</span>: <span class="hljs-string">'16.00'</span>,<br>   <span class="hljs-string">'uphosts'</span>: <span class="hljs-string">'0'</span>,<br>   <span class="hljs-string">'downhosts'</span>: <span class="hljs-string">'0'</span>,<br>   <span class="hljs-string">'totalhosts'</span>: <span class="hljs-string">'0'</span>&#125;&#125;,<br> <span class="hljs-string">'scan'</span>: &#123;&#125;&#125;<br><br><br>In [<span class="hljs-number">11</span>]: nm[<span class="hljs-string">'192.168.1.80'</span>].key()  <br>Out[<span class="hljs-number">11</span>]: dict_keys([<span class="hljs-string">'hostnames'</span>, <span class="hljs-string">'addresses'</span>, <span class="hljs-string">'vendor'</span>, <span class="hljs-string">'status'</span>, <span class="hljs-string">'tcp'</span>])<br></code></pre></td></tr></table></figure><h1>二、使用IPy进行IP管理</h1><p><strong>在网络设计中，首先要做的就是规划IP地址。IP地址规划的好坏直接影响路由算法的效率，包括网络性能和扩展性。在IP地址规划中，需要进行大量的IP地址计算，包括网段、网络掩码、广播地址、子网数、IP类型等计算操作。在大量的计算操作中，如果没有一个好的工具，计算IP地址是一个很无趣有容易出错的事情。在Perl语言中，可以使用NET::IP模块，在Python语言中，可以使用开源的IPy模块进行操作。</strong></p><h2 id="1、IPy模块介绍">1、IPy模块介绍</h2><p><strong>IPy模块是一个处理IP地址的模块，它能够自动识别IP地址的版本、IP地址的类型。使用IPy模块，可以方便地进行IP地址的计算。</strong></p><p><strong>IPy模块是第三方的开源模块，因此，在使用之前需要进行安装。直接使用pip安装即可：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install ipy<br></code></pre></td></tr></table></figure><h2 id="2、IPy模块的基本使用">2、IPy模块的基本使用</h2><p><strong>IPy模块有一个IP类，这个类几乎可以接受任何格式的IP地址和网段。如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> IPy <br>    <br>In [<span class="hljs-number">2</span>]:<span class="hljs-keyword">from</span> IPy <span class="hljs-keyword">import</span> IP           <br><br>In [<span class="hljs-number">3</span>]: IP(<span class="hljs-number">0x7f000001</span>)               <br>Out[<span class="hljs-number">3</span>]: IP(<span class="hljs-string">'127.0.0.1'</span>)<br><br>In [<span class="hljs-number">4</span>]: IP(<span class="hljs-string">'127.0.0.1'</span>)               <br>Out[<span class="hljs-number">4</span>]: IP(<span class="hljs-string">'127.0.0.1'</span>)<br><br>In [<span class="hljs-number">5</span>]: IP(<span class="hljs-string">'127.0.0.0/30'</span>)             <br>Out[<span class="hljs-number">5</span>]: IP(<span class="hljs-string">'127.0.0.0/30'</span>)<br><br>In [<span class="hljs-number">6</span>]: IP(<span class="hljs-string">'1080:0:0:0:8:800:200C:417A'</span>)<br>Out[<span class="hljs-number">6</span>]: IP(<span class="hljs-string">'1080::8:800:200c:417a'</span>)<br><br>In [<span class="hljs-number">7</span>]: IP(<span class="hljs-string">'127.0.0.0-127.255.255.255'</span>)<br>Out[<span class="hljs-number">7</span>]: IP(<span class="hljs-string">'127.0.0.0/8'</span>)<br></code></pre></td></tr></table></figure><p><strong>IP类包含了许多的方法，用来进行灵活的IP地址操作。例如：</strong></p><h3 id="（1）version-获取IP地址的版本">（1）version:获取IP地址的版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">9</span>]: IP(<span class="hljs-string">'127.0.0.0-127.255.255.255'</span>) <br>Out[<span class="hljs-number">9</span>]: IP(<span class="hljs-string">'127.0.0.0/8'</span>)<br><br>In [<span class="hljs-number">10</span>]: IP(<span class="hljs-string">'10.0.0.0/8'</span>).version()  <br>Out[<span class="hljs-number">10</span>]: <span class="hljs-number">4</span><br><br>In [<span class="hljs-number">11</span>]: IP(<span class="hljs-string">'::1'</span>).version()        <br>Out[<span class="hljs-number">11</span>]: <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h3 id="（2）len-得到子网IP地址的个数">（2）len:得到子网IP地址的个数</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">In</span> <span class="hljs-selector-attr">[12]</span>: <span class="hljs-selector-tag">IP</span>(<span class="hljs-string">'127.0.0.0/30'</span>)<span class="hljs-selector-class">.len</span>()    <br><span class="hljs-selector-tag">Out</span><span class="hljs-selector-attr">[12]</span>: <span class="hljs-selector-tag">4</span><br>    <br><span class="hljs-selector-tag">In</span> <span class="hljs-selector-attr">[13]</span>: <span class="hljs-selector-tag">IP</span>(<span class="hljs-string">'127.0.0.0/28'</span>)<span class="hljs-selector-class">.len</span>()    <br><span class="hljs-selector-tag">Out</span><span class="hljs-selector-attr">[13]</span>: <span class="hljs-selector-tag">16</span><br></code></pre></td></tr></table></figure><h3 id="（3）iptype-返回IP地址的类型">（3）iptype:返回IP地址的类型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">14</span>]: IP(<span class="hljs-string">'127.0.0.1'</span>).iptype()    <br>Out[<span class="hljs-number">14</span>]: <span class="hljs-string">'LOOPBACK'</span><br><br>In [<span class="hljs-number">15</span>]: IP(<span class="hljs-string">'8.8.8.8'</span>).iptype()      <br>Out[<span class="hljs-number">15</span>]: <span class="hljs-string">'PUBLIC'</span><br></code></pre></td></tr></table></figure><h3 id="（4）int-返回IP地址的整数形式">（4）int:返回IP地址的整数形式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">16</span>]: IP(<span class="hljs-string">'8.8.8.8'</span>).int()         <br>Out[<span class="hljs-number">16</span>]: <span class="hljs-number">134744072</span><br></code></pre></td></tr></table></figure><h3 id="（5）strHex-返回IP地址的十六进制形式">（5）strHex:返回IP地址的十六进制形式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">17</span>]: IP(<span class="hljs-string">'8.8.8.8'</span>).strHex()    <br>Out[<span class="hljs-number">17</span>]: <span class="hljs-string">'0x8080808'</span><br></code></pre></td></tr></table></figure><h3 id="（6）strBin-返回IP地址的二进制形式">（6）strBin:返回IP地址的二进制形式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">18</span>]: IP(<span class="hljs-string">'8.8.8.8'</span>).strBin()<br>Out[<span class="hljs-number">18</span>]: <span class="hljs-string">'00001000000010000000100000001000'</span><br></code></pre></td></tr></table></figure><p><strong>有一个方便的函数能够将IP转换为不同的格式，在工作环境中将会非常有用。例如，以数宇的形式在数据库中存储IP地址，在数据库中存储IP地址有两种形式，第一种是以变长字符串的形式将IP地址保存到数据库中，另一种是将IP地址转换为整数以后保存到数据库中。将IP地址转换为整数进行存储能够有效地节省存储空间，提高数据库的存储效率和访问速度。因此，在最佳实践中，我们一般将IP地址以数字的形式保存到数据库中。需要 IP地址时，再将数字形式的IP地址转换为字符串格式的IP地址。这个需求十分常见，因 此，MySQL提供了两个函数，分别用以将字符串形式的IP地址转换为数据格式的IP地址，以及将数字格式的IP地址转换为字符串形式的IP地址。如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">mysql&gt; select INET_ATON(<span class="hljs-string">'10.166.224.14'</span>);<br>+----------------------------+<br>| INET_ATON(<span class="hljs-string">'10.166.224.14'</span>) |<br>+----------------------------+<br>|                  <span class="hljs-number">178708494</span> |<br>+----------------------------+<br><span class="hljs-number">1</span> row <span class="hljs-keyword">in</span> set (<span class="hljs-number">0.00</span> sec)<br><br>mysql&gt; select INET_NTOA(<span class="hljs-string">'178708494'</span>);<br>+------------------------+<br>| INET_NTOA(<span class="hljs-string">'178708494'</span>) |<br>+------------------------+<br>| <span class="hljs-number">10.166</span><span class="hljs-number">.224</span><span class="hljs-number">.14</span>          |<br>+------------------------+<br><span class="hljs-number">1</span> row <span class="hljs-keyword">in</span> set (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p><strong>除了使用MySQL自带的函数以外，我们也可以使用IP类提供的int方法将字符串形式的IP地址转换为数字形式的IP地址。要将数字形式的IP地址转换会字符串形式的IP地址，可以直接使用数字的方式创建IP对象。如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">9</span>]: IP(<span class="hljs-string">'178708494'</span>)             <br>Out[<span class="hljs-number">9</span>]: IP(<span class="hljs-string">'10.166.224.14'</span>)<br><br>In [<span class="hljs-number">10</span>]: <span class="hljs-string">'&#123;0&#125;'</span>.format(IP(<span class="hljs-string">"178708494"</span>))<br>Out[<span class="hljs-number">11</span>]: <span class="hljs-string">'10.166.224.14'</span><br></code></pre></td></tr></table></figure><h2 id="3、网段管理">3、网段管理</h2><p><strong>IP类的构造函数可以接受不同格式的IP地址，也可以接受网段。如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">from</span> IPy <span class="hljs-keyword">import</span> IP            <br><br>In [<span class="hljs-number">2</span>]: IP(<span class="hljs-string">'127.0.0.0/24'</span>)        <br>Out[<span class="hljs-number">2</span>]: IP(<span class="hljs-string">'127.0.0.0/24'</span>)<br><br>In [<span class="hljs-number">3</span>]: IP(<span class="hljs-string">'127.0.0.0-127.255.255.255'</span>)<br>Out[<span class="hljs-number">3</span>]: IP(<span class="hljs-string">'127.0.0.0/8'</span>)<br><br>In [<span class="hljs-number">4</span>]: IP(<span class="hljs-string">'127.0.0.0/127.255.255.255'</span>)<br>Out[<span class="hljs-number">4</span>]: IP(<span class="hljs-string">'127.0.0.0/31'</span>)<br></code></pre></td></tr></table></figure><p><strong>网段包含多个IP地址，我们可以直接使用len方法或者Python内置的len函数得到网段中IP地址的个数，也可以直接使用for循环迭代网段，以此遍历各个IP。如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">19</span>]: ips = IP(<span class="hljs-string">'10.166.224.144/28'</span>)                           <br><br>In [<span class="hljs-number">20</span>]: ips.len()                                               <br>Out[<span class="hljs-number">20</span>]: <span class="hljs-number">16</span><br><br>In [<span class="hljs-number">21</span>]: len(ips)                      <br>Out[<span class="hljs-number">21</span>]: <span class="hljs-number">16</span><br>    <br>In [<span class="hljs-number">22</span>]: ip = [ip <span class="hljs-keyword">for</span> ip <span class="hljs-keyword">in</span> ips]                                 <br><br>In [<span class="hljs-number">23</span>]: ip = [ip <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ips]                                  <br><br>In [<span class="hljs-number">24</span>]: ip                                                      <br>Out[<span class="hljs-number">24</span>]: <br>[[IP(<span class="hljs-string">'10.166.224.144'</span>),<br>  IP(<span class="hljs-string">'10.166.224.145'</span>),<br>  IP(<span class="hljs-string">'10.166.224.146'</span>),<br>  IP(<span class="hljs-string">'10.166.224.147'</span>),<br>  IP(<span class="hljs-string">'10.166.224.148'</span>),<br></code></pre></td></tr></table></figure><h3 id="通过IP类，我们也可以方便地判断一个IP是否属于一个网段，判断子网是否包含于另一个网段中，以及两个网段是否有重叠。如下所示：">通过IP类，我们也可以方便地判断一个IP是否属于一个网段，判断子网是否包含于另一个网段中，以及两个网段是否有重叠。如下所示：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">25</span>]: <span class="hljs-string">'10.166.224.146'</span> <span class="hljs-keyword">in</span> IP(<span class="hljs-string">'10.166.224.144/28'</span>)   <br>//测试ip是否在某网段内<br>Out[<span class="hljs-number">25</span>]: <span class="hljs-literal">True</span><br>    <br>In [<span class="hljs-number">16</span>]: <span class="hljs-string">'10.166.224.144'</span> <span class="hljs-keyword">in</span> IP(<span class="hljs-string">'10.166.224.144/28'</span>)<br>Out[<span class="hljs-number">16</span>]: <span class="hljs-literal">True</span><br><br>In [<span class="hljs-number">17</span>]: IP(<span class="hljs-string">'10.166.224.144/29'</span>) <span class="hljs-keyword">in</span> IP(<span class="hljs-string">'10.166.224.144/28'</span>)<br>Out[<span class="hljs-number">17</span>]: <span class="hljs-literal">True</span><br><br>In [<span class="hljs-number">18</span>]: IP(<span class="hljs-string">'10.166.224.0/28'</span>).overlaps(<span class="hljs-string">'10.166.224.144/28'</span>)<br>Out[<span class="hljs-number">18</span>]: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>对于网段，我们可以方便地获取网络地址掩码以及网络的广播地址。如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">22</span>]: ips.netmask()              <br>Out[<span class="hljs-number">22</span>]: IP(<span class="hljs-string">'255.255.255.240'</span>)<br><br>In [<span class="hljs-number">23</span>]: ips.broadcast()            <br>Out[<span class="hljs-number">23</span>]: IP(<span class="hljs-string">'10.166.224.159'</span>)<br></code></pre></td></tr></table></figure><h1>三、使用dnspython解析DNS</h1><h2 id="1、dnspython简介与安装">1、dnspython简介与安装</h2><p><strong>dnspython是Python实现的一个DNS工具集，它支持几乎所有的记录类型，可以用于查询、传输并动态更新ZONE信息，同时支持TSIG（事务签名）验证消息和EDNS0（扩展DNS）。使用dnspython可以代替Linux命令行下的nslookup以及dig等工具。</strong></p><p><strong>dnspython是第三方的开源模块，因此，使用之前需要先进行安装：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip3 install dnspython<br></code></pre></td></tr></table></figure><h2 id="2、使用dnspython进行域名解析">2、使用dnspython进行域名解析</h2><p><strong>dnspython提供了丰富的API，其中，高层次的API根据名称和类型执行查询操作，低层次的API可以直接更新ZONE信息、消息、名称和记录。在所有的API中，最常使用的是域名查询。dnspython提供了一个DNS解析类resolver，使用它的query方法可以实现域名的查询功能。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dns.resolver.query(qname,rdtype=<span class="hljs-number">1</span>,rdclass=<span class="hljs-number">1</span>,tcp=<span class="hljs-literal">False</span>,source=<span class="hljs-literal">None</span>,raise_on_no_answer=<span class="hljs-literal">True</span>,source_port=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><strong>query方法各参数的含义如下：</strong></p><blockquote><p><strong>qname:査询的域名；</strong><br><strong>rdtype:指定RR资源；</strong></p></blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">A:地址记录（Address),返回域名指向的IP地址；<br>NS:域名服务器记录（Name Server)，返回保存下一级域名信息的服务器地址。该记录只能设罝为域名，不能设置为IP地址；<br>MX:邮件记录（Mail exchange),返回接收电子邮件的服务器地址；<br>CNAME:规范名称记录（Canonical Name)，别名记录，实现域名间的映射；<br>PTR:逆向査询记录（Pointer Record),反向解析，与A记录相反，将IP地址转换为主机名。<br></code></pre></td></tr></table></figure><blockquote><p><strong>rdclass:网络类型；</strong><br><strong>tcp:指定査询是否启用TCP协议；</strong><br><strong>source:査询源的地址；</strong><br><strong>source_port:査询源的端口 ;</strong><br><strong>raise_on_no_answer:指定査询无应答时是否触发异常，默认为True。</strong></p></blockquote><p><strong>在使用dnspython查询DNS相关信息之前，我们先简单了解一下dig命令，以便对照查看Python程序的输出结果与dig命令的输出结果。</strong><br><strong>dig的全称是domain information groper,它是一个灵活探测DNS的工具，可以执行DNS査找，并显示从查询的名称服务器返回的答案。由于dig命令灵活易用、输出明确， 因此，大多数DNS管理员都使用dig解决DNS问题。</strong><br><strong>在我的主机上运行dig命令査找dnspython.org域名的信息。运行结果如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@<span class="hljs-number">192</span> ~]<span class="hljs-comment"># dig qiniu.lexizhi.com</span><br><br>; &lt;&lt;&gt;&gt; DiG <span class="hljs-number">9.9</span><span class="hljs-number">.4</span>-RedHat<span class="hljs-number">-9.9</span><span class="hljs-number">.4</span><span class="hljs-number">-72.</span>el7 &lt;&lt;&gt;&gt; qiniu.lexizhi.com<br>;; <span class="hljs-keyword">global</span> options: +cmd<br>;; Got answer:<br>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 35907<br>;; flags: qr rd ra; QUERY: <span class="hljs-number">1</span>, ANSWER: <span class="hljs-number">12</span>, AUTHORITY: <span class="hljs-number">0</span>, ADDITIONAL: <span class="hljs-number">0</span><br><br>;; QUESTION SECTION:<br>;qiniu.lexizhi.com.INA<br><br>;; ANSWER SECTION:<br>qiniu.lexizhi.com.<span class="hljs-number">5</span>INCNAMEwww.lexizhi.com.qiniudns.com.<br>www.lexizhi.com.qiniudns.com. <span class="hljs-number">5</span>INCNAMEdt003.china.line.qiniudns.com.<br>dt003.china.line.qiniudns.com. <span class="hljs-number">5</span> INCNAMEtinychinacdnweb.qiniu.com.w.kunlunno.com.<br>tinychinacdnweb.qiniu.com.w.kunlunno.com. <span class="hljs-number">5</span> IN A <span class="hljs-number">150.138</span><span class="hljs-number">.180</span><span class="hljs-number">.231</span><br>tinychinacdnweb.qiniu.com.w.kunlunno.com. <span class="hljs-number">5</span> IN A <span class="hljs-number">150.138</span><span class="hljs-number">.180</span><span class="hljs-number">.234</span><br>tinychinacdnweb.qiniu.com.w.kunlunno.com. <span class="hljs-number">5</span> IN A <span class="hljs-number">150.138</span><span class="hljs-number">.180</span><span class="hljs-number">.232</span><br>tinychinacdnweb.qiniu.com.w.kunlunno.com. <span class="hljs-number">5</span> IN A <span class="hljs-number">150.138</span><span class="hljs-number">.180</span><span class="hljs-number">.233</span><br>tinychinacdnweb.qiniu.com.w.kunlunno.com. <span class="hljs-number">5</span> IN A <span class="hljs-number">219.147</span><span class="hljs-number">.157</span><span class="hljs-number">.66</span><br>tinychinacdnweb.qiniu.com.w.kunlunno.com. <span class="hljs-number">5</span> IN A <span class="hljs-number">150.138</span><span class="hljs-number">.180</span><span class="hljs-number">.228</span><br>tinychinacdnweb.qiniu.com.w.kunlunno.com. <span class="hljs-number">5</span> IN A <span class="hljs-number">150.138</span><span class="hljs-number">.180</span><span class="hljs-number">.235</span><br>tinychinacdnweb.qiniu.com.w.kunlunno.com. <span class="hljs-number">5</span> IN A <span class="hljs-number">150.138</span><span class="hljs-number">.180</span><span class="hljs-number">.229</span><br>tinychinacdnweb.qiniu.com.w.kunlunno.com. <span class="hljs-number">5</span> IN A <span class="hljs-number">150.138</span><span class="hljs-number">.180</span><span class="hljs-number">.230</span><br><br>;; Query time: <span class="hljs-number">633</span> msec<br>;; SERVER: <span class="hljs-number">192.168</span><span class="hljs-number">.79</span><span class="hljs-number">.2</span><span class="hljs-comment">#53(192.168.79.2)</span><br>;; WHEN: 一 <span class="hljs-number">3</span>月 <span class="hljs-number">02</span> <span class="hljs-number">17</span>:<span class="hljs-number">29</span>:<span class="hljs-number">51</span> CST <span class="hljs-number">2020</span><br>;; MSG SIZE  rcvd: <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><h3 id="（1）在Python代码中，可以使用dnspython查询A记录。如下所示："><strong>（1）在Python代码中，可以使用dnspython查询A记录。如下所示：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function<br><span class="hljs-keyword">import</span> dns.resolver<br><br>data = dns.resolver.query(<span class="hljs-string">'www.lexizhi.com'</span>, <span class="hljs-string">'A'</span>)<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data:<br>    print(item)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">47.100</span><span class="hljs-number">.98</span><span class="hljs-number">.242</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="（2）使用dnspython实现NS记录，查询方法如下："><strong>（2）使用dnspython实现NS记录，查询方法如下：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function<br><span class="hljs-keyword">import</span> dns.resolver<br><br>data = dns.resolver.query(<span class="hljs-string">'dnspython.org'</span>, <span class="hljs-string">'NS'</span>)<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data:<br>    print(item)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-2">输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">ns<span class="hljs-number">-343.</span>awsdns<span class="hljs-number">-42.</span>com.<br>ns<span class="hljs-number">-518.</span>awsdns<span class="hljs-number">-00.</span>net.<br>ns<span class="hljs-number">-1253.</span>awsdns<span class="hljs-number">-28.</span>org.<br>ns<span class="hljs-number">-2020.</span>awsdns<span class="hljs-number">-60.</span>co.uk.<br></code></pre></td></tr></table></figure><p><strong>从输出结果来看，使用dig命令或dnspython模块都是一样的。如果在命令行操作，建议使用dig命令。如果要使用程序管理DNS或查询DNS的内容，则推荐使用dnspython模块。</strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python邮件和网络的简单使用</title>
      <link href="/posts/539e.html"/>
      <url>/posts/539e.html</url>
      
        <content type="html"><![CDATA[<h1>一、Excel文档操作练习（pycharm）</h1><p><strong><code>sorted()</code> 函数对所有可迭代的对象进行排序操作。</strong></p><blockquote><h4 id="sort-与-sorted-区别："><strong>sort 与 sorted 区别：</strong></h4><p><strong>sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。</strong></p><p><strong>list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</strong></p></blockquote><h3 id="1、需提前在当前目录准备好excel文件（多复制几个）：">1、需提前在当前目录准备好excel文件（多复制几个）：</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200511160225332.png" alt="image-20200511160225332"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200511160105353.png" alt="image-20200511160105353"></p><h3 id="2、编写python脚本">2、编写python脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">'''</span><br><span class="hljs-string">员工角色: 行政</span><br><span class="hljs-string">工作内容: 做员工调查问卷</span><br><span class="hljs-string">工作流程: 给每个员工发送统-的问卷的模板</span><br><span class="hljs-string">要求: 员工按照提供的固定模板，填写调查问卷,并且发送给行政人员</span><br><span class="hljs-string"></span><br><span class="hljs-string">行政人员可能会受到多份格式相同而内容不同的Excel文件</span><br><span class="hljs-string">处理Excel文件:手工合并多个文件内容，</span><br><span class="hljs-string">比较常见的方法: 以某个文件(result.xlsx)的内容为基础,打开别的文件,复制其中需要的数据,粘贴到result.xlsx</span><br><span class="hljs-string">'''</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> openpyxl<br><br><span class="hljs-comment"># 定义函数，获取指定目录下的所有Excel文档</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_all_xlsx_files</span><span class="hljs-params">(path)</span>:</span><br>    xlsx_files = glob.glob(os.path.join(path,<span class="hljs-string">'*.xlsx'</span>))<br>    sorted(xlsx_files, key=str.lower)<br>    <span class="hljs-keyword">return</span>  xlsx_files<br><br><span class="hljs-comment"># 合并Excel文档的方法</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_xlsx_files</span><span class="hljs-params">(xlsx_files)</span>:</span><br>    wb = openpyxl.load_workbook(xlsx_files[<span class="hljs-number">0</span>])<br>    ws = wb[<span class="hljs-string">"Sheet1"</span>]<br><br>    <span class="hljs-comment"># 已排序后的Excel文件的第一 顺序的文档作为基础，读取其他文档内容</span><br>    <span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> xlsx_files[<span class="hljs-number">1</span>:]:<br>        workbook = openpyxl.load_workbook(filename)<br>        worksheet = workbook[<span class="hljs-string">"Sheet1"</span>]<br>        <span class="hljs-comment"># 从工作表的第二行开始读取,第一行是表头,不读取。</span><br>        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> worksheet.iter_rows(min_row=<span class="hljs-number">2</span>):<br>            values = [cell.value <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> row]<br>            <span class="hljs-comment"># 将读取到的单元格内容追加到第一顺序的Excel文档指定的sheet内容后面</span><br>            ws.append(values)<br>    <span class="hljs-keyword">return</span> wb<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    xlsx_files = get_all_xlsx_files(os.path.basename(<span class="hljs-string">"."</span>))<br>    wb = merge_xlsx_files(xlsx_files)<br>    wb.save(<span class="hljs-string">'result.xlsx'</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br><br><span class="hljs-comment"># 获取指定目录下的所有Excel文档</span><br><span class="hljs-comment"># xlsx_file = get_all_xlsx_files('.')</span><br></code></pre></td></tr></table></figure><h3 id="3、执行过后查看result-xlsx">3、执行过后查看result.xlsx</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200511160356134.png" alt="image-20200511160356134"></p><p><em><strong>都合并到一起了</strong></em></p><h1>二、python发送邮件（<a href="https://blog.csdn.net/qq_35644234/article/details/68961603" target="_blank" rel="noopener">SMTP协议介绍</a>）</h1><p><img src="/posts/G:%5C%E5%9B%9B%E6%9C%9F%5Cpython%5Cpython%E6%96%87%E6%A1%A3%5C29.assets%5Cimage-20200513225324512.png" alt="image-20200513225324512"></p><h3 id="smtplib发送邮件的步骤：">smtplib发送邮件的步骤：</h3><ul><li><strong>连接SMTP服务器  smtp = smtplib.SMTP(‘<a href="http://smtp.qq.com" target="_blank" rel="noopener">smtp.qq.com</a>’,25)</strong></li><li><strong>发送SMTP的“Hello”消息  smtp.ehlo()    smtp.starttls()</strong></li><li><strong>登录到SMTP服务器 smtp.login(发送邮件的邮箱，邮箱授权码，不是邮箱密码)</strong></li><li><strong>发送电子邮件  smtp.send(发件人，收件人，邮件内容)</strong></li><li><strong>关闭SMTP服务器的连接  smtp.quit()</strong></li></ul><h2 id="1、测试一下">1、测试一下</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> smtplib<br><br><br><span class="hljs-comment"># 连接SMTP服务器</span><br>smtp = smtplib.SMTP(<span class="hljs-string">'smtp.qq.com'</span>,<span class="hljs-number">25</span>)<br><span class="hljs-comment"># 发送SMTP的"Hello"消息</span><br>print(smtp.ehlo())          <span class="hljs-comment">#不加密</span><br>print(smtp.starttls())      <span class="hljs-comment">#加密</span><br><span class="hljs-comment"># 登录到SMTP服务器</span><br>print(smtp.login(<span class="hljs-string">'2877364346@qq.com'</span>,<span class="hljs-string">'gengfveyokhfdffe'</span>))    <span class="hljs-comment">#绑定授权码</span><br><br><span class="hljs-comment"># 发送电子邮件  smtp.send(发件人，收件人，邮件内容)</span><br>print(smtp.sendmail(<span class="hljs-string">'2877364346@qq.com'</span>,<span class="hljs-string">'3552422607@qq.com'</span>,<span class="hljs-string">'Subject:this is title\nthis is content'</span>))<br><br><span class="hljs-comment"># 关闭SMTP服务器的连接</span><br>smtp.quit()<br>print(<span class="hljs-string">'退出连接'</span>)<br></code></pre></td></tr></table></figure><h4 id="输出结果如下：">输出结果如下：</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#不加密</span><br>(<span class="hljs-number">250</span>, <span class="hljs-string">b'newxmesmtplogicsvrsza5.qq.com\nPIPELINING\nSIZE 73400320\nSTARTTLS\nAUTH LOGIN PLAIN\nAUTH=LOGIN\nMAILCOMPRESS\n8BITMIME'</span>)<br><br><span class="hljs-comment">#加密</span><br>(<span class="hljs-number">220</span>, <span class="hljs-string">b'Ready to start TLS from 113.25.19.201 to newxmesmtplogicsvrsza5.qq.com.'</span>)<br><br><span class="hljs-comment">#绑定授权码成功</span><br>(<span class="hljs-number">235</span>, <span class="hljs-string">b'Authentication successful'</span>)<br><br><span class="hljs-comment"># 发送电子邮件成功</span><br>&#123;&#125;<br>退出连接<br></code></pre></td></tr></table></figure></blockquote><h4 id="查看成功接收的邮件：">查看成功接收的邮件：</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200511161517956.png" alt="image-20200511161517956"></p><h2 id="2、较完整的发送">2、较完整的发送</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">'''发送纯文本邮件'''</span><br><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function<br><span class="hljs-keyword">import</span> smtplib<br><span class="hljs-keyword">from</span> email.mime.text <span class="hljs-keyword">import</span> MIMEText<br><br><br>SMTP_SERVER = <span class="hljs-string">'smtp.qq.com'</span><br>SMTP_PORT = <span class="hljs-number">25</span><br><br><span class="hljs-comment"># 定义发送邮件的方法</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send_mail</span><span class="hljs-params">(user,pwd,to,subject,text)</span>:</span><br>    <span class="hljs-comment"># 构建MIMEText邮件对象(纯文本)</span><br>    msg = MIMEText(text)<br>    msg[<span class="hljs-string">'From'</span>] = user<br>    msg[<span class="hljs-string">'To'</span>] = to<br>    msg[<span class="hljs-string">'Subject'</span>] = subject<br><br>    <span class="hljs-comment"># 连接SMTP服务器</span><br>    smtp = smtplib.SMTP(SMTP_SERVER,SMTP_PORT)<br>    print(<span class="hljs-string">"邮件服务器已连接"</span>)<br><br>    <span class="hljs-keyword">try</span>:<br>        smtp.ehlo()<br>        print(<span class="hljs-string">'和服务器打招呼。。。'</span>)<br><br>        smtp.starttls()<br>        print(<span class="hljs-string">'加密传输!'</span>)<br>        smtp.ehlo()<br>        print(<span class="hljs-string">'再次打招呼。。。'</span>)<br><br>        smtp.login(user,pwd)<br>        print(<span class="hljs-string">'登陆服务器'</span>)<br><br>        smtp.sendmail(user,to,msg.as_string())<br>        print(<span class="hljs-string">'邮件已发送。。。'</span>)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> err:<br>        <span class="hljs-keyword">raise</span> SystemExit(<span class="hljs-string">'邮件发送失败:&#123;0&#125;'</span>.format(err))<br>    <span class="hljs-keyword">finally</span>:<br>        smtp.quit()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    send_mail(<span class="hljs-string">'2877364346@qq.com'</span>,<span class="hljs-string">'gengfveyokhfdffe'</span>,<span class="hljs-string">'3552422607@qq.com'</span>,<span class="hljs-string">'这是一封测试邮件'</span>,<span class="hljs-string">'你好xgp！'</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></table></figure><h4 id="输出结果如下：-2">输出结果如下：</h4><blockquote><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmd">邮件服务器已连接<br>和服务器打招呼。。。<br>加密传输!<br>再次打招呼。。。<br>登陆服务器<br>邮件已发送。。。<br></code></pre></td></tr></table></figure></blockquote><h4 id="查看成功接收的邮件：-2">查看成功接收的邮件：</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200511161701646.png" alt="image-20200511161701646"></p><h2 id="3、发送带附件的邮件">3、发送带附件的邮件</h2><p><strong>发送带附件的邮件，首先要创建MIMEMultipart()实例，然后构造附件，如果有多个附件，可依次构造，最后利用smtplib.smtp发送。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> yagmail<br><br>yag = yagmail.SMTP(user=<span class="hljs-string">'2877364346@qq.com'</span>, password=<span class="hljs-string">'gengfveyokhfdffexgp'</span>, host=<span class="hljs-string">'smtp.qq.com'</span>, port=<span class="hljs-number">465</span>)<br>content = [<span class="hljs-string">'yagmail测试邮件内容'</span>, <span class="hljs-string">'1000263.jpg'</span>]<br><br>yag.send(<span class="hljs-string">'3552422607@qq.com'</span>, <span class="hljs-string">'this is from yagmailtest email.'</span>, content)<br></code></pre></td></tr></table></figure><h4 id="查看成功接收的邮件：-3">查看成功接收的邮件：</h4><p><img src="/posts/G:%5C%E5%9B%9B%E6%9C%9F%5Cpython%5Cpython%E6%96%87%E6%A1%A3%5C29.assets%5Cimage-20200512202333350.png" alt="image-20200512202333350"></p><h1>三、网络管理</h1><h2 id="1、列出活跃的主机">1、列出活跃的主机</h2><p><strong>在这一小节中，我们将会学习如何在shell脚本中调用ping命令得到网络上活跃的主机列表，随后，我们使用Python语言改造这个程序，以此支持并发的判断。</strong></p><h3 id="ping一下">ping一下</h3><p><img src="/posts/G:%5C%E5%9B%9B%E6%9C%9F%5Cpython%5Cpython%E6%96%87%E6%A1%A3%5C29.assets%5Cimage-20200513155336659.png" alt="image-20200513155336659"></p><h3 id="（1）创建测试的网络">（1）创建测试的网络</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">-bash-4.2# vim ips.txt <br># 本机ip<br>192.168.1.80   <br><br># 本机<br>127.0.0.1 <br><br># 不可达的地址<br>192.168.2.2<br></code></pre></td></tr></table></figure><h3 id="（2）创建shell脚本，批量测IP是否可用">（2）创建shell脚本，批量测IP是否可用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">-bash-4.2# vim ping.sh <br><br><span class="hljs-meta">#</span><span class="bash">/usr/bin/bash</span><br>for ip in $(cat ips.txt)<br>        do<br>                if ping $ip -c 2 &amp;&gt;/dev/null<br>                then<br>                        echo "$ip 是活跃的。"<br>                else<br>                        echo "$ip 是不可达的。"<br>                fi<br>        done<br></code></pre></td></tr></table></figure><h4 id="执行结果如下：">执行结果如下：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">-bash-4.2# sh ping.sh <br>192.168.1.80 是活跃的。<br>127.0.0.1 是活跃的。<br>192.168.2.2 是不可达的。<br></code></pre></td></tr></table></figure><p><img src="/posts/G:%5C%E5%9B%9B%E6%9C%9F%5Cpython%5Cpython%E6%96%87%E6%A1%A3%5C29.assets%5Cimage-20200513160742759.png" alt="image-20200513160742759"></p><h3 id="（3）线程模块">（3）线程模块</h3><p><strong>Python中使用线程有两种方式：函数或者用类来包装线程对象。</strong></p><p><strong>函数式：调用thread模块中的start_new_thread()函数来产生新线程。语法如下:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">thread.start_new_thread ( function, args[, kwargs] )<br></code></pre></td></tr></table></figure><h4 id="参数说明">参数说明:</h4><ul><li><strong>function - 线程函数。</strong></li><li><strong>args - 传递给线程函数的参数,他必须是个tuple类型。</strong></li><li><strong>kwargs - 可选参数。</strong></li></ul><p><strong>Python通过两个标准库thread和threading提供对线程的支持。thread提供了低级别的、原始的线程以及一个简单的锁。</strong></p><h4 id="threading-模块提供的其他方法：">threading 模块提供的其他方法：</h4><ul><li><strong>threading.currentThread(): 返回当前的线程变量。</strong></li><li><strong>threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</strong></li><li><strong>threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</strong></li></ul><h4 id="除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法"><strong>除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:</strong></h4><ul><li><strong>run():  用以表示线程活动的方法。</strong></li><li><strong>start(): 启动线程活动。</strong></li><li><strong>join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。</strong></li><li><strong>isAlive(): 返回线程是否活动的。</strong></li><li><strong>getName(): 返回线程名。</strong></li><li><strong>setName(): 设置线程名。</strong></li></ul><h3 id="（4）创建python脚本，批量测IP是否可用">（4）创建python脚本，批量测IP是否可用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-comment"># encodig=utf-8</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> threading<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ping</span><span class="hljs-params">(ip)</span>:</span><br>    <span class="hljs-string">'''测试网卡的连通性'''</span><br>    res = os.system(<span class="hljs-string">u'ping -c 2 '</span>+ip)<br>    <span class="hljs-keyword">if</span> res == <span class="hljs-number">0</span>:<br>        print(<span class="hljs-string">'网卡正常！'</span>)<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">'网卡异常！'</span>)<br>    <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'ips.txt'</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-comment"># 使用多线程</span><br>        threads = []<br>        lines = f.readlines()<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>            thread = threading.Thread(target=ping, args=(line,))<br>            thread.start()<br>            threads.append(thread)<br>        <span class="hljs-keyword">for</span> thr <span class="hljs-keyword">in</span> threads:<br>            thr.join()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></table></figure><h4 id="执行结果如下：-2">执行结果如下：</h4><p><img src="/posts/G:%5C%E5%9B%9B%E6%9C%9F%5Cpython%5Cpython%E6%96%87%E6%A1%A3%5C29.assets%5Cimage-20200513160559534.png" alt="image-20200513160559534"></p><h2 id="2、端口扫描">2、端口扫描</h2><p><strong>在Linux下，可以便用ping命令要判断一台主机是否可达。而判断一个端口是否打开可以使用telnet命令。 我们可以模仿前面小节中并行ping的例子，在Python代码中调用telnet命令判断一个端口是否打开。但是telnet命令存在一个问题，当我们telnet一个不可达的端口时，telnet需要很久才 能够超时返回，井且telnet命令没有参数控制超时时间。此外， 如果Python标准库中有相应的模块，应该尽可能地使用Python的标准库，而不是在Python代码中执行Linux命令。这一方面能够增加代码的可读性、可维护性.另一方面也能够保证程序跨平台运行。</strong></p><p><strong>为了使用Python编写端口扫描器，我们需要简单了解socket模块。socket模块为操作系统的socket连接提供了一个Python接口，有了socket模块，我们可以完成任何使用socket的任务。</strong></p><h3 id="（1）安装telnet">（1）安装telnet</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-bash-4.2# yum -y install telnet<br></code></pre></td></tr></table></figure><h4 id="测试一下">测试一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">-bash-4.2# telnet 192.168.1.80 22  #测试连接，本机的22端口<br>Trying 192.168.1.80...<br>Connected to 192.168.1.80.<br>Escape character is '^]'.<br>SSH-2.0-OpenSSH_6.6.1<br><br>exit #退出连接<br></code></pre></td></tr></table></figure><h3 id="（2）socket模块">（2）socket模块</h3><p><strong>socket模块提供了一个工厂函数socket, socket函数会返向一个socket对象。我们可以给socket函数传递参数，以此创建不同网络协议和网络类塑的socket对象。默认情况下，socket函数会返回一个使用TCP协议的socket对象。</strong></p><h4 id="什么是-Socket">什么是 Socket?</h4><p><strong>Socket又称&quot;套接字&quot;，应用程序通常通过&quot;套接字&quot;向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。</strong></p><h4 id="socket-函数">socket()函数</h4><p><strong>Python 中，我们用 socket（）函数来创建套接字，语法格式如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">socket.socket([family[, type[, proto]]])<br></code></pre></td></tr></table></figure><h3 id="参数">参数</h3><ul><li><strong>family: 套接字家族可以使AF_UNIX或者AF_INET</strong></li><li><strong>type: 套接字类型可以根据是面向连接的还是非连接分为<code>SOCK_STREAM</code>或<code>SOCK_DGRAM</code></strong></li><li><strong>protocol: 一般不填默认为0.</strong></li></ul><h4 id="（1）如下所示">（1）如下所示:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">-bash<span class="hljs-number">-4.2</span><span class="hljs-comment"># ipython</span><br>Python <span class="hljs-number">3.8</span><span class="hljs-number">.1</span> (default, Mar  <span class="hljs-number">9</span> <span class="hljs-number">2020</span>, <span class="hljs-number">12</span>:<span class="hljs-number">35</span>:<span class="hljs-number">12</span>) <br>Type <span class="hljs-string">'copyright'</span>, <span class="hljs-string">'credits'</span> <span class="hljs-keyword">or</span> <span class="hljs-string">'license'</span> <span class="hljs-keyword">for</span> more information<br>IPython <span class="hljs-number">7.13</span><span class="hljs-number">.0</span> -- An enhanced Interactive Python. Type <span class="hljs-string">'?'</span> <span class="hljs-keyword">for</span> help.<br><br>In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> socket                                            <br><br>In [<span class="hljs-number">2</span>]: s = socket.socket()                                      <br><br>In [<span class="hljs-number">4</span>]: s.connect((<span class="hljs-string">'47.100.98.242'</span>,<span class="hljs-number">80</span>))                          <br><br>In [<span class="hljs-number">6</span>]: s.send(<span class="hljs-string">"GET/HTTP/1.0"</span>.encode())                          <br>Out[<span class="hljs-number">6</span>]: <span class="hljs-number">12</span><br><br>In [<span class="hljs-number">7</span>]: print(s.recv(<span class="hljs-number">200</span>))                                       <br><span class="hljs-string">b''</span><br><br>In [<span class="hljs-number">8</span>]: s.close                                                  <br>Out[<span class="hljs-number">8</span>]: &lt;bound method socket.close of &lt;socket.socket fd=<span class="hljs-number">13</span>, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=<span class="hljs-number">0</span>, laddr=(<span class="hljs-string">'192.168.1.80'</span>, <span class="hljs-number">42550</span>), raddr=(<span class="hljs-string">'47.100.98.242'</span>, <span class="hljs-number">80</span>)&gt;&gt;<br></code></pre></td></tr></table></figure><p><strong>在这个例子中, socketI厂函数以默认参数AF. INET和SOCK STREAM创建了一个名为s的socket对象,该对象可以在进程间进行TCP通信。创建完对象以后，我们使用connect函数连接到远程服务器的80端口，并发送一个HTTP请求到远程服务器，发送完毕之后，接收服务器响应的前200个字节。最后，调用socket对象的close方法关闭连接。</strong></p><p><strong>在这个例子中,我们用到了socket工厂函数、socket的connect方法、 send方法、recv 方法和close方法,这也是socket中最常使用的一些方法。</strong></p><h4 id="（2）如下所示">（2）如下所示</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br>s = socket. socket()<br>s. connect(( <span class="hljs-string">'47.100.98.242'</span> ,<span class="hljs-number">80</span>))<br>s.send( <span class="hljs-string">' http:/ /www.baidu.com/'</span>.encode())<br>print(s.recv(<span class="hljs-number">10</span>))<br>s.close()<br></code></pre></td></tr></table></figure><h5 id="执行结果如下">执行结果如下</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">b'HTTP/1.1 4'</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="（3）接下来，我们就看一下如何使用简单的socket接口编写一个端口扫描器。-如下所示">（3）接下来，我们就看一下如何使用简单的socket接口编写一个端口扫描器。 如下所示:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-comment"># encoding=utf-8</span><br><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conn_scan</span><span class="hljs-params">(host, port)</span>:</span><br>    conn = socket(AF_INET, SOCK_STREAM)<br>    <span class="hljs-keyword">try</span>:<br>        conn.connect((host, port))<br>        print(host, port, <span class="hljs-string">'已连接'</span>)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        print(host, port, <span class="hljs-string">'连接失败'</span>)<br>    <span class="hljs-keyword">finally</span>:<br>        conn.close()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    host = <span class="hljs-string">'47.100.98.242'</span><br>    <span class="hljs-keyword">for</span> port <span class="hljs-keyword">in</span> range(<span class="hljs-number">20</span>, <span class="hljs-number">5000</span>):<br>        conn_scan(host, port)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></table></figure><h5 id="执行结果如下：-3">执行结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">47.100</span><span class="hljs-number">.98</span><span class="hljs-number">.242</span> <span class="hljs-number">20</span> 连接失败<br><span class="hljs-number">47.100</span><span class="hljs-number">.98</span><span class="hljs-number">.242</span> <span class="hljs-number">21</span> 已连接<br><span class="hljs-number">47.100</span><span class="hljs-number">.98</span><span class="hljs-number">.242</span> <span class="hljs-number">22</span> 已连接<br><span class="hljs-number">47.100</span><span class="hljs-number">.98</span><span class="hljs-number">.242</span> <span class="hljs-number">23</span> 连接失败<br><span class="hljs-number">47.100</span><span class="hljs-number">.98</span><span class="hljs-number">.242</span> <span class="hljs-number">24</span> 连接失败<br></code></pre></td></tr></table></figure></blockquote><h4 id="较快的：">较快的：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#encoding=utf-8</span><br><span class="hljs-keyword">import</span> telnetlib<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conn_scan</span><span class="hljs-params">(host, port)</span>:</span><br>    t = telnetlib.Telnet()<br>    <span class="hljs-keyword">try</span>:<br>        t.open(host, port, timeout=<span class="hljs-number">1</span>)<br>        print(host, port, <span class="hljs-string">'已连接'</span>)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        print(host, port, <span class="hljs-string">'连接失败'</span>)<br>    <span class="hljs-keyword">finally</span>:<br>        t.close()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    host = <span class="hljs-string">'47.100.98.242'</span><br>    <span class="hljs-keyword">for</span> port <span class="hljs-keyword">in</span> range(<span class="hljs-number">20</span>, <span class="hljs-number">26</span>):<br>        conn_scan(host, port)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-3">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">47.100</span><span class="hljs-number">.98</span><span class="hljs-number">.242</span> <span class="hljs-number">20</span> 连接失败<br><span class="hljs-number">47.100</span><span class="hljs-number">.98</span><span class="hljs-number">.242</span> <span class="hljs-number">21</span> 已连接<br><span class="hljs-number">47.100</span><span class="hljs-number">.98</span><span class="hljs-number">.242</span> <span class="hljs-number">22</span> 已连接<br><span class="hljs-number">47.100</span><span class="hljs-number">.98</span><span class="hljs-number">.242</span> <span class="hljs-number">23</span> 连接失败<br></code></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的文件处理</title>
      <link href="/posts/e80d.html"/>
      <url>/posts/e80d.html</url>
      
        <content type="html"><![CDATA[<h1>一、python操作excel之openpyxl</h1><h2 id="前言">前言</h2><p><strong>根据官方文档，openpyxl 是一个第三方库, 它可以可以处理 xlsx/xlsm 格式的 Excel 文件(A Python library to read/write Excel 2010 xlsx/xlsm files)。</strong></p><p><strong>openpyxl 中主要的三个概念: Workbook(工作表)，Sheet(表页)和Cell(格)。</strong></p><p><strong>openpyxl 中主要的操作: 打开 Workbook，定位 Sheet，操作 Cell。</strong></p><h3 id="（1）支持excel格式">（1）支持excel格式</h3><ul><li><strong>xlsx</strong></li><li><strong>xlsm</strong></li><li><strong>xltx</strong></li><li><strong>xltm</strong></li></ul><h3 id="（2）基本用法">（2）基本用法</h3><p><strong>首先介绍下Excel的一些基本概念，Workbook相当于是一个文件,WorkSheet就是文件里面的每个具体的表,比如新建Excel文件里面的’Sheet1’这个,一个Workbook里面有一个或多个WorkSheet.</strong></p><ul><li><strong>workbook： 工作簿，一个excel文件包含多个sheet。</strong></li><li><strong>worksheet：工作表，一个workbook有多个，表名识别，如“sheet1”,“sheet2”等。</strong></li><li><strong>cell： 单元格，存储数据对象</strong></li></ul><h2 id="1、安装openpyxl">1、安装openpyxl</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">pip install openpyxl<br></code></pre></td></tr></table></figure><h2 id="2、参数介绍">2、参数介绍</h2><h3 id="（一）常遇到的情况">（一）常遇到的情况</h3><p><strong>就我自己来说，常遇到的情况可能就下面几种：</strong></p><ul><li><strong>读取excel整个sheet页的数据。</strong></li><li><strong>读取指定行、列的数据</strong></li><li><strong>往一个空白的excel文档写数据</strong></li><li><strong>往一个已经有数据的excel文档追加数据</strong></li></ul><p><strong>下面就以这几种情况为例进行说明。</strong></p><h3 id="（二）-涉及的模块及函数说明"><strong>（二）</strong> <strong>涉及的模块及函数说明</strong></h3><p><strong>就我知道的，有3个模块可以操作excel文档，3个模块通过pip都可以直接安装。</strong></p><ul><li><strong>xlrd:读数据</strong></li><li><strong>xlwt:写数据</strong></li><li><strong>openpyxl：可以读数据，也可以写数据</strong></li></ul><p><strong>这里就就只说明openpyxl了，因为这个模块能满足上面的需要了。</strong></p><p><strong>openpyxl函数</strong></p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>load_workbook(filename)</code></strong></td><td>打开excel，并返回所有sheet页访问指定sheet页的方法：*#**打开excel文档 *wb = openpyxl.load_workbook(file_name) *#**访问sheet页 *sheet = wb[‘sheet页的名称’]#关闭excel文档wb.close()</td></tr><tr><td><strong><code>Workbook()</code></strong></td><td>创建excel文档wb = openpyxl.Workbook()#保存excel文档wb.save（‘文件名.xlsx’）</td></tr><tr><td>下面的函数是针对sheet页的sheet = wb[‘sheet页的名称’]访问指定单元格的方式sheet[‘A1’]、sheet[‘B1’]…</td><td></td></tr><tr><td><strong><code>min_row</code></strong></td><td>返回包含数据的最小行索引，索引从1开始<code>例如：sheet.min_row</code></td></tr><tr><td><strong><code>max_row</code></strong></td><td>返回包含数据的最大行索引，索引从1开始</td></tr><tr><td><strong><code>min_column</code></strong></td><td>返回包含数据的最小列索引，索引从1开始</td></tr><tr><td><strong><code>max_column</code></strong></td><td>返回包含数据的最大列索引，索引从1开始</td></tr><tr><td><strong><code>values</code></strong></td><td>获取excel文档所有的数据，返回的是一个generator对象</td></tr><tr><td>iter_rows(min_row=<strong>None</strong>, max_row=<strong>None</strong>, min_col=<strong>None</strong>, max_col=<strong>None</strong>)</td><td>min_row:最小行索引max_row:最大行索引min_col:最小列索引max_col:最大列索引获取指定行、列的单元格，没指定就是获取所有的</td></tr><tr><td><strong><code>title</code></strong></td><td>WorkSheet的名称</td></tr></tbody></table><p><strong>现在我有这么一个excel，下面以这个excel进行说明。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200508161540660.png" alt="image-20200508161540660"></p><h2 id="3、读取文件属性">3、读取文件属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> openpyxl<br><br><br><span class="hljs-comment"># 打开一个EXcel文档</span><br>wb = openpyxl.load_workbook(<span class="hljs-string">'test.xlsx'</span>)<br>sheet2 = wb[<span class="hljs-string">'Sheet2'</span>]<br><br>print(<span class="hljs-string">'表名为：'</span>,sheet2.title)<br><br>print(<span class="hljs-string">'数据的行数和列数：'</span>,sheet2.dimensions)<br><br>print(<span class="hljs-string">'最小行数为：'</span>,sheet2.max_row)<br><br>print(<span class="hljs-string">'最大行数为：'</span>,sheet2.min_row)<br><br>print(<span class="hljs-string">'最大列数为：'</span>,sheet2.max_column)<br><br>print(<span class="hljs-string">'最小列数为：'</span>,sheet2.min_column)<br><br><span class="hljs-comment"># 获取指定单元格</span><br>print(<span class="hljs-string">'单元格A1：'</span>,sheet2[<span class="hljs-string">'A1'</span>])<br>print(<span class="hljs-string">'单元格B1：'</span>,sheet2.cell(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">2</span>))<br><br><span class="hljs-comment"># 获取行</span><br>print(<span class="hljs-string">'行：'</span>,sheet2.rows)<br><br><span class="hljs-comment"># 获取列</span><br>print(<span class="hljs-string">'列：'</span>,sheet2.columns)<br><br><span class="hljs-comment"># 获取所有的数据</span><br>print(<span class="hljs-string">'所有的数据：'</span>,sheet2.values)<br><br><br><span class="hljs-comment"># 查看Excel文档的属性</span><br>print(<span class="hljs-string">'是否只读：'</span>,wb.read_only)<br>print(<span class="hljs-string">'文档的属性：'</span>,wb.properties)<br><br><br><span class="hljs-comment">#文档的字符集格式</span><br>print(<span class="hljs-string">'字符集格式：'</span>,wb.encoding)<br><br><span class="hljs-comment"># 获取活跃的工作表</span><br>print(<span class="hljs-string">'活跃的工作表：'</span>,wb.active)<br><br><span class="hljs-comment"># 获取所有的工作表</span><br>print(<span class="hljs-string">'所有的工作表：'</span>,wb.worksheets)<br><br><span class="hljs-comment"># 获取所有的工作表的名称</span><br>print(<span class="hljs-string">'输出文件所有工作表名：'</span>, wb.sheetnames)<br><br><span class="hljs-comment"># 根据表格名称获取worksheet对象,区分大小写</span><br>print(<span class="hljs-string">'表名：'</span>,wb[<span class="hljs-string">'Sheet2'</span>])<br></code></pre></td></tr></table></figure><h5 id="输出结果为：">输出结果为：</h5><blockquote><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cmd">表名为： Sheet2<br>数据的行数和列数： A1:C8<br>最小行数为： <span class="hljs-number">8</span><br>最大行数为： <span class="hljs-number">1</span><br>最大列数为： <span class="hljs-number">3</span><br>最小列数为： <span class="hljs-number">1</span><br>单元格A1： &lt;Cell 'Sheet2'.A1&gt;<br>单元格B1： &lt;Cell 'Sheet2'.B1&gt;<br>行： &lt;generator object Worksheet._cells_by_row <span class="hljs-built_in">at</span> <span class="hljs-number">0</span>x000002612197F2E0&gt;<br>列： &lt;generator object Worksheet._cells_by_col <span class="hljs-built_in">at</span> <span class="hljs-number">0</span>x000002612197F2E0&gt;<br>所有的数据： &lt;generator object Worksheet.values <span class="hljs-built_in">at</span> <span class="hljs-number">0</span>x000002612197F2E0&gt;<br>是否只读： False<br>文档的属性： &lt;openpyxl.packaging.core.DocumentProperties object&gt;<br><span class="hljs-function">Parameters:</span><br><span class="hljs-function"><span class="hljs-title">creator</span>='小钢炮', <span class="hljs-title">title</span>=<span class="hljs-title">None</span>, <span class="hljs-title">description</span>=<span class="hljs-title">None</span>, <span class="hljs-title">subject</span>=<span class="hljs-title">None</span>, <span class="hljs-title">identifier</span>=<span class="hljs-title">None</span>, <span class="hljs-title">language</span>=<span class="hljs-title">None</span>, <span class="hljs-title">created</span>=<span class="hljs-title">datetime.datetime</span>(2015, 6, 5, 18, 17, 20), <span class="hljs-title">modified</span>=<span class="hljs-title">datetime.datetime</span>(2020, 5, 7, 4, 9, 19), <span class="hljs-title">lastModifiedBy</span>='<span class="hljs-title">xxx</span>', <span class="hljs-title">category</span>=<span class="hljs-title">None</span>, <span class="hljs-title">contentStatus</span>=<span class="hljs-title">None</span>, <span class="hljs-title">version</span>=<span class="hljs-title">None</span>, <span class="hljs-title">revision</span>=<span class="hljs-title">None</span>, <span class="hljs-title">keywords</span>=<span class="hljs-title">None</span>, <span class="hljs-title">lastPrinted</span>=<span class="hljs-title">None</span></span><br><span class="hljs-function">字符集格式： <span class="hljs-title">utf</span>-8</span><br><span class="hljs-function">活跃的工作表： &lt;<span class="hljs-title">Worksheet</span> "成绩表"&gt;</span><br><span class="hljs-function">所有的工作表： [&lt;<span class="hljs-title">Worksheet</span> "<span class="hljs-title">Sheet2</span>"&gt;, &lt;<span class="hljs-title">Worksheet</span> "<span class="hljs-title">Sheet3</span>"&gt;, &lt;<span class="hljs-title">Worksheet</span> "成绩表"&gt;]</span><br><span class="hljs-function">输出文件所有工作表名： ['<span class="hljs-title">Sheet2</span>', '<span class="hljs-title">Sheet3</span>', '成绩表']</span><br><span class="hljs-function">表名： &lt;<span class="hljs-title">Worksheet</span> "<span class="hljs-title">Sheet2</span>"&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="4、读取文件内容">4、读取文件内容</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> openpyxl<br><br>wb = openpyxl.load_workbook(<span class="hljs-string">'test.xlsx'</span>)<br>sheet2 = wb[<span class="hljs-string">'Sheet2'</span>]<br><br><span class="hljs-comment"># 获取单元格内容</span><br><span class="hljs-comment"># 方式一</span><br>print(<span class="hljs-string">'方法一'</span>)<br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> sheet2.values:<br>    print(*row)<br>print(<span class="hljs-string">'========================='</span>)<br><span class="hljs-comment"># 方式二</span><br>print(<span class="hljs-string">'方法二'</span>)<br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> sheet2.rows:<br>    print(*[cell.value <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> row])<br>print(<span class="hljs-string">'========================='</span>)<br><span class="hljs-comment"># 方式三</span><br>print(<span class="hljs-string">'方法三'</span>)<br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> sheet2.iter_rows():<br>    print(*[cell.value <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> row])<br>print(<span class="hljs-string">'========================='</span>)<br><span class="hljs-comment"># 方式四(最复杂，最原始)</span><br>print(<span class="hljs-string">'方法四'</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(sheet2.min_row, sheet2.max_row + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(sheet2.min_column, sheet2.max_column + <span class="hljs-number">1</span>):<br>        print(sheet2.cell(row=i,column=j).value,end=<span class="hljs-string">' '</span>)<br>    print()<br></code></pre></td></tr></table></figure><h5 id="输出结果为：-2">输出结果为：</h5><blockquote><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cmd">方法一<br>序号 姓名 年龄<br><span class="hljs-number">1</span> 发生的 <span class="hljs-number">25</span><br><span class="hljs-number">2</span> 浮动视 <span class="hljs-number">26</span><br><span class="hljs-number">3</span> 好的 <span class="hljs-number">27</span><br><span class="hljs-number">4</span> 经回复 <span class="hljs-number">28</span><br><span class="hljs-number">5</span> 好的话 <span class="hljs-number">29</span><br><span class="hljs-number">6</span> 套网 <span class="hljs-number">30</span><br><span class="hljs-number">7</span> 太温柔 <span class="hljs-number">31</span><br>=========================<br>方法二<br>序号 姓名 年龄<br><span class="hljs-number">1</span> 发生的 <span class="hljs-number">25</span><br><span class="hljs-number">2</span> 浮动视 <span class="hljs-number">26</span><br><span class="hljs-number">3</span> 好的 <span class="hljs-number">27</span><br><span class="hljs-number">4</span> 经回复 <span class="hljs-number">28</span><br><span class="hljs-number">5</span> 好的话 <span class="hljs-number">29</span><br><span class="hljs-number">6</span> 套网 <span class="hljs-number">30</span><br><span class="hljs-number">7</span> 太温柔 <span class="hljs-number">31</span><br>=========================<br>方法三<br>序号 姓名 年龄<br><span class="hljs-number">1</span> 发生的 <span class="hljs-number">25</span><br><span class="hljs-number">2</span> 浮动视 <span class="hljs-number">26</span><br><span class="hljs-number">3</span> 好的 <span class="hljs-number">27</span><br><span class="hljs-number">4</span> 经回复 <span class="hljs-number">28</span><br><span class="hljs-number">5</span> 好的话 <span class="hljs-number">29</span><br><span class="hljs-number">6</span> 套网 <span class="hljs-number">30</span><br><span class="hljs-number">7</span> 太温柔 <span class="hljs-number">31</span><br>=========================<br>方法四<br>序号 姓名 年龄 <br><span class="hljs-number">1</span> 发生的 <span class="hljs-number">25</span> <br><span class="hljs-number">2</span> 浮动视 <span class="hljs-number">26</span> <br><span class="hljs-number">3</span> 好的 <span class="hljs-number">27</span> <br><span class="hljs-number">4</span> 经回复 <span class="hljs-number">28</span> <br><span class="hljs-number">5</span> 好的话 <span class="hljs-number">29</span> <br><span class="hljs-number">6</span> 套网 <span class="hljs-number">30</span> <br><span class="hljs-number">7</span> 太温柔 <span class="hljs-number">31</span> <br></code></pre></td></tr></table></figure></blockquote><h2 id="5、删除和创建表">5、删除和创建表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> openpyxl<br><br><br><span class="hljs-comment"># 打开一个EXcel文档</span><br>wb = openpyxl.load_workbook(<span class="hljs-string">'test.xlsx'</span>)<br>sheet2 = wb[<span class="hljs-string">'Sheet2'</span>]<br><br><span class="hljs-comment"># 删除表</span><br>sheet1 = wb.get_sheet_by_name(<span class="hljs-string">'Sheet1'</span>)<br>wb.remove_sheet(sheet1)<br><br><span class="hljs-comment"># 保存workbook的修改</span><br>wb.save(<span class="hljs-string">'test.xlsx'</span>)<br><br><span class="hljs-comment"># 创建一个新的worksheet</span><br>wb.create_sheet(<span class="hljs-string">'成绩表'</span>)<br><br><span class="hljs-comment"># 保存workbook的修改</span><br>wb.save(<span class="hljs-string">'test.xlsx'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200508162223906.png" alt="image-20200508162223906"></p><h2 id="6、在Excel中存储学生成绩">6、在Excel中存储学生成绩</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> openpyxl<br><br><span class="hljs-comment"># 打开workbook</span><br>wb = openpyxl.load_workbook(<span class="hljs-string">"成绩表.xlsx"</span>)<br><br><span class="hljs-comment"># #创建一个成绩表</span><br><span class="hljs-comment"># wb.create_sheet("学生成绩表")</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># # 删除表</span><br><span class="hljs-comment"># wb.remove_sheet(wb['Sheet1'])</span><br><br><span class="hljs-comment"># 获取“学生成绩表”</span><br>score = wb[<span class="hljs-string">"学生成绩表"</span>]<br><span class="hljs-comment"># title = ['序号','姓名','语文','数学']</span><br><span class="hljs-comment"># no = range(6)</span><br><span class="hljs-comment"># names = ['张三','李四','王五','赵柳','田七']</span><br><span class="hljs-comment"># wen = [80,88,85,81,89]</span><br><br><span class="hljs-comment"># 第一行数据</span><br>score[<span class="hljs-string">'A1'</span>].value = <span class="hljs-string">'序号'</span><br>score[<span class="hljs-string">'B1'</span>].value = <span class="hljs-string">'姓名'</span><br>score[<span class="hljs-string">'C1'</span>].value = <span class="hljs-string">'语文'</span><br>score[<span class="hljs-string">'D1'</span>].value = <span class="hljs-string">'数学'</span><br><span class="hljs-comment"># 第二行数据</span><br>score[<span class="hljs-string">'A2'</span>].value = int(<span class="hljs-string">'1'</span>)<br>score[<span class="hljs-string">'B2'</span>].value = <span class="hljs-string">'张三'</span><br>score[<span class="hljs-string">'C2'</span>].value = int(<span class="hljs-string">'52'</span>)<br>score[<span class="hljs-string">'D2'</span>].value = int(<span class="hljs-string">'64'</span>)<br><br><span class="hljs-comment"># 第三行数据</span><br>score[<span class="hljs-string">'A3'</span>].value = int(<span class="hljs-string">'2'</span>)<br>score[<span class="hljs-string">'B3'</span>].value = <span class="hljs-string">'李四'</span><br>score[<span class="hljs-string">'C3'</span>].value = int(<span class="hljs-string">'28'</span>)<br>score[<span class="hljs-string">'D3'</span>].value = int(<span class="hljs-string">'95'</span>)<br><br><span class="hljs-comment"># 保存workbook</span><br>wb.save(<span class="hljs-string">'成绩表.xlsx'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200508165903892.png" alt="image-20200508165903892"></p><h2 id="7、插入工作表内容">7、插入工作表内容</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">import</span> openpyxl<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_worksheet</span><span class="hljs-params">(sheet)</span>:</span><br>    <span class="hljs-comment"># 总分所在的列</span><br>    sum_column = sheet.max_column + <span class="hljs-number">2</span><br>    <span class="hljs-comment"># 平均分所在的列</span><br>    avg_column = sheet.max_column + <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 将总分和平均分保存到最后两列</span><br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> sheet.iter_rows(min_row=<span class="hljs-number">2</span>, min_col=<span class="hljs-number">3</span>):<br>        <span class="hljs-comment"># 单元格</span><br>        score = [cell.value <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> row]<br>        <span class="hljs-comment"># 总分</span><br>        sum_score = sum(score)<br>        <span class="hljs-comment"># 平均分</span><br>        avg_score = sum_score / len(score)<br>        <span class="hljs-comment"># 将总分和平均分保存到最后两列</span><br>        sheet.cell(row=row[<span class="hljs-number">0</span>].row, column=avg_column).value = avg_score<br>        sheet.cell(row=row[<span class="hljs-number">0</span>].row, column=sum_column).value = sum_score<br><br>    <span class="hljs-comment"># 设置平均分和总分的标题</span><br>    sheet.cell(row=<span class="hljs-number">1</span>, column=avg_column).value = <span class="hljs-string">"平均分"</span><br>    sheet.cell(row=<span class="hljs-number">1</span>, column=sum_column).value = <span class="hljs-string">"总分"</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-comment"># 打开Excel文档</span><br>    wb = openpyxl.load_workbook(<span class="hljs-string">"成绩.xlsx"</span>)<br>    <span class="hljs-comment"># 获取一个工作表</span><br>    sheet = wb[<span class="hljs-string">"成绩表"</span>]<br>    <span class="hljs-comment">#    把外部Excel文件（成绩表）中的sheet（成绩）插入当前Excel中</span><br>    process_worksheet(sheet)<br>    <span class="hljs-comment"># 保存“练习.xlsx”</span><br>    wb.save(<span class="hljs-string">"练习-copy.xlsx"</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></table></figure><h5 id="查看练习-copy-xlsx的数据">查看<code>练习-copy.xlsx</code>的数据</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200508170037604.png" alt="image-20200508170037604"></p><h1>二、Python 读、写Excel文件（三种模块三种方式</h1><p><strong>python读写excel的方式有很多，不同的模块在读写的讲法上稍有区别：</strong></p><ul><li><strong>用xlrd和xlwt进行excel读写；</strong></li><li><strong>用openpyxl进行excel读写；</strong></li><li><strong>用pandas进行excel读写；</strong></li></ul><h2 id="pandas介绍">pandas介绍</h2><ul><li><strong>Pandas是Python的一个数据分析包，该工具为解决数据分析任务而创建。</strong></li><li><strong>Pandas纳入大量库和标准数据模型，提供高效的操作数据集所需的工具。</strong></li><li><strong>Pandas提供大量能使我们快速便捷地处理数据的函数和方法。</strong></li><li><strong>Pandas是字典形式，基于NumPy创建，让NumPy为中心的应用变得更加简单。</strong></li></ul><p>作者：谓之小一<br>链接：<a href="https://www.jianshu.com/p/218baa41bab9" target="_blank" rel="noopener">https://www.jianshu.com/p/218baa41bab9</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="1、xlrd模块">1、xlrd模块</h2><p><strong>xlrd是用来从Excel中读写数据的，但我平常只用它进行读操作，写操作会遇到些问题。用xlrd进行读取比较方便，流程和平常手动操作Excel一样，打开工作簿(Workbook)，选择工作表(sheets)，然后操作单元格(cell)。下面举个例子，例如要打开当前目录下名为”data.xlsx”的Excel文件，选择第一张工作表，然后读取第一行的全部内容并打印出来。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#打开excel文件</span><br>data=xlrd.open_workbook(<span class="hljs-string">'data.xlsx'</span>)     <br><span class="hljs-comment">#获取第一张工作表（通过索引的方式）</span><br>table=data.sheets()[<span class="hljs-number">0</span>] <br><span class="hljs-comment">#data_list用来存放数据</span><br>data_list=[]    <br><span class="hljs-comment">#将table中第一行的数据读取并添加到data_list中</span><br>data_list.extend(table.row_values(<span class="hljs-number">0</span>))<br><span class="hljs-comment">#打印出第一行的全部数据</span><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data_list:<br>    <span class="hljs-keyword">print</span> item<br></code></pre></td></tr></table></figure><p><strong>上面的代码中读取一行用table.row_values(number)，类似的读取一列用table.column_values(number)，其中number为行索引，在xlrd中行和列都是从0开始索引的，因此Excel中最左上角的单元格A1是第0行第0列。</strong></p><p><strong>xlrd中读取某个单元格用table.cell(row,col)即可，其中row和col分别是单元格对应的行和列。</strong><br><strong>下面简单归纳一下xlrd的用法</strong></p><h3 id="（1）安装xlrd模块">（1）安装xlrd模块</h3><p><strong>到python官网下载http://pypi.python.org/cmdpypi/xlrd模块安装，前提是已经安装了python 环境。</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">pip install xlrd<br></code></pre></td></tr></table></figure><h3 id="（2）使用技巧">（2）使用技巧</h3><ul><li><strong><a href="http://sheet.name" target="_blank" rel="noopener">sheet.name</a>：sheet的名字</strong></li><li><strong>sheet.nrows：sheet的行数</strong></li><li><strong>sheet.ncols：sheet的列数</strong></li><li><strong>sheet.get_rows()：返回一个迭代器，遍历所有行，给出每个行的值列表</strong></li><li><strong>sheet.row_values(index)：返回某一行的值列表</strong></li><li><strong>sheet.row(index)：返回一个row对象，可通过row[index]获取这行里的单元格cell对象</strong></li><li><strong>sheet.col_values(index)：返回某一列的值列表</strong></li><li><strong>sheet.cell(row,col)：获取一个cell对象（row和col都从0开始算</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python">table = data.sheets()[<span class="hljs-number">0</span>]          <span class="hljs-comment">#通过索引顺序获取</span><br>table = data.sheet_by_index(<span class="hljs-number">0</span>) <span class="hljs-comment">#通过索引顺序获取</span><br>table = data.sheet_by_name(<span class="hljs-string">u'Sheet1'</span>)<span class="hljs-comment">#通过名称获取</span><br><br><span class="hljs-comment"># 获取整行和整列的值（数组）　　</span><br>table.row_values(i)<br>table.col_values(i)<br> <br><span class="hljs-comment"># 获取行数和列数　　</span><br>nrows = table.nrows <br>ncols = table.ncols<br>       <br><span class="hljs-comment"># 循环行列表数据</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(nrows):<br>       <span class="hljs-keyword">print</span> table.row_values(i)<br> <br><span class="hljs-comment"># 单元格</span><br>cell_A1 = table.cell(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>).value<br>cell_C4 = table.cell(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>).value<br> <br><span class="hljs-comment"># 使用行列索引</span><br>cell_A1 = table.row(<span class="hljs-number">0</span>)[<span class="hljs-number">0</span>].value<br>cell_A2 = table.col(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>].value<br> <br><span class="hljs-comment"># 简单的写入</span><br>row = <span class="hljs-number">0</span><br>col = <span class="hljs-number">0</span><br> <br><span class="hljs-comment"># 类型 0 empty,1 string, 2 number, 3 date, 4 boolean, 5 error</span><br>ctype = <span class="hljs-number">1</span> value = <span class="hljs-string">'单元格的值'</span><br>xf = <span class="hljs-number">0</span> <span class="hljs-comment"># 扩展的格式化</span><br>table.put_cell(row, col, ctype, value, xf)<br>table.cell(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)  <span class="hljs-comment">#单元格的值'</span><br>table.cell(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>).value <span class="hljs-comment">#单元格的值'</span><br></code></pre></td></tr></table></figure><h3 id="（3）查看文件数据">（3）查看文件数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xlrd<br><br>book = xlrd.open_workbook(<span class="hljs-string">'练习-copy.xlsx'</span>)<br>sheet1 = book.sheets()[<span class="hljs-number">0</span>]<br><br>nrows = sheet1.nrows<br>print(<span class="hljs-string">'表格总行数：'</span>, nrows)<br><br>ncols = sheet1.ncols<br>print(<span class="hljs-string">'表格总列数：'</span>, ncols)<br><br>row3_values = sheet1.row_values(<span class="hljs-number">2</span>)<br>print(<span class="hljs-string">'第3行的值：'</span>, row3_values)<br><br>col3_values = sheet1.col_values(<span class="hljs-number">2</span>)<br>print(<span class="hljs-string">'第3列的值：'</span>, col3_values)<br><br>cell_2_2 = sheet1.cell(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>).value<br>print(<span class="hljs-string">'3行3列的值'</span>,cell_2_2)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下">输出结果如下</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">表格总行数： <span class="hljs-number">8</span><br>表格总列数： <span class="hljs-number">3</span><br>第<span class="hljs-number">3</span>行的值： [<span class="hljs-number">2.0</span>, <span class="hljs-string">'浮动视'</span>, <span class="hljs-number">26.0</span>]<br>第<span class="hljs-number">3</span>列的值： [<span class="hljs-string">'年龄'</span>, <span class="hljs-number">25.0</span>, <span class="hljs-number">26.0</span>, <span class="hljs-number">27.0</span>, <span class="hljs-number">28.0</span>, <span class="hljs-number">29.0</span>, <span class="hljs-number">30.0</span>, <span class="hljs-number">31.0</span>]<br><span class="hljs-number">3</span>行<span class="hljs-number">3</span>列的值 <span class="hljs-number">26.0</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="2、xlwt模块">2、xlwt模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install xlwt<br></code></pre></td></tr></table></figure><p><strong>如果说xlrd不是一个单纯的Reader（如果把xlrd中的后两个字符看成Reader，那么xlwt后两个字符类似看成Writer），那么xlwt就是一个纯粹的Writer了，因为它只能对Excel进行写操作。xlwt和xlrd不光名字像，连很多函数和操作格式也是完全相同。下面简要归纳一下常用操作</strong></p><h3 id="（1）xlwt常用操作">（1）xlwt常用操作</h3><p><strong>新建一个Excel文件（只能通过新建写入）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">data=xlwt.Workbook()<br></code></pre></td></tr></table></figure><p><strong>新建一个工作表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">table=data.add_sheet(<span class="hljs-string">'name'</span>)<br></code></pre></td></tr></table></figure><p><strong>写入数据到A1单元格</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">table.write(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-string">u'呵呵'</span>)<br></code></pre></td></tr></table></figure><p>注意：<strong>如果对同一个单元格重复操作，会引发overwrite Exception，想要取消该功能，需要在添加工作表时指定为可覆盖</strong>，像下面这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">table=data.add_sheet(<span class="hljs-string">'name'</span>,cell_overwrite_ok=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p><strong>保存文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">data.save(<span class="hljs-string">'test.xls'</span>)<br></code></pre></td></tr></table></figure><p><em><strong>这里只能保存扩展名为xls的，xlsx的格式不支持</strong></em></p><h4 id="xlwt支持一定的样式，操作如下">xlwt支持一定的样式，操作如下</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#初始化样式</span><br>style=xlwt.XFStyle()<br><br><span class="hljs-comment">#为样式创建字体</span><br>font=xlwt.Font()<br><br><span class="hljs-comment">#指定字体名字</span><br>font.name=<span class="hljs-string">'Times New Roman'</span><br><br><span class="hljs-comment">#字体加粗</span><br>font.bold=<span class="hljs-literal">True</span><br><br><span class="hljs-comment">#将该font设定为style的字体</span><br>style.font=font<br><br><span class="hljs-comment">#写入到文件时使用该样式</span><br>sheet.write(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">'just for test'</span>,style)<br></code></pre></td></tr></table></figure><h3 id="（2）实例">（2）实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xlwt  <span class="hljs-comment"># 貌似不支持excel2007的xlsx格式</span><br><br>wb = xlwt.Workbook()<br>wb_sheet = wb.add_sheet(<span class="hljs-string">'ddd'</span>)<br>wb_sheet.write(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-string">'测试内容'</span>)<br>wb.save(<span class="hljs-string">'d.xls'</span>)<br></code></pre></td></tr></table></figure><h5 id="查看d-xls文件">查看d.xls文件</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200508181829850.png" alt="image-20200508181829850"></p><h2 id="3、openpyxl模块">3、openpyxl模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install openpyxl<br></code></pre></td></tr></table></figure><p><strong>该模块支持最新版的Excel文件格式，对Excel文件具有响应的读写操作，对此有专门的Reader和Writer两个类，便于对Excel文件的操作。虽然如此，但我一般还是用默认的workbook来进行操作。常用操作归纳如下：</strong></p><h3 id="（1）openpyxl常用操作">（1）openpyxl常用操作</h3><h4 id="读取Excel文件">读取Excel文件</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> openpyxl.reader.excel import load_workbook<br><br><span class="hljs-attribute">wb</span>=load_workbook(filename)<br></code></pre></td></tr></table></figure><h4 id="显示工作表的索引范围">显示工作表的索引范围</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">wb</span><span class="hljs-selector-class">.get_named_ranges</span>()<br></code></pre></td></tr></table></figure><h4 id="显示所有工作表的名字">显示所有工作表的名字</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">wb</span><span class="hljs-selector-class">.get_sheet_names</span>()<br></code></pre></td></tr></table></figure><h4 id="取得第一张表">取得第一张表</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">sheetnames</span> = wb.get_sheet_names()  <br><span class="hljs-attr">ws</span> = wb.get_sheet_by_name(sheetnames[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h4 id="获取表名">获取表名</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ws</span><span class="hljs-selector-class">.title</span><br></code></pre></td></tr></table></figure><h4 id="获取表的行数">获取表的行数</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ws</span><span class="hljs-selector-class">.get_highest_row</span>()<br></code></pre></td></tr></table></figure><h4 id="获取表的列数">获取表的列数</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ws</span><span class="hljs-selector-class">.get_highest_column</span>()<br></code></pre></td></tr></table></figure><p><strong>单元格的读取，此处和xlrd的读取方式很相近，都是通过行和列的索引来读取</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">#读取B1单元格中的内容<br>ws.cell(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>).value<br></code></pre></td></tr></table></figure><p><strong>当然也支持通过Excel坐标来读取数据，代码如下</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-meta">#读取B1单元格中的内容</span><br>ws.cell(<span class="hljs-string">"B1"</span>).<span class="hljs-keyword">value</span><br></code></pre></td></tr></table></figure><h3 id="（2）实例-2">（2）实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> pandas <span class="hljs-keyword">import</span> DataFrame<br><br><span class="hljs-comment"># df = pd.read_excel(r'练习-copy.xlsx',sheet_name='学生成绩表')</span><br><span class="hljs-comment"># print(df.head())</span><br><br>data = &#123;<br>        <span class="hljs-string">'name'</span>:[<span class="hljs-string">'张三'</span>,<span class="hljs-string">'李四'</span>,<span class="hljs-string">'王五'</span>],<br>        <span class="hljs-string">'age'</span>:[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>],<br>        <span class="hljs-string">'sex'</span>:[<span class="hljs-string">'男'</span>,<span class="hljs-string">'女'</span>,<span class="hljs-string">'未知'</span>],<br>&#125;<br><br><br>df = DataFrame(data)<br>df.to_excel(<span class="hljs-string">'new.xlsx'</span>)<br></code></pre></td></tr></table></figure><h5 id="查看new-xlsx文件">查看<code>new.xlsx</code>文件</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200508182901056.png" alt="image-20200508182901056"></p><h2 id="4、案例">4、案例</h2><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200508183249888.png" alt="image-20200508183249888"></p><p><strong>把提供的原始Excel文档中的两个表格提取到另外一个新的Excel文档中，横向排列</strong></p><h4 id="代码如下：">代码如下：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> openpyxl<br><span class="hljs-keyword">import</span> pandas<br><span class="hljs-keyword">from</span> pandas <span class="hljs-keyword">import</span> DataFrame<br><br>wb = openpyxl.load_workbook(<span class="hljs-string">'Live数据库及表结构.xlsx'</span>)<br>sheet = wb[<span class="hljs-string">'Sheet1'</span>]<br><br>aa = []<br><span class="hljs-keyword">for</span> row1 <span class="hljs-keyword">in</span> sheet.iter_rows(min_row=<span class="hljs-number">3</span>,max_row=<span class="hljs-number">6</span>):<br>    score1 = [cell.value <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> row1]<br>    aa.append(score1)<br>df = DataFrame(aa)<br>df.to_excel(<span class="hljs-string">'xgp.xlsx'</span>)<br><br>bb = []<br><span class="hljs-keyword">for</span> row2 <span class="hljs-keyword">in</span> sheet.iter_rows(min_row=<span class="hljs-number">8</span>,max_row=<span class="hljs-number">14</span>):<br>    score2 = [cell.value <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> row2]<br>    bb.append(score2)<br><br>df = pandas.DataFrame(bb)<br>book = openpyxl.load_workbook(<span class="hljs-string">'xgp.xlsx'</span>)<br><span class="hljs-keyword">with</span> pandas.ExcelWriter(<span class="hljs-string">'xgp.xlsx'</span>)<span class="hljs-keyword">as</span> E:<br>    E.book = book<br>    E.sheets = dict((ws.title, ws) <span class="hljs-keyword">for</span> ws <span class="hljs-keyword">in</span> book.worksheets)<br>    df.to_excel(E,sheet_name=<span class="hljs-string">'Sheet1'</span>,index=<span class="hljs-literal">False</span>,startcol=<span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure><h5 id="查看xgp-xlsx文件">查看<code>xgp.xlsx</code>文件</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200508183511501.png" alt="image-20200508183511501"></p><h2 id="5、总结">5、总结</h2><p><strong>读取Excel时，选择openpyxl和xlrd差别不大，都能满足要求</strong><br><strong>写入少量数据且存为xls格式文件时，用xlwt更方便</strong><br><strong>写入大量数据（超过xls格式限制）或者必须存为xlsx格式文件时，就要用openpyxl了。</strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python监控Linux系统（1）</title>
      <link href="/posts/54c9.html"/>
      <url>/posts/54c9.html</url>
      
        <content type="html"><![CDATA[<h1>一、使用开源库监控Linux</h1><p><strong>在这一小节，我们将介绍一个在Python生态中广泛使用的开源项目，即psutil。随后，我们将使用psutil重构前一小节编写的监控程序。另外，还会简单介绍psutil提供的进程管理功能。</strong></p><h2 id="1、psutil介绍">1、psutil介绍</h2><blockquote><p>psutil = process and system utilities</p></blockquote><ul><li><strong>psutil是一个开源且跨平台的库，其提供了便利的函数用来获取操作系统的信息，比如CPU，内存，磁盘，网络等。此外，psutil还可以用来进行进程管理，包括判断进程是否存在、获取进程列表、获取进程详细信息等。而且psutil还提供了许多命令行工具提供的功能，包括：ps，top，lsof，netstat，ifconfig， who，df，kill，free，nice，ionice，iostat，iotop，uptime，pidof，tty，taskset，pmap。</strong></li><li><strong><code>psutil是一个跨平台的库</code>，支持Linux、Windows、OSX、FreeBSD、OpenBSD、NetBSD、Sun Solaris、AIX等操作系统。同时，psutil也支持32位与64位的系统架构，支持Python2.6到Python3.x之间的所有Python版本。</strong></li><li><strong>psutil具有简单易用、功能强大、跨平台等诸多优点，广泛应用于开源项目中，比较有名的有glances、Facebook的osquery、Google的grr等。psutil不但广泛应用于Python语言开发的开源项目中，还被移植到了其他编程语言中，如Go语言的gopsutil、C语言的cpslib、Rust语言的rust-psutil、Ruby语言的posixpsutil等。</strong></li></ul><h3 id="pip安装psutil">pip安装psutil</h3><p><strong>psutil是一个第三方的开源项目，因此，需要先安装才能够使用。如果安装了Anaconda，psutil就已经可用了。否则，需要在命令行下通过pip安装：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# pip3 install psutil<br>Collecting psutil<br>  Downloading psutil-5.7.0.tar.gz (449 kB)<br>     |████████████████████████████████| 449 kB 4.6 kB/s <br>Installing collected packages: psutil<br>    Running setup.py install for psutil ... done<br>Successfully installed psutil-5.7.0<br>[root@python scripts]# ipython            #打开ipython<br></code></pre></td></tr></table></figure><p><strong>psutil包含了异常、类、功能函数和常量，其中功能函数用来获取系统的信息，如CPU、磁盘、内存、网络等。类用来实现进程的管理功能。</strong></p><h2 id="2、psutil提供的功能函数">2、psutil提供的功能函数</h2><p><strong>根据函数的功能，主要分为CPU、磁盘、内存、网络几类，下面将会总几个方面来介绍psutil提供的功能函数。在这一小节，我们也将学习如何使用psutil来简化使用shell脚本获取监控信息的程序，并获取CPU、内存、磁盘和网络等不同维度。</strong></p><h3 id="（1）CPU">（1）CPU</h3><h4 id="与CPU相关的功能函数如下："><strong>与CPU相关的功能函数如下：</strong></h4><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>psutil.cpu_count()</td><td>cpu_count(,[logical]):默认返回逻辑CPU的个数,当设置logical的参数为False时，返回物理CPU的个数。</td></tr><tr><td>psutil.cpu_percent()</td><td>cpu_percent(,[percpu],[interval])：返回CPU的利用率,percpu为True时显示所有物理核心的利用率,interval不为0时,则阻塞时显示interval执行的时间内的平均利用率</td></tr><tr><td>psutil.cpu_times()</td><td>cpu_times(,[percpu])：以命名元组(namedtuple)的形式返回cpu的时间花费,percpu=True表示获取每个CPU的时间花费</td></tr><tr><td>psutil.cpu_times_percent()</td><td>cpu_times_percent(,[percpu])：功能和cpu_times大致相同，看字面意思就能知道，该函数返回的是耗时比例。</td></tr><tr><td>psutil.cpu_stats()</td><td>cpu_stats()以命名元组的形式返回CPU的统计信息，包括上下文切换，中断，软中断和系统调用次数。</td></tr><tr><td>psutil.cpu_freq()</td><td>cpu_freq([percpu])：返回cpu频率</td></tr></tbody></table><h4 id="1）cpu-count">1）cpu_count</h4><blockquote><p><strong>默认返回逻辑CPU的个数,当设置logical的参数为False时，返回物理CPU的个数。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> psutil                                            <br><br>In [<span class="hljs-number">2</span>]: psutil.cpu_count()                    <span class="hljs-comment">#查看处理器内核数</span><br>Out[<span class="hljs-number">2</span>]: <span class="hljs-number">1</span><br><br>In [<span class="hljs-number">3</span>]: psutil.cpu_count(logical=<span class="hljs-literal">False</span>)       <span class="hljs-comment">#查看目前使用的处理器内核数                   </span><br>Out[<span class="hljs-number">3</span>]: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="2）cpu-percent">2）cpu_percent</h4><blockquote><p><strong>返回CPU的利用率，percpu为True时显示所有物理核心的利用率，interval不为0时，则阻塞时显示interval执行的时间内的平均利用率。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">5</span>]: psutil.cpu_percent()                <span class="hljs-comment">#查看每个内核使用率 </span><br>Out[<span class="hljs-number">5</span>]: <span class="hljs-number">0.2</span><br><br>In [<span class="hljs-number">6</span>]: psutil.cpu_percent(percpu=<span class="hljs-literal">True</span>)                          <br>Out[<span class="hljs-number">6</span>]: [<span class="hljs-number">0.5</span>]<br><br>In [<span class="hljs-number">7</span>]: psutil.cpu_percent(percpu=<span class="hljs-literal">True</span>,interval=<span class="hljs-number">2</span>)               <br>Out[<span class="hljs-number">7</span>]: [<span class="hljs-number">0.0</span>]<br></code></pre></td></tr></table></figure><h4 id="3）cpu-times">3）cpu_times</h4><blockquote><p><strong>以命名元组(namedtuple)的形式返回cpu的时间花费，percpu=True表示获取每个CPU的时间花费。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">8</span>]: psutil.cpu_times()                                       <br>Out[<span class="hljs-number">8</span>]: scputimes(user=<span class="hljs-number">11.1</span>, nice=<span class="hljs-number">0.0</span>, system=<span class="hljs-number">14.05</span>, idle=<span class="hljs-number">3252.64</span>, iowait=<span class="hljs-number">0.98</span>, irq=<span class="hljs-number">0.0</span>, softirq=<span class="hljs-number">0.18</span>, steal=<span class="hljs-number">0.0</span>, guest=<span class="hljs-number">0.0</span>, guest_nice=<span class="hljs-number">0.0</span>)<br><br>In [<span class="hljs-number">9</span>]: psutil.cpu_times_percent()                               <br>Out[<span class="hljs-number">9</span>]: scputimes(user=<span class="hljs-number">0.2</span>, nice=<span class="hljs-number">0.0</span>, system=<span class="hljs-number">0.1</span>, idle=<span class="hljs-number">99.6</span>, iowait=<span class="hljs-number">0.0</span>, irq=<span class="hljs-number">0.0</span>, softirq=<span class="hljs-number">0.0</span>, steal=<span class="hljs-number">0.0</span>, guest=<span class="hljs-number">0.0</span>, guest_nice=<span class="hljs-number">0.0</span>)<br></code></pre></td></tr></table></figure><h4 id="4）cpu-stats">4）cpu_stats</h4><blockquote><p><strong>以命名元组的形式返回CPU的统计信息，包括上下文切换，中断，软中断和系统调用次数。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">10</span>]: psutil.cpu_stats()                                      <br>Out[<span class="hljs-number">10</span>]: scpustats(ctx_switches=<span class="hljs-number">403960</span>, interrupts=<span class="hljs-number">214204</span>, soft_interrupts=<span class="hljs-number">217258</span>, syscalls=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h4 id="5）cpu-freq">5）cpu_freq</h4><blockquote><p><strong>返回cpu频率。</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">11</span>]: psutil.cpu_freq()                                       <br>Out[<span class="hljs-number">11</span>]: scpufreq(current=<span class="hljs-number">1799.453</span>, min=<span class="hljs-number">0.0</span>, max=<span class="hljs-number">0.0</span>)<br></code></pre></td></tr></table></figure><h3 id="（2）内存">（2）内存</h3><h4 id="与内存相关的功能函数如下：">与内存相关的功能函数如下：</h4><h4 id="1）virtual-memory">1）virtual_memory</h4><p><strong>以命名元组的形式返回内存使用情况，包括总内存、可用内存、内存利用率、buffer和cache等。除了内存利用率，其它字段都以字节为单位返回。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> psutil                                                              <br><br>In [<span class="hljs-number">12</span>]: psutil.virtual_memory()                                 <br>Out[<span class="hljs-number">12</span>]: svmem(total=<span class="hljs-number">1023934464</span>, available=<span class="hljs-number">383610880</span>, percent=<span class="hljs-number">62.5</span>, used=<span class="hljs-number">481861632</span>, free=<span class="hljs-number">67833856</span>, active=<span class="hljs-number">436379648</span>, inactive=<span class="hljs-number">340885504</span>, buffers=<span class="hljs-number">2166784</span>, cached=<span class="hljs-number">472072192</span>, shared=<span class="hljs-number">7598080</span>, slab=<span class="hljs-number">79253504</span>)<br></code></pre></td></tr></table></figure><h4 id="单位转换"><strong>单位转换</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/usr/bin/python</span><br><span class="hljs-comment">#-*- conding:utf-8 _*_</span><br><br><span class="hljs-keyword">import</span> psutil<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bytes2human</span><span class="hljs-params">(n)</span>:</span><br>     symbols = (<span class="hljs-string">'K'</span>,<span class="hljs-string">'M'</span>,<span class="hljs-string">'G'</span>,<span class="hljs-string">'T'</span>,<span class="hljs-string">'P'</span>,<span class="hljs-string">'E'</span>,<span class="hljs-string">'Z'</span>,<span class="hljs-string">'Y'</span>)<br>     prefix = &#123;&#125;<br>     <span class="hljs-keyword">for</span> i,s <span class="hljs-keyword">in</span> enumerate(symbols):<br>         prefix[s] = <span class="hljs-number">1</span> &lt;&lt; (i + <span class="hljs-number">1</span>) * <span class="hljs-number">10</span><br>         print(prefix[s])<br>     print(<span class="hljs-string">'============'</span>)<br>     <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> reversed(symbols):<br>         <span class="hljs-keyword">if</span> n &gt;= prefix[s]:<br>             value = float(n) / prefix[s]<br>             <span class="hljs-keyword">return</span> <span class="hljs-string">'%.1f%s'</span> % (value,s)<br>             <span class="hljs-comment"># return '&#123;0&#125;.1f&#123;1&#125;'.format(value, s)</span><br>     <span class="hljs-keyword">return</span> <span class="hljs-string">"%sB"</span> % n<br>     <span class="hljs-comment"># return "&#123;0&#125;B" .format(n)</span><br><br><br>print(<span class="hljs-string">"总内存："</span>+bytes2human(psutil.virtual_memory().total))<br></code></pre></td></tr></table></figure><h5 id="运行结果如下所示：">运行结果如下所示：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python scripts]# python3 monitor_mem.py <br>1024<br>1048576<br>1073741824<br>1099511627776<br>1125899906842624<br>1152921504606846976<br>1180591620717411303424<br>1208925819614629174706176<br>============<br>总内存：976.5M<br></code></pre></td></tr></table></figure><h5 id="分析一下">分析一下</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200506155100111.png" alt="image-20200506155100111"></p><h4 id="2）swap-memory">2）swap_memory</h4><p><strong>以命名元组的形式返回swap/memory使用情况，包含swap中页的换入和换出。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">13</span>]: psutil.swap_memory()                                    <br>Out[<span class="hljs-number">13</span>]: sswap(total=<span class="hljs-number">2147479552</span>, used=<span class="hljs-number">0</span>, free=<span class="hljs-number">2147479552</span>, percent=<span class="hljs-number">0.0</span>, sin=<span class="hljs-number">0</span>, sout=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h3 id="（3）磁盘">（3）磁盘</h3><p><strong>与磁盘相关的功能如下：</strong></p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>psutil.disk_io_counters()</td><td>disk_io_counters([perdisk])：以命名元组的形式返回磁盘io统计信息(汇总的)，包括读、写的次数，读、写的字节数等。 当perdisk的值为True，则分别列出单个磁盘的统计信息(字典：key为磁盘名称，value为统计的namedtuple)。</td></tr><tr><td>psutil.disk_partitions()</td><td>disk_partitions([all=False])：以命名元组的形式返回所有已挂载的磁盘，包含磁盘名称，挂载点，文件系统类型等信息。 当all等于True时，返回包含/proc等特殊文件系统的挂载信息</td></tr><tr><td>psutil.disk_usage()</td><td>disk_usage(path)：以命名元组的形式返回path所在磁盘的使用情况，包括磁盘的容量、已经使用的磁盘容量、磁盘的空间利用率等。</td></tr></tbody></table><h4 id="1）psutil-disk-io-counters">1）psutil.disk_io_counters</h4><p><strong>以命名元组的形式返回磁盘io统计信息(汇总的)，包括读、写的次数，读、写的字节数等。 当perdisk的值为True，则分别列出单个磁盘的统计信息(字典：key为磁盘名称，value为统计的namedtuple)。有了disk_io_counters函数，省去了解析/proc/diskstats文件的烦恼。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> psutil                                                              <br><br>In [<span class="hljs-number">2</span>]: psutil.disk_io_counters()                              <br>Out[<span class="hljs-number">2</span>]: sdiskio(read_count=<span class="hljs-number">86913</span>, write_count=<span class="hljs-number">46560</span>, read_bytes=<span class="hljs-number">5038501376</span>, write_bytes=<span class="hljs-number">408987648</span>, read_time=<span class="hljs-number">77974</span>, write_time=<span class="hljs-number">79557</span>, read_merged_count=<span class="hljs-number">5933</span>, write_merged_count=<span class="hljs-number">35916</span>, busy_time=<span class="hljs-number">42153</span>)<br><br>In [<span class="hljs-number">3</span>]: psutil.disk_io_counters(perdisk=Tru<br>Out[<span class="hljs-number">3</span>]: <br>&#123;<span class="hljs-string">'sda'</span>: sdiskio(read_count=<span class="hljs-number">41472</span>, write_count=<span class="hljs-number">5340</span>, read_bytes=<span class="hljs-number">2524417024</span>, write_bytes=<span class="hljs-number">205662720</span>, read_time=<span class="hljs-number">38302</span>, write_time=<span class="hljs-number">4484</span>, read_merged_count=<span class="hljs-number">5933</span>, write_merged_count=<span class="hljs-number">35916</span>, busy_time=<span class="hljs-number">21074</span>),<br> <span class="hljs-string">'sda1'</span>: sdiskio(read_count=<span class="hljs-number">1854</span>, write_count=<span class="hljs-number">4</span>, read_bytes=<span class="hljs-number">6441472</span>, write_bytes=<span class="hljs-number">2097152</span>, read_time=<span class="hljs-number">370</span>, write_time=<span class="hljs-number">35</span>, read_merged_count=<span class="hljs-number">0</span>, write_merged_count=<span class="hljs-number">0</span>, busy_time=<span class="hljs-number">396</span>),<br> <span class="hljs-string">'sda2'</span>: sdiskio(read_count=<span class="hljs-number">39587</span>, write_count=<span class="hljs-number">5337</span>, read_bytes=<span class="hljs-number">2516263424</span>, write_bytes=<span class="hljs-number">203570688</span>, read_time=<span class="hljs-number">37925</span>, write_time=<span class="hljs-number">4449</span>, read_merged_count=<span class="hljs-number">5933</span>, write_merged_count=<span class="hljs-number">35916</span>, busy_time=<span class="hljs-number">20675</span>),<br> <span class="hljs-string">'sr0'</span>: sdiskio(read_count=<span class="hljs-number">0</span>, write_count=<span class="hljs-number">0</span>, read_bytes=<span class="hljs-number">0</span>, write_bytes=<span class="hljs-number">0</span>, read_time=<span class="hljs-number">0</span>, write_time=<span class="hljs-number">0</span>, read_merged_count=<span class="hljs-number">0</span>, write_merged_count=<span class="hljs-number">0</span>, busy_time=<span class="hljs-number">0</span>),<br> <span class="hljs-string">'dm-0'</span>: sdiskio(read_count=<span class="hljs-number">38566</span>, write_count=<span class="hljs-number">5197</span>, read_bytes=<span class="hljs-number">2483773952</span>, write_bytes=<span class="hljs-number">55885312</span>, read_time=<span class="hljs-number">37685</span>, write_time=<span class="hljs-number">3546</span>, read_merged_count=<span class="hljs-number">0</span>, write_merged_count=<span class="hljs-number">0</span>, busy_time=<span class="hljs-number">19410</span>),<br> <span class="hljs-string">'dm-1'</span>: sdiskio(read_count=<span class="hljs-number">6875</span>, write_count=<span class="hljs-number">36059</span>, read_bytes=<span class="hljs-number">30310400</span>, write_bytes=<span class="hljs-number">147697664</span>, read_time=<span class="hljs-number">1987</span>, write_time=<span class="hljs-number">71537</span>, read_merged_count=<span class="hljs-number">0</span>, write_merged_count=<span class="hljs-number">0</span>, busy_time=<span class="hljs-number">1673</span>)&#125;<br></code></pre></td></tr></table></figure><h4 id="2）psutil-disk-partitions">2）psutil.disk_partitions</h4><p><strong>以命名元组的形式返回所有已挂载的磁盘，包含磁盘名称，挂载点，文件系统类型等信息。当all等于True时，返回包含/proc等特殊文件系统的挂载信息。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">4</span>]: psutil.disk_partitions()      <span class="hljs-comment">#查看挂载点信息                    </span><br>Out[<span class="hljs-number">4</span>]: <br>[sdiskpart(device=<span class="hljs-string">'/dev/mapper/centos-root'</span>, mountpoint=<span class="hljs-string">'/'</span>, fstype=<span class="hljs-string">'xfs'</span>, opts=<span class="hljs-string">'rw,seclabel,relatime,attr2,inode64,noquota'</span>),<br> sdiskpart(device=<span class="hljs-string">'/dev/sda1'</span>, mountpoint=<span class="hljs-string">'/boot'</span>, fstype=<span class="hljs-string">'xfs'</span>, opts=<span class="hljs-string">'rw,seclabel,relatime,attr2,inode64,noquota'</span>)]<br><br>In [<span class="hljs-number">5</span>]: [device <span class="hljs-keyword">for</span> device <span class="hljs-keyword">in</span> psutil.disk_partitions() <span class="hljs-keyword">if</span> device.mountpoint == <span class="hljs-string">'/'</span>]<br>Out[<span class="hljs-number">5</span>]: [sdiskpart(device=<span class="hljs-string">'/dev/mapper/centos-root'</span>, mountpoint=<span class="hljs-string">'/'</span>, fstype=<span class="hljs-string">'xfs'</span>, opts=<span class="hljs-string">'rw,seclabel,relatime,attr2,inode64,noquota'</span>)]<br><br>In [<span class="hljs-number">6</span>]: <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_disk_via_mountpoint</span><span class="hljs-params">(point)</span>:</span>      <span class="hljs-comment">#创建一个函数</span><br>    ...:     disk = [item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> psutil.disk_partitions() <span class="hljs-keyword">if</span> item.mountpoint == point] <br>    ...:     <span class="hljs-keyword">return</span> disk[<span class="hljs-number">0</span>].device <br>//没有任何输出                           <br><br>In [<span class="hljs-number">7</span>]: get_disk_via_mountpoint(<span class="hljs-string">'/'</span>)   <span class="hljs-comment">#调用get_disk_via_mountpoint查看“/”的挂载点</span><br>Out[<span class="hljs-number">7</span>]: <span class="hljs-string">'/dev/mapper/cl-root'</span><br><br>    <br>In [<span class="hljs-number">8</span>]: get_disk_via_mountpoint(<span class="hljs-string">'/boot'</span>) <span class="hljs-comment">#调用get_disk_via_mountpoint查看“/boot”的挂载点</span><br>Out[<span class="hljs-number">8</span>]: <span class="hljs-string">'/dev/sda1'</span><br></code></pre></td></tr></table></figure><h4 id="3）psutil-disk-usage">3）psutil.disk_usage</h4><p><strong>以命名元组的形式返回path所在磁盘的使用情况，包括磁盘的容量、已经使用的磁盘容量、磁盘的空间利用率等。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">9</span>]: psutil.disk_usage(<span class="hljs-string">'/'</span>)       <br>Out[<span class="hljs-number">9</span>]: sdiskusage(total=<span class="hljs-number">18238930944</span>, used=<span class="hljs-number">6775488512</span>, free=<span class="hljs-number">11463442432</span>, percent=<span class="hljs-number">37.1</span>)<br><br>In [<span class="hljs-number">10</span>]: psutil.disk_usage(<span class="hljs-string">'/'</span>).percent<br>Out[<span class="hljs-number">10</span>]: <span class="hljs-number">37.2</span><br><br>In [<span class="hljs-number">11</span>]: type(psutil.disk_usage(<span class="hljs-string">'/'</span>).percent)<br>Out[<span class="hljs-number">11</span>]: float<br></code></pre></td></tr></table></figure><h3 id="（4）网络">（4）网络</h3><p><strong>与网络相关的函数如下：</strong></p><table><thead><tr><th>函数</th><th>详情</th></tr></thead><tbody><tr><td>psutil.net_io_counter([pernic])</td><td>以命名元组的形式返回当前系统中每块网卡的网络io统计信息，包括收发字节数，收发包的数量、出错的情况和删包情况。当pernic为True时，则列出所有网卡的统计信息。</td></tr><tr><td>psutil.net_connections([kind])</td><td>以列表的形式返回每个网络连接的详细信息(namedtuple)。命名元组包含fd, family, type, laddr, raddr, status, pid等信息。kind表示过滤的连接类型，支持的值如下：(默认为inet)</td></tr><tr><td>psutil.net_if_addrs()</td><td>以字典的形式返回网卡的配置信息，包括IP地址和mac地址、子网掩码和广播地址。</td></tr><tr><td>psutil.net_if_stats()</td><td>返回网卡的详细信息，包括是否启动、通信类型、传输速度与mtu。</td></tr><tr><td>psutil.users()</td><td>以命名元组的方式返回当前登陆用户的信息，包括用户名，登陆时间，终端，与主机信息</td></tr><tr><td>psutil.boot_time()</td><td>以时间戳的形式返回系统的启动时间</td></tr></tbody></table><h4 id="1）psutil-net-io-counter">1）psutil.net_io_counter</h4><p><strong>以命名元组的形式返回当前系统中每块网卡的网络io统计信息，包括收发字节数，收发包的数量、出错的情况和删包情况。当pernic为True时，则列出所有网卡的统计信息。使用net_io_counter函数与自己解析/proc/net/dev文件内容实现的功能相同。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> psutil                <br><br>In [<span class="hljs-number">2</span>]: psutil.net_io_counters()     <br>Out[<span class="hljs-number">2</span>]: snetio(bytes_sent=<span class="hljs-number">720405</span>, bytes_recv=<span class="hljs-number">3661606</span>, packets_sent=<span class="hljs-number">5520</span>, packets_recv=<span class="hljs-number">14886</span>, errin=<span class="hljs-number">0</span>, errout=<span class="hljs-number">0</span>, dropin=<span class="hljs-number">0</span>, dropout=<span class="hljs-number">0</span>)<br><br>In [<span class="hljs-number">3</span>]: psutil.net_io_counters(pernic=<span class="hljs-literal">True</span>) <br>Out[<span class="hljs-number">3</span>]: <br>&#123;<span class="hljs-string">'ens37'</span>: snetio(bytes_sent=<span class="hljs-number">724145</span>, bytes_recv=<span class="hljs-number">3365944</span>, packets_sent=<span class="hljs-number">5538</span>, packets_recv=<span class="hljs-number">10017</span>, errin=<span class="hljs-number">0</span>, errout=<span class="hljs-number">0</span>, dropin=<span class="hljs-number">0</span>, dropout=<span class="hljs-number">0</span>),<br> <span class="hljs-string">'lo'</span>: snetio(bytes_sent=<span class="hljs-number">0</span>, bytes_recv=<span class="hljs-number">0</span>, packets_sent=<span class="hljs-number">0</span>, packets_recv=<span class="hljs-number">0</span>, errin=<span class="hljs-number">0</span>, errout=<span class="hljs-number">0</span>, dropin=<span class="hljs-number">0</span>, dropout=<span class="hljs-number">0</span>),<br> <span class="hljs-string">'virbr0-nic'</span>: snetio(bytes_sent=<span class="hljs-number">0</span>, bytes_recv=<span class="hljs-number">0</span>, packets_sent=<span class="hljs-number">0</span>, packets_recv=<span class="hljs-number">0</span>, errin=<span class="hljs-number">0</span>, errout=<span class="hljs-number">0</span>, dropin=<span class="hljs-number">0</span>, dropout=<span class="hljs-number">0</span>),<br> <span class="hljs-string">'virbr0'</span>: snetio(bytes_sent=<span class="hljs-number">0</span>, bytes_recv=<span class="hljs-number">0</span>, packets_sent=<span class="hljs-number">0</span>, packets_recv=<span class="hljs-number">0</span>, errin=<span class="hljs-number">0</span>, errout=<span class="hljs-number">0</span>, dropin=<span class="hljs-number">0</span>, dropout=<span class="hljs-number">0</span>),<br> <span class="hljs-string">'ens33'</span>: snetio(bytes_sent=<span class="hljs-number">0</span>, bytes_recv=<span class="hljs-number">298202</span>, packets_sent=<span class="hljs-number">0</span>, packets_recv=<span class="hljs-number">4899</span>, errin=<span class="hljs-number">0</span>, errout=<span class="hljs-number">0</span>, dropin=<span class="hljs-number">0</span>, dropout=<span class="hljs-number">0</span>)&#125;<br></code></pre></td></tr></table></figure><h4 id="2）net-connections">2）net_connections</h4><p><strong>以列表的形式返回每个网络连接的详细信息(namedtuple)，可以使用该函数查看网络连接状态，统计连接个数以及处于特定状态的网络连接个数。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">4</span>]: psutil.net_connections()      <br>Out[<span class="hljs-number">4</span>]: <br>[sconn(fd=<span class="hljs-number">6</span>, family=&lt;AddressFamily.AF_INET6: <span class="hljs-number">10</span>&gt;, type=&lt;SocketKind.SOCK_STREAM: <span class="hljs-number">1</span>&gt;, laddr=addr(ip=<span class="hljs-string">'::'</span>, port=<span class="hljs-number">111</span>), raddr=(), status=<span class="hljs-string">'LISTEN'</span>, pid=<span class="hljs-number">6558</span>),<br> sconn(fd=<span class="hljs-number">7</span>, family=&lt;AddressFamily.AF_INET6: <span class="hljs-number">10</span>&gt;, type=&lt;SocketKind.SOCK_DGRAM: <span class="hljs-number">2</span>&gt;, laddr=addr(ip=<span class="hljs-string">'::'</span>, port=<span class="hljs-number">111</span>), raddr=(), status=<span class="hljs-string">'NONE'</span>, pid=<span class="hljs-number">6558</span>),<br> sconn(fd=<span class="hljs-number">8</span>, family=&lt;AddressFamily.AF_INET6: <span class="hljs-number">10</span>&gt;, type=&lt;SocketKind.SOCK_STREAM: <span class="hljs-number">1</span>&gt;, laddr=addr(ip=<span class="hljs-string">'::1'</span>, port=<span class="hljs-number">6010</span>), raddr=(), status=<span class="hljs-string">'LISTEN'</span>, pid=<span class="hljs-number">9047</span>),<br> sconn(fd=<span class="hljs-number">6</span>, family=&lt;AddressFamily.AF_INET: <span class="hljs-number">2</span>&gt;, type=&lt;SocketKind.SOCK_STREAM: <span class="hljs-number">1</span>&gt;,<br>......<br><br>In [<span class="hljs-number">5</span>]: conns = psutil.net_connections()<br><br>In [<span class="hljs-number">6</span>]: len([conn <span class="hljs-keyword">for</span> conn <span class="hljs-keyword">in</span> conns <span class="hljs-keyword">if</span> conn.status == <span class="hljs-string">'TIME_WAIT'</span>])   <br>Out[<span class="hljs-number">6</span>]: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="3）net-if-addrs">3）net_if_addrs</h4><p><strong>以字典的形式返回网卡的配置信息，包括IP地址和mac地址、子网掩码和广播地址。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">7</span>]: psutil.net_if_addrs()                                                     Out[<span class="hljs-number">7</span>]: <br>&#123;<span class="hljs-string">'lo'</span>: [snicaddr(family=&lt;AddressFamily.AF_INET: <span class="hljs-number">2</span>&gt;, address=<span class="hljs-string">'127.0.0.1'</span>, netmask=<span class="hljs-string">'255.0.0.0'</span>, broadcast=<span class="hljs-literal">None</span>, ptp=<span class="hljs-literal">None</span>),<br>  snicaddr(family=&lt;AddressFamily.AF_INET6: <span class="hljs-number">10</span>&gt;, address=<span class="hljs-string">'::1'</span>, netmask=<span class="hljs-string">'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff'</span>, broadcast=<span class="hljs-literal">None</span>, ptp=<span class="hljs-literal">None</span>),<br>  snicaddr(family=&lt;AddressFamily.AF_PACKET: <span class="hljs-number">17</span>&gt;, address=<span class="hljs-string">'00:00:00:00:00:00'</span>, netmask=<span class="hljs-literal">None</span>, broadcast=<span class="hljs-literal">None</span>, ptp=<span class="hljs-literal">None</span>)],<br> <span class="hljs-string">'ens37'</span>: [snicaddr(family=&lt;AddressFamily.AF_INET: <span class="hljs-number">2</span>&gt;, address=<span class="hljs-string">'192.168.1.131'</span>, netmask=<span class="hljs-string">'255.255.255.255'</span>, broadcast=<span class="hljs-string">'192.168.1.131'</span>, ptp=<span class="hljs-literal">None</span>),<br>  snicaddr(family=&lt;AddressFamily.AF_INET6: <span class="hljs-number">10</span>&gt;, address=<span class="hljs-string">'240e:82:e03:7342:4378:7be3:558c:fc88'</span>, netmask=<span class="hljs-string">'ffff:ffff:ffff:ffff::'</span>, broadcast=<span class="hljs-literal">None</span>, ptp=<span class="hljs-literal">None</span>)<br>......<br></code></pre></td></tr></table></figure><h4 id="4）psutil-net-if-stats">4）psutil.net_if_stats</h4><p><strong>返回网卡的详细信息，包括是否启动、通信类型、传输速度与mtu。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">8</span>]: psutil.net_if_stats()        <br>Out[<span class="hljs-number">8</span>]: <br>&#123;<span class="hljs-string">'ens37'</span>: snicstats(isup=<span class="hljs-literal">True</span>, duplex=&lt;NicDuplex.NIC_DUPLEX_FULL: <span class="hljs-number">2</span>&gt;, speed=<span class="hljs-number">1000</span>, mtu=<span class="hljs-number">1500</span>),<br> <span class="hljs-string">'lo'</span>: snicstats(isup=<span class="hljs-literal">True</span>, duplex=&lt;NicDuplex.NIC_DUPLEX_UNKNOWN: <span class="hljs-number">0</span>&gt;, speed=<span class="hljs-number">0</span>, mtu=<span class="hljs-number">65536</span>),<br> <span class="hljs-string">'virbr0-nic'</span>: snicstats(isup=<span class="hljs-literal">False</span>, duplex=&lt;NicDuplex.NIC_DUPLEX_FULL: <span class="hljs-number">2</span>&gt;, speed=<span class="hljs-number">10</span>, mtu=<span class="hljs-number">1500</span>),<br> <span class="hljs-string">'virbr0'</span>: snicstats(isup=<span class="hljs-literal">True</span>, duplex=&lt;NicDuplex.NIC_DUPLEX_UNKNOWN: <span class="hljs-number">0</span>&gt;, speed=<span class="hljs-number">0</span>, mtu=<span class="hljs-number">1500</span>),<br> <span class="hljs-string">'ens33'</span>: snicstats(isup=<span class="hljs-literal">True</span>, duplex=&lt;NicDuplex.NIC_DUPLEX_FULL: <span class="hljs-number">2</span>&gt;, speed=<span class="hljs-number">1000</span>, mtu=<span class="hljs-number">1500</span>)&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200506164244803.png" alt="image-20200506164244803"></p><h3 id="（5）其他">（5）其他</h3><h4 id="1）users">1）users</h4><p><strong>以命名元组的方式返回当前登陆用户的信息，包括用户名，登陆时间，终端，与主机信息。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">9</span>]: psutil.users()              <br>Out[<span class="hljs-number">9</span>]: <br>[suser(name=<span class="hljs-string">'root'</span>, terminal=<span class="hljs-string">':0'</span>, host=<span class="hljs-string">'localhost'</span>, started=<span class="hljs-number">1582366080.0</span>, pid=<span class="hljs-number">7991</span>),<br> suser(name=<span class="hljs-string">'root'</span>, terminal=<span class="hljs-string">'pts/0'</span>, host=<span class="hljs-string">'localhost'</span>, started=<span class="hljs-number">1582366208.0</span>, pid=<span class="hljs-number">8927</span>),<br> suser(name=<span class="hljs-string">'root'</span>, terminal=<span class="hljs-string">'pts/1'</span>, host=<span class="hljs-string">'192.168.1.4'</span>, started=<span class="hljs-number">1582370816.0</span>, pid=<span class="hljs-number">10099</span>),<br> suser(name=<span class="hljs-string">'root'</span>, terminal=<span class="hljs-string">'pts/3'</span>, host=<span class="hljs-string">'192.168.1.4'</span>, started=<span class="hljs-number">1582369408.0</span>, pid=<span class="hljs-number">9787</span>)]<br></code></pre></td></tr></table></figure><h4 id="2）boot-time">2）boot_time</h4><p><strong>以时间戳的形式返回系统的启动时间。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">9</span>]: <span class="hljs-keyword">import</span> datetime<br><br>In [<span class="hljs-number">10</span>]: psutil.boot_time()    <br>Out[<span class="hljs-number">10</span>]: <span class="hljs-number">1582527367.0</span><br>    <br>In [<span class="hljs-number">11</span>]: datetime.datetime.fromtimestamp(psutil.boot_time()).strftime(<span class="hljs-string">'%Y-%m-%d %H:%M:%S'</span>)                                  <br>Out[<span class="hljs-number">11</span>]: <span class="hljs-string">'2020-02-24 14:56:07'</span><br></code></pre></td></tr></table></figure><h2 id="3、综合案例：使用psutil实现监控程序">3、综合案例：使用psutil实现监控程序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-comment"># !/usr/bin/python</span><br><br><span class="hljs-keyword">import</span> psutil<br><span class="hljs-keyword">import</span> datetime<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bytes2human</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-string">'''内存单位转换的方法'''</span><br>    symbols = (<span class="hljs-string">'K'</span>, <span class="hljs-string">'M'</span>, <span class="hljs-string">'G'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">'P'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'Z'</span>, <span class="hljs-string">'Y'</span>)<br>    prefix = &#123;&#125;<br>    <span class="hljs-keyword">for</span> i, s <span class="hljs-keyword">in</span> enumerate(symbols):<br>        prefix[s] = <span class="hljs-number">1</span> &lt;&lt; (i + <span class="hljs-number">1</span>) * <span class="hljs-number">10</span><br>    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> reversed(symbols):<br>        <span class="hljs-keyword">if</span> n &gt;= prefix[s]:<br>            value = float(n) / prefix[s]<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">'%.1f%s'</span> % (value, s)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"%sB"</span> % n<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cpu_info</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-string">'''获取CPU使用率'''</span><br>    cpu_count = psutil.cpu_count()<br>    cpu_percent = psutil.cpu_percent(interval=<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> dict(cpu_count=cpu_count, cpu_percent=cpu_percent)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_memory_info</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-string">'''获取内存信息'''</span><br>    virtual_mem = psutil.virtual_memory()<br>    mem_total = bytes2human(virtual_mem.total)<br>    mem_percent = virtual_mem.percent<br>    mem_free = bytes2human(virtual_mem.free + virtual_mem.buffers + virtual_mem.cached)<br>    mem_used = bytes2human(virtual_mem.total * mem_percent / <span class="hljs-number">100</span>)<br>    <span class="hljs-keyword">return</span> dict(mem_total=mem_total, mem_percent=mem_percent, mem_free=mem_free, mem_used=mem_used)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_disk_info</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-string">'''获取磁盘信息'''</span><br>    disk_usage = psutil.disk_usage(<span class="hljs-string">'/'</span>)<br>    disk_total = bytes2human(disk_usage.total)<br>    disk_percent = disk_usage.percent<br>    disk_free = bytes2human(disk_usage.free)<br>    disk_used = bytes2human(disk_usage.used)<br>    <span class="hljs-keyword">return</span> dict(disk_total=disk_total, disk_percent=disk_percent, disk_free=disk_free, disk_used=disk_used)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_boot_info</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-string">'''获取启动时间'''</span><br>    boot_time = datetime.datetime.fromtimestamp(psutil.boot_time()).strftime(<span class="hljs-string">"%Y-%m-%d %H:%M:%S"</span>)<br>    <span class="hljs-keyword">return</span> dict(boot_time=boot_time)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">collect_monitor_data</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-string">'''集中监控硬件信息'''</span><br>    data = &#123;&#125;<br>    data.update(get_boot_info())<br>    data.update(get_cpu_info())<br>    data.update(get_memory_info())<br>    data.update(get_disk_info())<br>    print(data)<br>    <span class="hljs-keyword">return</span> data<br><br><br>collect_monitor_data()<br></code></pre></td></tr></table></figure><h5 id="执行结果如下">执行结果如下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python scripts]# python3 monitor_psutil.py<br>&#123;'boot_time': '2020-05-06 16:23:37', 'cpu_count': 1, 'cpu_percent': 0.0, 'mem_total': '976.5M', 'mem_percent': 71.4, 'mem_free': '448.0M', 'mem_used': '697.2M', 'disk_total': '17.0G', 'disk_percent': 30.4, 'disk_free': '11.8G', 'disk_used': '5.2G'&#125;<br></code></pre></td></tr></table></figure><h2 id="4、psutil进程管理">4、psutil进程管理</h2><p><strong>psutil还提供了作为进程管理的功能函数，包括获取进程列表，判断是否存在，以及进程管理的类封装</strong>。</p><table><thead><tr><th>函数</th><th>详情</th></tr></thead><tbody><tr><td>psutil.Process()</td><td>对进程进行封装，可以使用该类的方法获取进行的详细信息，或者给进程发送信号。</td></tr><tr><td>psutil.pids()</td><td>以列表的形式返回当前正在运行的进程</td></tr><tr><td>psutil.pid_exists(1)</td><td>判断给点定的pid是否存在</td></tr><tr><td>psutil.process_iter()</td><td>迭代当前正在运行的进程，返回的是每个进程的Process对象</td></tr></tbody></table><h3 id="1）Process类">1）Process类</h3><p><strong>对进程进行封装，可以使用该类的方法获取进行的详细信息，或者给进程发送信号。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> psutil                 <br><br>In [<span class="hljs-number">2</span>]: init_process = psutil.Process()<br><br>In [<span class="hljs-number">3</span>]: init_process.cmdline()      <br>Out[<span class="hljs-number">3</span>]: [<span class="hljs-string">'/usr/local/python38/bin/python3.8'</span>, <span class="hljs-string">'/usr/local/python38/bin/ipython'</span>]<br></code></pre></td></tr></table></figure><p><strong>Process类包含很多方法来获取进程的详细信息。下面是几个较常用的方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">name：获取进程的名称<br>cmdline：获取启动进程的命令行参数<br>create_time：获取进程的创建时间(时间戳格式)<br>num_fds：进程打开的文件个数<br>num_threads：进程的子进程个数<br>is_running：判断进程是否正在运行<br>send_signal：给进程发送信号，类似与os.kill等<br>kill：发送SIGKILL信号结束进程<br>terminate：发送SIGTEAM信号结束进程<br></code></pre></td></tr></table></figure><h3 id="2）pids">2）pids</h3><p><strong>以列表的形式返回当前正在运行的进程。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> psutil                 <br><br>In [<span class="hljs-number">2</span>]: init_process = psutil.Process()<br><br>In [<span class="hljs-number">3</span>]: init_process.cmdline()       <br>Out[<span class="hljs-number">3</span>]: [<span class="hljs-string">'/usr/local/python38/bin/python3.8'</span>, <span class="hljs-string">'/usr/local/python38/bin/ipython'</span>]<br><br>In [<span class="hljs-number">4</span>]: psutil.pids()[:<span class="hljs-number">5</span>]            <br>Out[<span class="hljs-number">4</span>]: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><h3 id="3）pid-exists">3）pid_exists</h3><p><strong>判断给点定的pid是否存在。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">5</span>]: psutil.pid_exists(<span class="hljs-number">1</span>)          <br>Out[<span class="hljs-number">5</span>]: <span class="hljs-literal">True</span><br><br>In [<span class="hljs-number">6</span>]: psutil.pid_exists(<span class="hljs-number">10245</span>)                              <br>Out[<span class="hljs-number">6</span>]: <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h3 id="4）process-iter">4）process_iter</h3><p><strong>迭代当前正在运行的进程，返回的是每个进程的Process对象，而pids返回的是进程的列表。</strong></p><h1>二、使用Python监控MongoDB</h1><p><strong>对于MongoDB数据库来说，获取监控的方法比较简单，因为MongoDB本身流返回给我们一个字典形式的数据。如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pymongo<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/usr/bin/python</span><br><span class="hljs-comment">#_*_ coding:utf-8 _*_</span><br><br><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function<br><span class="hljs-keyword">import</span> pymongo<br><br><br>client = pymongo.MongoClient(host=<span class="hljs-string">'127.0.0.1:27017'</span>)<br>client.admin.authenticate(<span class="hljs-string">'laoyu'</span>,<span class="hljs-string">'laoyu'</span>)<br>rs = client.admin.command(<span class="hljs-string">'replSetGetStatus'</span>)<br><br>print(<span class="hljs-string">"set:"</span>,rs[<span class="hljs-string">'set'</span>])<br>print(<span class="hljs-string">"myState:"</span>,rs[<span class="hljs-string">'myState'</span>])<br>print(<span class="hljs-string">'num of members:'</span>,len(rs[<span class="hljs-string">'members'</span>]))<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python监控Linux系统（2）</title>
      <link href="/posts/10c9.html"/>
      <url>/posts/10c9.html</url>
      
        <content type="html"><![CDATA[<h1>使用Python监控Linux系统</h1><p><strong>Linux下有许多使用Python语言编写的监控工具，如inotify-sync, dstat和glances. 此外，如果要根据业务编写简单的监控脚本，很多工程师也会选择Python语言。Python语言是一门简单 易学/语法清晰/表达能力强的编程语言,非常适合于编写监控程序的场景。使用Python语言编写监控程序具有以下几个优势:</strong></p><ul><li><strong>Python语言开发效率高。 Python语言有自 己的优势与劣势，使用Python开发监控程序是一个充分发挥Python优势，避免Python劣势的领域。对于监控程序来说，能够利用Python语言开发效率高的优势尽快完成程序的编写工作。同时，监控程序也不要求性能，因此避免了Python语言性能不如C、C++和Java的劣势。</strong></li><li><strong>Python语言表达能力强。相信任何-个学习Linux的工程师都使用过shel脚本编写过监控程序。虽然Linux下有很多监控工具,也有很多文本处理程序，但是获取监控与解析结果是完全不同的工具。解析监控结果的程序不理解监控程序输出结果的具体含义。Python语言中有非常丰富的数据结构，可以用各种方式保存监控结果，以便后续处理。</strong></li><li><strong>利用第三方库开发监控程序。Python的标准库本身非常强大,被称为”连电池都包含在内”。对于-个问题,如果标准库没有提供相应的工具,那么也会有开源的项目来填补这个空白。监控程序正式这样一种情况， 在Python语言中，具有非常成熟的第三方库帮助开发者简化监控程序的编写工作。</strong></li></ul><h1>一、Python编写的监控工具</h1><p><strong>我们将介绍两个Python语言编写的监控工具，分别是dstat和glances。</strong></p><h2 id="1、多功能系统资源统计工具dstat">1、多功能系统资源统计工具dstat</h2><p><strong>dstat是一个用Python语言实现的多功能系统资源统计工具，用来取代Linux下的vmstat、iostat、netstat和ifstat等命令。并且，dstat克服了这些命令的限制，增加了额外的功能、以及更多的计数器与更好的灵活性。dstat可以在一个界面上展示非常全面的监控信息，因此，在系统监控、基准测试和故障排除等应用场景下特别有用。</strong></p><p><strong>我们可以使用dstat监控所有系统资源的使用情况，并且可以结合不同的场景定制监控的资源。例如，在同一时间段以相同的时间频率比较网络带宽与磁盘的吞吐率。</strong></p><p><strong>dstat将以列表的形式显示监控信息，并且用不同的颜色进行输出，以可读性较强的单位展示监控数值。例如，对于字节数值，dstat自动根据数值的大小，以K、M、G等单位进行显示，避免了开发者使用其他命令时因为数值太大造成的困惑和错误。此外，使用dstat还可以非常方便地编写插件用来收集默认情况下没有收集的监控信息。dstat是专门为人们实时查看监控信息设计的，因此，默认将监控结果输出到屏幕终端。我们也可以将监控信息以CSV格式输出到文件，以便后续处理。</strong></p><h2 id="2、dstat介绍">2、dstat介绍</h2><p><strong>作为一个多功能系统资源统计工具， dstat具有以下特性:</strong></p><ul><li><strong>结合了 vmstat, iostat, ifstat, netstat 等监控工具的功能，并且提供了更多的监控信息；</strong></li><li><strong>实时显示监控数据；</strong></li><li><strong>在问题分析和故障排查时，可以监视最重要的计数器，也可以对计数器进行排序；</strong></li><li><strong>模块化设计；</strong></li><li><strong>使用 Python 语言编写，更方便扩展现有的工作任务；</strong></li><li><strong>容易扩展，便于添加自定义的计数器；</strong></li><li><strong>包含的许多扩展插件充分说明了增加新的监控项目是很方便的；</strong></li><li><strong>可以分组统计块设备/网络设备，并给出、汇总信息；</strong></li><li><strong>可以显示每台设备中断信息；</strong></li><li><strong>非常准确的时间精度，即便是系统负荷较高也不会延迟显示；</strong></li><li><strong>准确显示单位，限制转换误差范围；</strong></li><li><strong>用不同的颜色显示不同的单位，增加可读性；</strong></li><li><strong>显示中间结果延时小于1秒</strong></li><li><strong>支持 csv 格式输出，便于将监控信息导人 Gnumeric 和 Excel 以生成图形。</strong></li></ul><h2 id="3、安装使用">3、安装使用</h2><p><strong>如果操作系统默认没有安装dstat.那么需要我们手动进行安装。如下所示:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# yum -y install dstat<br></code></pre></td></tr></table></figure><p><strong>&lt;1&gt;dstat命令的–version选项，除了显示出tat的版本以外，还会显示操作系统的版本、Python语言的版本、cpu的个数，以及dstat支持的插件列表等详细信息。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# dstat --version<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200429141843251.png" alt="image-20200429141843251"></p><p><strong>&lt;2&gt;dstat --list获取dstat的插件列表</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dstat --list<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200429141907299.png" alt="image-20200429141907299"></p><p><strong>&lt;3&gt;直接在终端输入dstat命令，dstat将以默认参数运行。默认情况下，dstat会收集cpu、磁盘、网络、换页和系统信息，并以一秒钟一次的频率进行输出，直到我们按 ctrl+c 结束。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# dstat<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200429141632842.png" alt="image-20200429141632842"></p><h2 id="4、常用选项如下">4、常用选项如下: .</h2><blockquote><p><strong>直接跟数字，表示#秒收集一次数据，默认为1秒; dstat 5表示5秒更新一次</strong></p></blockquote><ul><li><p><strong>-c,–cpu：统计CPU状态，包括system，user，idle，wait，hardware interrupt，software，interrupt等;</strong></p></li><li><p><strong>-d，–disk：统计磁盘读写状态</strong></p></li><li><p><strong>-D total,sda：统计指定磁盘或汇总信息</strong></p></li><li><p><strong>-l，–load：统计系统负载情况，包括1分钟、5分钟、15分钟平均值</strong></p></li><li><p><strong>-m，- -mem：统计系统物理内存使用情况，包括used, buffers， cache，free</strong></p></li><li><p><strong>-s，–swap：统计swap已使用和剩余量</strong></p></li><li><p><strong>-n，–net：统计网络使用情况，包括接收和发送数据</strong></p></li><li><p><strong>-N eth1,total 统计eth1接口汇总流量</strong></p></li><li><p><strong>-r，–io：统计I/0请求，包括读写请求</strong></p></li><li><p><strong>-p，–proc：统计进程信息，包括runnable、uninterruptible、new</strong></p></li><li><p><strong>-y，–sys：统计系统信息，包括中断、上下文切换</strong></p></li><li><p><strong>-t：显示统计时时间，对分析历史数据非常有用</strong></p></li><li><p><strong>–fs：统计文件打开数和inodes数</strong></p></li></ul><p><strong>除了前面介绍的与监控相关的参数以外，dstat还可以像vmstat和iostat- 样使用参数控制报告的时间间隔，或者同时指定时间间隔与报告次数。</strong></p><p><strong>例如，下面的命令表示以默认的选项运行dstat,每2秒钟输出1条监控信息，并在输出10条监控信息以后退出dstat。如下所示:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# dstat 2 10<br>You did not select any stats, using -cdngy by default.<br>Terminal width too small, trimming output.<br>----total-cpu-usage---- -dsk/total- -net/total- ---paging--&gt;<br>usr sys idl wai hiq siq| read  writ| recv  send|  in   out &gt;<br>  2   1  96   0   0   0| 270k  233k|   0     0 |  75B 1812B&gt;<br>  0   0 100   0   0   0|   0     0 |  60B  510B|   0     0 &gt;<br>  0   0 100   0   0   0|   0     0 |  60B  294B|   0     0 &gt;<br>  0   1 100   0   0   0|   0     0 |  60B  294B|   0     0 &gt;<br>  0   0 100   0   0   0|   0     0 | 182B  294B|   0     0 &gt;<br>  1   0 100   0   0   0|   0     0 |  60B  294B|   0     0 &gt;<br>  0   1  99   0   0   0|   0     0 |  60B  294B|   0     0 &gt;<br>  0   1 100   0   0   0|   0     0 |  60B  294B|   0     0 &gt;<br>  0   0 100   0   0   0|   0     0 |  60B  294B|   0     0 &gt;<br>  1   0 100   0   0   0|   0     0 |  60B  294B|   0     0 &gt;<br>  0   0 100   0   0   0|   0    25k|  60B  298B|   0     0 &gt;<br></code></pre></td></tr></table></figure><p><strong>dstat命令中有很多参数可选，你可以通过man dstat命令查看，大多数常用的参数有这些：</strong></p><ul><li><strong>-l ：显示负载统计量</strong></li><li><strong>-m ：显示内存使用率（包括used，buffer，cache，free值）</strong></li><li><strong>-r ：显示I/O统计</strong></li><li><strong>-s ：显示交换分区使用情况</strong></li><li><strong>-t ：将当前时间显示在第一行</strong></li><li><strong>–fs ：显示文件系统统计数据（包括文件总数量和inodes值）</strong></li><li><strong>–nocolor ：不显示颜色（有时候有用）</strong></li><li><strong>–socket ：显示网络统计数据</strong></li><li><strong>–tcp ：显示常用的TCP统计</strong></li><li><strong>–udp ：显示监听的UDP接口及其当前用量的一些动态数据</strong></li></ul><p><strong>dstat附带了一些插件很大程度地扩展了它的功能。你可以通过查看/usr/share/dstat目录来查看它们的一些使用方法，常用的有这些：</strong></p><ul><li><strong>-–disk-util ：显示某一时间磁盘的忙碌状况</strong></li><li><strong>-–freespace ：显示当前磁盘空间使用率</strong></li><li><strong>-–proc-count ：显示正在运行的程序数量</strong></li><li><strong>-–top-bio ：指出块I/O最大的进程</strong></li><li><strong>-–top-cpu ：图形化显示CPU占用最大的进程</strong></li><li><strong>-–top-io ：显示正常I/O最大的进程</strong></li><li><strong>-–top-mem ：显示占用最多内存的进程</strong></li></ul><h2 id="5、-dstat高级用法">5、 dstat高级用法</h2><p><strong>dstat的强大之处不仅仅是因为它聚合了多种工具的监控结果，还因为它能通过附带的插件事项一些更高级功能。</strong></p><p><strong>如:找出磁盘重占用资源最高的进程和用户。</strong></p><p><strong>dstat -cdlmnpsyt 5 可以得到较全面的系统性能数据。</strong></p><p><strong>dstat的–top-(io|bio|cpu|cputime|cputime-avg |mem)通过这几个选项，可以看到具体是那个用户哪个进程占用了相关系统资源, 对系统调优非常有效。如查看当前占用I/O、 cpu、内存等最高的进程信息可以使用dstat --top-mem --top-io --top-cpu选项。以下示例演示了如何找出占用资源最多的进程。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python scripts]# dstat --top-mem --top-io --top-cpu<br>//查看当前占用I/O、CPU、内存等最高的进程信息<br><br>--most-expensive- ----most-expensive---- -most-expensive-<br>  memory process |     i/o process      |  cpu process   <br>gnome-shell 53.0M|bash        420k  119k|vmtoolsd     0.1<br>gnome-shell 53.0M|BT-Task    1026B    0 |                <br>gnome-shell 53.0M|gnome-shell 352B   82k|kworker/0:0  1.0<br>gnome-shell 53.0M|sshd: root@ 230B  196B|                <br>gnome-shell 53.0M|sshd: root@ 155B  196B|                <br>gnome-shell 53.0M|sshd: root@ 155B  196B|                <br>gnome-shell 53.0M|sshd: root@ 155B  196B|                <br>gnome-shell 53.0M|BT-Task    1406B    0 |<br></code></pre></td></tr></table></figure><p><em><strong>dstat的插件保存在/usr/share/dstat目录下， 我们可以参考它们的实现，编写自己的插件。</strong></em></p><h2 id="6、将结果输出到CSV文件">6、将结果输出到CSV文件</h2><p><strong>dstat还可以将监控信息保存到CSV文件中，以便后续进行处理。通过–output选项指定监控数据输出的文件。如下所示:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# dstat -a --output dstat_output.csv<br>Terminal width too small, trimming output.<br>----total-cpu-usage---- -dsk/total- -net/total- ---paging--&gt;<br>usr sys idl wai hiq siq| read  writ| recv  send|  in   out &gt;<br>  2   1  97   0   0   0| 175k  158k|   0     0 |  59B 1973B&gt;<br>  0   0 100   0   0   0|   0     0 | 150B  822B|   0     0 &gt;<br>  0   0 100   0   0   0|   0     0 |  60B  298B|   0     0 &gt;<br>  0   0 100   0   0   0|   0     0 |  60B  298B|   0     0 &gt;<br>  0   0 100   0   0   0|   0     0 |  60B  298B|   0     0 &gt;<br>  0   1  99   0   0   0|   0     0 |  60B  298B|   0     0 &gt;<br>  0   0 100   0   0   0|   0     0 | 210B  448B|   0     0 &gt;<br>  1   0  99   0   0   0|   0    49k|  60B  298B|   0     0 &gt;<br>  0   0 100   0   0   0|   0     0 | 210B  396B|   0     0 &gt;<br>  0   0 100   0   0   0|   0     0 |  60B  298B|   0     0 &gt;^C<br></code></pre></td></tr></table></figure><h3 id="用excel查看信息">用excel查看信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# sz dstat_output.csv<br>//导出本地文件到windows指定位置<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200429160149926.png" alt="image-20200429160149926"></p><h1>二、交互性监控工具glances</h1><h2 id="1、glances简介">1、glances简介</h2><p><strong>glances是一款使用Python语言开发、基于psutil的跨平台系统监控工具。在所有的Linux命令行工具中，它与top命令最相似，都是命令行交互式监控工具。但是，glances实现了比top命令更齐全的监控，提供了更加丰富的功能。</strong></p><p><strong>在紧急情况下，工程师需要在尽可能短的时间内查看尽可能多的信息。此时，glances是一个不错的选择。 glances的设计初衷就是在当前窗口中尽可能多地显示系统消息。</strong></p><p><strong>glances可以在用户终端上实时显示重要的系统信息，并动态刷新内容。glances每隔3秒钟对其进行刷新，我们也可以使用命令行参数修改刷新的频率。与dstat相同的是，glances可以将捕获到的数据保存到文件中；而不同的是glances提供了API接口以便应用程序从glances中获取数据。</strong></p><h2 id="2、glances-提供的系统信息">2、glances 提供的系统信息</h2><ul><li><strong>CPU使用率；</strong></li><li><strong>内存使用情况；</strong></li><li><strong>内核统计信息和运行队列信息；</strong></li><li><strong>磁盘I/O速度、传输和读/写比率；</strong></li><li><strong>文件系统中的可用空间；</strong></li><li><strong>磁盘适配器；</strong></li><li><strong>网络I/O速度、传输和读/写比率；</strong></li><li><strong>页面空间和页面速度；</strong></li><li><strong>消耗资源最多的进程；</strong></li><li><strong>计算机信息和系统资源。</strong></li></ul><p><strong>glances 工具可以在用户的终端上实时显示重要的系统信息，并动态地对其进行更新。这个高效的工具可以工作于任何终端屏幕。另外它并不会消耗大量的 CPU 资源，通常低于百分之二。glances 在屏幕上对数据进行显示，并且每隔2秒钟对其进行更新。您也可以自己将这个时间间隔更改为更长或更短的数值。</strong></p><p><strong>glances 工具还可以将相同的数据捕获到一个文件，便于以后对报告进行分析和绘制图形。输出文件可以是电子表格的格式 (.csv) 或者 html 格式。</strong></p><h2 id="3、Linux下安装glances">3、Linux下安装glances</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">需要epel-release </span><br>yum -y install epel-release <br>yum -y install glances<br></code></pre></td></tr></table></figure><p><strong>或</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">需要python-devel</span><br>yum -y install python-devel -y<br>pip install glances<br></code></pre></td></tr></table></figure><h2 id="4、glances的使用">4、glances的使用</h2><h3 id="（1）glances的默认输出">（1）glances的默认输出</h3><p><strong>glances的使用非常简单，直接输入glances命令便进入了一个类似于top命令的交互式界面。在这个界面中，显示了比top更加全面，更加具有可读性的信息。</strong></p><p><strong>为了增加可读性，glances会以不同的颜色表示不同的状态。其中，绿色表示性能良好，元须做任何额外工作；蓝色表示系统性能有一些小问题，用户应当开始关注系统性能；紫色表示性能报警，应当采取措施；红色表示性能问题严重，应当立即处理。</strong></p><p><strong>lances是一个交互式的工具．因此，我们也可以输入命令来控制glances的行为。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shrell">[root@python ~]# glances<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200429151108154.png" alt="image-20200429151108154"></p><h4 id="glances-工作界面的说明"><strong>glances 工作界面的说明 :</strong></h4><p><strong>在图 1 的上部是 CPU 、Load（负载）、Mem（内存使用）、 Swap（交换分区）的使用情况。在图 1 的中上部是网络接口、Processes（进程）的使用情况。通常包括如下字段：</strong></p><ul><li><strong>VIRT: 虚拟内存大小</strong></li><li><strong>RES: 进程占用的物理内存值</strong></li><li><strong>%CPU：该进程占用的 CPU 使用率</strong></li><li><strong>%MEM：该进程占用的物理内存和总内存的百分比</strong></li><li><strong>PID: 进程 ID 号</strong></li><li><strong>USER: 进程所有者的用户名</strong></li><li><strong>TIME+: 该进程启动后占用的总的 CPU 时间</strong></li><li><strong>IO_R 和 IO_W: 进程的读写 I/O 速率</strong></li><li><strong>NAME: 进程名称</strong></li><li><strong>NI: 进程优先级</strong></li><li><strong>S: 进程状态，其中 S 表示休眠，R 表示正在运行，Z 表示僵死状态。</strong></li></ul><h3 id="（2）glances的可读性">（2）glances的可读性</h3><p><strong>对比可以发现，glances对屏幕的利用率比top明显高很多，信息量很大，有许多top所没有显示的数据。而且，glances的实时变动比top颜值高太多了。</strong></p><p><strong>Glances 会用一下几种颜色来代表状态，如下所示：</strong></p><ul><li><strong>绿色：OK（一切正常）</strong></li><li><strong>蓝色：CAREFUL（需要注意）</strong></li><li><strong>紫色：WARNING（警告）</strong></li><li><strong>红色：CRITICAL（严重）</strong></li></ul><h3 id="（3）glances中常见的命令">（3）glances中常见的命令</h3><ul><li><strong>h：显示帮助信息</strong></li><li><strong>q：离开程序退出</strong></li><li><strong>c：按照 CPU 实时负载对系统进程进行排序</strong></li><li><strong>m：按照内存使用状况对系统进程排序</strong></li><li><strong>i：按照 I/O 使用状况对系统进程排序</strong></li><li><strong>p：按照进程名称排序</strong></li><li><strong>d：显示磁盘读写状况</strong></li><li><strong>w：删除日志文件</strong></li><li><strong>l：显示日志</strong></li><li><strong>s：显示传感器信息</strong></li><li><strong>f：显示系统信息</strong></li><li><strong>1：轮流显示每个 CPU 内核的使用情况（次选项仅仅使用在多核 CPU 系统）</strong></li></ul><p><strong>glances还支持将采集的数据导入到其他服务中心，包括InfluxDB、 Cassandra. CouchDB、 OpenTSDB、Prometheus. StatsD、 ElasticSearch, RabbitMQ/ActiveMQ、ZeroMQ、 Kafaka和Riemann.</strong></p><h3 id="（4）如果我们安装了-Bottle-这个-web-框架，还能够通过-web-浏览器显示和命令行终端相同的监控界面。">（4）如果我们安装了 Bottle 这个 web 框架，还能够通过 web 浏览器显示和命令行终端相同的监控界面。</h3><p><strong>glances还支持将采集的数据导人到其他服务中心，包括InfluxDB，Cassandra，CouchDB，OpenTSDB，Prometheus，StatsD，ElasticSearch，RabbitMQ/ActiveMQ，ZeroMQ，Kafka和Riemann。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# pip install bottle<br>//安装Bottle框架<br>[root@python ~]#  glances -w              ##默认端口是61208，访问地址没有限制<br>Glances Web User Interface started on http://0.0.0.0:61208/<br></code></pre></td></tr></table></figure><h4 id="web访问如下图："><a href="127.0.0.1:61208">web访问如下图：</a></h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200429185614710.png" alt="image-20200429185614710"></p><h1>三、Python监控Linux</h1><p><strong>shell查看磁盘的监控信息，如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python proc]# cat /proc/diskstats <br>   8       0 sda 85935 21845 10913707 101067 3119 81257 743486 15647 0 31410 109079<br>   8       1 sda1 1822 0 12456 397 4 0 4096 74 0 457 462<br>   8       2 sda2 84082 21845 10897907 100659 3115 81257 739390 15573 0 30950 108604<br>  11       0 sr0 0 0 0 0 0 0 0 0 0 0 0<br> 253       0 dm-0 80726 0 10688467 99971 2275 0 82606 10224 0 27927 110196<br> 253       1 dm-1 25123 0 205184 7367 82098 0 656784 616558 0 5167 623924<br></code></pre></td></tr></table></figure><h2 id="1、使用shell脚本监控">1、使用shell脚本监控</h2><h3 id="（1）安装转换工具">（1）安装转换工具</h3><p><strong>dos2unix 和 unix2dos 命令将纯文本文件从 DOS 或 Mac 格式转换为 Unix，反之亦然。</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cs">[<span class="hljs-meta">root@python scripts</span>]<span class="hljs-meta"># yum -y install dos2unix</span><br><span class="hljs-comment">//下载dos2unix</span><br></code></pre></td></tr></table></figure><h3 id="（2）编写shell脚本">（2）编写shell脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python scripts]# vim monitor.sh<br><span class="hljs-meta">#</span><span class="bash">/bin/sh</span><br>cpu_idle=$(top -n2 | grep 'Cpu' | tail -n 1 | awk '&#123;print $8&#125;')<br>cpu_usage=$(printf "%.2f" `echo "scale=2; 100 - $cpu_idle" | bc`)<br>mem_free=$(free -m | awk '/Mem:/&#123;print $4 + $6&#125;')<br>mem_total=$(free -m | awk '/Mem:/&#123;print $2&#125;')<br>mem_used=$(echo "$mem_total - $mem_free" | bc)<br>mem_rate=$(echo "$mem_used * 100 / $mem_total" | bc)<br>disk_usage=$(df -h / | tail -n 1 | awk '&#123;print $5&#125;')<br>disk_used=$(df -h / | tail -n 1 | awk '&#123;print $3&#125;')<br>echo "CPU利用率：$cpu_usage %"<br>echo "内存使用量: $mem_used M"<br>echo "内存利用率：$mem_rate %"<br>echo "磁盘空间使用量：$disk_used"<br>echo "磁盘空间利用率：$disk_usage"<br></code></pre></td></tr></table></figure><h3 id="（3）转换并执行">（3）转换并执行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python scripts]# dos2unix monitor.sh<br>//转换为格式为Unix<br>[root@python scripts]# cat monitor.sh<br><span class="hljs-meta">#</span><span class="bash">/bin/sh</span><br>cpu_idle=$(top -n2 | grep 'Cpu' | tail -n 1 | awk '&#123;print $8&#125;')<br>cpu_usage=$(printf "%.2f" `echo "scale=2; 100 - $cpu_idle" | bc`)<br>mem_free=$(free -m | awk '/Mem:/&#123;print $4 + $6&#125;')<br>mem_total=$(free -m | awk '/Mem:/&#123;print $2&#125;')<br>mem_used=$(echo "$mem_total - $mem_free" | bc)<br>mem_rate=$(echo "$mem_used * 100 / $mem_total" | bc)<br>disk_usage=$(df -h / | tail -n 1 | awk '&#123;print $5&#125;')<br>disk_used=$(df -h / | tail -n 1 | awk '&#123;print $3&#125;')<br>echo "CPU利用率：$cpu_usage %"<br>echo "内存使用量: $mem_used M"<br>echo "内存利用率：$mem_rate %"<br>echo "磁盘空间使用量：$disk_used"<br>echo "磁盘空间利用率：$disk_usage"<br>[root@python scripts]# sh monitor.sh<br>//执行编写好的脚本<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200429165132049.png" alt="image-20200429165132049"></p><h2 id="2、使用python脚本监控">2、使用python脚本监控</h2><p><strong>编写一个Python脚本，监控磁盘信息，如下所示：</strong></p><h3 id="（1）查看服务启动情况">（1）查看服务启动情况</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python scripts]# vim proc_count.py <br><br>import os<br><br>n = 0<br>for item in os.listdir('/proc'):<br>    if item.isdigit():<br>        n = n+1<br>        # print(len(item))<br>print(n)<br></code></pre></td></tr></table></figure><h5 id="执行结果如下">执行结果如下:</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python scripts]# python3 proc_count.py <br>175<br></code></pre></td></tr></table></figure><h3 id="（2）简易版">（2）简易版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@python scripts]<span class="hljs-comment"># vim monitor_dick.py</span><br><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-comment"># !/usr/bin/python</span><br><br><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><br>disk = namedtuple(<span class="hljs-string">'Disk'</span>, <span class="hljs-string">'major_number minor_number device_name'</span><br>                          <span class="hljs-string">' read_count read_merged_count read_sections'</span><br>                          <span class="hljs-string">' time_spent_reading write_count write_merged_count'</span><br>                          <span class="hljs-string">' write_sections time_spent_write io_requests'</span><br>                          <span class="hljs-string">' time_spent_doing_io weighted_time_spent_dong_io'</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_disk_info</span><span class="hljs-params">(device)</span>:</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'/proc/diskstats'</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>            <span class="hljs-keyword">if</span> line.split()[<span class="hljs-number">2</span>] == device:<br>                <span class="hljs-keyword">return</span> disk(*(line.split()))<br>    <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'设备(&#123;0&#125;)没找到。。。'</span>.format(device))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    disk_info = get_disk_info(<span class="hljs-string">'sda1'</span>)<br><br>    print(disk_info)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></table></figure><h4 id="执行脚本：">执行脚本：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python scripts]# python3 monitor_dick.py<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200429173414704.png" alt="image-20200429173414704"></p><h3 id="（3）直观图">（3）直观图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-comment"># !/usr/bin/python</span><br><br><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><br>disk = namedtuple(<span class="hljs-string">'Disk'</span>, <span class="hljs-string">'major_number minor_number device_name'</span><br>                          <span class="hljs-string">' read_count read_merged_count read_sections'</span><br>                          <span class="hljs-string">' time_spent_reading write_count write_merged_count'</span><br>                          <span class="hljs-string">' write_sections time_spent_write io_requests'</span><br>                          <span class="hljs-string">' time_spent_doing_io weighted_time_spent_dong_io'</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_disk_info</span><span class="hljs-params">(device)</span>:</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'/proc/diskstats'</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>            <span class="hljs-keyword">if</span> line.split()[<span class="hljs-number">2</span>] == device:<br>                <span class="hljs-keyword">return</span> disk(*(line.split()))<br>    <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">'设备(&#123;0&#125;)没找到。。。'</span>.format(device))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">(device)</span>:</span><br>    disk_info = get_disk_info(device)<br>    print(disk_info)<br>    print(<span class="hljs-string">"磁盘写入次数:&#123;0&#125;"</span>.format(disk_info.write_count))<br>    print(<span class="hljs-string">"磁盘写入的字节数:&#123;0&#125;"</span>.format(float(disk_info.write_sections) * <span class="hljs-number">512</span>))<br>    print(<span class="hljs-string">"磁盘写入的延时:&#123;0&#125;"</span>.format(disk_info.time_spent_write))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main(<span class="hljs-string">'sda1'</span>)<br></code></pre></td></tr></table></figure><h4 id="执行脚本：-2">执行脚本：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python scripts]# python3 monitor_dick.py<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200429180049979.png" alt="image-20200429180049979"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python执行外部命令（subprocess，call，Popen）</title>
      <link href="/posts/48ac.html"/>
      <url>/posts/48ac.html</url>
      
        <content type="html"><![CDATA[<h1>一、Python执行外部命令</h1><h2 id="1、subprocess模块简介">1、subprocess模块简介</h2><p><strong>subprocess 模块允许我们启动一个新进程，并连接到它们的输入/输出/错误管道，从而获取返回值。</strong></p><p><strong>这个模块用来创建和管理子进程。它提供了高层次的接口，用来替换os.system*()、 os.spawn*()、 os.popen*()、os,popen2.*()和commands.*等模块和函数。</strong></p><p><strong>subprocess提供了一个名为Popen的类启动和设置子进程的参数，由于这个类比较复杂, subprocess还提供了若干便利的函数，这些函数都是对Popen类的封装。</strong></p><h2 id="2、subprocess模块的遍历函数">2、subprocess模块的遍历函数</h2><h4 id="linux安装ipython">linux安装ipython</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip3 install ipython<br></code></pre></td></tr></table></figure><h3 id="（1）call函数">（1）call函数</h3><h4 id="call函数的定义如下">call函数的定义如下:</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">subprocess.ca11(args, *, stdin=None, stdout=None, stderr=None, she11=False)<br><span class="hljs-meta">#</span><span class="bash">运行由args参数提供的命令，等待命令执行结束并返回返回码。args参数由字符串形式提供且有多个命令参数时，需要提供shell=True参数</span><br></code></pre></td></tr></table></figure><ul><li><strong>args：表示要执行的命令。必须是一个字符串，字符串参数列表。</strong></li><li><strong>stdin、stdout 和 stderr：子进程的标准输入、输出和错误。其值可以是 subprocess.PIPE、subprocess.DEVNULL、一个已经存在的文件描述符、已经打开的文件对象或者 None。subprocess.PIPE 表示为子进程创建新的管道。subprocess.DEVNULL 表示使用 os.devnull。默认使用的是 None，表示什么都不做。另外，stderr 可以合并到 stdout 里一起输出。</strong></li><li><strong>shell：如果该参数为 True，将通过操作系统的 shell 执行指定的命令。</strong></li></ul><h5 id="示例代码">示例代码:</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@python ~]<span class="hljs-comment"># ipython      #启动ipython</span><br>Python <span class="hljs-number">3.8</span><span class="hljs-number">.1</span> (default, Mar  <span class="hljs-number">9</span> <span class="hljs-number">2020</span>, <span class="hljs-number">12</span>:<span class="hljs-number">35</span>:<span class="hljs-number">12</span>) <br>Type <span class="hljs-string">'copyright'</span>, <span class="hljs-string">'credits'</span> <span class="hljs-keyword">or</span> <span class="hljs-string">'license'</span> <span class="hljs-keyword">for</span> more information<br>IPython <span class="hljs-number">7.13</span><span class="hljs-number">.0</span> -- An enhanced Interactive Python. Type <span class="hljs-string">'?'</span> <span class="hljs-keyword">for</span> help.<br>In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> subprocess                <span class="hljs-comment">#调用函数                         </span><br><br>In [<span class="hljs-number">2</span>]: subprocess.call([<span class="hljs-string">'ls'</span>,<span class="hljs-string">'-l'</span>])    <br>drwxr-xr-x.  <span class="hljs-number">2</span> root root        <span class="hljs-number">6</span> <span class="hljs-number">10</span>月 <span class="hljs-number">31</span> <span class="hljs-number">23</span>:<span class="hljs-number">04</span> 公共<br>drwxr-xr-x.  <span class="hljs-number">2</span> root root        <span class="hljs-number">6</span> <span class="hljs-number">10</span>月 <span class="hljs-number">31</span> <span class="hljs-number">23</span>:<span class="hljs-number">04</span> 模板<br>drwxr-xr-x.  <span class="hljs-number">2</span> root root        <span class="hljs-number">6</span> <span class="hljs-number">10</span>月 <span class="hljs-number">31</span> <span class="hljs-number">23</span>:<span class="hljs-number">04</span> 视频<br>drwxr-xr-x.  <span class="hljs-number">2</span> root root     <span class="hljs-number">4096</span> <span class="hljs-number">10</span>月 <span class="hljs-number">31</span> <span class="hljs-number">22</span>:<span class="hljs-number">40</span> 图片<br>drwxr-xr-x.  <span class="hljs-number">2</span> root root        <span class="hljs-number">6</span> <span class="hljs-number">10</span>月 <span class="hljs-number">31</span> <span class="hljs-number">23</span>:<span class="hljs-number">04</span> 文档<br>drwxr-xr-x.  <span class="hljs-number">2</span> root root        <span class="hljs-number">6</span> <span class="hljs-number">10</span>月 <span class="hljs-number">31</span> <span class="hljs-number">23</span>:<span class="hljs-number">04</span> 下载<br>drwxr-xr-x.  <span class="hljs-number">2</span> root root        <span class="hljs-number">6</span> <span class="hljs-number">10</span>月 <span class="hljs-number">31</span> <span class="hljs-number">23</span>:<span class="hljs-number">04</span> 音乐<br>drwxr-xr-x.  <span class="hljs-number">2</span> root root        <span class="hljs-number">6</span> <span class="hljs-number">10</span>月 <span class="hljs-number">31</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span> 桌面<br>Out[<span class="hljs-number">2</span>]: <span class="hljs-number">0</span><br><br>In [<span class="hljs-number">3</span>]: subprocess.call(<span class="hljs-string">'exit 1'</span>,shell=<span class="hljs-literal">True</span>)                 <br>Out[<span class="hljs-number">3</span>]: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="（2）check-call函数">（2）check_call函数</h3><p><strong>check_call函数的作用与call函数类似，区别在于异常情况下返回的形式不同。</strong></p><p><strong>对于call函数，工程师通过捕获call命令的返回值判断命令是否执行成功，如果成功则返回0，否则的话返回非0，对于check_call函数，如果执行成功，返回0，如果执行失败，抛出subrocess.CalledProcessError异常。如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">5</span>]: subprocess.check_call([<span class="hljs-string">'ls'</span>,<span class="hljs-string">'-l'</span>])<br>drwxr-xr-x.  <span class="hljs-number">2</span> root root        <span class="hljs-number">6</span> <span class="hljs-number">10</span>月 <span class="hljs-number">31</span> <span class="hljs-number">23</span>:<span class="hljs-number">04</span> 公共<br>drwxr-xr-x.  <span class="hljs-number">2</span> root root        <span class="hljs-number">6</span> <span class="hljs-number">10</span>月 <span class="hljs-number">31</span> <span class="hljs-number">23</span>:<span class="hljs-number">04</span> 模板<br>drwxr-xr-x.  <span class="hljs-number">2</span> root root        <span class="hljs-number">6</span> <span class="hljs-number">10</span>月 <span class="hljs-number">31</span> <span class="hljs-number">23</span>:<span class="hljs-number">04</span> 视频<br>drwxr-xr-x.  <span class="hljs-number">2</span> root root     <span class="hljs-number">4096</span> <span class="hljs-number">10</span>月 <span class="hljs-number">31</span> <span class="hljs-number">22</span>:<span class="hljs-number">40</span> 图片<br>drwxr-xr-x.  <span class="hljs-number">2</span> root root        <span class="hljs-number">6</span> <span class="hljs-number">10</span>月 <span class="hljs-number">31</span> <span class="hljs-number">23</span>:<span class="hljs-number">04</span> 文档<br>drwxr-xr-x.  <span class="hljs-number">2</span> root root        <span class="hljs-number">6</span> <span class="hljs-number">10</span>月 <span class="hljs-number">31</span> <span class="hljs-number">23</span>:<span class="hljs-number">04</span> 下载<br>drwxr-xr-x.  <span class="hljs-number">2</span> root root        <span class="hljs-number">6</span> <span class="hljs-number">10</span>月 <span class="hljs-number">31</span> <span class="hljs-number">23</span>:<span class="hljs-number">04</span> 音乐<br>drwxr-xr-x.  <span class="hljs-number">2</span> root root        <span class="hljs-number">6</span> <span class="hljs-number">10</span>月 <span class="hljs-number">31</span> <span class="hljs-number">15</span>:<span class="hljs-number">27</span> 桌面<br>Out[<span class="hljs-number">5</span>]: <span class="hljs-number">0</span><br><br>In [<span class="hljs-number">6</span>]: subprocess.check_call(<span class="hljs-string">'exit 1'</span>,shell=<span class="hljs-literal">True</span>)           <br>-------------------------------------------------------------<br>CalledProcessError          Traceback (most recent call last)<br>&lt;ipython-input<span class="hljs-number">-6</span><span class="hljs-number">-5e148</span>d3ce640&gt; <span class="hljs-keyword">in</span> &lt;module&gt;<br>----&gt; 1 subprocess.check_call('exit 1',shell=True)<br><br>/usr/local/python381/lib/python3<span class="hljs-number">.8</span>/subprocess.py <span class="hljs-keyword">in</span> check_call(*popenargs, **kwargs)<br>    <span class="hljs-number">362</span>         <span class="hljs-keyword">if</span> cmd <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-number">363</span>             cmd = popenargs[<span class="hljs-number">0</span>]<br>--&gt; 364         raise CalledProcessError(retcode, cmd)<br>    <span class="hljs-number">365</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-number">366</span> <br><br>CalledProcessError: Command <span class="hljs-string">'exit 1'</span> returned non-zero exit status <span class="hljs-number">1.</span><br></code></pre></td></tr></table></figure><h3 id="（3）check-output">（3）check_output</h3><p><strong>Python3中的subprocess.check_output函数可以执行一条sh命令，并返回命令的输出内容，用法如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">10</span>]: output = subprocess.check_output([<span class="hljs-string">'df'</span>,<span class="hljs-string">'-h'</span>])       <br>In [<span class="hljs-number">11</span>]: print(output.decode())                              <br>文件系统             容量  已用  可用 已用% 挂载点<br>/dev/mapper/cl-root   <span class="hljs-number">17</span>G  <span class="hljs-number">5.2</span>G   <span class="hljs-number">12</span>G   <span class="hljs-number">31</span>% /<br>devtmpfs             <span class="hljs-number">473</span>M     <span class="hljs-number">0</span>  <span class="hljs-number">473</span>M    <span class="hljs-number">0</span>% /dev<br>tmpfs                <span class="hljs-number">489</span>M   <span class="hljs-number">92</span>K  <span class="hljs-number">489</span>M    <span class="hljs-number">1</span>% /dev/shm<br>tmpfs                <span class="hljs-number">489</span>M  <span class="hljs-number">7.1</span>M  <span class="hljs-number">482</span>M    <span class="hljs-number">2</span>% /run<br>tmpfs                <span class="hljs-number">489</span>M     <span class="hljs-number">0</span>  <span class="hljs-number">489</span>M    <span class="hljs-number">0</span>% /sys/fs/cgroup<br>/dev/sda1           <span class="hljs-number">1014</span>M  <span class="hljs-number">173</span>M  <span class="hljs-number">842</span>M   <span class="hljs-number">18</span>% /boot<br>tmpfs                 <span class="hljs-number">98</span>M   <span class="hljs-number">16</span>K   <span class="hljs-number">98</span>M    <span class="hljs-number">1</span>% /run/user/<span class="hljs-number">42</span><br>tmpfs                 <span class="hljs-number">98</span>M     <span class="hljs-number">0</span>   <span class="hljs-number">98</span>M    <span class="hljs-number">0</span>% /run/user/<span class="hljs-number">0</span><br>In [<span class="hljs-number">12</span>]: lines = output.decode().split(<span class="hljs-string">'\n'</span>)<br>In [<span class="hljs-number">13</span>]: lines                                               <br>Out[<span class="hljs-number">13</span>]: <br>[<span class="hljs-string">'文件系统             容量  已用  可用 已用% 挂载点'</span>,<br> <span class="hljs-string">'/dev/mapper/cl-root   17G  5.2G   12G   31% /'</span>,<br> <span class="hljs-string">'devtmpfs             473M     0  473M    0% /dev'</span>,<br> <span class="hljs-string">'tmpfs                489M   92K  489M    1% /dev/shm'</span>,<br> <span class="hljs-string">'tmpfs                489M  7.1M  482M    2% /run'</span>,<br> <span class="hljs-string">'tmpfs                489M     0  489M    0% /sys/fs/cgroup'</span>,<br> <span class="hljs-string">'/dev/sda1           1014M  173M  842M   18% /boot'</span>,<br> <span class="hljs-string">'tmpfs                 98M   16K   98M    1% /run/user/42'</span>,<br> <span class="hljs-string">'tmpfs                 98M     0   98M    0% /run/user/0'</span>,<br> <span class="hljs-string">''</span>]<br><br>In [<span class="hljs-number">14</span>]: <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines[<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>]: <br>    ...:     <span class="hljs-keyword">if</span> line: <br>    ...:         print(line.split()[<span class="hljs-number">-2</span>]) <br>    ...: <span class="hljs-comment">#截取挂载点数据                                                    </span><br><span class="hljs-number">31</span>%<br><span class="hljs-number">0</span>%<br><span class="hljs-number">1</span>%<br><span class="hljs-number">2</span>%<br><span class="hljs-number">0</span>%<br><span class="hljs-number">18</span>%<br><span class="hljs-number">1</span>%<br><span class="hljs-number">0</span>%<br></code></pre></td></tr></table></figure><p><strong>在子进程执行命令，以字符串形式返回执行结果的输出。如果子进程退出码不是0，抛出subprocess.CalledProcessError异常，异常的output字段包含错误输出：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">19</span>]: <span class="hljs-keyword">try</span>: <br>    ...:     output = subprocess.check_output([<span class="hljs-string">'df'</span>,<span class="hljs-string">'-h'</span>]).decode()  <span class="hljs-comment">#正确的</span><br>    ...: <span class="hljs-keyword">except</span> subprocess.CalledProcessError <span class="hljs-keyword">as</span> e: <br>    ...:     output = e.output <br>    ...:     code = e.returncode <br>//正确的没有任何输出<br>        <br>In [<span class="hljs-number">23</span>]: <span class="hljs-keyword">try</span>: <br>    ...:     output = subprocess.check_output([<span class="hljs-string">'wsd'</span>,<span class="hljs-string">'-h'</span>], stderr=subprocess.STDOUT)<br>    ...: .decode()                                                   <span class="hljs-comment">#错误的</span><br>    ...: <span class="hljs-keyword">except</span> subprocess.CalledProcessError <span class="hljs-keyword">as</span> e: <br>    ...:     output = e.output <br>    ...:     code = e.returncode <br>    ...:     <br> <br>//前面的错误代码省略<br>FileNotFoundError: [Errno <span class="hljs-number">2</span>] No such file <span class="hljs-keyword">or</span> directory: <span class="hljs-string">'wsd'</span><br></code></pre></td></tr></table></figure><h2 id="3、subprocess模块的Popen类（PyCharm）">3、subprocess模块的Popen类（PyCharm）</h2><p><strong>实际上，我们上面的三个函数都是基于Popen()的封装(wrapper)。这些封装的目的在于让我们容易使用子进程。当我们想要更个性化我们的需求的时候，就要转向Popen类，该类生成的对象用来代表子进程。</strong></p><ul><li><strong><code>subprocess </code>模块中基本的进程创建和管理由<code>Popen </code>类来处理</strong></li><li><strong><code>subprocess.popen</code>是用来替代<code>os.popen</code>的</strong></li><li><strong>Popen 是 <code>subprocess</code>的核心，子进程的创建和管理都靠它处理。</strong></li></ul><p>构造函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">subprocess</span>.<span class="hljs-title">Popen</span><span class="hljs-params">(args, bufsize=<span class="hljs-number">-1</span>, executable=None, stdin=None, stdout=None, stderr=None, </span></span><br><span class="hljs-class"><span class="hljs-params">preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=False, </span></span><br><span class="hljs-class"><span class="hljs-params">startupinfo=None, creationflags=<span class="hljs-number">0</span>,restore_signals=True, start_new_session=False, pass_fds=<span class="hljs-params">()</span>,</span></span><br><span class="hljs-class"><span class="hljs-params">*, encoding=None, errors=None)</span></span><br></code></pre></td></tr></table></figure><h3 id="（1）常用参数：">（1）常用参数：</h3><ul><li><strong>args：shell命令，可以是字符串或者序列类型（如：list，元组）</strong></li><li><strong>bufsize：缓冲区大小。当创建标准流的管道对象时使用，默认-1。</strong><br><strong>0：不使用缓冲区</strong><br><strong>1：表示行缓冲，仅当universal_newlines=True时可用，也就是文本模式</strong><br><strong>正数：表示缓冲区大小</strong><br><strong>负数：表示使用系统默认的缓冲区大小。</strong></li><li><strong>stdin, stdout, stderr：分别表示程序的标准输入、输出、错误句柄</strong></li><li><strong>preexec_fn：只在 Unix 平台下有效，用于指定一个可执行对象（callable object），它将在子进程运行之前被调用</strong></li><li><strong>shell：如果该参数为 True，将通过操作系统的 shell 执行指定的命令。</strong></li><li><strong>cwd：用于设置子进程的当前目录。</strong></li><li><strong>env：用于指定子进程的环境变量。如果 env = None，子进程的环境变量将从父进程中继承。</strong></li></ul><h4 id="创建一个子进程，然后执行一个简单的命令：">创建一个子进程，然后执行一个简单的命令：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-meta">&gt;&gt;&gt; </span>p = subprocess.Popen(<span class="hljs-string">'ls -l'</span>, shell=<span class="hljs-literal">True</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>total <span class="hljs-number">164</span><br>-rw-r--r--  <span class="hljs-number">1</span> root root   <span class="hljs-number">133</span> Jul  <span class="hljs-number">4</span> <span class="hljs-number">16</span>:<span class="hljs-number">25</span> admin-openrc.sh<br>-rw-r--r--  <span class="hljs-number">1</span> root root   <span class="hljs-number">268</span> Jul <span class="hljs-number">10</span> <span class="hljs-number">15</span>:<span class="hljs-number">55</span> admin-openrc-v3.sh<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.returncode<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.wait()<br><span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>p.returncode<br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><em><strong>这里也可以使用 <code>p = subprocess.Popen(['ls', '-cl'])</code> 来创建子进程。</strong></em></p><h3 id="（2）Popen-对象的属性">（2）Popen 对象的属性</h3><h4 id="1-p-pid：">&lt;1&gt;  <code>p.pid</code>：</h4><p><strong>子进程的PID。</strong></p><h4 id="2-p-returncode：">&lt;2&gt;  <code>p.returncode</code>：</h4><p><strong>该属性表示子进程的返回状态，returncode可能有多重情况：</strong></p><ul><li><strong>None —— 子进程尚未结束；</strong></li><li><strong>==0 —— 子进程正常退出；</strong></li><li><strong>&gt; 0—— 子进程异常退出，returncode对应于出错码；</strong></li><li><strong>&lt; 0—— 子进程被信号杀掉了。</strong></li></ul><h4 id="3-p-stdin-p-stdout-p-stderr：">&lt;3&gt;  <code>p.stdin, p.stdout, p.stderr</code>：</h4><p><strong>子进程对应的一些初始文件，如果调用Popen()的时候对应的参数是subprocess.PIPE，则这里对应的属性是一个包裹了这个管道的 file 对象。</strong></p><h3 id="（3）Popen-对象方法">（3）Popen 对象方法</h3><ul><li><strong>poll(): 检查进程是否终止，如果终止返回 returncode，否则返回 None。</strong></li><li><strong>wait(timeout): 等待子进程终止。</strong></li><li><strong>communicate(input,timeout): 和子进程交互，发送和读取数据。</strong></li><li><strong>send_signal(singnal): 发送信号到子进程 。</strong></li><li><strong>terminate(): 停止子进程,也就是发送SIGTERM信号到子进程。</strong></li><li><strong>kill(): 杀死子进程。发送 SIGKILL 信号到子进程。</strong></li></ul><p><em><strong>子进程的PID存储在child.pid</strong></em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> subprocess<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cmd</span><span class="hljs-params">(command)</span>:</span><br>    subp = subprocess.Popen(command,shell=<span class="hljs-literal">True</span>,stdout=subprocess.PIPE,stderr=subprocess.PIPE,encoding=<span class="hljs-string">"utf-8"</span>)<br>    subp.wait(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">if</span> subp.poll() == <span class="hljs-number">0</span>:<br>        print(subp.communicate()[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">"失败"</span>)<br><br>cmd(<span class="hljs-string">"java -version"</span>)<br>cmd(<span class="hljs-string">"exit 1"</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">java version <span class="hljs-string">"1.8.0_31"</span><br>Java(TM) SE Runtime Environment (build <span class="hljs-number">1.8</span><span class="hljs-number">.0</span>_31-b13)<br>Java HotSpot(TM) <span class="hljs-number">64</span>-Bit Server VM (build <span class="hljs-number">25.31</span>-b07, mixed mode)<br><br>失败<br></code></pre></td></tr></table></figure></blockquote><h3 id="（4）子进程的文本流控制">（4）子进程的文本流控制</h3><p><strong>(沿用child子进程) 子进程的标准输入，标准输出和标准错误也可以通过如下属性表示:</strong></p><ul><li><strong>child.stdin</strong></li><li><strong>child.stdout</strong></li><li><strong>child.stderr</strong></li></ul><h5 id="我们可以在Popen-建立子进程的时候改变标准输入、标准输出和标准错误，并可以利用subprocess-PIPE将多个子进程的输入和输出连接在一起，构成管道-pipe"><strong>我们可以在Popen()建立子进程的时候改变标准输入、标准输出和标准错误，并可以利用subprocess.PIPE将多个子进程的输入和输出连接在一起，构成管道(pipe):</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br>child1 = subprocess.Popen([<span class="hljs-string">"ls"</span>,<span class="hljs-string">"-l"</span>], stdout=subprocess.PIPE)<br>child2 = subprocess.Popen([<span class="hljs-string">"wc"</span>], stdin=child1.stdout,stdout=subprocess.PIPE)<br>out = child2.communicate()<br>print(out)<br></code></pre></td></tr></table></figure><h5 id="执行结果如下：">执行结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(<span class="hljs-string">b'      2      11      60\n'</span>, <span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure></blockquote><p><strong>subprocess.PIPE实际上为文本流提供一个缓存区。child1的stdout将文本输出到缓存区，随后child2的stdin从该PIPE中将文本读取走。child2的输出文本也被存放在PIPE中，直到communicate()方法从PIPE中读取出PIPE中的文本。</strong></p><p><strong>要注意的是，communicate()是Popen对象的一个方法，该方法会阻塞父进程，直到子进程完成。</strong></p><h5 id="我们还可以利用communicate-方法来使用PIPE给子进程输入"><strong>我们还可以利用communicate()方法来使用PIPE给子进程输入:</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br>child = subprocess.Popen([<span class="hljs-string">"cat"</span>], stdin=subprocess.PIPE)<br>child.communicate(<span class="hljs-string">"vamei"</span>.encode())<br></code></pre></td></tr></table></figure><p><strong>我们启动子进程之后，cat会等待输入，直到我们用communicate()输入&quot;vamei&quot;。</strong></p><p><strong>通过使用subprocess包，我们可以运行外部程序。这极大的拓展了Python的功能。如果你已经了解了操作系统的某些应用，你可以从Python中直接调用该应用(而不是完全依赖Python)，并将应用的结果输出给Python，并让Python继续处理。shell的功能(比如利用文本流连接各个应用)，就可以在Python中实现。</strong></p><h2 id="4、使用python自动安装并启动mongodb">4、使用python自动安装并启动mongodb</h2><p><em><strong>PyCharm记得连接linux</strong></em></p><h4 id="简易流程">简易流程</h4><ul><li><p><strong>Python自动化运维 --&gt; 基于shell命令进行封装</strong></p></li><li><p><strong>编写自动化脚本 --&gt; 用Python语法封装shell命令的执行过程</strong></p></li><li><p><strong>python执行shell命令 --&gt; python外部命令</strong></p></li><li><p><strong>python函数执行shell命令</strong></p></li><li><p><strong>os.system(cmd)：执行cmd指令</strong></p></li><li><p><strong>subprocess模块</strong></p></li><li><pre><code class="language-python">subprocess.call(['ls','-l'])subprocess.call('ll' , shell=True)运行成功: 返回0运行失败: 返回非0 <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br>- ```python<br>  subprocess. check_call ([<span class="hljs-string">'ls'</span>,  <span class="hljs-string">'-l'</span>])<br>  subprocess. check_call (<span class="hljs-string">'ll'</span>, <span class="hljs-attribute">shell</span>=<span class="hljs-literal">True</span>)<br>  运行成功: 返回0<br>  运行失败: 返回CalledProcessError<br></code></pre></td></tr></table></figure></code></pre></li><li><pre><code class="language-python">subprocess. check_ output(['cat', 'apache.log'], stderr= subprocess.STDOUT)运行成功:返回命令的输出结果运行失败:自定义错误输出stderr<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>- **subprocess模块的Popen类**<br><br><span class="hljs-comment">### （1）PyCharm创建文件</span><br><br>```python<br><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> shutil<br><span class="hljs-keyword">import</span> tarfile<br><br><span class="hljs-comment"># 执行外部命令的函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">execute_cmd</span><span class="hljs-params">(cmd)</span>:</span><br>    <span class="hljs-string">'''执行shell命令'''</span><br>    p = subprocess.Popen(cmd, shell=<span class="hljs-literal">True</span>,<br>                         stdin=subprocess.PIPE,<br>                         stdout=subprocess.PIPE,<br>                         stderr=subprocess.PIPE)<br>    stdout, stderr = p.communicate()<br>    <span class="hljs-keyword">if</span> p.returncode != <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> p.returncode, stderr<br>    <span class="hljs-keyword">return</span> p.returncode, stdout<br><br><span class="hljs-comment"># 解压</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unpackage_mongo</span><span class="hljs-params">(package, package_dir)</span>:</span><br>    <span class="hljs-comment"># 获取MongoDB压缩包的主文件名，也就是解压后的目录名称</span><br>    <span class="hljs-comment"># mongodb-linux-x86_64-rhe170-4.2.3</span><br>    unpackage_dir = os.path.splitext(package)[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">if</span> os.path.exists(unpackage_dir):<br>        shutil.rmtree(unpackage_dir)<br>    <span class="hljs-keyword">if</span> os.path.exists(package_dir):<br>        shutil.rmtree(package_dir)<br>    <span class="hljs-comment"># 解压</span><br>    <span class="hljs-keyword">try</span>:<br>        t = tarfile.open(package, <span class="hljs-string">'r:gz'</span>)<br>        t.extractall(<span class="hljs-string">'.'</span>)<br>        print(<span class="hljs-string">'tar is ok.'</span>)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        print(e)<br>    <span class="hljs-comment"># 重命名</span><br>    shutil.move(unpackage_dir, <span class="hljs-string">'mongo'</span>)<br><br><span class="hljs-comment"># 创建mongodata</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_datadir</span><span class="hljs-params">(data_dir)</span>:</span><br>    <span class="hljs-keyword">if</span> os.path.exists(data_dir):<br>        shutil.rmtree(data_dir)<br>    os.mkdir(data_dir)<br><br><span class="hljs-comment"># 拼接启动MongoDB</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">format_mongod_commamd</span><span class="hljs-params">(package_dir, data_dir, logfile)</span>:</span><br>    <span class="hljs-comment"># mongo/bin/mongod</span><br>    mongod = os.path.join(package_dir, <span class="hljs-string">'bin'</span>, <span class="hljs-string">'mongod'</span>)<br>    <span class="hljs-comment"># mongo/bin/mongod --fork --logpath mongodata/mongod.log --dbpath mongodata</span><br>    mongod_format = <span class="hljs-string">"""&#123;0&#125; --fork --dbpath &#123;1&#125; --logpath &#123;2&#125;"""</span><br>    <span class="hljs-keyword">return</span> mongod_format.format(mongod, data_dir, logfile)<br><br><span class="hljs-comment"># 启动MongoDB</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start_mongod</span><span class="hljs-params">(cmd)</span>:</span><br>    returncode, out = execute_cmd(cmd)<br>    <span class="hljs-keyword">if</span> returncode != <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">raise</span> SystemExit(<span class="hljs-string">'execute &#123;0&#125; error:&#123;1&#125;'</span>.format(cmd, out))<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">'execute &#123;0&#125; successfuly.'</span>.format(cmd))<br><br><span class="hljs-comment">#入口函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    package = <span class="hljs-string">'mongodb-linux-x86_64-rhel70-4.2.3.tgz'</span><br>    cur_dir = os.path.abspath(<span class="hljs-string">'.'</span>)<br>    package_dir = os.path.join(cur_dir, <span class="hljs-string">'mongo'</span>)<br>    data_dir = os.path.join(cur_dir, <span class="hljs-string">'mongodata'</span>)<br>    logfile = os.path.join(data_dir, <span class="hljs-string">'mongod.log'</span>)<br><br>    <span class="hljs-comment"># 判断MongoDB压缩包是否存在</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(package):<br>        <span class="hljs-keyword">raise</span> SystemExit(<span class="hljs-string">'&#123;0&#125; not found.'</span>.format(package))<br><br>    <span class="hljs-comment"># 解压</span><br>    unpackage_mongo(package, package_dir)<br>    create_datadir(data_dir)<br><br>    <span class="hljs-comment"># 启动mongodb</span><br>    start_mongod(format_mongod_commamd(package_dir, data_dir, logfile))<br><br>    <span class="hljs-comment"># 配置环境变量</span><br>    os.system(<span class="hljs-string">'echo "export PATH=./mongo/bin:$PATH" &gt; ~/.bash_profile'</span>)<br>    os.system(<span class="hljs-string">'source ~/.bash_profile'</span>)<br><br>    os.system(<span class="hljs-string">'./mongo/bin/mongo'</span>)<br>main()<br></code></pre></td></tr></table></figure></code></pre></li><li><p><strong>在这段程序中，我们首先在main函数中定义了几个变量，包括当前目录的路径、MongoDB二进制文件所在的路径、MongoDB数据目录所在的路径，以及MongoDB的日志文件。</strong></p></li><li><p><strong>随后，我们判断MongoDB的安装包是否存在，如果不存在，则通过抛出SystemExit异常的方式结束程序。</strong></p></li><li><p><strong>在unpackage_mongo函数中，我们通过Python程序得到MongoDB安装包解压以后的目录。如果目录已经存在，则删除该目录。随后，我们使用tarfile解MongoDB数据库，解压完成后，将命令重命名为mongo目录。</strong></p></li><li><p><strong>在create_datadir目录中，我们首先判断MongoDB数据库目录是否存在，如果存在，则删除该目录，随后再创建MongoDB数据库目录。</strong></p></li><li><p><strong>在start_mongod函数中， 我们执行MongoDB数据库的启动命令启动MongoDB数据库。为了在Python代码中执行shell命令，我们使用了subprocess库。 我们将subprocess库执行she11命令的逻辑封装成execute_cmd函数，在执行shell命令时，直接调用该函数即可。</strong></p></li></ul><h3 id="（2）将PyCharm中的文件上传到Linux">（2）将PyCharm中的文件上传到Linux</h3><h4 id="如果，是直接调用Linux中文件可用：">如果，是直接调用Linux中文件可用：</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200427220345590.png" alt="image-20200427220345590"></p><h4 id="如果是本地创建：">如果是本地创建：</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200427220500076.png" alt="image-20200427220500076"></p><h3 id="（3）Linux执行脚本，并测试">（3）Linux执行脚本，并测试</h3><p><strong>记得进入PyCharm与linux连接的目录（目前是/opt）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python opt]# python auto_install_mongodb.py   #执行提前编写好的脚本<br>tar is ok.<br>execute /opt/mongo/bin/mongod --fork --dbpath /opt/mongodata --logpath /opt/mongodata/mongod.log successfuly.<br>[root@python opt]# netstat -anpt | grep mongo       #查看mongo是否启动<br>tcp        0      0 127.0.0.1:27017         0.0.0.0:*               LISTEN      4616mongod         <br>[root@python opt]# ls                               #查看是否生成mongo目录<br>01find_cmd.py            bb.bmp     mongodb-linux-x86_64-rhel70-4.2.3.tgz<br>aaa.jpg                  cc.png     rh<br>adc.txt                  mongo      subprocess_demo<br>auto_install_mongodb.py  mongodata<br>[root@python opt]# cd mongo<br>[root@python mongo]# cd bin/<br>[root@python bin]# ./mongo                          #进入mongo<br>MongoDB shell version v4.2.3<br>connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&amp;gssapiServiceName=mongodb<br>Implicit session: session &#123; "id" : UUID("c302ff50-7e27-40b7-8046-8441af8cb965") &#125;<br>MongoDB server version: 4.2.3<br><br><span class="hljs-meta">&gt;</span><span class="bash"> show databases;                                  <span class="hljs-comment">#查看数据库</span></span><br>admin   0.000GB<br>config  0.000GB<br>local   0.000GB<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python使用ConfigParser类解析配置文件</title>
      <link href="/posts/cbc8.html"/>
      <url>/posts/cbc8.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p><strong>使用配置文件来灵活的配置一些参数是一件很常见的事情，配置文件的解析并不复杂，在python里更是如此，在官方发布的库中就包含有做这件事情的库，那就是configParser</strong></p><p><strong>configParser解析的配置文件的格式比较象ini的配置文件格式，就是文件中由多个section构成，每个section下又有多个配置项</strong></p><h2 id="ConfigParser简介"><strong>ConfigParser简介</strong></h2><p><strong>ConfigParser 是用来读取配置文件的包。配置文件的格式如下：中括号“[ ]”内包含的为section。section 下面为类似于key-value 的配置内容。</strong></p><p><strong><code>ConfigParser</code>模块在python3中修改为<code>configparser</code>.这个模块定义了一个ConfigParser类，该类的作用是使用配置文件生效，配置文件的格式和windows的INI文件的格式相同</strong></p><p><strong>该模块的作用 就是使用模块中的<code>RawConfigParser()</code>、<code>ConfigParser()</code>、 <code>SafeConfigParser()</code>这三个方法<a href="https://blog.csdn.net/miner_k/article/details/77857292" target="_blank" rel="noopener">（三者择其一）</a>，创建一个对象使用对象的方法对指定的配置文件做增删改查 操作。</strong></p><h2 id="ini文件结构"><a href="https://docs.python.org/3.5/library/configparser.html#supported-ini-file-structure" target="_blank" rel="noopener">ini文件结构</a></h2><h4 id="ini文件结构需要注意一下几点："><strong>ini文件结构需要注意一下几点：</strong></h4><ul><li><strong>键值对可用<code>=</code>或者<code>:</code>进行分隔</strong></li><li><strong><code>section</code>的名字是区分大小写的,而<code>key</code>的名字是不区分大小写的</strong></li><li><strong>键值对中头部和尾部的空白符会被去掉</strong></li><li><strong>值可以为多行</strong></li><li><strong>配置文件可以包含注释，注释以<code>#</code>或者<code>;</code>为前缀</strong></li></ul><p><em><strong>注意：configparser有default_section的概念,默认为<code>[DEFAULT]</code>节,也就是之后的所有的section都有该默认section中的键值对,详情参见<a href="https://hg.python.org/cpython/file/3.5/Lib/configparser.py" target="_blank" rel="noopener">configparser源码的<code>__init__()</code>方法</a></strong></em></p><h1>一、使用ConfigParser类解析ini配置文件</h1><h4 id="（PyCharm中实现）"><em>（PyCharm中实现）</em></h4><p><em><strong>实现查询、添加、删除、保存。</strong></em></p><h4 id="练习目的：">练习目的：</h4><ul><li><strong>掌握文件基本操作</strong></li><li><strong>认识ini文件</strong></li><li><strong>了解ConfigParser类</strong></li></ul><h4 id="使用ConfigParser类解析配置文件">使用ConfigParser类解析配置文件</h4><p><strong>ini配置文件的格式：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">节：[session]<br>参数(键=值)name=value<br></code></pre></td></tr></table></figure><h2 id="1、解析mysql配置文件">1、解析mysql配置文件</h2><ul><li><code>**read(filename)</code>      直接读取文件内容**</li><li><strong><code>get(section, option)</code> 获取<code>section</code> 下具体某一配置项的值(返回的是字符串)</strong></li><li><strong><code>sections()</code> 得到所有的section，并以列表的形式返回</strong></li><li><strong><code>options(section)</code>    得到该section的所有option</strong></li><li><strong><code>items(section)</code> 键值对的形式 得到该section的所有option</strong></li><li><strong><code>getint(section,option)</code>、<code>cnf.getboolean(section,option)</code>、<code>getfloat(section,option)</code> 获取整型、布尔型和浮点型的<code>option</code>的值</strong></li></ul><h5 id="my-ini文件示例：">my.ini文件示例：</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[client]</span><br><span class="hljs-attr">port</span>    = <span class="hljs-number">3306</span><br><span class="hljs-attr">user</span>    = mysql<br><span class="hljs-attr">password</span>  = mysql<br><span class="hljs-attr">host</span>    = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><br><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">basedir</span>    = /usr<br><span class="hljs-attr">datadir</span>    = /var/lib/mysql<br><span class="hljs-attr">tmpdir</span>    = /tmp<br>skip-external-locking<br></code></pre></td></tr></table></figure><h2 id="2、ConfigParser类的使用方法">2、ConfigParser类的使用方法</h2><h3 id="1-创建configParser对象">(1)创建configParser对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> configparser<br><br>In [<span class="hljs-number">2</span>]: cf = configparser.ConfigParser(allow_no_value=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h3 id="2-读取配置文件内容">(2)读取配置文件内容</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">4</span>]: cf.read(<span class="hljs-string">'my.ini'</span>)<br>Out[<span class="hljs-number">4</span>]: [<span class="hljs-string">'my.ini'</span>]<br></code></pre></td></tr></table></figure><h3 id="3-获取配置文件信息">(3)获取配置文件信息</h3><ul><li><strong>sections: 返回一个包含所有章节的列表</strong></li><li><strong>options: 返回一个包含章节下所有选项的列表</strong></li><li><strong>has_section: 判断章节是否存在</strong></li><li><strong>has_options: 判断某个选项是否存在</strong></li><li><strong>items: 以元组的形式返回所有的选项</strong></li><li><strong>get、getboolean、getint、getfloat: 获取选项的值</strong></li></ul><p><em><strong>同时需要注意<code>getboolean()</code>方法能判断True/False的值有： ‘yes’/‘no’, ‘on’/‘off’, ‘true’/‘false’ 和 ‘1’/‘0’</strong></em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">4</span>]: cf.sections()                  <span class="hljs-comment"># 返回一个包含所有章节的列表</span><br>Out[<span class="hljs-number">4</span>]: [<span class="hljs-string">'client'</span>,<span class="hljs-string">'mysq1d'</span>]<br><br>In [<span class="hljs-number">5</span>]: cf.has_section(<span class="hljs-string">'client'</span>)       <span class="hljs-comment"># 判断章节是否存在</span><br><span class="hljs-number">0</span>ut[<span class="hljs-number">5</span>]: <span class="hljs-literal">True</span><br><br>In [<span class="hljs-number">6</span>]cf.options(<span class="hljs-string">'client '</span>)            <span class="hljs-comment"># 判断某个选项是否存在</span><br>Out[<span class="hljs-number">6</span>]: [<span class="hljs-string">'port", '</span>use<span class="hljs-string">r', '</span>password<span class="hljs-string">', '</span>host<span class="hljs-string">' ]</span><br><span class="hljs-string"></span><br><span class="hljs-string">In [7]: cf.has_option('</span>client<span class="hljs-string">', '</span>use<span class="hljs-string">r') # 判断某个选项是否存在</span><br><span class="hljs-string">0ut[7]: True</span><br><span class="hljs-string"></span><br><span class="hljs-string">In [8]: cf.get('</span>client<span class="hljs-string">','</span> port<span class="hljs-string">')       # 获取选项的值</span><br><span class="hljs-string">0ut[8]: '</span><span class="hljs-number">3306</span><span class="hljs-string">'</span><br><span class="hljs-string"></span><br><span class="hljs-string">In [9]: cf.getint('</span>client<span class="hljs-string">','</span>port<span class="hljs-string">')      # 获取选项的值</span><br><span class="hljs-string">0ut[9]: 3306</span><br></code></pre></td></tr></table></figure><h3 id="4-修改配置文件">(4)修改配置文件</h3><h4 id="常用方法">常用方法:</h4><ul><li><strong>remove_section: 删除一个章节</strong></li><li><strong>add_section: 添加一个章节</strong></li><li><strong>remove_option: 删除一个选项</strong></li><li><strong>set: 添加一个选项</strong></li><li><strong>write: 将ConfigParser兑现中的数据保存到文件中</strong></li></ul><h4 id="方法测试">方法测试:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">11</span>]: cf.remove_section(<span class="hljs-string">'client'</span>)            <span class="hljs-comment"># 删除一个章节</span><br>Out[<span class="hljs-number">11</span>]: <span class="hljs-literal">True</span><br><br>In [<span class="hljs-number">14</span>]: cf.write(open(<span class="hljs-string">'my.ini'</span>,<span class="hljs-string">'w'</span>))           <span class="hljs-comment"># 将ConfigParser兑现中的数据保存到文件中</span><br><span class="hljs-comment">#可在PyCharm中my.ini文件查看是否少了'client‘字段。</span><br>    <br>In [<span class="hljs-number">15</span>]: cf.add.section(<span class="hljs-string">'client'</span>)               <span class="hljs-comment"># 添加一个章节</span><br>In [<span class="hljs-number">16</span>]: cf.set(<span class="hljs-string">'client'</span>,<span class="hljs-string">'port'</span>,<span class="hljs-string">'3306'</span>)         <span class="hljs-comment"># 添加一个选项</span><br>In [<span class="hljs-number">17</span>]: cf.set(<span class="hljs-string">'client'</span>,<span class="hljs-string">'user'</span>,<span class="hljs-string">'mysq1'</span>)        <span class="hljs-comment"># 添加一个选项</span><br>In [<span class="hljs-number">18</span>]: cf.set(<span class="hljs-string">'client'</span>,<span class="hljs-string">'password'</span> <span class="hljs-string">'mysq1'</span>)    <span class="hljs-comment"># 添加一个选项</span><br>In [<span class="hljs-number">19</span>]: cf.set(<span class="hljs-string">'client'</span>,<span class="hljs-string">'host'</span>,<span class="hljs-string">'127.0.0.1'</span>)    <span class="hljs-comment"># 添加一个选项</span><br><br>In [<span class="hljs-number">20</span>]: cf.write(open(<span class="hljs-string">'my.ini'</span>,<span class="hljs-string">'w'</span>))           <span class="hljs-comment"># 将ConfigParser兑现中的数据保存到文件中</span><br><span class="hljs-comment">#可在PyCharm中my.ini文件查看是否增加了'client‘字段。</span><br><br>In [<span class="hljs-number">21</span>]: cf.remove_option(<span class="hljs-string">'client'</span>, <span class="hljs-string">'host'</span>)     <span class="hljs-comment"># 删除一个选项**</span><br>Out[<span class="hljs-number">21</span>]: <span class="hljs-literal">True</span><br><br>In [<span class="hljs-number">22</span>]: cf.write(open(<span class="hljs-string">'my.ini'</span>,<span class="hljs-string">'w'</span> ))          <span class="hljs-comment"># 将ConfigParser兑现中的数据保存到文件中</span><br><span class="hljs-comment">#可在PyCharm中my.ini文件查看是否减少了指定选项。</span><br></code></pre></td></tr></table></figure><p><em><strong>可在PyCharm上查看测试效果。</strong></em></p><h2 id="3、常见异常">3、常见异常</h2><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>ConfigParser.Error</td><td>所有异常的基类</td></tr><tr><td>ConfigParser.NoSectionError</td><td>指定的section没有找到</td></tr><tr><td>ConfigParser.DuplicateSectionError</td><td>调用add_section() 时，section名称已经被使用</td></tr><tr><td>ConfigParser.NoOptionError</td><td>指定的参数没有找到</td></tr><tr><td>ConfigParser.InterpolationError</td><td>当执行字符串插值时出现问题时，出现异常的基类</td></tr><tr><td>ConfigParser.InterpolationDepthError</td><td>当字符串插值无法完成时，因为迭代次数超过了最大的范围，所以无法完成。InterpolationError的子类</td></tr><tr><td>InterpolationMissingOptionError</td><td>当引用的选项不存在时，会出现异常。InterpolationError的子类</td></tr><tr><td>ConfigParser.InterpolationSyntaxError</td><td>当产生替换的源文本不符合所需的语法时，就会出现异常。InterpolationError的子类。</td></tr><tr><td>ConfigParser.MissingSectionHeaderError</td><td>当试图解析一个没有分段标题的文件时，会出现异常。</td></tr><tr><td>ConfigParser.ParsingError</td><td>当试图解析文件时发生错误时，会出现异常</td></tr><tr><td>ConfigParser.MAX_INTERPOLATION_DEPTH</td><td>当raw参数为false时，get()的递归插值的最大深度。这只适用于ConfigParser类</td></tr></tbody></table><h1>二、查找文件</h1><h3 id="PyCharm创建测试文件，格式如下：">PyCharm创建测试文件，格式如下：</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">G:\四期\<span class="hljs-title">python</span>\<span class="hljs-title">ConfigParser</span>\<span class="hljs-title">files</span>&gt;<span class="hljs-title">tree</span> /<span class="hljs-title">f</span></span><br><span class="hljs-function">卷 学习 的文件夹 <span class="hljs-title">PATH</span> 列表</span><br><span class="hljs-function">卷序列号为 7<span class="hljs-title">C11</span>-994<span class="hljs-title">A</span></span><br><span class="hljs-function"><span class="hljs-title">G</span>:.</span><br><span class="hljs-function">│  <span class="hljs-title">a.jpg</span></span><br><span class="hljs-function">│  <span class="hljs-title">A.png</span></span><br><span class="hljs-function">│  <span class="hljs-title">b.jpg</span></span><br><span class="hljs-function">│  <span class="hljs-title">c.png</span></span><br><span class="hljs-function">│  <span class="hljs-title">e.bmp</span></span><br><span class="hljs-function">│  <span class="hljs-title">f.txt</span></span><br><span class="hljs-function">│  <span class="hljs-title">ff.txt</span></span><br><span class="hljs-function">│  <span class="hljs-title">find_file.py</span></span><br><span class="hljs-function">│  <span class="hljs-title">find_file2.py</span></span><br><span class="hljs-function">│  <span class="hljs-title">find_file3.py</span></span><br><span class="hljs-function">│</span><br><span class="hljs-function">└─<span class="hljs-title">test</span></span><br></code></pre></td></tr></table></figure><h4 id="测试一下">测试一下</h4><h5 id="find-file-py">find_file.py</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> os.listdir(<span class="hljs-string">'.'</span>):<br>    <span class="hljs-keyword">if</span> os.path.isfile(item):<br>truetrueprint(item)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：">输出结果如下：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">a.jpg<br>A.png<br>b.jpg<br>c.png<br>e.bmp<br>f.txt<br>ff.txt<br>find_file.py<br>find_file2.py<br>find_file3.py<br></code></pre></td></tr></table></figure><h2 id="1、使用fnmatch找到特定文件">1、使用fnmatch找到特定文件</h2><h4 id="1-fnmatch支持的通配符">&lt;1&gt;fnmatch支持的通配符</h4><table><thead><tr><th>字符</th><th>函数</th></tr></thead><tbody><tr><td>*</td><td>匹配所有字符</td></tr><tr><td>？</td><td>匹配单个字符</td></tr><tr><td>[seq]</td><td>匹配指定范围内的字符</td></tr><tr><td>[!seq]</td><td>匹配不在指定范围内的字符</td></tr></tbody></table><h4 id="2-fnmatch的基本使用">&lt;2&gt;fnmatch的基本使用</h4><p><strong>fnmatch这个库相对比较简单，只有4个函数，分别是fnmatch、fnmatchcase、filter和translate，其中最常用的是fnmatch。主要功能如下：</strong></p><ul><li><strong>fnmatch：判断文件名是否符合特定的模式。</strong></li><li><strong>fnmatchcase：判断文件名是否符合特定的模式，区分大小写。</strong></li><li><strong>filter：返回输入列表中，符合特定模式的文件名列表。</strong></li><li><strong>translate：将通配符模式转换成正则表达式。</strong></li></ul><p><em><strong>fnmatch和fnmatchcase用法相同，判断名称是否符合表达式，返回True or False</strong></em></p><h3 id="（1）fnmatch-fnmatch-：一次只能处理一个文件">（1）fnmatch.fnmatch()：一次只能处理一个文件</h3><h5 id="find-file2-py">find_file2.py</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> fnmatch<br><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> os.listdir(<span class="hljs-string">'.'</span>):<br>    <span class="hljs-keyword">if</span> os.path.isfile(item):<br>        <span class="hljs-comment"># if fnmatch.fnmatch(item,'*.jpg'):</span><br>        <span class="hljs-comment"># if fnmatch.fnmatch(item, '[a-e].*'):</span><br>        <span class="hljs-comment"># if fnmatch.fnmatch(item, '[a-z]?.txt'):</span><br>        <span class="hljs-comment"># if fnmatch.fnmatch(item, '[!a-c]*'):</span><br>            print(item)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-2">输出结果如下：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">输出以“.jpg”为结尾的文件</span><br>a.jpg<br>b.jpg<br><br><span class="hljs-meta">#</span><span class="bash">输出以“a<span class="hljs-_">-e</span>”为标题的文件</span><br>a.jpg<br>A.png<br>b.jpg<br>c.png<br>e.bmp<br><br><span class="hljs-meta">#</span><span class="bash">输出以“a-z”和一个任意字符为标题，并且以“.txt”为后缀的文件</span><br>ff.txt<br><br><span class="hljs-meta">#</span><span class="bash">输出除了以“a-c”为开通的文件</span><br>e.bmp<br>f.txt<br>ff.txt<br>find_file.py<br>find_file2.py<br>find_file3.py<br></code></pre></td></tr></table></figure><h3 id="（2）fnmath-filter-：一次可以处理多个文件">（2）fnmath.filter()：一次可以处理多个文件</h3><h5 id="find-file3-py">find_file3.py</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> fnmatch<br><br>items = os.listdir(<span class="hljs-string">'.'</span>)<br>files = fnmatch.filter(items, <span class="hljs-string">'[a-c]*'</span>)<br>print(files)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-3">输出结果如下：</h5><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">['a.jpg', 'A.png', 'b.jpg', 'c.png']<br></code></pre></td></tr></table></figure><h2 id="2、使用glob找到特定文件">2、使用glob找到特定文件</h2><h3 id="glob模块支持的通配符：">glob模块支持的通配符：</h3><table><thead><tr><th>通配符</th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>*</td><td>匹配0或多个字符</td></tr><tr><td>**</td><td>匹配所有文件、目录、子目录和子目录里的文件（3.5版本新增）</td></tr><tr><td>?</td><td>匹配1个字符，与正则表达式里的?不同</td></tr><tr><td>[exp]</td><td>匹配指定范围内的字符，如：[1-9]匹配1至9范围内的字符</td></tr><tr><td>[!exp]</td><td>匹配不在指定范围内的字符</td></tr></tbody></table><p><strong>标准库glob的作用相当于os.listdir()加上fnmatch。使用glob以后，不需要调用os.listdir获取文件列表，直接通过模式匹配即可。如下所示:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> glob<br><br>file = glob.glob(<span class="hljs-string">'*.txt'</span>)<br>print(file)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-4">输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">'f.txt'</span>, <span class="hljs-string">'ff.txt'</span>]<br></code></pre></td></tr></table></figure><h3 id="glob基本使用">glob基本使用</h3><p>glob和iglob的区别在于glob返回的是一个列表，iglob返回的是一个生成器对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> glob<br><span class="hljs-meta">&gt;&gt;&gt; </span>glob.glob(<span class="hljs-string">'*.txt'</span>)<br>[<span class="hljs-string">'a1.txt'</span>, <span class="hljs-string">'a2.txt'</span>, <span class="hljs-string">'aA.txt'</span>]<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>g = glob.iglob(<span class="hljs-string">'*.txt'</span>)        <span class="hljs-comment"># 使用iglob返回的是一个生成器</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>g<br>&lt;generator object _iglob at <span class="hljs-number">0x1050bbba0</span>&gt;<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>list(g)<br>[<span class="hljs-string">'a1.txt'</span>, <span class="hljs-string">'a2.txt'</span>, <span class="hljs-string">'aA.txt'</span>]<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p><strong>PS：glob同样支持通配符和fnmatch相同，这里不在列举，并且在通配符表达式中支持路径</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>glob.glob(<span class="hljs-string">'/Users/DahlHin/github/test/*.txt'</span>)<br>[<span class="hljs-string">'/Users/DahlHin/github/test/a1.txt'</span>,<span class="hljs-string">'/Users/DahlHin/github/test/a2.txt'</span>,<span class="hljs-string">'/Users/DahlHin/github/test/aA.txt'</span>]<br></code></pre></td></tr></table></figure><p><strong>总结：虽然glob模块可以很轻松地匹配特定文件和文件夹，但是仅仅支持少量的通配符，没办法像正则表达式一样匹配更复杂的字符串。使用的时候应当认真考虑使用场景，根据需求针对性地选择解决方案。</strong></p><h2 id="3、找到目录下最大-或最老-的10个文件">3、找到目录下最大(或最老)的10个文件</h2><h4 id="PyCharm创建测试文件，格式如下：-2">PyCharm创建测试文件，格式如下：</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">G:\四期\<span class="hljs-title">python</span>\打印最常用的10条<span class="hljs-title">linux</span>命令\<span class="hljs-title">exam</span>&gt;<span class="hljs-title">tree</span> /<span class="hljs-title">f</span></span><br><span class="hljs-function">    1000313.<span class="hljs-title">jpg</span></span><br><span class="hljs-function">    1000367.<span class="hljs-title">jpg</span></span><br><span class="hljs-function">    1000591.<span class="hljs-title">bmp</span></span><br><span class="hljs-function">    1000925.<span class="hljs-title">tiff</span></span><br><span class="hljs-function">    323507.<span class="hljs-title">jpg</span></span><br><span class="hljs-function">    325738.<span class="hljs-title">jpg</span></span><br><span class="hljs-function">    <span class="hljs-title">find_file_max.py</span></span><br></code></pre></td></tr></table></figure><h1>三、高级文件处理接口shutil</h1><h3 id="shutil">shutil</h3><blockquote><p><strong>是一种高层次的文件操作工具</strong><br><strong>类似于高级API，而且主要强大之处在于其对文件的复制与删除操作更是比较支持好。</strong></p></blockquote><h4 id="使用方法">使用方法</h4><ul><li><strong>copyfile( src, dst)    从源src复制到dst中去。当然前提是目标地址是具备可写权限。抛出的异常信息为IOException. 如果当前的dst已存在的话就会被覆盖掉</strong></li><li><strong>copymode( src, dst)    只是会复制其权限其他的东西是不会被复制的</strong></li><li><strong>copystat( src, dst)    复制权限、最后访问时间、最后修改时间</strong></li><li><strong>copy( src, dst)        复制一个文件到一个文件或一个目录</strong></li><li><strong>copy2( src, dst)   在copy上的基础上再复制文件最后访问时间与修改时间也复制过来了，类似于cp –p的东西</strong></li><li><strong>copy2( src, dst)   如果两个位置的文件系统是一样的话相当于是rename操作，只是改名；如果是不在相同的文件系统的话就是做move操作</strong></li><li><strong>copytree(olddir,newdir,True/Flase)     把olddir拷贝一份newdir，如果第3个参数是True，则复制目录时将保持文件夹下的符号连接，如果第3个参数是False，则将在复制的目录下生成物理副本来替代符号连接</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# mkdir /tmp/demo<br>[root@python ~]# cd /tmp/demo/<br>[root@python demo]# mkdir -p dir1<br>[root@python demo]# touch a.txt b.txt c.txt<br>[root@python demo]# touch sh.py cc.py 001.jpg 002.jpg 003.jpg<br>//创建所需文件<br><br>[root@python demo]# ipython<br>//打开ipython<br></code></pre></td></tr></table></figure><p><em><strong>也可以在PyCharm中创建文件，进行实施。</strong></em></p><h2 id="1、复制文件和文件夹">1、复制文件和文件夹</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.copy(file1,file2)     <span class="hljs-comment">#文件</span><br>shutil.copytree(dir1,dir2) <span class="hljs-comment">#文件夹</span><br></code></pre></td></tr></table></figure><h3 id="（1）复制文件">（1）复制文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> shutil                                         <br><br>In [<span class="hljs-number">2</span>]: shutil.copy(<span class="hljs-string">'a.txt'</span>,<span class="hljs-string">'aa.txt'</span>)                         <br>Out[<span class="hljs-number">2</span>]: <span class="hljs-string">'aa.txt'</span><br>//可在PyCharm和Linux的相应路径查看是否有生成的文件<br>    <br>In [<span class="hljs-number">3</span>]: ls                                                    <br><span class="hljs-number">001.j</span>pg  <span class="hljs-number">003.j</span>pg  a.txt  cc.py  sh.py<br><span class="hljs-number">002.j</span>pg  aa.txt   b.txt  c.txt<br></code></pre></td></tr></table></figure><h3 id="（2）复制文件夹">（2）复制文件夹</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">5</span>]: shutil.copytree(<span class="hljs-string">'dir1'</span>,<span class="hljs-string">'dir11'</span>)                       <br>Out[<span class="hljs-number">5</span>]: <span class="hljs-string">'dir11'</span><br>    <br>In [<span class="hljs-number">6</span>]: ls                                                    <br><span class="hljs-number">001.j</span>pg  <span class="hljs-number">003.j</span>pg  a.txt  cc.py  dir1/   sh.py<br><span class="hljs-number">002.j</span>pg  aa.txt   b.txt  c.txt  dir11/<br></code></pre></td></tr></table></figure><h2 id="2、文件和文件夹的重命名与移动">2、文件和文件夹的重命名与移动</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.move(filel, file2)<br>shutil.move(file, dir)<br></code></pre></td></tr></table></figure><h3 id="（1）文件的重命名">（1）文件的重命名</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">7</span>]: shutil.move(<span class="hljs-string">'aa.txt'</span>,<span class="hljs-string">'dd.txt'</span>)                        <br>Out[<span class="hljs-number">7</span>]: <span class="hljs-string">'dd.txt'</span><br><br>In [<span class="hljs-number">8</span>]: ls                                                    <br><span class="hljs-number">001.j</span>pg  <span class="hljs-number">003.j</span>pg  b.txt  c.txt   dir1/   sh.py<br><span class="hljs-number">002.j</span>pg  a.txt    cc.py  dd.txt  dir11/<br></code></pre></td></tr></table></figure><h3 id="（2）文件移动到文件夹">（2）文件移动到文件夹</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">9</span>]: shutil.move(<span class="hljs-string">'dd.txt'</span>,<span class="hljs-string">'dir1'</span>)                          <br>Out[<span class="hljs-number">9</span>]: <span class="hljs-string">'dir1/dd.txt'</span><br><br>In [<span class="hljs-number">11</span>]: ls dir1                                              <br>dd.txt<br></code></pre></td></tr></table></figure><h2 id="3、删除目录">3、删除目录</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.rmtree(dir)    <span class="hljs-comment"># 删除目录</span><br>os.unlink(file)       <span class="hljs-comment"># 删除文件</span><br></code></pre></td></tr></table></figure><h3 id="删除目录">删除目录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">15</span>]: shutil.rmtree(<span class="hljs-string">'dir1'</span>)                                <br><br>In [<span class="hljs-number">16</span>]: ls                                                   <br><span class="hljs-number">001.j</span>pg  <span class="hljs-number">003.j</span>pg  b.txt  c.txt   sh.py<br><span class="hljs-number">002.j</span>pg  a.txt    cc.py  dir11/<br></code></pre></td></tr></table></figure><h1>四、文件内容管理</h1><h2 id="1、目录和文件的对比">1、目录和文件的对比</h2><p><strong>filecmp模块包含了比较目录和文件的操作。</strong></p><p><strong>filecmp可以实现文件，目录，遍历子目录的差异对比功能。</strong></p><p><strong>自带filecmp模块，无需安装。</strong></p><h3 id="（1）目录结构">（1）目录结构</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200426143707738.png" alt="image-20200426143707738"></p><p><em><strong>目录dir1中文件a_copy.txt，a.txt，c.txt内容一样，b.txt内容不一样</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python demo]# mkdir compare<br>[root@python demo]# cd compare/<br>[root@python compare]# mkdir -p dir1 dir2<br>[root@python compare]# mkdir dir1/subdir1<br>[root@python compare]# ls<br>dir1  dir2<br>[root@python compare]# touch dir1/a_copy.txt dir1/a.txt dir1/b.txt   dir1/c.txt<br>[root@python compare]# touch dir2/a.txt dir2/b.txt dir2/c.txt<br>[root@python compare]# mkdir -p dir2/subdir1 dir2/subdir2<br>[root@python compare]# touch dir2/subdir1/sb.txt<br>//创建所需文件<br><br>[root@python compare]# ipython<br>//打开ipython<br></code></pre></td></tr></table></figure><p><strong>filecmp提供3个操作方法，cmp(单文件对比),cmpfile(多文件对比),dircmp(目录对比)。</strong></p><h3 id="（2）示例代码：">（2）示例代码：</h3><p><strong>使用filecmp模块的cmp函数比较两个文件是否相同，如果文件相同则返回True,否则False</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">1</span>]: <span class="hljs-keyword">import</span> filecmp <br><br>In [<span class="hljs-number">2</span>]: filecmp.cmp(<span class="hljs-string">'a.txt'</span>,<span class="hljs-string">'b.txt'</span>)                          <br>Out[<span class="hljs-number">2</span>]: <span class="hljs-literal">False</span><br><br>In [<span class="hljs-number">3</span>]: filecmp.cmp(<span class="hljs-string">'a.txt'</span>,<span class="hljs-string">'c.txt'</span>)                          <br>Out[<span class="hljs-number">3</span>]: <span class="hljs-literal">True</span><br>   <br>In [<span class="hljs-number">4</span>]: filecmp.cmp(<span class="hljs-string">'a.txt'</span>,<span class="hljs-string">'a_copy.txt'</span>)                     <br>Out[<span class="hljs-number">4</span>]: <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="（3）比较两个文件">（3）比较两个文件</h3><p><strong>filecmp目录下还有一个名为cmpfiles的函数， 该函数用来同时比较两个不同的目录下的多个文件,并且返回一个三元组，分别包含相同的文件、不同的文件和无法比较的文件。示例如下:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">9</span>]: filecmp.cmpfiles(<span class="hljs-string">'dir1'</span>,<span class="hljs-string">'dir2'</span>,[<span class="hljs-string">'a.txt'</span>,<span class="hljs-string">'b.txt'</span>,<span class="hljs-string">'c.txt'</span>,<span class="hljs-string">'a_copy.txt'</span>])                                      <br>Out[<span class="hljs-number">9</span>]: ([<span class="hljs-string">'b.txt'</span>], [<span class="hljs-string">'a.txt'</span>, <span class="hljs-string">'c.txt'</span>], [<span class="hljs-string">'a_copy.txt'</span>])<br><span class="hljs-comment"># 返回一个三元组第一个是一样的第个是不一样的第三个是无法比较(没有这个文件或者其他原因)</span><br></code></pre></td></tr></table></figure><h3 id="（4）比较多个文件">（4）比较多个文件</h3><p><strong>cmpfiles函数同时用来比较两个目录下的文件,也可以使用该函数比较两个目录。但是，在比较两个目录时，需要通过参数指定可能的文件，因此比较繁琐。</strong></p><p><strong>filecmp中还有一个名为dircmp的函数，用来比较两个目录。调用dircmp函数以后，会返回一个dircmp类的对象,该对象保存了诸多属性，我们可以通过查看这些属性获取目录之间的差异。如下所示:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">11</span>]: d = filecmp.dircmp(<span class="hljs-string">'dir1'</span>,<span class="hljs-string">'dir2'</span>)                    <br><span class="hljs-comment">#设置测试目录</span><br>    <br>In [<span class="hljs-number">12</span>]: d.report()                                           <br>diff dir1 dir2<br>Only <span class="hljs-keyword">in</span> dir1 : [<span class="hljs-string">'a_copy.txt'</span>]<br>Only <span class="hljs-keyword">in</span> dir2 : [<span class="hljs-string">'subdir2'</span>]<br>Identical files : [<span class="hljs-string">'b.txt'</span>]<br>Differing files : [<span class="hljs-string">'a.txt'</span>, <span class="hljs-string">'c.txt'</span>]<br>Common subdirectories: [<span class="hljs-string">'subdir1'</span>]<br></code></pre></td></tr></table></figure><h3 id="（5）直接比较目录不指定文件">（5）直接比较目录不指定文件</h3><p><strong>目录对比，通过<code>filecmp（a,b[,ignore[,hide]]）</code>类创建一个目录比较对象用于比较文件夹，通过该类比较两个文件夹，可以获取一些详细的比较结果（如只在A文件夹存在的文件列表），并支持子文件夹的递归比较。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">17</span>]: d.left_list      <span class="hljs-comment">#查看dir1目录结构                                    </span><br>Out[<span class="hljs-number">17</span>]: [<span class="hljs-string">'a.txt'</span>, <span class="hljs-string">'a_copy.txt'</span>, <span class="hljs-string">'b.txt'</span>, <span class="hljs-string">'c.txt'</span>, <span class="hljs-string">'subdir1'</span>]<br><br>In [<span class="hljs-number">18</span>]: d.right_list     <span class="hljs-comment">#查看dir2目录结构                                 </span><br>Out[<span class="hljs-number">18</span>]: [<span class="hljs-string">'a.txt'</span>, <span class="hljs-string">'b.txt'</span>, <span class="hljs-string">'c.txt'</span>, <span class="hljs-string">'subdir1'</span>, <span class="hljs-string">'subdir2'</span>]<br><br>In [<span class="hljs-number">19</span>]: d.left_only      <span class="hljs-comment">#仅第dir1目录存在的           </span><br>Out[<span class="hljs-number">19</span>]: [<span class="hljs-string">'a_copy.txt'</span>]<br><br>In [<span class="hljs-number">20</span>]: d.right_only     <span class="hljs-comment">#仅第dir2目录存在的                                 </span><br>Out[<span class="hljs-number">20</span>]: [<span class="hljs-string">'subdir2'</span>]<br></code></pre></td></tr></table></figure><h2 id="2、MD5校验和比较">2、MD5校验和比较</h2><p><strong>校验码是通过散列函数计算而成，是一种从任何数据中创建小的数字”指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，便于进行比较。MDS是目前使用最官方的</strong></p><p><strong>MD5哈希一般用于检查文件的完整性，尤其常用于检查文件传输、磁盘错误或其他情况下文件的正确性。</strong></p><p><strong>Linux下计算一个文件的MD5校验码，如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@192 demo]# md5sum a.txt<br>d41d8cd98f00b204e9800998ecf8427e  a.txt<br></code></pre></td></tr></table></figure><p><strong>在Python中计算文件的MD5校验码也非常简单，使用标准库hashlib模块即可。如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br><br>d = hashlib.md5()<br><span class="hljs-keyword">with</span> open(<span class="hljs-string">'b.txt'</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>        d.update(line.encode(<span class="hljs-string">'utf-8'</span>))<br>print(d.hexdigest())<br><br><span class="hljs-comment"># 或者可以这样（最常见的写法，常用于图片的命名）</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> hashlib<br>    <br><span class="hljs-meta">&gt;&gt;&gt; </span>hashlib.md5(<span class="hljs-string">b'123'</span>).hexdigest()<br><span class="hljs-string">'202cb962ac59075b964b07152d234b70'</span><br><br><span class="hljs-comment"># 也可以使用hash.new()这个一般方法，hashlib.new(name[, data])，name传入的是哈希加密算法的名称，如md5</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>hashlib.new(<span class="hljs-string">'md5'</span>, <span class="hljs-string">b'123'</span>).hexdigest()<br><span class="hljs-string">'202cb962ac59075b964b07152d234b70'</span><br></code></pre></td></tr></table></figure><p><em><strong>记得创建b.txt文件</strong></em></p><h1>五、Python管理压缩包</h1><h2 id="1、tarfile">1、tarfile</h2><p><strong>既然有压缩模块zipfile，那有一个归档模块tarfile也是很自然的。tarfile模块用于解包和打包文件，包括被<code>gzip</code>，<code>bz2</code>或<code>lzma</code>压缩后的打包文件。如果是<code>.zip</code>类型的文件，建议使用zipfile模块，更高级的功能请使用shutil模块。</strong></p><h3 id="定义的类和异常">定义的类和异常</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tarfile.open(name=<span class="hljs-literal">None</span>, mode=<span class="hljs-string">'r'</span>, fileobj=<span class="hljs-literal">None</span>, bufsize=<span class="hljs-number">10240</span>, \kwargs)<br></code></pre></td></tr></table></figure><p><strong>返回一个TarFile类型的对象。本质上就是打开一个文件对象。Python随处可见这种文件对象类型的设计，你很容易就明白，不是吗？</strong></p><p><strong><code>name</code>是文件名或路径。</strong></p><p><strong><code>bufsize</code>用于指定数据块的大小，默认为20*512字节。</strong></p><p><strong><code>mode</code>是打开模式，一个类似<code>filemode[:compression]</code>格式的字符串，可以有下表所示的组合，默认为“r”</strong></p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>‘r’or’r:*’</td><td>自动解压并打开文件（推荐模式）</td></tr><tr><td>‘r:’</td><td>只打开文件不解压</td></tr><tr><td>‘r:gz’</td><td>采用gzip格式解压并打开文件</td></tr><tr><td>‘r:bz2’</td><td>采用bz2格式解压并打开文件</td></tr><tr><td>‘r:xz’</td><td>采用lzma格式解压并打开文件</td></tr><tr><td>‘x’or’x:’</td><td>仅创建打包文件，不压缩</td></tr><tr><td>‘x:gz’</td><td>采用gzip方式压缩并打包文件</td></tr><tr><td>‘x:bz2’</td><td>采用bzip2方式压缩并打包文件</td></tr><tr><td>‘x:xz’</td><td>采用lzma方式压缩并打包文件</td></tr><tr><td>‘a’or’a:’</td><td>打开文件，并以不压缩的方式追加内容。如果文件不存在，则新建</td></tr><tr><td>‘w’or’w:’</td><td>以不压缩的方式写入</td></tr><tr><td>‘w:gz’</td><td>以gzip的方式压缩并写入</td></tr><tr><td>‘w:bz2’</td><td>以bzip2的方式压缩并写入</td></tr><tr><td>‘w:xz’</td><td>以lzma的方式压缩并写入</td></tr><tr><td><code>注意</code></td><td>不支持’a:gz’, 'a:bz2’和’a:xz’的模式</td></tr></tbody></table><p><strong>如果当前模式不能正常打开文件用于读取，将抛出<code>ReadError</code>异常，这种情况下，请使用“r”模式。如果指定的压缩方式不支持，将抛出<code>CompressionError</code>异常。</strong></p><p><strong>在<code>w:gz</code>,<code>r:gz</code>,<code>w:bz2</code>,<code>r:bz2</code>,<code>x:gz</code>,<code>x:bz2</code>模式下，<code>tarfile.open()</code>方法额外接受一个压缩等级参数<code>compresslevel</code>，默认值为9。</strong></p><h3 id="（1）读取文件">（1）读取文件</h3><p><a href="https://pan.baidu.com/s/1-6HQAr_eJSgoyJxSKgSYIQ" target="_blank" rel="noopener">压缩文件</a><strong>提取码：0418</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tarfile<br><br><span class="hljs-keyword">with</span> tarfile.open(<span class="hljs-string">'tengine-2.3.2.tar.gz'</span>) <span class="hljs-keyword">as</span> t:<br>    <span class="hljs-comment"># getmember() 查看文件列表</span><br>    <span class="hljs-keyword">for</span> member <span class="hljs-keyword">in</span> t.getmembers():<br>        print(member.name)<br><span class="hljs-keyword">with</span> tarfile.open(<span class="hljs-string">'tengine-2.3.2.tar.gz'</span>) <span class="hljs-keyword">as</span> t:<br>    t.extractall(<span class="hljs-string">'a'</span>,<span class="hljs-string">'tengine-2.3.2/man'</span>)<br>    t.extract(<span class="hljs-string">'tengine-2.3.2/man'</span>,<span class="hljs-string">'b'</span>)<br></code></pre></td></tr></table></figure><h5 id="常用方法说明">常用方法说明:</h5><ul><li><strong>getmembers () : 获取tar包中的文件列表</strong></li><li><strong><a href="http://member.name" target="_blank" rel="noopener">member.name</a> : 获取tar包中文件的文件名</strong></li><li><strong>extract(member, path) : 提取单个文件</strong></li><li><strong>extractall(path,memebers) : 提取所有的文件</strong></li></ul><h3 id="（2）创建tar包">（2）创建tar包</h3><p><em><strong>记得创建read.txt文件</strong></em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tarfile<br><br><span class="hljs-keyword">with</span> tarfile.open( <span class="hljs-string">'readme.tar'</span>,mode=<span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> out :<br>    out.add(<span class="hljs-string">'read.txt'</span>)<br></code></pre></td></tr></table></figure><p><em><strong>可在对应位置查看是否有readme.tar文件</strong></em></p><h3 id="（3）读取与创建压缩包">（3）读取与创建压缩包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tarfile<br><br><span class="hljs-keyword">with</span> tarfile.open(<span class="hljs-string">'tarfile_add.tar '</span>,mode=<span class="hljs-string">'r:gz'</span>) <span class="hljs-keyword">as</span> out:<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">with</span> tarfile.open(<span class="hljs-string">'tarfile_add.tar '</span>,mode=<span class="hljs-string">'r:bz2'</span>) <span class="hljs-keyword">as</span> out:<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h3 id="（4）备份指定文件到压缩包中">（4）备份指定文件到压缩包中</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> fnmatch<br><span class="hljs-keyword">import</span> tarfile<br><span class="hljs-keyword">import</span> datetime<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_file_math</span><span class="hljs-params">(filename, patterns)</span>:</span><br>    <span class="hljs-string">'''查找特定类型的文件'''</span><br>    <span class="hljs-keyword">for</span> pattern <span class="hljs-keyword">in</span> patterns:<br>        <span class="hljs-keyword">if</span> fnmatch.fnmatch(filename, pattern):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_files</span><span class="hljs-params">(root, patterns=[<span class="hljs-string">'*'</span>])</span>:</span><br>    <span class="hljs-keyword">for</span> root, dirnames, filenames <span class="hljs-keyword">in</span> os.walk(root):<br>        <span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> filenames:<br>            <span class="hljs-keyword">if</span> is_file_math(filename, patterns):<br>                <span class="hljs-keyword">yield</span> os.path.join(root, filename)<br><br><br>patterns = [<span class="hljs-string">'*.txt'</span>,<span class="hljs-string">'*.md'</span>]<br>now = datetime.datetime.now().strftime(<span class="hljs-string">'%Y_%m_%d_%H_%M_%S'</span>)<br>filename = <span class="hljs-string">'backup_all_file_&#123;0&#125;.tar.gz'</span>.format(now)<br><span class="hljs-keyword">with</span> tarfile.open(filename, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> find_files(<span class="hljs-string">'.'</span>, patterns):<br>        f.add(item)<br></code></pre></td></tr></table></figure><p><em><strong>可在对应位置查看是否有readme.tar文件</strong></em></p><h2 id="2、zipfile">2、zipfile</h2><p><strong>zipfile 是python里用来做zip格式编码的压缩和解压缩的，由于是很常见的zip格式，所以这个模块使用频率也是比较高。</strong></p><p><strong>zipfile里有两个非常重要的class, 分别是ZipFile和ZipInfo, 在绝大多数的情况下，只需要使用这两个class就可以。</strong></p><ul><li><p><strong>ZipFile是主要的类，用来创建和读取zip文件；</strong></p></li><li><p><strong>ZipInfo是存储的zip文件的每个文件的信息的。</strong></p></li></ul><h3 id="1-读取zip文件">(1)读取zip文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> zipfile<br><br>demo_zip = zipfile.ZipFile(<span class="hljs-string">'read.zip'</span>)<br>print(demo_zip.namelist())<br>demo_zip.extractall(<span class="hljs-string">'1'</span>)<br>demo_zip.extract(<span class="hljs-string">'a.jpg'</span>,<span class="hljs-string">'2'</span>)<br>//记得创建名为<span class="hljs-number">2</span>的目录，当然第一个字段的路径也必须正确。<br></code></pre></td></tr></table></figure><h5 id="常用方法说明-2">常用方法说明:</h5><ul><li><strong>namelist() :返回zip文件中包含的所有文件和文件夹的字符串列表</strong></li><li><strong>extract(filename, path): 从zip文件中提取单个文件</strong></li><li><strong>extractall(path): 从zip文件中提取所有文件</strong></li></ul><h3 id="2-创建zip文件">(2)创建zip文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> zipfile<br><br>newZip = zipfile.ZipFile( <span class="hljs-string">'new.zip'</span>, mode=<span class="hljs-string">'w'</span> )<br>newZip.write(<span class="hljs-string">'a.jpg'</span>)     <span class="hljs-comment">#文件必须存在</span><br>newZip.close()<br></code></pre></td></tr></table></figure><h3 id="3-Python命令行调用zipfile">(3) Python命令行调用zipfile</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建zip文件</span><br>python -m zipfile -c new1.zip b.txt<br><br><span class="hljs-comment">#查看zip文件内容</span><br>python -m zipfile -l new1.zip<br>File Name                                             Modified             Size<br>b.txt                                          <span class="hljs-number">2020</span><span class="hljs-number">-04</span><span class="hljs-number">-26</span> <span class="hljs-number">14</span>:<span class="hljs-number">35</span>:<span class="hljs-number">12</span>            <span class="hljs-number">0</span><br><br><span class="hljs-comment">#提取zip文件到指定目录</span><br>python -m zipfile -e new1.zip /<br></code></pre></td></tr></table></figure><h4 id="zipfile模块提供的命令行接口包含的选项">zipfile模块提供的命令行接口包含的选项:</h4><ul><li><strong>-1: 显示zi p格式压缩包中的文件列表</strong></li><li><strong>-e: 提取z i p格式的压缩包</strong></li><li><strong>-c:创建zip格式的压缩包</strong></li><li><strong>-t: 验证文件是不是一个有效的zi p格式压缩包</strong></li></ul><h3 id="4-zipfile的各个属性">(4) zipfile的各个属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> zipfile, os<br>zipFile = zipfile.ZipFile(os.path.join(os.getcwd(), <span class="hljs-string">'duoduo.zip'</span>))<br>zipInfo = zipFile.getinfo(<span class="hljs-string">'文件中的文件.txt'</span>)<br><span class="hljs-keyword">print</span> (<span class="hljs-string">'filename:'</span>, zipInfo.filename) <span class="hljs-comment">#获取文件名称</span><br><span class="hljs-keyword">print</span> (<span class="hljs-string">'date_time:'</span>, zipInfo.date_time) <span class="hljs-comment">#获取文件最后修改时间。返回一个包含6个元素的元组：(年, 月, 日, 时, 分, 秒)</span><br><span class="hljs-keyword">print</span> (<span class="hljs-string">'compress_type:'</span>, zipInfo.compress_type) <span class="hljs-comment">#压缩类型</span><br><span class="hljs-keyword">print</span> (<span class="hljs-string">'comment:'</span>, zipInfo.comment) <span class="hljs-comment">#文档说明</span><br><span class="hljs-keyword">print</span> (<span class="hljs-string">'extra:'</span>, zipInfo.extra) <span class="hljs-comment">#扩展项数据</span><br><span class="hljs-keyword">print</span> (<span class="hljs-string">'create_system:'</span>, zipInfo.create_system) <span class="hljs-comment">#获取创建该zip文档的系统。</span><br><span class="hljs-keyword">print</span> (<span class="hljs-string">'create_version:'</span>, zipInfo.create_version) <span class="hljs-comment">#获取 创建zip文档的PKZIP版本。</span><br><span class="hljs-keyword">print</span> (<span class="hljs-string">'extract_version:'</span>, zipInfo.extract_version) <span class="hljs-comment">#获取 解压zip文档所需的PKZIP版本。</span><br><span class="hljs-keyword">print</span> (<span class="hljs-string">'extract_version:'</span>, zipInfo.reserved) <span class="hljs-comment"># 预留字段，当前实现总是返回0。</span><br><span class="hljs-keyword">print</span> (<span class="hljs-string">'flag_bits:'</span>, zipInfo.flag_bits) <span class="hljs-comment">#zip标志位。</span><br><span class="hljs-keyword">print</span> (<span class="hljs-string">'volume:'</span>, zipInfo.volume) <span class="hljs-comment"># 文件头的卷标。</span><br><span class="hljs-keyword">print</span> (<span class="hljs-string">'internal_attr:'</span>, zipInfo.internal_attr) <span class="hljs-comment">#内部属性。</span><br><span class="hljs-keyword">print</span> (<span class="hljs-string">'external_attr:'</span>, zipInfo.external_attr) <span class="hljs-comment">#外部属性。</span><br><span class="hljs-keyword">print</span> (<span class="hljs-string">'header_offset:'</span>, zipInfo.header_offset) <span class="hljs-comment"># 文件头偏移位。</span><br><span class="hljs-keyword">print</span> (<span class="hljs-string">'CRC:'</span>, zipInfo.CRC) <span class="hljs-comment"># 未压缩文件的CRC-32。</span><br><span class="hljs-keyword">print</span> (<span class="hljs-string">'compress_size:'</span>, zipInfo.compress_size) <span class="hljs-comment">#获取压缩后的大小。</span><br><span class="hljs-keyword">print</span> (<span class="hljs-string">'file_size:'</span>, zipInfo.file_size) <span class="hljs-comment">#获取未压缩的文件大小。</span><br>zipFile.close() <span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h2 id="3、shutil创建和读取压缩包">3、shutil创建和读取压缩包</h2><p><strong>shutil可以简单地理解为<code>sh + util</code>，shell工具的意思。shutil模块是对os模块的补充，主要针对文件的拷贝、删除、移动、压缩和解压操作。</strong></p><h4 id="使用方法-2">使用方法</h4><ul><li><strong>copyfile( src, dst)    从源src复制到dst中去。当然前提是目标地址是具备可写权限。抛出的异常信息为IOException. 如果当前的dst已存在的话就会被覆盖掉</strong></li><li><strong>copymode( src, dst)    只是会复制其权限其他的东西是不会被复制的</strong></li><li><strong>copystat( src, dst)    复制权限、最后访问时间、最后修改时间</strong></li><li><strong>copy( src, dst)        复制一个文件到一个文件或一个目录</strong></li><li><strong>copy2( src, dst)   在copy上的基础上再复制文件最后访问时间与修改时间也复制过来了，类似于cp –p的东西</strong></li><li><strong>copy2( src, dst)   如果两个位置的文件系统是一样的话相当于是rename操作，只是改名；如果是不在相同的文件系统的话就是做move操作</strong></li><li><strong>copytree(olddir,newdir,True/Flase)     把olddir拷贝一份newdir，如果第3个参数是True，则复制目录时将保持文件夹下的符号连接，如果第3个参数是False，则将在复制的目录下生成物理副本来替代符号连接</strong></li></ul><h3 id="测试">测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> shutil<br><br>print(shutil.get_archive_formats())<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-5">输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[(<span class="hljs-string">'bztar'</span>, <span class="hljs-string">"bzip2'ed tar-file"</span>), (<span class="hljs-string">'gztar'</span>, <span class="hljs-string">"gzip'ed tar-file"</span>), (<span class="hljs-string">'tar'</span>, <span class="hljs-string">'uncompressed tar file'</span>), (<span class="hljs-string">'xztar'</span>, <span class="hljs-string">"xz'ed tar-file"</span>), (<span class="hljs-string">'zip'</span>, <span class="hljs-string">'ZIP file'</span>)]<br></code></pre></td></tr></table></figure><h3 id="（1）创建压缩包">（1）创建压缩包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> shutil<br><span class="hljs-comment"># 参数1：生成的压缩包文件名</span><br><span class="hljs-comment"># 参数2：压缩包的格式</span><br><span class="hljs-comment"># 参数3：压缩的目录</span><br>shutil.make_archive(<span class="hljs-string">'a.jpg'</span>,<span class="hljs-string">'gztar'</span>, <span class="hljs-string">'ddd'</span>)<br></code></pre></td></tr></table></figure><p><em><strong>可在对应位置查看是否有生成的文件</strong></em></p><h3 id="（2）解压">（2）解压</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> shutil<br><span class="hljs-comment"># 参数1：需要解压的压缩包</span><br><span class="hljs-comment"># 参数2：解压的目录</span><br>print(shutil.unpack_archive(<span class="hljs-string">'a.jpg.tar.gz'</span>,<span class="hljs-string">'jpg'</span>))<br></code></pre></td></tr></table></figure><p><em><strong>可在对应位置查看是否有生成的文件</strong></em></p><h3 id="（3）将文件内容拷贝到另一个文件中">（3）将文件内容拷贝到另一个文件中</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># _*_ coding:utf-8 _*_</span><br>__author__ = <span class="hljs-string">'junxi'</span><br><br><span class="hljs-keyword">import</span> shutil<br><br><span class="hljs-comment"># 将文件内容拷贝到另一个文件中</span><br>shutil.copyfileobj(open(<span class="hljs-string">'old.txt'</span>, <span class="hljs-string">'r'</span>), open(<span class="hljs-string">'new.txt'</span>, <span class="hljs-string">'w'</span>))<br><br><span class="hljs-comment"># 拷贝文件</span><br>shutil.copyfile(<span class="hljs-string">'old.txt'</span>, <span class="hljs-string">'old1.txt'</span>)<br><br><span class="hljs-comment"># 仅拷贝权限。内容、组、用户均不变</span><br>shutil.copymode(<span class="hljs-string">'old.txt'</span>, <span class="hljs-string">'old1.txt'</span>)<br><br><span class="hljs-comment"># 复制权限、最后访问时间、最后修改时间</span><br>shutil.copystat(<span class="hljs-string">'old.txt'</span>, <span class="hljs-string">'old1.txt'</span>)<br><br><span class="hljs-comment"># 复制一个文件到一个文件或一个目录</span><br>shutil.copy(<span class="hljs-string">'old.txt'</span>, <span class="hljs-string">'old2.txt'</span>)<br><br><span class="hljs-comment"># 在copy上的基础上再复制文件最后访问时间与修改时间也复制过来了</span><br>shutil.copy2(<span class="hljs-string">'old.txt'</span>, <span class="hljs-string">'old2.txt'</span>)<br><br><span class="hljs-comment"># 把olddir拷贝一份newdir，如果第3个参数是True，则复制目录时将保持文件夹下的符号连接，如果第3个参数是False，则将在复制的目录下生成物理副本来替代符号连接</span><br>shutil.copytree(<span class="hljs-string">'C:/Users/xiaoxinsoso/Desktop/aaa'</span>, <span class="hljs-string">'C:/Users/xiaoxinsoso/Desktop/bbb'</span>)<br><br><span class="hljs-comment"># 移动目录或文件</span><br>shutil.move(<span class="hljs-string">'C:/Users/xiaoxinsoso/Desktop/aaa'</span>, <span class="hljs-string">'C:/Users/xiaoxinsoso/Desktop/bbb'</span>) <span class="hljs-comment"># 把aaa目录移动到bbb目录下</span><br><br><span class="hljs-comment"># 删除一个目录</span><br>shutil.rmtree(<span class="hljs-string">'C:/Users/xiaoxinsoso/Desktop/bbb'</span>) <span class="hljs-comment"># 删除bbb目录</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的os模块</title>
      <link href="/posts/b677.html"/>
      <url>/posts/b677.html</url>
      
        <content type="html"><![CDATA[<h3 id="什么是os模块">什么是os模块</h3><p><strong>os模块提供了多数操作系统的功能接口函数。当os模块被导入后，它会自适应于不同的操作系统平台，根据不同的平台进行相应的操作，在python编程时，经常和文件、目录打交道，这时就离不了os模块，本节内容将对os模块提供的函数进行详细的解读</strong></p><h1>一、使用脚本自动安装Python版本</h1><p><strong>要求：没有安装过Python3的系统</strong></p><p><strong>如果已经安装过Python3，只能选择一个不用的版本安装</strong></p><h2 id="1、PyCharm连接Linux">1、PyCharm连接Linux</h2><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200423142429261.png" alt="image-20200423142429261"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200423142500430.png" alt="image-20200423142500430"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200423142531948.png" alt="image-20200423142531948"></p><h2 id="2、os模块执行shell命令">2、os模块执行shell命令</h2><p><strong>os.system()的作用：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">执行shell命令<br>返回shell命令的返回值<br>命令的输出会输出到标准输出<br></code></pre></td></tr></table></figure><p>代码演示：</p><blockquote><p><strong>os.system(‘cls’)</strong></p></blockquote><h5 id="编写自动安装Python的脚本">编写自动安装Python的脚本</h5><h3 id="（1）实现步骤：">（1）实现步骤：</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">下载Python版本源码<br>安装Python需要的依赖库<br>编译安装Python<br></code></pre></td></tr></table></figure><h3 id="（2）伪代码：">（2）伪代码：</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">1. 判断用户是不是root<br>2. 如果是，等待用户输入Python版本<br>3. 执行shell命令下载源码包<br>4. 安装依赖开发包<br>5. 编译安装Python<br></code></pre></td></tr></table></figure><h3 id="（3）脚本内容如下（基于Python2）：">（3）脚本内容如下（基于Python2）：</h3><blockquote><p>auto_install_python.py</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> coding=utf-8</span><br>import os<br><br><span class="hljs-meta">#</span><span class="bash"> 判断用户是否是root用户</span><br>if os.getuid() == 0:<br>    pass<br>else:<br>    print('当前用户不是root用户！')<br>    SystemExit(1)<br><br><span class="hljs-meta">#</span><span class="bash"> 安装Python依赖库</span><br>cmd_module = 'yum -y install wget gcc zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel'<br>res = os.system(cmd_module)<br>if res != 0:<br>    print('Python依赖库安装失败，请重新执行该脚本！')<br>    SystemExit(1)<br>else:<br>    print('Python依赖库安装成功！')<br><br><span class="hljs-meta">#</span><span class="bash"> 输入python版本，下载Python源码包到本地目录</span><br><span class="hljs-meta">#</span><span class="bash"> weget url</span><br>version = raw_input('请输入python版本：（3.6/3.8）')<br>if version == '3.6':<br>    url = 'https://www.python.org/ftp/python/3.6.10/Python-3.6.10.tgz'<br>else:<br>    url = 'https://www.python.org/ftp/python/3.8.2/Python-3.8.2.tgz'<br>cmd = 'wget ' + url<br>res = os.system(cmd)<br>if res != 0:<br>    print('Python源码包下载失败！')<br>    SystemExit(1)<br>else:<br>    print('===============================&gt;&gt;&gt;Python源码包下载成功！')<br><br><span class="hljs-meta">#</span><span class="bash"> 解压Python源码包</span><br><span class="hljs-meta">#</span><span class="bash"> tar zxvf Python-3.8.2.tgz</span><br>if version == '3.6':<br>    package_name = 'Python-3.6.10'<br>else:<br>    package_name = 'Python-3.8.1'<br>res = os.system('tar zxvf ' + package_name + '.tgz')<br>if res != 0:<br>    print('解压失败！')<br>    SystemExit(1)<br>else:<br>    print('=============&lt;&lt;解压成功！&gt;&gt;===============')<br><br><span class="hljs-meta">#</span><span class="bash"> 必要的配置，否则出现错误：“make: *** [pybuilddir.txt] 错误1”</span><br><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">export</span> LANG=zh_CN.UTF-8</span><br><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">export</span> LANGUAGE=zhb_CN.UTF-8</span><br>cmd_export_lang = 'export LANG=zh_CN.UTF-8'<br>cmd_export_language = 'export LANGUAGE=zhb_CN.UTF-8'<br>res1 = os.system(cmd_export_lang)<br>res2 = os.system(cmd_export_language)<br>if res1 != 0 or res2 != 0:<br>    print('配置失败，请检查解脚本后在运行！')<br>    SystemExit(1)<br><br><span class="hljs-meta">#</span><span class="bash"> 切换Python目录</span><br>os.chdir(package_name)<br>os.system('./configure --prefix=/usr/local/python3')<br>res = os.system('make &amp;&amp; make install')<br>if res != 0:<br>    print('源码编译失败！')<br>    SystemExit(1)<br>else:<br>    print('=========&lt;&lt;Python安装成功，请进行验证！&gt;&gt;==========')<br><br><span class="hljs-meta">#</span><span class="bash"> 修改用户环境变量</span><br>os.system('echo "export PYTHON3=/usr/local/python3" &gt;&gt;~/.bash_profile')<br>os.system('echo "export PATH=$PYTHON3/bin:$PATH" &gt;&gt;~/.bash_profile')<br>os.system("source ~/.bash_profile")<br>os.system('cat ~/.bash_profile')<br>print('用户环境变量已更改，请进行验证！')<br>os.system('ln -s /usr/local/python3/bin/*  /usr/local/bin')<br>os.system('python3 --version')<br></code></pre></td></tr></table></figure><h2 id="3、上传到Linux并执行">3、上传到Linux并执行</h2><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200423142821340.png" alt="image-20200423142821340"></p><h3 id="Linux执行">Linux执行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# cd /opt/<br>[root@python opt]# python  test1.py<br></code></pre></td></tr></table></figure><h1>二、Python的os模块shell</h1><p><strong>Python 的 os 模块封装了常见的文件和目录操作，本文只列出部分常用的方法，更多的方法可以查看<a href="https://docs.python.org/3/library/os.path.html" target="_blank" rel="noopener">官方文档</a>。</strong></p><p><strong>下面是部分常见的用法：</strong></p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>os.mkdir</code></td><td style="text-align:center">创建目录</td></tr><tr><td style="text-align:center"><code>os.rmdir</code></td><td style="text-align:center">删除目录</td></tr><tr><td style="text-align:center"><code>os.rename</code></td><td style="text-align:center">重命名</td></tr><tr><td style="text-align:center"><code>os.remove</code></td><td style="text-align:center">删除文件</td></tr><tr><td style="text-align:center"><code>os.getcwd</code></td><td style="text-align:center">获取当前工作路径</td></tr><tr><td style="text-align:center"><code>os.walk</code></td><td style="text-align:center">遍历目录</td></tr><tr><td style="text-align:center"><code>os.path.join</code></td><td style="text-align:center">连接目录与文件名</td></tr><tr><td style="text-align:center"><code>os.path.split</code></td><td style="text-align:center">分割文件名与目录</td></tr><tr><td style="text-align:center"><code>os.path.abspath</code></td><td style="text-align:center">获取绝对路径</td></tr><tr><td style="text-align:center"><code>os.path.dirname</code></td><td style="text-align:center">获取路径</td></tr><tr><td style="text-align:center"><code>os.path.basename</code></td><td style="text-align:center">获取文件名或文件夹名</td></tr><tr><td style="text-align:center"><code>os.path.splitext</code></td><td style="text-align:center">分离文件名与扩展名</td></tr><tr><td style="text-align:center"><code>os.path.isfile</code></td><td style="text-align:center">判断给出的路径是否是一个文件</td></tr><tr><td style="text-align:center"><code>os.path.isdir</code></td><td style="text-align:center">判断给出的路径是否是一个目录</td></tr></tbody></table><h2 id="1、安装ipython">1、安装ipython</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@root ~]# pip3 install -i https://pypi.douban.com/simple/ ipython<br></code></pre></td></tr></table></figure><h4 id="启动ipython">启动ipython</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@root ~]# ipython<br></code></pre></td></tr></table></figure><h4 id="如果启动不了使用：">如果启动不了使用：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python3 -m IPython --version<br></code></pre></td></tr></table></figure><p><strong>来查看<code>ipython</code>版本，如果看到版本信息，那么就可以使用<code>python -m IPython</code> 命令来启动<code>ipython</code></strong></p><h4 id="如果要使用ipython命令来启动，可以在用户目录下的-bash-profile中增加如下：">如果要使用ipython命令来启动，可以在用户目录下的 .bash_profile中增加如下：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">alias ipython="python3 -m IPython"<br></code></pre></td></tr></table></figure><h4 id="再次启动ipython">再次启动ipython</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python3 -m IPython --version<br></code></pre></td></tr></table></figure><p><em><strong>这样就可以了</strong></em></p><h2 id="2、例子">2、例子</h2><p><strong>后文的例子以下面的目录结构为参考，工作目录为 <code>/Users/ethan/coding/python</code>。</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim">Users/ethan<br>└── coding<br>    └── <span class="hljs-keyword">python</span><br>        ├── hello.<span class="hljs-keyword">py</span>    - 文件<br>        └── web         - 目录<br></code></pre></td></tr></table></figure><h3 id="看看例子：">看看例子：</h3><h4 id="（1）os-path-abspath：获取文件或目录的绝对路径">（1）<code>os.path.abspath</code>：获取文件或目录的绝对路径</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pwd<br>/Users/ethan/coding/python<br>$ python<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> os                          <span class="hljs-comment"># 记得导入 os 模块</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="hljs-string">'hello.py'</span>)<br><span class="hljs-string">'/Users/ethan/coding/python/hello.py'</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="hljs-string">'web'</span>)<br><span class="hljs-string">'/Users/ethan/coding/python/web'</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="hljs-string">'.'</span>)                <span class="hljs-comment"># 当前目录的绝对路径</span><br><span class="hljs-string">'/Users/ethan/coding/python'</span><br></code></pre></td></tr></table></figure><h4 id="（2）os-path-dirname：获取文件或文件夹的路径">（2）<code>os.path.dirname</code>：获取文件或文件夹的路径</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.dirname(<span class="hljs-string">'/Users/ethan/coding/python/hello.py'</span>)<br><span class="hljs-string">'/Users/ethan/coding/python'</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.dirname(<span class="hljs-string">'/Users/ethan/coding/python/'</span>)<br><span class="hljs-string">'/Users/ethan/coding/python'</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.dirname(<span class="hljs-string">'/Users/ethan/coding/python'</span>)<br><span class="hljs-string">'/Users/ethan/coding'</span><br></code></pre></td></tr></table></figure><h4 id="（3）os-path-basename：获取文件名或文件夹名">（3）<code>os.path.basename</code>：获取文件名或文件夹名</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.basename(<span class="hljs-string">'/Users/ethan/coding/python/hello.py'</span>)<br><span class="hljs-string">'hello.py'</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.basename(<span class="hljs-string">'/Users/ethan/coding/python/'</span>)<br><span class="hljs-string">''</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.basename(<span class="hljs-string">'/Users/ethan/coding/python'</span>)<br><span class="hljs-string">'python'</span><br></code></pre></td></tr></table></figure><h4 id="（4）os-path-splitext：分离文件名与扩展名">（4）<code>os.path.splitext</code>：分离文件名与扩展名</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.splitext(<span class="hljs-string">'/Users/ethan/coding/python/hello.py'</span>)<br>(<span class="hljs-string">'/Users/ethan/coding/python/hello'</span>, <span class="hljs-string">'.py'</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.splitext(<span class="hljs-string">'/Users/ethan/coding/python'</span>)<br>(<span class="hljs-string">'/Users/ethan/coding/python'</span>, <span class="hljs-string">''</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.splitext(<span class="hljs-string">'/Users/ethan/coding/python/'</span>)<br>(<span class="hljs-string">'/Users/ethan/coding/python/'</span>, <span class="hljs-string">''</span>)<br></code></pre></td></tr></table></figure><h4 id="（5）os-path-split：分离目录与文件名">（5）<code>os.path.split</code>：分离目录与文件名</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.split(<span class="hljs-string">'/Users/ethan/coding/python/hello.py'</span>)<br>(<span class="hljs-string">'/Users/ethan/coding/python'</span>, <span class="hljs-string">'hello.py'</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.split(<span class="hljs-string">'/Users/ethan/coding/python/'</span>)<br>(<span class="hljs-string">'/Users/ethan/coding/python'</span>, <span class="hljs-string">''</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.split(<span class="hljs-string">'/Users/ethan/coding/python'</span>)<br>(<span class="hljs-string">'/Users/ethan/coding'</span>, <span class="hljs-string">'python'</span>)<br></code></pre></td></tr></table></figure><h4 id="（6）os-path-isfile：是否是一个文件">（6）<code>os.path.isfile</code>：是否是一个文件</h4><h4 id="os-path-isdir：是否是一个目录"><code>os.path.isdir</code>：是否是一个目录</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.isfile(<span class="hljs-string">'/Users/ethan/coding/python/hello.py'</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.isdir(<span class="hljs-string">'/Users/ethan/coding/python/'</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.isdir(<span class="hljs-string">'/Users/ethan/coding/python'</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.isdir(<span class="hljs-string">'/Users/ethan/coding/python/hello.py'</span>)<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h4 id="（7）os-walk：遍历目录">（7）os.walk：遍历目录</h4><p><strong><code>os.walk</code> 是遍历目录常用的模块，它返回一个包含 3 个元素的元祖：(<code>dirpath</code>, <code>dirnames</code>, <code>filenames</code>)。<code>dirpath</code> 是以 string 字符串形式返回该目录下所有的绝对路径；<code>dirnames</code> 是以列表 list 形式返回每一个绝对路径下的文件夹名字；<code>filesnames</code> 是以列表 list 形式返回该路径下所有文件名字。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> root, dirs, files <span class="hljs-keyword">in</span> os.walk(<span class="hljs-string">'/Users/ethan/coding'</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">print</span> root<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">print</span> dirs<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">print</span> files<br>...<br>/Users/ethan/coding<br>[<span class="hljs-string">'python'</span>]<br>[]<br>/Users/ethan/coding/python<br>[<span class="hljs-string">'web2'</span>]<br>[<span class="hljs-string">'hello.py'</span>]<br>/Users/ethan/coding/python/web2<br>[]<br>[]<br></code></pre></td></tr></table></figure><h2 id="3、os模块打开文件">3、os模块打开文件</h2><p><strong>方法如下：</strong></p><blockquote><p><strong>os.open(filename, flag, [,mode])</strong></p></blockquote><h4 id="flag参数说明："><strong>flag参数说明：</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">file # 要打开的文件<br>flags # 该参数可以是以下选项，多个使用 "|" 隔开：<br>os.O_RDONLY # 以只读的方式打开<br>os.O_WRONLY # 以只写的方式打开<br>os.O_RDWR # 以读写的方式打开<br>os.O_NONBLOCK # 打开时不阻塞<br>os.O_APPEND # 以追加的方式打开<br>os.O_CREAT # 创建并打开一个新文件<br>os.O_TRUNC # 打开一个文件并截断它的长度为零（必须有写权限）<br>os.O_EXCL # 如果指定的文件存在，返回错误<br>os.O_SHLOCK # 自动获取共享锁<br>os.O_EXLOCK # 自动获取独立锁<br>os.O_DIRECT # 消除或减少缓存效果<br>os.O_FSYNC # 同步写入<br>os.O_NOFOLLOW# 不追踪软链接<br>mode # 类似 chmod()。<br></code></pre></td></tr></table></figure><h2 id="4、os模块对文件进行操作">4、os模块对文件进行操作</h2><p><strong>常用方法如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取文件</span><br>os.read(fd, buffersize)<br><span class="hljs-comment"># 写入文件</span><br>os.write(fd, string)<br><span class="hljs-comment"># 文件指针操作</span><br>os.lseek(fd, pos, how)<br><span class="hljs-comment"># 关闭文件</span><br>os.close(fd)<br></code></pre></td></tr></table></figure><h5 id="代码演示：">代码演示：</h5><blockquote><p><strong>文件创建和写入</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 打开文件</span><br>fd = os.open(<span class="hljs-string">"abc.txt"</span>, os.O_RDWR | os.O_CREAT)<br><br><span class="hljs-comment"># 写入字符串</span><br>str = <span class="hljs-string">"Hello Python!"</span><br>ret = os.write(fd, bytes(str, <span class="hljs-string">'UTF-8'</span>))<br><br><span class="hljs-comment"># 输入返回值</span><br>print(<span class="hljs-string">"写入的位数为: "</span>)<br>print(ret)<br><br>print(<span class="hljs-string">"写入成功"</span>)<br><br><span class="hljs-comment"># 关闭文件</span><br>os.close(fd)<br>print(<span class="hljs-string">"关闭文件成功!!"</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：">输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">写入的位数为: <br><span class="hljs-number">13</span><br>写入成功<br>关闭文件成功!!<br></code></pre></td></tr></table></figure><blockquote><p><strong>文件读取</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 打开文件</span><br>fd = os.open(<span class="hljs-string">"abc.txt"</span>, os.O_RDWR)<br><br><span class="hljs-comment"># 读取文本</span><br>ret = os.read(fd, <span class="hljs-number">6</span>)<br>print(ret)<br><br><span class="hljs-comment"># 关闭文件</span><br>os.close(fd)<br>print(<span class="hljs-string">"关闭文件成功!!"</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-2">输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">b'Hello '</span><br>关闭文件成功!!<br></code></pre></td></tr></table></figure><h2 id="5、os模块管理文件和目录">5、os模块管理文件和目录</h2><h4 id="常用方法如下：">常用方法如下：</h4><table><thead><tr><th>os方法</th><th>说明</th></tr></thead><tbody><tr><td>remove(path)</td><td>删除文件</td></tr><tr><td>rename(old, new)</td><td>修改文件或者目录名</td></tr><tr><td>getcwd()</td><td>获取当前目录</td></tr><tr><td>listdir(path)</td><td>返回当前目录下所有文件组成的列表</td></tr><tr><td>mkdir(path [,mode])</td><td>创建目录</td></tr><tr><td>makedirs(path [,mode])</td><td>创建多级目录</td></tr><tr><td>rmdir(path)</td><td>删除目录（目录必须为空目录）</td></tr><tr><td>removedirs(path)</td><td>删除多级目录（目录必须为空目录）</td></tr></tbody></table><h5 id="代码演示：-2">代码演示：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><br><span class="hljs-keyword">import</span> os<br><br><br>print(os.getcwd())  <span class="hljs-comment"># pwd</span><br>print(os.listdir()) <span class="hljs-comment"># ls</span><br>os.rename(<span class="hljs-string">'abc.txt'</span>,<span class="hljs-string">'test.txt'</span>) <span class="hljs-comment"># mv abc.txt test.txt</span><br>os.remove(<span class="hljs-string">'read.py'</span>)    <span class="hljs-comment"># rm -f abc.txt</span><br><br>os.mkdir(<span class="hljs-string">'test'</span>)    <span class="hljs-comment"># mkdir dir1</span><br>os.makedirs(<span class="hljs-string">'demo/abc'</span>) <span class="hljs-comment"># mkdir -p dir2/dir22</span><br>os.rmdir(<span class="hljs-string">'test'</span>)    <span class="hljs-comment"># 目录必须为空</span><br>os.removedirs(<span class="hljs-string">'demo'</span>)   <span class="hljs-comment">#目录必须为空</span><br></code></pre></td></tr></table></figure><h2 id="6、os模块管理文件权限">6、os模块管理文件权限</h2><table><thead><tr><th>os方法</th><th>说明</th></tr></thead><tbody><tr><td>access(path, mode)</td><td>判断该文件权限：F_OK存在；<br>权限：R_OK，W_OK，X_OK</td></tr><tr><td>chmod(path, mode)</td><td>修改文件权限：0o755</td></tr><tr><td>chown(path, uid, gid)</td><td>更改文件所有者，如果不修改可以设置为 -1</td></tr></tbody></table><h5 id="代码演示：-3">代码演示：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><br><span class="hljs-comment"># 测试路径是否存在：os.F_OK</span><br>res = os.access(<span class="hljs-string">'test.txt'</span>,os.F_OK)<br>print(res)<br><br><span class="hljs-comment"># 测试当前用户对该文件是否有读的权限</span><br>res = os.access(<span class="hljs-string">'test.txt'</span>,os.R_OK)<br>print(res)<br><br><span class="hljs-comment"># 测试当前用户对该文件是否有写的权限</span><br>res = os.access(<span class="hljs-string">'test.txt'</span>,os.W_OK)<br>print(res)<br><br><span class="hljs-comment"># 测试当前用户对该文件是否有执行的权限</span><br>res = os.access(<span class="hljs-string">'test.txt'</span>,os.X_OK)<br>print(res)<br><br><span class="hljs-comment"># 更改当前用户的权限</span><br>os.chmod(<span class="hljs-string">'test.txt'</span>,<span class="hljs-number">0o755</span>)<br><br><span class="hljs-comment"># 更改文件的所有者</span><br>os.chown(<span class="hljs-string">'test.txt'</span>, <span class="hljs-number">1001</span>, <span class="hljs-number">1002</span>)<br></code></pre></td></tr></table></figure><p><em><strong>执行前提，确保需要文件存在。</strong></em></p><h2 id="7、os-path模块管理文件与路径">7、os.path模块管理文件与路径</h2><h5 id="（1）拆分路径">（1）拆分路径</h5><table><thead><tr><th>os.path方法</th><th>说明</th></tr></thead><tbody><tr><td>split</td><td>返回一个二元组，包含文件的路径和文件名</td></tr><tr><td>dirname</td><td>返回文件的路径</td></tr><tr><td>basename</td><td>返回文件名</td></tr><tr><td>splitext</td><td>返回一个去掉文件扩展名的部分和扩展名的二元组</td></tr></tbody></table><h5 id="代码演示：-4">代码演示：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">10</span>]: os.getcwd()<br>Out[<span class="hljs-number">10</span>]: <span class="hljs-string">'/opt/os_demo'</span><br><br>In [<span class="hljs-number">11</span>]: os.listdir()<br>Out[<span class="hljs-number">11</span>]: [<span class="hljs-string">'os_access.py'</span>, <span class="hljs-string">'test.txt'</span>]<br><br>In [<span class="hljs-number">12</span>]: path = <span class="hljs-string">'/opt/os_demo/test.txt'</span><br>    <br>In [<span class="hljs-number">13</span>]: os.path.split(path)<br>Out[<span class="hljs-number">13</span>]: (<span class="hljs-string">'/opt/os_demo'</span>, <span class="hljs-string">'test.txt'</span>)<br><br>In [<span class="hljs-number">14</span>]: os.path.dirname(path)<br>Out[<span class="hljs-number">14</span>]: <span class="hljs-string">'/opt/os_demo'</span><br><br>In [<span class="hljs-number">15</span>]: os.path.basename(path)<br>Out[<span class="hljs-number">15</span>]: <span class="hljs-string">'test.txt'</span><br><br>In [<span class="hljs-number">16</span>]: os.path.splitext(path) <br>Out[<span class="hljs-number">16</span>]: (<span class="hljs-string">'/opt/os_demo/test'</span>, <span class="hljs-string">'.txt'</span>)<br></code></pre></td></tr></table></figure><h5 id="（2）构建路径">（2）构建路径</h5><table><thead><tr><th>os.path方法</th><th>说明</th></tr></thead><tbody><tr><td>expanduser</td><td>展开用户的HOME目录，如~，~oracle</td></tr><tr><td>abspath</td><td>得到文件或路径的绝对路径</td></tr><tr><td>join</td><td>根据不同的操作系统平台，使用不同的路径分隔符拼接路径</td></tr><tr><td>isabs</td><td>检查一个路径是不是一个绝对路径</td></tr></tbody></table><h5 id="代码演示：-5">代码演示：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">19</span>]: os.path.expanduser(<span class="hljs-string">'~'</span>) <br>Out[<span class="hljs-number">19</span>]: <span class="hljs-string">'/root'</span><br><br>In [<span class="hljs-number">20</span>]: os.path.expanduser(<span class="hljs-string">'~oracle'</span>) <br>Out[<span class="hljs-number">20</span>]: <span class="hljs-string">'/home/oracle'</span><br><br>In [<span class="hljs-number">21</span>]: os.path.expanduser(<span class="hljs-string">'~accp'</span>)<br>Out[<span class="hljs-number">21</span>]: <span class="hljs-string">'/home/accp'</span><br><br>In [<span class="hljs-number">22</span>]: os.path.expanduser(<span class="hljs-string">'~acp'</span>) <br>Out[<span class="hljs-number">22</span>]: <span class="hljs-string">'~acp'</span><br><br>In [<span class="hljs-number">23</span>]: os.path.abspath(<span class="hljs-string">'.'</span>)<br>Out[<span class="hljs-number">23</span>]: <span class="hljs-string">'/opt/os_demo'</span><br><br>In [<span class="hljs-number">24</span>]: os.path.abspath(<span class="hljs-string">'..'</span>)<br>Out[<span class="hljs-number">24</span>]: <span class="hljs-string">'/opt'</span><br><br>In [<span class="hljs-number">25</span>]: os.path.join(<span class="hljs-string">'/opt/os_demo'</span>,<span class="hljs-string">'test.txt'</span>)<br>Out[<span class="hljs-number">25</span>]: <span class="hljs-string">'/opt/os_demo/test.txt'</span><br><br>In [<span class="hljs-number">26</span>]: os.path.isabs(<span class="hljs-string">'/opt/os_demo/'</span>) <br>Out[<span class="hljs-number">26</span>]: <span class="hljs-literal">True</span><br><br>In [<span class="hljs-number">27</span>]: os.path.isabs(<span class="hljs-string">'.'</span>) <br>Out[<span class="hljs-number">27</span>]: <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h5 id="（3）获取文件属性">（3）获取文件属性</h5><table><thead><tr><th>os.path</th><th>方法</th></tr></thead><tbody><tr><td>os.path.getmtime(path)</td><td>返回最近文件修改时间</td></tr><tr><td>os.path.getctime(path)</td><td>返回文件 path 创建时间</td></tr><tr><td>os.path.getsize(path)</td><td>返回文件大小，如果文件不存在就返回错误</td></tr></tbody></table><h5 id="代码演示：-6">代码演示：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">33</span>]: os.path.getatime(path)<br>Out[<span class="hljs-number">33</span>]: <span class="hljs-number">1587547270.7306058</span><br><br>In [<span class="hljs-number">34</span>]: os.path.getmtime(path)<br>Out[<span class="hljs-number">34</span>]: <span class="hljs-number">1587547270.7306058</span><br><br>In [<span class="hljs-number">35</span>]: os.path.getctime(path)<br>Out[<span class="hljs-number">35</span>]: <span class="hljs-number">1587548055.4721448</span><br><br>In [<span class="hljs-number">36</span>]: os.path.getsize(path)<br>Out[<span class="hljs-number">36</span>]: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="（4）判断文件类型">（4）判断文件类型</h5><table><thead><tr><th>os.path方法</th><th>说明</th></tr></thead><tbody><tr><td>os.path.isfile(path)</td><td>判断路径是否为文件</td></tr><tr><td>os.path.isdir(path)</td><td>判断路径是否为目录</td></tr><tr><td>os.path.islink(path)</td><td>判断路径是否为链接</td></tr><tr><td>os.path.ismount(path)</td><td>判断路径是否为挂载点</td></tr></tbody></table><h5 id="代码演示：-7">代码演示：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">37</span>]: os.path.isfile(path)<br>Out[<span class="hljs-number">37</span>]: <span class="hljs-literal">True</span><br><br>In [<span class="hljs-number">38</span>]: os.path.isdir(path)<br>Out[<span class="hljs-number">38</span>]: <span class="hljs-literal">False</span><br><br>In [<span class="hljs-number">39</span>]: os.path.islink(path)<br>Out[<span class="hljs-number">39</span>]: <span class="hljs-literal">False</span><br><br>In [<span class="hljs-number">40</span>]: os.path.ismount(path)<br>Out[<span class="hljs-number">40</span>]: <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="8、os-walk遍历目录树">8、<code>os.walk</code>遍历目录树</h2><p><strong>os.walk0方法遍历某个目录及其子目录，对于每一个目录，walk()函数返回一 个三元组(dirpath, dirnames.filenames)。其中dirpath保存的是 当前目录，dirnames是 当前目录下的子目录列表，filenames是 当前目录下的文件列表。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">for</span> root, dirs, files <span class="hljs-keyword">in</span> os .walk(<span class="hljs-string">"."</span>, topdown=<span class="hljs-literal">False</span>):<br>true<span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> files:<br>truetrue<span class="hljs-keyword">print</span> (os.path.join(root, name))<br>true<span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> dirs:<br>truetrue<span class="hljs-keyword">print</span> (os.path.join(root, name))<br></code></pre></td></tr></table></figure><h3 id="（1）在Linux用ipython中把-opt目录遍历一下">（1）在Linux用ipython中把/opt目录遍历一下</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">4</span>]: <span class="hljs-keyword">for</span> root, dirs, files <span class="hljs-keyword">in</span> os .walk(<span class="hljs-string">"/opt"</span>): <br>   ...:     print(root) <br>   ...:     print() <br>   ...:     <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> files: <br>   ...:         print(os.path.join(root,name)) <br>   ...:     <span class="hljs-keyword">for</span> dir <span class="hljs-keyword">in</span> dirs: <br>   ...:         print(os.path.join(root,dir)) <br>   ...:<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-3">输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">/opt<br><br>/opt/rh<br>/opt/rh<br></code></pre></td></tr></table></figure><p><strong>os.walk()方法是一个简单易用的文件、目录遍历器，可以帮助我们高效的处理文件、目录方面的事情.</strong></p><h3 id="（2）打印最常用的10条Linux命令">（2）打印最常用的10条Linux命令</h3><h4 id="步骤：">步骤：</h4><ul><li><strong>读取~/.bash_history文件内容</strong></li><li><strong>将读取到的内容格式化（去掉空行）</strong></li><li><strong>获取指令：索引为0的元素</strong></li><li><strong>指令使用次数进行累加</strong></li><li><strong>去除重复的数据</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python opt]# vim find_cmd.py <br><span class="hljs-meta">#</span><span class="bash"> coding=utf-8</span><br>import os<br>from collections import Counter<br><br>count = Counter()<br>with open(os.path.expanduser('~/.bash_history')) as f:<br>    for line in f:<br>        cmd = line.strip().split()<br>        if cmd:<br>            count[cmd[0]] += 1<br>print(count.most_common(10))<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-4">输出结果如下：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python opt]# python3 find_cmd.py <br>[('ip', 8), ('cd', 8), ('systemctl', 7), ('ls', 6), ('vim', 5), ('ping', 3), ('tar', 3), ('vmware-install.pl', 3), ('rm', 3), ('sh', 2)]<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的pep8编码规范和代码调试</title>
      <link href="/posts/8e56.html"/>
      <url>/posts/8e56.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200420222035640.png" alt="image-20200420222035640"></p><h2 id="一、python的pep8编码规范">一、python的pep8编码规范</h2><p><strong>通常会听别人提到PEP8，但是具体指什么内容呢?《Python Enhancement Proposal #8》 （8号python增强提案）又叫PEP8，它是针对python而编订的代码格式指南。</strong></p><p><strong>编程语言不是艺术，而是工作或者工具，所以整理并遵循一套编码规范十分必要。</strong></p><p><strong>1、每个缩进层级使用4个空格。</strong><br><strong>2、每行最多79个字符。</strong><br><strong>3、顶层的函数（def）或类（class）的定义之间空两行。</strong><br><strong>4、采用ASCII或UTF-8编码文件。（就是在里面表明编码格式，ASCII编码格式或者是UTF-8的编码格式）</strong><br><strong>5、在文件的顶端，注释和文档说明之下，每行每条import语句只导入一个模块，</strong><br><strong>同时要按标准库、第三方库和本地库的导入顺序进行分组。（标准库是下载python后就有的，也就是python自带的，要是需要下载，无论是pip还是其他，都是第三方库。而本地库就是自己创建的）</strong><br><strong>6、在小括号、中括号、大括号之间或者括号之前没有额外的空格</strong><br><strong>7、类(class)的命名采用驼峰命名法，如CamelCase；异常的定义使用Error前缀（如适用的话）；函数的命名采用下划线分隔的小写字母，如separateed_by_underscores;用下划线开头定义私有的属性或方法，如_private</strong></p><h3 id="自动检查代码标准的pep8工具">自动检查代码标准的pep8工具</h3><p><strong>pep8会在哪里显示哪行哪里违反了pep8的，并为每个问题提供了其错误码，要是违反了那些必要的遵守规范，p便会爆出错误(以E开头的的错误码)，如果是细微的问题则会报警告(以W开头的</strong><br><strong>错误码)。跟在字母后面的3位数则是错误或者警告，可以从中看出大概的错误类别。例如以E2开</strong><br><strong>头的错误通常是与空格有关，以3开头的错误通常与空行有关，而以w6开头的警告则表明使用已</strong><br><strong>经废弃的功能。</strong></p><h2 id="1-代码布局">1. 代码布局</h2><h3 id="1-1-缩进">1.1 缩进</h3><ul><li><strong>每级缩进用4个空格</strong></li><li><strong>括号中使用垂直隐式缩进或悬挂缩进</strong></li><li><strong>不使用Tap，更不能混合使用Tap和空格</strong></li></ul><h5 id="正确示范"><strong>正确示范</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># (垂直隐式缩进)对准左括号起的第一个字符</span><br>foo = long_function_name(var_one, var_two,<br>                         var_three, var_four)<br><br><span class="hljs-comment"># (悬挂缩进) 以行首字符为基准，缩进（一般情况只需一层缩进）</span><br>foo = long_function_name(<br>    var_one, var_two,<br>    var_three, var_four)<br><br><span class="hljs-comment"># (悬挂缩进) 但下面情况, 需再加多一层缩进，和函数体的语句块区分开</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">long_function_name</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        var_one, var_two, var_three,</span></span><br><span class="hljs-function"><span class="hljs-params">        var_four)</span>:</span><br>    print(var_one)<br><br><span class="hljs-comment"># 右括号回退</span><br>my_list = [<br>    <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,<br>    <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>,<br>]<br>result = some_function_that_takes_arguments(<br>    <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>,<br>    <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>,<br>)<span class="hljs-number">123456789101112131415161718192021222324</span><br></code></pre></td></tr></table></figure><h5 id="错误示范"><strong>错误示范</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用悬挂缩进时，第一行有参数。</span><br>foo = long_function_name(var_one, var_two,<br>    var_three, var_four)<br><br><span class="hljs-comment"># 参数的悬挂缩进和后续代码块缩进不能区别。</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">long_function_name</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    var_one, var_two, var_three,</span></span><br><span class="hljs-function"><span class="hljs-params">    var_four)</span>:</span><br>    print(var_one)<br><br><span class="hljs-comment"># 右括号不回退，不推荐</span><br>my_list = [<br>    <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,<br>    <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>,<br>    ]<br><br>result = some_function_that_takes_arguments(<br>    <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>,<br>    <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>,<br>    )<span class="hljs-number">1234567891011121314151617181920</span><br></code></pre></td></tr></table></figure><h3 id="1-2-最大行宽"><strong>1.2 最大行宽</strong></h3><ul><li><strong>每行最大行宽不超过 79 个字符</strong></li><li><strong>无括号续行，可使用反斜杠</strong></li><li><strong>括号内续行不需要使用反斜杠</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 无括号续行， 可使用反斜杠</span><br><span class="hljs-keyword">with</span> open(<span class="hljs-string">'/path/to/some/file/you/want/to/read'</span>) <span class="hljs-keyword">as</span> file_1, \<br>     open(<span class="hljs-string">'/path/to/some/file/being/written'</span>, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> file_2:<br>    file_2.write(file_1.read())<br><br><span class="hljs-comment"># 括号内续行，尽量在运算符后再续行</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span><span class="hljs-params">(Blob)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, width, height,</span></span><br><span class="hljs-function"><span class="hljs-params">                 color=<span class="hljs-string">'black'</span>, emphasis=None, highlight=<span class="hljs-number">0</span>)</span>:</span><br>        <span class="hljs-keyword">if</span> (width == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> height == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span><br>                color == <span class="hljs-string">'red'</span> <span class="hljs-keyword">and</span> emphasis == <span class="hljs-string">'strong'</span> <span class="hljs-keyword">or</span><br>                highlight &gt; <span class="hljs-number">100</span>):<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"sorry, you lose"</span>)<br>        <span class="hljs-keyword">if</span> width == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> height == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> (color == <span class="hljs-string">'red'</span> <span class="hljs-keyword">or</span><br>                                           emphasis <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>):<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"I don't think so, values are %s,%s"</span>%                             (width, height))<span class="hljs-number">12345678910111213141516</span><br></code></pre></td></tr></table></figure><h3 id="1-3-空行"><strong>1.3 空行</strong></h3><ul><li><strong>两行空行用于分割顶层函数和类的定义</strong></li><li><strong>单个空行用于分割类定义中的方法</strong></li><li><strong>函数内逻辑无关段落之间空一行；其他地方尽量不要再空行</strong></li><li><strong>虽然可以使用‘；’，但尽量不要把多个语句写在同一行</strong></li><li><strong>if/for/while语句中，即使执行语句只有一句，也必须另起一行</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><span class="hljs-params">(object)</span>:</span>     <span class="hljs-comment"># 类的方法定义用单个空行分割</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span>:</span>       <span class="hljs-comment"># 两行空行分割顶层函数和类的定义</span><br>    pass12345678910<br></code></pre></td></tr></table></figure><h3 id="1-4-模块导入"><strong>1.4 模块导入</strong></h3><ul><li><strong>导入的每个模块应该单独成行</strong></li><li><strong>导入顺序如下: 先标准库，再相关的第三方库，最后本地库。(导入不同类型的模块之间，要有空行分割，各组里面的模块顺序按首字母自上而下升序排列)</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 正确示范</span><br><span class="hljs-keyword">import</span> active   <span class="hljs-comment"># 按模块首字母排序导入, 依此递推</span><br><span class="hljs-keyword">import</span> adidas<br><span class="hljs-keyword">import</span> create<br><br><span class="hljs-comment"># 错误示范</span><br><span class="hljs-keyword">import</span> sys, os, knife  <span class="hljs-comment"># 错误：一行导入多模块</span><br><br><span class="hljs-keyword">import</span> create          <span class="hljs-comment"># 错误：不按模块首字母导入</span><br><span class="hljs-keyword">import</span> active<br><span class="hljs-keyword">import</span> beyond1234567891011<br></code></pre></td></tr></table></figure><h3 id="1-5-字符串"><strong>1.5 字符串</strong></h3><p><strong>单引号和双引号作用是一样的，但必须保证成对存在，不能夹杂使用。</strong><br><strong>(建议句子使用双引号, 单词使用单引号, 但不强制。)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单引号和双引号效果一样</span><br><br>name = <span class="hljs-string">'JmilkFan'</span><br>name = <span class="hljs-string">"Hey Guys!"</span><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><h3 id="1-6-表达式和语句中的空格"><strong>1.6 表达式和语句中的空格</strong></h3><h5 id="括号里边避免空格"><strong>括号里边避免空格</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">spam(ham[<span class="hljs-number">1</span>], &#123;eggs: <span class="hljs-number">2</span>&#125;)        <span class="hljs-comment"># 正确示范</span><br><br>spam( ham[ <span class="hljs-number">1</span> ], &#123; eggs: <span class="hljs-number">2</span> &#125; )  <span class="hljs-comment"># 错误示范123</span><br></code></pre></td></tr></table></figure><h5 id="逗号，冒号，分号之前避免空格"><strong>逗号，冒号，分号之前避免空格</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> x == <span class="hljs-number">4</span>: <span class="hljs-keyword">print</span> x, y; x, y = y, x       <span class="hljs-comment"># 正确示范</span><br><br><span class="hljs-keyword">if</span> x == <span class="hljs-number">4</span> : <span class="hljs-keyword">print</span> x , y ; x , y = y , x  <span class="hljs-comment"># 错误示范123</span><br></code></pre></td></tr></table></figure><h5 id="函数调用的左括号之前不能有空格"><strong>函数调用的左括号之前不能有空格</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">spam(<span class="hljs-number">1</span>)<br>dct[<span class="hljs-string">'key'</span>] = lst[index]     <span class="hljs-comment"># 正确示范</span><br><br>spam (<span class="hljs-number">1</span>)<br>dct [<span class="hljs-string">'key'</span>] = lst [index]   <span class="hljs-comment"># 错误示范12345</span><br></code></pre></td></tr></table></figure><h5 id="赋值等操作符前后不能因为对齐而添加多个空格"><strong>赋值等操作符前后不能因为对齐而添加多个空格</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">1</span>                <span class="hljs-comment"># 正确示范</span><br>y = <span class="hljs-number">2</span><br>long_variable = <span class="hljs-number">3</span><br><br>x             = <span class="hljs-number">1</span>    <span class="hljs-comment"># 错误示范</span><br>y             = <span class="hljs-number">2</span><br>long_variable = <span class="hljs-number">31234567</span><br></code></pre></td></tr></table></figure><h5 id="二元运算符两边各放置一个空格"><strong>二元运算符两边各放置一个空格</strong></h5><ul><li><strong>涉及 = 的复合操作符 ( += , -=等)</strong></li><li><strong>比较操作符 ( == , &lt; , &gt; , != , &lt;&gt; , &lt;= , &gt;= , in , not in , is , is not )</strong></li><li><strong>逻辑操作符( and , or , not )</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = b<br>a <span class="hljs-keyword">or</span> b<br><br><span class="hljs-comment"># 括号内的操作符两边不需要空格</span><br>name = get_name(age, sex=<span class="hljs-literal">None</span>, city=Beijing)<span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure><h3 id="1-7-注释"><strong>1.7 注释</strong></h3><p><strong>总体原则，错误的注释不如没有注释。所以当一段代码发生变化时，第一件事就是修改注释。</strong></p><ul><li><strong>注释块</strong><ul><li><strong>注释块通常应用在代码前，并和代码有同样的缩进。每行以 ‘# ’ 开头, 而且#后面有单个空格。段落之间以只有‘#’的行间隔</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Have to define the param `args(List)`, </span><br><span class="hljs-comment"># otherwise will be capture the CLI option when execute `python manage.py server`.</span><br><span class="hljs-comment"># oslo_config: (args if args is not None else sys.argv[1:])</span><br>CONF(args=[], default_config_files=[CONFIG_FILE])<span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><ul><li><strong>单行注释(这种方式尽量少使用)</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x = x + <span class="hljs-number">1</span> <span class="hljs-comment"># Compensate for border1</span><br></code></pre></td></tr></table></figure><ul><li><strong>文档字符串</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 多行文档, 首行首字母大写，结尾的 """ 应该单独成行</span><br><span class="hljs-string">"""Return a foobang</span><br><span class="hljs-string">Optional plotz says to frobnicate the bizbaz first.</span><br><span class="hljs-string">"""</span><br><br><span class="hljs-comment"># 单行的文档， 结尾的 """ 在同一行。</span><br><span class="hljs-string">"""Return a foobang"""</span><span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure><ul><li><strong>为共有的模块、函数、类、方法写docstrings；非共有的没有必要写docstrings，但是可以写注释（在def的下一行）</strong></li><li><strong>应避免无谓的注释</strong></li></ul><h3 id="1-8-命名规则"><strong>1.8 命名规则</strong></h3><ul><li><strong>包和模块名</strong><br><strong>包和模块名应该简短，全部用小写字母, 多字母之间可以使用单下划线连接。</strong></li><li><strong>类名</strong><br><strong>遵循驼峰命名。</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><span class="hljs-params">(object)</span>:</span><br>    pass12<br></code></pre></td></tr></table></figure><ul><li><strong>全局变量名</strong><br><strong>全局变量名应尽量只在模块内部使用, 对可能使用语句<code>from moduleName import variableName</code>而被导入的模块，应采用<code>__all__</code>机制来防止全局变量被别的模块导入, 或者在全局变量名开头加一个前置下划线。</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">_name = <span class="hljs-string">'name'</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li><strong>函数名</strong><br><strong>函数名应该为全部小写的凹驼峰规则。</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">vcenter_connection = <span class="hljs-string">''</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li><strong>常量名</strong><br><strong>常量全部使用大写字母的凹驼峰规则来表示, 通常在模块顶格定义。</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">MAX_OVERFLOW = <span class="hljs-string">''</span><br>TOTAL = <span class="hljs-number">112</span><br></code></pre></td></tr></table></figure><ul><li><strong>方法名和实例变量</strong><ul><li><strong>非公开方法和实例变量开头使用前置下划线</strong></li><li><strong>有时候可能会为了避免与子类命名冲突，采用两个前置下划线</strong><br><strong>需要注意的是: 若 class Foo 的属性名为 a， 该属性是不能以 Foo.a 的方式访问的(执著的用户还是可以通过Foo._Foo__a 来访问), 所以通常双前置下划线仅被用来避免与基类的属性发生命名冲突。</strong></li></ul></li></ul><h2 id="2-编程建议"><strong>2. 编程建议</strong></h2><ul><li><strong>编码中应考虑到其他python实现的效率问题，比如运算符‘+’在CPython中效率很高，在Jython中却非常低</strong></li><li><strong>None 的比较用 is 或 is not，而不要用 ==；尽可能使用‘is’‘is not’取代‘==’；用 is not 代替 not … is, 前者的可读性更好</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> foo <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>     <span class="hljs-comment"># Yes</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> foo <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>     <span class="hljs-comment"># No123</span><br><span class="hljs-keyword">if</span> x <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>       <span class="hljs-comment"># if x is not None 要优于if x</span><br><br><span class="hljs-keyword">if</span> x123<br></code></pre></td></tr></table></figure><ul><li><strong>使用函数定义关键字 def 代替 lambda 赋值给标识符, 这样更适合于回调和字符串表示</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(x)</span>:</span>              <span class="hljs-comment"># Yes</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*x<br><br>f = <span class="hljs-keyword">lambda</span> x: <span class="hljs-number">2</span>*x      <span class="hljs-comment"># No1234</span><br></code></pre></td></tr></table></figure><ul><li><strong>异常类应该继承自Exception，而不是 BaseException；捕获异常时尽量指明具体异常, 尽量不用 except Exception；应该捕获出了什么问题，而不是问题发生</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:                                   <span class="hljs-comment"># Yes (捕获具体异常)</span><br>    <span class="hljs-keyword">import</span> platform_specific_module    <br><span class="hljs-keyword">except</span> ImportError:<br>    platform_specific_module = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">try</span>:                                   <span class="hljs-comment"># No (不要全局捕获)</span><br>    <span class="hljs-keyword">import</span> platform_specific_module<br><span class="hljs-keyword">except</span>:<br>    platform_specific_module = None123456789<br></code></pre></td></tr></table></figure><ul><li><strong>try/except 子句中的代码要尽可能的少, 以免屏蔽掉其他的错误</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:                            <span class="hljs-comment"># Yes</span><br>    value = collection[key]<br><span class="hljs-keyword">except</span> KeyError:<br>    <span class="hljs-keyword">return</span> key_not_found(key)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> handle_value(value)<br><br><br><span class="hljs-keyword">try</span>:                            <span class="hljs-comment"># No</span><br>    <span class="hljs-keyword">return</span> handle_value(collection[key])<br><span class="hljs-keyword">except</span> KeyError:<br>    <span class="hljs-comment"># 可能会捕捉到handle_value()中的 KeyError, 而不是collection的</span><br>    <span class="hljs-keyword">return</span> key_not_found(key)<span class="hljs-number">12345678910111213</span><br></code></pre></td></tr></table></figure><ul><li><strong>函数或者方法在没有返回值时要明确返回 None</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span>        <span class="hljs-comment"># Yes</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span>        <span class="hljs-comment"># No</span><br>    return12345<br></code></pre></td></tr></table></figure><ul><li><strong>使用字符串方法而不是 string 模块</strong><br><strong>python 2.0 以后字符串方法总是更快，而且与 Unicode 字符串使用了相同的 API</strong></li><li><strong>使用使用 .startswith() 和 .endswith() 代替字符串切片来检查前缀和后缀</strong><br><strong>startswith() 和 endswith 更简洁，利于减少错误</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> foo.startswith(<span class="hljs-string">'bar'</span>):   <span class="hljs-comment"># Yes</span><br><br><span class="hljs-keyword">if</span> foo[:<span class="hljs-number">3</span>] == <span class="hljs-string">'bar'</span>:        <span class="hljs-comment"># No123</span><br></code></pre></td></tr></table></figure><ul><li><strong>使用 isinstance() 比较对象的类型</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> isinstance(obj, int):   <span class="hljs-comment"># Yes</span><br><br><span class="hljs-keyword">if</span> type(obj) <span class="hljs-keyword">is</span> type(<span class="hljs-number">1</span>):   <span class="hljs-comment"># No123</span><br></code></pre></td></tr></table></figure><ul><li><strong>判断序列空或不空</strong><br><strong>空序列类型对象的 bool 为 False:</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> seq:       <span class="hljs-comment"># Yes</span><br>   <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">if</span> seq:<br>   <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">if</span> len(seq):      <span class="hljs-comment"># No</span><br>   <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> len(seq):<br>   pass123456789<br></code></pre></td></tr></table></figure><ul><li><strong>不要使用 == 进行 bool 比较</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"> <span class="hljs-comment"># Yes</span><br><span class="hljs-keyword">if</span> greeting:          <br>   <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># No</span><br><span class="hljs-keyword">if</span> greeting == <span class="hljs-literal">True</span><br>   <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">if</span> greeting <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>: <span class="hljs-comment"># Worse</span><br>   pass123456789<br></code></pre></td></tr></table></figure><ul><li><strong>字符串不要以空格收尾</strong></li><li><strong>二进制数据判断使用<code>if boolvalue</code>的方式</strong></li><li><strong>使用Map和Reduce，不要使用循环</strong></li></ul><h1>二、<code>pdb</code>代码调试</h1><p><strong>程序能一次写完并正常运行的概率很小，基本不超过1%。总会有各种各样的bug需要修正。有的bug很简单，看看错误信息就知道，有的bug很复杂，我们需要知道出错时，哪些变量的值是正确的，哪些变量的值是错误的，因此，需要一整套调试程序的手段来修复bug。</strong></p><h2 id="安装ipdb库">安装ipdb库</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">PS G:\四期\python&gt; pip install pdb<br></code></pre></td></tr></table></figure><h4 id="G-四期-python-4-1-py文件内容如下：">G:\四期\python\4\1.py文件内容如下：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pdb<br>s = <span class="hljs-string">'0'</span><br>n = int(s)<br>pdb.set_trace()<br>print(<span class="hljs-number">10</span>/n)<br></code></pre></td></tr></table></figure><h2 id="调试一下">调试一下</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">PS G:\四期\python\<span class="hljs-number">4</span>&gt; python <span class="hljs-number">2</span>.py<br>&gt; g:\四期\python\<span class="hljs-number">4</span>\<span class="hljs-number">2</span>.py(<span class="hljs-number">5</span>)&lt;module&gt;()<br>-&gt; <span class="hljs-built_in">print</span>(<span class="hljs-number">10</span>/n)<br></code></pre></td></tr></table></figure><h3 id="1、使用pdb进行调试：">1、使用pdb进行调试：</h3><p><strong>pdb 是 python 自带的一个包，为 python 程序提供了一种交互的源代码调试功能，主要特性包括设置断点、单步调试、进入函数调试、查看当前代码、查看栈片段、动态改变变量的值等。pdb 提供了一些常用的调试命令，详情见表 1。</strong></p><h4 id="pdb-常用命令">pdb 常用命令</h4><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>break 或 b 设置断点</td><td>设置断点</td></tr><tr><td>continue 或 c</td><td>继续执行程序</td></tr><tr><td>list 或 l</td><td>查看当前行的代码段</td></tr><tr><td>step 或 s</td><td>进入函数</td></tr><tr><td>return 或 r</td><td>执行代码直到从当前函数返回</td></tr><tr><td>exit 或 q</td><td>中止并退出</td></tr><tr><td>next 或 n</td><td>执行下一行</td></tr><tr><td>pp</td><td>打印变量的值</td></tr><tr><td>help</td><td>帮助</td></tr></tbody></table><p><strong>下面结合具体的实例讲述如何使用 pdb 进行调试。</strong></p><h3 id="2、测试代码示例">2、测试代码示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pdb <br>a = <span class="hljs-string">"aaa"</span><br>pdb.set_trace() <br>b = <span class="hljs-string">"bbb"</span><br>c = <span class="hljs-string">"ccc"</span><br>final = a + b + c <br><span class="hljs-keyword">print</span> final<br></code></pre></td></tr></table></figure><p><strong>开始调试：直接运行脚本，会停留在 pdb.set_trace() 处，选择 n+enter 可以执行当前的 statement。在第一次按下了 n+enter 之后可以直接按 enter 表示重复执行上一条 debug 命令。</strong></p><h3 id="（1）利用-pdb-调试">（1）利用 pdb 调试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@rcc-pok-idg<span class="hljs-number">-2255</span> ~]<span class="hljs-comment">#  python epdb1.py </span><br> &gt; /root/epdb1.py(4)?() <br> -&gt; b = "bbb"<br> (Pdb) n <br> &gt; /root/epdb1.py(5)?() <br> -&gt; c = "ccc"<br> (Pdb) <br> &gt; /root/epdb1.py(6)?() <br> -&gt; final = a + b + c <br> (Pdb) list <br>  <span class="hljs-number">1</span>     <span class="hljs-keyword">import</span> pdb <br>  <span class="hljs-number">2</span>     a = <span class="hljs-string">"aaa"</span><br>  <span class="hljs-number">3</span>     pdb.set_trace() <br>  <span class="hljs-number">4</span>     b = <span class="hljs-string">"bbb"</span><br>  <span class="hljs-number">5</span>     c = <span class="hljs-string">"ccc"</span><br>  6  -&gt; final = a + b + c <br>  <span class="hljs-number">7</span>     <span class="hljs-keyword">print</span> final <br> [EOF] <br> (Pdb) <br> [EOF] <br> (Pdb) n <br> &gt; /root/epdb1.py(7)?() <br> -&gt; print final <br> (Pdb)<br></code></pre></td></tr></table></figure><p><strong>退出 debug：使用 quit 或者 q 可以退出当前的 debug，但是 quit 会以一种非常粗鲁的方式退出程序，其结果是直接 crash。</strong></p><h3 id="（2）退出-debug">（2）退出 debug</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@rcc-pok-idg<span class="hljs-number">-2255</span> ~]<span class="hljs-comment">#  python epdb1.py </span><br> &gt; /root/epdb1.py(4)?() <br> -&gt; b = "bbb"<br> (Pdb) n <br> &gt; /root/epdb1.py(5)?() <br> -&gt; c = "ccc"<br> (Pdb) q <br> Traceback (most recent call last): <br>  File "epdb1.py", line 5, in ? <br>    c = <span class="hljs-string">"ccc"</span><br>  File "epdb1.py", line 5, in ? <br>    c = <span class="hljs-string">"ccc"</span><br>  File <span class="hljs-string">"/usr/lib64/python2.4/bdb.py"</span>, line <span class="hljs-number">48</span>, <span class="hljs-keyword">in</span> trace_dispatch <br>    <span class="hljs-keyword">return</span> self.dispatch_line(frame) <br>  File <span class="hljs-string">"/usr/lib64/python2.4/bdb.py"</span>, line <span class="hljs-number">67</span>, <span class="hljs-keyword">in</span> dispatch_line <br>    <span class="hljs-keyword">if</span> self.quitting: <span class="hljs-keyword">raise</span> BdbQuit <br> bdb.BdbQuit<br></code></pre></td></tr></table></figure><p><strong>打印变量的值：如果需要在调试过程中打印变量的值，可以直接使用 p 加上变量名，但是需要注意的是打印仅仅在当前的 statement 已经被执行了之后才能看到具体的值，否则会报 NameError: &lt; exceptions.NameError … …&gt; 错误。</strong></p><h3 id="（3）debug-过程中打印变量">（3）debug 过程中打印变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@rcc-pok-idg<span class="hljs-number">-2255</span> ~]<span class="hljs-comment">#  python epdb1.py </span><br> &gt; /root/epdb1.py(4)?() <br> -&gt; b = "bbb"<br> (Pdb) n <br> &gt; /root/epdb1.py(5)?() <br> -&gt; c = "ccc"<br> (Pdb) p b <br><span class="hljs-string">'bbb'</span><br> (Pdb) <br><span class="hljs-string">'bbb'</span><br> (Pdb) n <br> &gt; /root/epdb1.py(6)?() <br> -&gt; final = a + b + c <br> (Pdb) p c <br><span class="hljs-string">'ccc'</span><br> (Pdb) p final <br> *** NameError: &lt;exceptions.NameError instance at <span class="hljs-number">0x1551b710</span> &gt; <br> (Pdb) n <br> &gt; /root/epdb1.py(7)?() <br> -&gt; print final <br> (Pdb) p final <br><span class="hljs-string">'aaabbbccc'</span><br> (Pdb)<br></code></pre></td></tr></table></figure><p><strong>使用 c 可以停止当前的 debug 使程序继续执行。如果在下面的程序中继续有 set_statement() 的申明，则又会重新进入到 debug 的状态，读者可以在代码 print final 之前再加上 set_trace() 验证。</strong></p><h3 id="（4）停止-debug-继续执行程序">（4）停止 debug 继续执行程序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@rcc-pok-idg<span class="hljs-number">-2255</span> ~]<span class="hljs-comment">#  python epdb1.py </span><br> &gt; /root/epdb1.py(4)?() <br> -&gt; b = "bbb"<br> (Pdb) n <br> &gt; /root/epdb1.py(5)?() <br> -&gt; c = "ccc"<br> (Pdb) c <br> aaabbbccc<br></code></pre></td></tr></table></figure><p><strong>显示代码：在 debug 的时候不一定能记住当前的代码块，如要要查看具体的代码块，则可以通过使用 list 或者 l 命令显示。list 会用箭头 -&gt; 指向当前 debug 的语句。</strong></p><h3 id="（5）debug-过程中显示代码">（5）debug 过程中显示代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@rcc-pok-idg<span class="hljs-number">-2255</span> ~]<span class="hljs-comment">#  python epdb1.py </span><br> &gt; /root/epdb1.py(4)?() <br> -&gt; b = "bbb"<br> (Pdb) list <br>  <span class="hljs-number">1</span>     <span class="hljs-keyword">import</span> pdb <br>  <span class="hljs-number">2</span>     a = <span class="hljs-string">"aaa"</span><br>  <span class="hljs-number">3</span>     pdb.set_trace() <br>  4  -&gt; b = "bbb"<br>  <span class="hljs-number">5</span>     c = <span class="hljs-string">"ccc"</span><br>  <span class="hljs-number">6</span>     final = a + b + c <br>  <span class="hljs-number">7</span>     pdb.set_trace() <br>  <span class="hljs-number">8</span>     <span class="hljs-keyword">print</span> final <br> [EOF] <br> (Pdb) c <br> &gt; /root/epdb1.py(8)?() <br> -&gt; print final <br> (Pdb) list <br>  <span class="hljs-number">3</span>     pdb.set_trace() <br>  <span class="hljs-number">4</span>     b = <span class="hljs-string">"bbb"</span><br>  <span class="hljs-number">5</span>     c = <span class="hljs-string">"ccc"</span><br>  <span class="hljs-number">6</span>     final = a + b + c <br>  <span class="hljs-number">7</span>     pdb.set_trace() <br>  8  -&gt; print final <br> [EOF] <br> (Pdb)<br></code></pre></td></tr></table></figure><p><strong>在使用函数的情况下进行 debug</strong></p><h3 id="（6）使用函数的例子">（6）使用函数的例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pdb <br> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combine</span><span class="hljs-params">(s1,s2)</span>:</span>      <span class="hljs-comment"># define subroutine combine, which... </span><br>    s3 = s1 + s2 + s1    <span class="hljs-comment"># sandwiches s2 between copies of s1, ... </span><br>    s3 = <span class="hljs-string">'"'</span> + s3 +<span class="hljs-string">'"'</span>   <span class="hljs-comment"># encloses it in double quotes,... </span><br>    <span class="hljs-keyword">return</span> s3            <span class="hljs-comment"># and returns it. </span><br> a = <span class="hljs-string">"aaa"</span><br> pdb.set_trace() <br> b = <span class="hljs-string">"bbb"</span><br> c = <span class="hljs-string">"ccc"</span><br> final = combine(a,b) <br> <span class="hljs-keyword">print</span> final<br></code></pre></td></tr></table></figure><p><strong>如果直接使用 n 进行 debug 则到 final=combine(a,b) 这句的时候会将其当做普通的赋值语句处理，进入到 print final。如果想要对函数进行 debug 如何处理呢 ? 可以直接使用 s 进入函数块。函数里面的单步调试与上面的介绍类似。如果不想在函数里单步调试可以在断点处直接按 r 退出到调用的地方。</strong></p><h3 id="（8）对函数进行-debug">（8）对函数进行 debug</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@rcc-pok-idg<span class="hljs-number">-2255</span> ~]<span class="hljs-comment"># python epdb2.py </span><br> &gt; /root/epdb2.py(10)?() <br> -&gt; b = "bbb"<br> (Pdb) n <br> &gt; /root/epdb2.py(11)?() <br> -&gt; c = "ccc"<br> (Pdb) n <br> &gt; /root/epdb2.py(12)?() <br> -&gt; final = combine(a,b) <br> (Pdb) s <br> --Call-- <br> &gt; /root/epdb2.py(<span class="hljs-number">3</span>)combine() <br> -&gt; def combine(s1,s2):      # define subroutine combine, which... <br> (Pdb) n <br> &gt; /root/epdb2.py(<span class="hljs-number">4</span>)combine() <br> -&gt; s3 = s1 + s2 + s1    # sandwiches s2 between copies of s1, ... <br> (Pdb) list <br>  <span class="hljs-number">1</span>     <span class="hljs-keyword">import</span> pdb <br>  <span class="hljs-number">2</span> <br>  <span class="hljs-number">3</span>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combine</span><span class="hljs-params">(s1,s2)</span>:</span>      <span class="hljs-comment"># define subroutine combine, which... </span><br>  4  -&gt;     s3 = s1 + s2 + s1    # sandwiches s2 between copies of s1, ... <br>  <span class="hljs-number">5</span>         s3 = <span class="hljs-string">'"'</span> + s3 +<span class="hljs-string">'"'</span>   <span class="hljs-comment"># encloses it in double quotes,... </span><br>  <span class="hljs-number">6</span>         <span class="hljs-keyword">return</span> s3            <span class="hljs-comment"># and returns it. </span><br>  <span class="hljs-number">7</span> <br>  <span class="hljs-number">8</span>     a = <span class="hljs-string">"aaa"</span><br>  <span class="hljs-number">9</span>     pdb.set_trace() <br> <span class="hljs-number">10</span>     b = <span class="hljs-string">"bbb"</span><br> <span class="hljs-number">11</span>     c = <span class="hljs-string">"ccc"</span><br> (Pdb) n <br> &gt; /root/epdb2.py(<span class="hljs-number">5</span>)combine() <br> -&gt; s3 = '"' + s3 +'"'   # encloses it in double quotes,... <br> (Pdb) n <br> &gt; /root/epdb2.py(<span class="hljs-number">6</span>)combine() <br> -&gt; return s3            # and returns it. <br> (Pdb) n <br> --Return-- <br> &gt; /root/epdb2.py(6)combine()-&gt;'"aaabbbaaa"'<br> -&gt; return s3            # and returns it. <br> (Pdb) n <br> &gt; /root/epdb2.py(13)?() <br> -&gt; print final <br> (Pdb)<br></code></pre></td></tr></table></figure><p><strong>在调试的时候动态改变值 。在调试的时候可以动态改变变量的值，具体如下实例。需要注意的是下面有个错误，原因是 b 已经被赋值了，如果想重新改变 b 的赋值，则应该使用！ B。</strong></p><h3 id="（7）在调试的时候动态改变值">（7）在调试的时候动态改变值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">[root@rcc-pok-idg<span class="hljs-number">-2255</span> ~]<span class="hljs-comment"># python epdb2.py </span><br> &gt; /root/epdb2.py(10)?() <br> -&gt; b = "bbb"<br> (Pdb) var = <span class="hljs-string">"1234"</span><br> (Pdb) b = <span class="hljs-string">"avfe"</span><br> *** The specified object <span class="hljs-string">'= "avfe"'</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> a function <br> <span class="hljs-keyword">or</span> was <span class="hljs-keyword">not</span> found along sys.path. <br> (Pdb) !b=<span class="hljs-string">"afdfd"</span><br> (Pdb)<br></code></pre></td></tr></table></figure><h3 id="补充">补充</h3><ul><li><strong>在命令行中进入调试模式的方法：<code>python -m pdb demo.py</code></strong></li><li><strong>在调试模式中按一下<code>Enter</code>键表示执行一下上一条命令。</strong></li><li><strong>在ipython中使用PDB（体验更好）：<code>%run -d demo.py</code></strong></li></ul><p><a href="https://blog.csdn.net/yjk13703623757/article/details/79322172" target="_blank" rel="noopener">参考1</a></p><p><a href="https://www.jianshu.com/p/fb5f791fcb18" target="_blank" rel="noopener">参考2</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python内置小工具</title>
      <link href="/posts/ef11.html"/>
      <url>/posts/ef11.html</url>
      
        <content type="html"><![CDATA[<h5 id="image-20200420222035640"><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200420222035640.png" alt="image-20200420222035640"></h5><h1>一、1秒钟启动一个下载服务器</h1><p><strong>在实际工作中，时常会有这样的一个需求：将文件传给其他同事。将文件传给同事本身并不是一个很繁 琐的工作，现在的聊天工具一般都支持文件传输。但是，如果需要传送的文件较多，操作起来就会比较 麻烦。此外，如果文件在远程的服务器上，则需要先将远程服务器的文件下载到本地，然后再通过聊天 工具传给同事。再或者，你并不是特别清楚要传哪几个文件给同事，所以，你们需要进行交流，而交流 的时间成本是比较高的，会降低办事效率。</strong></p><p><strong>此时，如果你知道Python内置了一个下载服务器就能够显著提升效率了。例如，你的同事要让你传的文 件位于某一个目录下，那么，你可以进入这个目录，然后执行下面的命令启动一个下载服务器：</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">python -m SimpleHTTPServer<br></code></pre></td></tr></table></figure><p><strong>在Python 3中，由于对系统库进行了重新整理，因此，使用方式会有不同：</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">python -m http.server<br></code></pre></td></tr></table></figure><p><strong>执行上面的命令就会在当前目录下启动一个文件下载服务器，默认打开8000端口。完成以后，只需要将 IP和端口告诉同事，让同事自己去操作即可，非常方便高效。</strong></p><p><strong>使用浏览器访问Python启动的下载服务器，可以看到一个类似于FTP下载的界面，这个时候单击文件下 载即可。通过这种方式传输文件，可以降低大家的沟通成本，提高文件传输的效率。</strong></p><p><strong>上面使用的Python语句，从工作原理来说，仅仅是启动了一个Python内置的Web服务器。如果当前目 录下存在一个名为index.html的文件，则默认显示该文件的内容。如果当前目录下不存在这样一个文 件，则默认显示当前目录下的文件列表，也就是大家看到的下载服务器。</strong></p><h2 id="测试">测试</h2><p><strong>进入cmd进入一个目录输入<code>python -m http.server</code>即可</strong></p><p>![image-20200420172014212](G:\四期\python\python文档\21 python工作环境管理.assets\image-20200420172014212.png)</p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200420173052715.png" alt="image-20200420173052715"></p><h1>二、字符串转换为JSON</h1><p><strong>JSON是一种轻量级的数据交换格式，易于人类阅读和编写，同时也易于机器解析和生成。由于JSON的 诸多优点，已被广泛使用在各个系统中。JSON使用越广泛，需要将JSON字符串转换为JSON对象的需求 就越频繁。</strong></p><p><strong>例如，在工作过程中，我们的系统会调用底层服务的API。底层服务的API一般都是以JSON的格式返 回，为了便于问题追踪，我们会将API返回的JSON转换为字符串记录到日志文件中。当需要分析问题 时，就需要将日志文件中的JSON字符串拿出来进行分析。这个时候，需要将一个JSON字符串转换为 JSON对象，以提高日志的可读性。</strong></p><p><strong>这个需求十分常见，以至于使用搜索引擎搜索&quot;JSON&quot;，处于搜索结果的第一项便是“在线JSON格式化工 具”。除了打开浏览器，使用在线JSON格式化工具以外，我们也可以使用命令行终端的Python解释器来 解析JSON串，如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@oracle ~]# echo '&#123;"job": "developer", "name": "lmx", "sex": "male"&#125;' | python -m json.tool   <br>&#123;    <br>true"job": "developer",<br>    "name": "lmx",<br>    "sex": "male" <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用命令行解释器解析JSON串非常方便，而且，为了便于阅读，该工具还会自动将转换的结果进行对齐和格式化。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@oracle ~]# echo '&#123;"address": &#123;"province": "zhejiang", "city": "hangzhou"&#125;, "name": "lmx", "sex": "male"&#125;' | python -m json.tool <br>&#123;    <br>true"address": &#123;<br>    "city": "hangzhou",<br>    "province": "zhejiang"<br>    &#125;,<br>    "name": "lmx",<br>    "sex": "male"<br>&#125;<br></code></pre></td></tr></table></figure><h1>三、检查第三方库是否正确安装</h1><p><strong>安装完Python的第三方库以后，如何确认这个库已经正确安装了呢？答案很简单，只需要尝试进行 import导入即可。如果导入没有任何错误，则认为安装成功；如果导入失败，则认为安装失败。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# python <br>Python 2.7.5 (default, Oct 30 2018, 23:45:53) <br>[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linux2 <br>Type "help", "copyright", "credits" or "license" for more information. <br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;</span><br></code></pre></td></tr></table></figure><p><strong>验证Python的第三方库是否安装成功，本身也是一件很简单的事情，但是，如果我们使用脚本对大批量 的服务器进行自动部署，又应该如何验证第三方库安装成功了呢？肯定不能登录每一台服务器进行验 证。这个时候，我们可以使用Python解释器的-c参数快速地执行import语句，如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# python -c "import paramiko" <br>Traceback (most recent call last):  <br>File "&lt;string&gt;", line 1, in &lt;module&gt; <br>ImportError: No module named paramiko <br>[root@python ~]#<br></code></pre></td></tr></table></figure><h1>四、pip高级用法</h1><p><strong>为了便于用户安装和管理第三方库和软件，越来越多的编程语言拥有自己的包管理工具，如nodejs的 npm，ruby的gem。Python也不例外，现在Python生态主流的包管理工具是pip。</strong></p><h2 id="1、pip介绍">1、pip介绍</h2><p><strong>pip是一个用来安装和管理Python包的工具，是easy_install的替代品，如果读者使用的是Python 2.7.9+或Python 3.4+版本的Python，则已经内置了pip，无须安装直接使用即可。如果系统中没有安装 pip，也可以手动安装。</strong></p><h2 id="2、python3安装pip">2、python3安装pip</h2><h3 id="方法1：python3安装完成后默认已经带有pip3"><strong>方法1：python3安装完成后默认已经带有pip3</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python bin]# pip3 -V pip 19.2.3 from /usr/local/python38/lib/python3.8/site-packages/pip (python 3.8) <br>[root@python bin]# pwd <br>/usr/local/python38/bin <br>[root@python bin]#<br></code></pre></td></tr></table></figure><p><strong>你可以用以下命令,创建软链接</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s /usr/local/python38/bin/pip3 /usr/bin/pip<br></code></pre></td></tr></table></figure><h3 id="方法2：使用以下方法重新安装pip插件">方法2：使用以下方法重新安装pip插件</h3><h4 id="下载get-pip-py脚本">下载get-pip.py脚本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://bootstrap.pypa.io/3.2/get-pip.py<br></code></pre></td></tr></table></figure><h4 id="运行脚本">运行脚本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python3 get-pip.py<br></code></pre></td></tr></table></figure><h4 id="python3创建pip3索引">python3创建pip3索引</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s /usr/python3.6.1/bin/pip /usr/bin/pip3<br></code></pre></td></tr></table></figure><h4 id="测试是否安装成功">测试是否安装成功</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip3 install request<br></code></pre></td></tr></table></figure><p><strong>pip之所以能够成为流行的包管理工具，并不是因为它被Python官方作为默认的包管理器，而是因为 它自身的诸多优点。pip的优点有：</strong></p><ul><li><strong>pip提供了丰富的功能，其竞争对手easy_install则只支持安装，没有提供卸载和显示已安装列表的功 能；</strong></li><li><strong>pip能够很好地支持虚拟环境；</strong></li><li><strong>pip可以通过requirements.txt集中管理依赖；</strong></li><li><strong>pip能够处理二进制格式(.whl)；</strong></li><li><strong>pip是先下载后安装，如果安装失败，也会清理干净，不会留下一个中间状态。</strong></li></ul><p><strong><a href="http://xn--pypi-z94fx2cpii0ty2bsy4aoqgoxuqkav67c75bq19aje7az32h.python.org" target="_blank" rel="noopener">如果用户没有将软件打包上传到pypi.python.org</a>，则无法使用pip进行安装。对于这种情况，Python生 态也有标准的做法，例如，我们尝试从源码安装paramiko。需要注意的是，我们也可以通过pip安装 paramiko的，这里只是为了演示Python生态中源码安装：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://github.com/paramiko/paramiko.git   </span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> paramiko   </span><br><span class="hljs-meta">$</span><span class="bash"> python setup.py install</span><br></code></pre></td></tr></table></figure><h2 id="3、给pip3重命名">3、给pip3重命名</h2><h4 id="切换至家目录，通过-bashrc添加别名"><strong>切换至家目录，通过.bashrc添加别名</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python bin]# cd ~ <br>[root@python ~]# vim .bashrc alias pip=pip3 <br>[root@python ~]# source .bashrc <br>[root@python ~]# pip -V <br>pip 19.2.3 from /usr/local/python38/lib/python3.8/site-packages/pip (python 3.8)<br></code></pre></td></tr></table></figure><h2 id="4、pip3常用命令">4、pip3常用命令</h2><table><thead><tr><th>子命令</th><th>解释说明</th></tr></thead><tbody><tr><td>install</td><td>安装软件包</td></tr><tr><td>download</td><td>下载软件包</td></tr><tr><td>uninstall</td><td>卸载安装包</td></tr><tr><td>freeze</td><td>按照requirements格式输出安装包，可以到其他服务器上执行pip install -r requirements.txt直接安装软件</td></tr><tr><td>list</td><td>列出当前系统中的安装包</td></tr><tr><td>show</td><td>查看安装包的信息，包括版本、依赖、许可证、作者、主页等信息</td></tr><tr><td>check</td><td>检查安装包依赖是否完整</td></tr><tr><td>search</td><td>查找安装包</td></tr><tr><td>wheel</td><td>打包软件到wheel格式</td></tr><tr><td>hash</td><td>计算安装包的hash值</td></tr><tr><td>completion</td><td>生成命令补全配置</td></tr><tr><td>help</td><td>获取pip和子命令的帮助信息</td></tr></tbody></table><h2 id="5、加速pip安装的技巧（linux）">5、加速pip安装的技巧（linux）</h2><p><strong>如果大家使用Python的时间比较长的话，会发现Python安装的一个问题，即pypi.python.org不是特别 稳定，有时候会很慢，甚至处于完全不可用的状态。这个问题有什么好办法可以解决呢？根据笔者的经 验，至少有两种不同的方法。</strong></p><h3 id="（1）使用豆瓣或阿里云的源加速软件安装">（1）使用豆瓣或阿里云的源加速软件安装</h3><p><strong>访问pypi.python.org不稳定的主要原因是因为网络不稳定，如果我们从网络稳定的服务器下载安装 包，问题就迎刃而解了。我们国内目前有多个pypi镜像，推荐使用豆瓣的镜像源或阿里的镜像源。如果 要使用第三方的源，只需要在安装时，通过pip命令的-i选项指定镜像源即可。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install -i https://pypi.douban.com/simple/ flask<br></code></pre></td></tr></table></figure><p><strong>每次都要指定镜像源的地址比较麻烦，我们也可以修改pip的配置文件，将镜像源写入配置文件中。对 于Linux系统来说，需要创建～/.pip/pip.conf文件，然后在文件中保存如下内容：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# mkdir .pip <br>[root@python ~]# cd .pip <br>[root@python .pip]# touch pip.conf <br>[root@python .pip]# vim pip.conf <br>[global]   <br>index-url = https://pypi.douban.com/simple/ <br>[root@python .pip]#<br></code></pre></td></tr></table></figure><h3 id="（2）将软件下载到本地部署">（2）将软件下载到本地部署</h3><p><strong>如果需要对大批量的服务器安装软件包，并且安装包比较多或者比较大，则可以考虑将软件包下载到本 地，然后从本地安装。这对于使用脚本部署大量的服务器非常有用，此外，对于服务器无法连接外网的 情况，也可以使用这种方法。如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 下载到本地   </span><br>pip install --download='pwd' -r requirements.txt  <br> <br><span class="hljs-meta">#</span><span class="bash"> 本地安装   </span><br>pip install --no-index -f file://'pwd'  -r requirements.txt<br></code></pre></td></tr></table></figure><p><strong>使用这种方式，只需要下载一次，就可以多处安装，不用担心网络不稳定的问题。并且，pip能够自动 处理软件依赖问题。例如，我们通过这种方式下载Flask到当前目录下，则Flask的依赖click、 itsdangerous、Jinja2、MarkupSafe和Werkzeug也会被下载到本地，如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install --download='pwd' flask  <br> <br><span class="hljs-meta">$</span><span class="bash"> ls   </span><br>click-6.7-py2.py3-none-any.whl   itsdangerous-0.24.tar.gz   <br>MarkupSafe-0.23.tar.gz  Flask-0.12-py2.py3-none-any.whl   <br>Jinja2-2.9.5-py2.py3-none-any.whl  Werkzeug-0.11.15-py2.py3-none-any.whl<br></code></pre></td></tr></table></figure><h2 id="6、在windows环境下修改pip镜像源的方法-以python3-5为例">6、在windows环境下修改pip镜像源的方法(以python3.5为例)</h2><h4 id="1-在windows文件管理器中-输入-APPDATA">(1):在windows文件管理器中,输入 <strong>%APPDATA%``</strong></h4><h4 id="2-会定位到一个新的目录下，在该目录下新建pip文件夹，然后到pip文件夹里面去新建个pip-ini文件">(2):会定位到一个新的目录下，在该目录下新建pip文件夹，然后到pip文件夹里面去新建个pip.ini文件</h4><h4 id="3-在新建的pip-ini文件中输入以下内容，搞定文件路径：“C-Users-Administrator-AppData-Roaming-pip-pip-ini”">(3):在新建的pip.ini文件中输入以下内容，搞定文件路径：“C:\Users\Administrator\AppData\Roaming\pip\pip.ini”</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-keyword">global</span>]<br>timeout = <span class="hljs-number">6000</span><br>index-url = http://pypi.douban.com/simple<br>trusted-host = pypi.douban.com<br></code></pre></td></tr></table></figure><h5 id="设置完成测试：">设置完成测试：</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200420163029245.png" alt="image-20200420163029245"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyenv的安装和简单使用</title>
      <link href="/posts/16bd.html"/>
      <url>/posts/16bd.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200420222035640.png" alt="image-20200420222035640"></p><h1><strong>Python工作环境管理</strong></h1><p><strong>Python 2和Python 3之间存在着较大的差异，并且，由于各种原因导致了Python 2和Python 3的长期 共存。在实际工作过程中，我们可能会同时用到Python 2和Python 3，因此，需要经常在Python 2和 Python 3之间进行来回切换。此外，如果你是喜欢尝鲜的人，那么，你很有可能在Python新版本出来 的时候立即下载Python的版本，试验Python的特性。</strong></p><p><strong>在Python世界里，除了需要对Python的版本进行管理以外，还需要对不同的软件包进行管理。大部分 情况下，对于开源的库我们使用版本即可。但是，有时候可能需要对相同的Python版本，在不同的 项目中使用不同版本的软件包。</strong></p><p><strong>在这一节里，我们将介绍两个工具，即pyenv和virtualenv。前者用于管理不同的Python版本，后者用 于管理不同的工作环境。有了这两个工具，Python相关的版本问题将不再是问题。</strong></p><h2 id="1、问题情景">1、问题情景:</h2><ol><li><strong>Python解释器版本混乱, 2和3差别巨大, 而且细分版本也不尽相同, 难以选择和管理.</strong></li><li><strong>不同Linux发行版自带Python不同, 如ubuntu16自带2.7和3.5版本, 其中系统许多组件依赖于自带解释器, 一旦删除或者更改都可能会造成系统出问题.</strong></li><li><strong>不同的Python解释器软件包管理也是问题, 如pip和ipython等必备包组件, 而且在项目开发中如何保证不同的包环境互不干扰也是一个问题.</strong></li></ol><p><strong>那么有没有一个终极的解决办法能在管理不同解释器版本的同时控制不同的包环境呢? 有的, 就是pyenv.</strong></p><h2 id="2、使用pyenv管理不同的Python版本">2、使用pyenv管理不同的Python版本**</h2><p><strong>安装不同的Python版本并不是一件容易的事情，在不同的Python版本之间来回切换更加困难，而且， 多版本并存非常容易互相干扰。因此，我们需要一个名为pyenv的工具。pyenv是一个Python版本管理 工具，它能够进行全局的Python版本切换，也可以为单个项目提供对应的Python版本。使用pyenv以 后，可以在服务器上安装多个不同的Python版本，也可以安装不同的Python实现。不同Python版本之 间的切换也非常简单。接下来我们就一起看一下pyenv的安装和使用。</strong></p><h2 id="3、pyenv是什么-能干什么">3、pyenv是什么? 能干什么?</h2><blockquote><p><strong>pyenv是一个forked自ruby社区的简单、低调、遵循UNIX哲学的Python环境管理工具, 它可以轻松切换全局解释器版本, 同时结合vitualenv插件可以方便的管理对应的包源.</strong></p></blockquote><p><strong>我们知道, 在terminal中输入一个命令比如‘ls’时, shell会从当前环境的PATH中的各个目录里看是不是有ls这个可执行文件, 如果找到就执行, 否则就会报‘command no found’ 的错误, 同理, 只要控制PATH变量就能够做到python版本的切换, pyenv通过在PATH头部插入shims路径来实现对python版本的控制.</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200420220830037.png" alt="image-20200420220830037"></p><h4 id="pyenv和流行的pipenv、virtualenv的关系"><strong>pyenv和流行的pipenv、virtualenv的关系</strong></h4><p><strong>pipenv是requests 作者 Kenneth Reitz大神写的一个python虚拟环境管理工具, 结合了pip和virtualenv的功能, 侧重点还是在包环境管理上, 使用思路是先创建一个指定python版本的环境, 然后在此环境上安装相应的包, 好评不错, 看到很多大牛都在推荐.</strong></p><p><strong>virtualenv是一个比较传统成熟的虚拟环境管理工具了, 用的人也比较多, 思路也是创建虚拟环境, 然后安装相应的包, 要进入环境就source一下activate脚本激活一下, 尽管成熟, 但是我个人不太喜欢用, 在部署项目的时候老是容易出现一些环境问题.</strong></p><p><strong>pyenv相对来说知名度就差很多了, 不过也很稳定, 这三个环境管理工具我都用过, 我个人更喜欢pyenv, 理由如下:</strong></p><ul><li><strong>相对于其他两个工具, pyenv更侧重在python 解释器版本管理上, 比包管理更大一个层级, 使用pyenv我可以方便的下载指定版本的python解释器, pypy, anaconda等, 可以随时自由的在shell环境中本地、全局切换python解释器</strong></li><li><strong>开发的时候不需要限定某个版本的虚拟环境, 只需要在部署的时候用pyenv指定某个版本就好了</strong></li><li><strong>pyenv切换解释器版本的时候, pip和ipython以及对应的包环境都是一起切换的, 所以如果你要同时运行ipython2.x和ipython3.x多个解释器验证一些代码时就很方便</strong></li><li><strong>pyenv也可以创建好指定的虚拟环境, 但不需要指定具体目录, 自由度更高, 使用也简单</strong></li></ul><h2 id="4、简单使用">4、简单使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看当前版本</span><br>pyenv version<br><br><span class="hljs-meta">#</span><span class="bash"> 查看所有版本</span><br>pyenv versions<br><br><span class="hljs-meta">#</span><span class="bash"> 查看所有可安装的版本</span><br>pyenv install --list<br><br><span class="hljs-meta">#</span><span class="bash"> 安装指定版本</span><br>pyenv install 3.6.5<br><span class="hljs-meta">#</span><span class="bash"> 安装新版本后<span class="hljs-built_in">rehash</span>一下</span><br>pyenv rehash<br><br><span class="hljs-meta">#</span><span class="bash"> 删除指定版本</span><br>pyenv uninstall 3.5.2<br><br><span class="hljs-meta">#</span><span class="bash"> 指定全局版本</span><br>pyenv global 3.6.5<br><br><span class="hljs-meta">#</span><span class="bash"> 指定多个全局版本, 3版本优先</span><br>pyenv global 3.6.5 2.7.14<br><br><span class="hljs-meta">#</span><span class="bash"> 实际上当你切换版本后, 相应的pip和包仓库都是会自动切换过去的</span><br></code></pre></td></tr></table></figure><h1>一、pyenv安装</h1><h2 id="linux环境"><strong>linux环境</strong></h2><table><thead><tr><th><strong>版本</strong></th><th><strong>主机</strong></th><th><strong>环境</strong></th></tr></thead><tbody><tr><td><strong>centos7.6</strong></td><td><strong>192.168.1.80</strong></td><td><strong>python3</strong></td></tr></tbody></table><h2 id="1、安装git"><strong>1、安装git</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# yum install git<br></code></pre></td></tr></table></figure><h2 id="2、开启终端"><strong>2、开启终端</strong></h2><p><strong>本文使用 bash</strong></p><h2 id="3、安装-pyenv"><strong>3、安装 pyenv</strong></h2><p>*<strong>说明：本文的所有安装都严格遵守官方文档，与官方文档完全保持一致。*</strong></p><p><strong>git 地址：<a href="https://github.com/pyenv/pyenv" target="_blank" rel="noopener">https://github.com/pyenv/pyenv</a></strong></p><p><strong>在你的终端中执行如下命令，安全无毒，请放心食用：</strong></p><p><strong>首先把项目克隆下来，放在家目录下的隐藏文件夹中：.pyenv</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/pyenv/pyenv.git ~/.pyenv<br></code></pre></td></tr></table></figure><p><strong>然后配置环境变量</strong></p><h5 id="如果你使用-bash，就依次执行如下命令："><strong>如果你使用 bash，就依次执行如下命令：</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo 'export PYENV_ROOT="$HOME/.pyenv"' &gt;&gt; ~/.bashrc<br>echo 'export PATH="$PYENV_ROOT/bin:$PATH"' &gt;&gt; ~/.bashrc<br>echo -e 'if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\n eval "$(pyenv init -)"\nfi' &gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure><h5 id="如果你使用-zsh，就依次执行如下命令："><strong>如果你使用 zsh，就依次执行如下命令：</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo 'export PYENV_ROOT="$HOME/.pyenv"' &gt;&gt; ~/.zshrc<br>echo 'export PATH="$PYENV_ROOT/bin:$PATH"' &gt;&gt; ~/.zshrc<br>echo -e 'if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\n eval "$(pyenv init -)"\nfi' &gt;&gt; ~/.zshrc<br></code></pre></td></tr></table></figure><p><strong>echo 命令的含义是：将引号中内容写入某文件中</strong><br><strong>请注意，以上的三条 echo 命令的最后一条长长的命令，请你保证它引号中的内容处于 ~/.bashrc 或者 ~/.zshrc 的最底部。</strong><br><strong>因为在 pyenv 初始化期间会操作 path 环境变量，导致不可预测的行为。</strong><br><strong>查看文件的底部内容，可以使用 tail 命令，用法：tail ~/.bashrc 或者 tail ~/.zshrc，编辑文件可以使用 vim 或者 vscode</strong></p><p><strong>最后，在使用 pyenv 之前，重新初始化 shell 环境，执行如下命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">exec $SHELL<br></code></pre></td></tr></table></figure><p><strong>不执行该命令也是完全可以的，你可以关闭当前的终端窗口，重新启动一个就可以了。</strong></p><p><strong>此时，你已经完成了 pyenv 的安装了，你使用可以它的全部命令了，但是我建议你先别急着用，一口气装完 pyenv 的一个插件，那就是 pyenv-virtualenv</strong></p><h2 id="4、安装-pyenv-virtualenv">4、安装 pyenv-virtualenv</h2><p>**virtualenv本身是一个独立的项目，用以隔离不同项目的工作环境。例如，用户lmx希望在项目A中使用 Flask 0.8这个版本，与此同时，又想在项目B中使用Flask 0.9这个版本。如果我们全局安装Flask，必然 无法满足用户的需求。这个时候，我们就可以使用virtualenv。 **</p><p><strong>读者需要注意pyenv和virtualenv的区别。pyenv用以管理不同的Python版本，例如，你的系统工作时 使用Python 2.7.13，学习时使用Python 3.6.0。virtualenv用以隔离项目的工作环境，例如，项目A和 项目B都是使用Python 2.7.13，但是，项目A需要使用Flask 0.8版本，项目B需要使用Flask 0.9版本。我 们只要组合pyenv和virtualenv这两个工具，就能够构造Python和第三方库的任意版本组合，拥有很好 的灵活性，也避免了项目之间的相互干扰。</strong></p><p><strong>virtualenv本身是一个独立的工具，用户可以不使用pyenv而单独使用virtualenv。但是，如果你使用了 pyenv，就需要安装pyenv-virtualenv插件，而不是通过virtualenv软件使用virtualenv的功能。</strong></p><p><strong>git 地址：<a href="https://github.com/pyenv/pyenv-virtualenv" target="_blank" rel="noopener">https://github.com/pyenv/pyenv-virtualenv</a></strong></p><h4 id="1-把插件克隆在刚才已经安装完毕的-pyenv-的-plugins-文件夹中"><strong>(1) 把插件克隆在刚才已经安装完毕的 pyenv 的 plugins 文件夹中</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv<br></code></pre></td></tr></table></figure><h4 id="2-然后配置环境变量">(2) 然后配置环境变量</h4><h5 id="如果你使用-bash，就执行如下命令：">如果你使用 bash，就执行如下命令：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo 'eval "$(pyenv virtualenv-init -)"' &gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure><h5 id="如果你使用-zsh，就执行如下命令：">如果你使用 zsh，就执行如下命令：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo 'eval "$(pyenv virtualenv-init -)"' &gt;&gt; ~/.zshrc<br></code></pre></td></tr></table></figure><h4 id="3-最后，在使用-pyenv-之前，重新初始化-shell-环境，执行如下命令"><strong>(3) 最后，在使用 pyenv 之前，重新初始化 shell 环境，执行如下命令</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">exec $SHELL<br></code></pre></td></tr></table></figure><p><strong>不执行该命令也是完全可以的，你可以关闭当前的终端窗口，重新启动一个就可以了。</strong></p><p><strong>至此，pyenv就安装完成了，我们可以通过下面的命令验证pyenv是否正确安装并获取pyenv的帮助信息：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# pyenv --help<br>Usage: pyenv &lt;command&gt; [&lt;args&gt;]<br><br>Some useful pyenv commands are:<br>   commands    List all available pyenv commands<br>   exec        Run an executable with the selected Python version<br>   global      Set or show the global Python version(s)<br>   help        Display help for a command<br>   hooks       List hook scripts for a given pyenv command<br>   init        Configure the shell environment for pyenv<br>   install     Install a Python version using python-build<br>   local       Set or show the local application-specific Python version(s)<br>   prefix      Display prefix for a Python version<br>   rehash      Rehash pyenv shims (run this after installing executables)<br>   root        Display the root directory where versions and shims are kept<br>   shell       Set or show the shell-specific Python version<br>   shims       List existing pyenv shims<br>   uninstall   Uninstall a specific Python version<br>   version     Show the current Python version(s) and its origin<br>   --version   Display the version of pyenv<br>   version-file   Detect the file that sets the current pyenv version<br>   version-name   Show the current Python version<br>   version-origin   Explain how the current Python version is set<br>   versions    List all Python versions available to pyenv<br>   whence      List all Python versions that contain the given executable<br>   which       Display the full path to an executable<br><br>See `pyenv help &lt;command&gt;' for information on a specific command.<br>For full documentation, see: https://github.com/pyenv/pyenv#readme<br></code></pre></td></tr></table></figure><h1>二、使用 pyenv</h1><p>*<strong>此处仅仅展示 pyenv 和 virtualenv 的日常用法*</strong></p><h2 id="1、检查安装是否正确">1、检查安装是否正确</h2><h5 id="检查-pyenv-的版本"><strong>检查 pyenv 的版本</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# pyenv version<br>(set by /root/.pyenv/version)<br></code></pre></td></tr></table></figure><h5 id="查看-pyenv-已经托管了哪些-python-版本"><strong>查看 pyenv 已经托管了哪些 python 版本</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]#pyenv versions<br>* system (set by /root/.pyenv/version)<br></code></pre></td></tr></table></figure><p><strong>如果你看到了正常的版本信息，就说明可以了，如果看到了类似于 command not found 之类的，就说明安装失败了。</strong></p><p><strong>我们通过pyenv的install命令，可以查看pyenv当前支持哪些Python版本，如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# pyenv install --list <br>Available versions:<br>2.1.3<br>……省略部分信息<br>3.8.0<br>3.8-dev<br>3.8.1<br>3.9-dev<br>……省略部分信息<br>anaconda3-2018.12<br>anaconda3-2019.03<br>anaconda3-2019.07<br>anaconda3-2019.10<br>……省略部分信息<br>[root@python ~]#<br></code></pre></td></tr></table></figure><h2 id="2、pyenv切换python版本">2、pyenv切换python版本</h2><p>**由于pyenv可以安装的Python版本列表非常长，所以，这里进行了省略。读者可以在自己电脑上安装 pyenv，然后执行pyenv install --list命令进行查看。可以看到，pyenv不但可以安装不同的Python版 本，而且还可以安装不同的Python实现，也可以安装版本的Python用以学习。 **</p><p><strong>查看当前系统中包含的Python版本：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# pyenv versions <br>* system (set by /root/.pyenv/version)<br></code></pre></td></tr></table></figure><h5 id="使用pyenv安装不同的Python版本：">使用pyenv安装不同的Python版本：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]#pyenv install -v 3.8.1  <br>[root@python ~]#pyenv install -v 2.7.13<br></code></pre></td></tr></table></figure><h5 id="再次查看当前系统中包含的Python版本">再次查看当前系统中包含的Python版本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# pyenv versions<br>* system (set by /root/.pyenv/version)<br>  2.7.13<br>  3.8.1<br></code></pre></td></tr></table></figure><h3 id="切换版本">切换版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">切换前为3.8.1</span><br>[root@python ~]# python<br>Python 3.8.1 (default, Apr 20 2020, 15:00:10) <br>[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux<br>Type "help", "copyright", "credits" or "license" for more information.<br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt; <span class="hljs-built_in">exit</span>()</span><br><br><span class="hljs-meta">#</span><span class="bash">切换为2.7.13</span><br>[root@python ~]# pyenv  global 2.7.13 <br>[root@python ~]# python<br>Python 2.7.13 (default, Apr 20 2020, 15:04:15) <br>[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux2<br>Type "help", "copyright", "credits" or "license" for more information.<br></code></pre></td></tr></table></figure><p><strong>使用pyenv以后，可以快速切换Python的版本。切换Python版本以后，与版本相关的依赖也会一起切 换。因此，我们不用担心不同的版本在系统中是否会相互干扰。例如，切换Python版本以后，相应的 pip也会跟着切换，所以不用担心自己使用的pip版本和Python版本不匹配的问题，如下所示：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# pyenv  global 3.8.1<br>[root@python ~]# pip --version<br>pip 19.2.3 from /root/.pyenv/versions/3.8.1/lib/python3.8/site-packages/pip (python 3.8)<br></code></pre></td></tr></table></figure><h5 id="如果想要删除Python版本，使用uninstall命令即可。如下所示：">如果想要删除Python版本，使用uninstall命令即可。如下所示：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# pyenv uninstall 2.7.10<br></code></pre></td></tr></table></figure><h1>三、pyenv-virtualenv的使用</h1><p><strong>有了pyenv-virtualenv以后，我们可以为同一个Python解释器，创建多个不同的工作环境。例如，我们 新建两个工作环境：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# pyenv virtualenv 3.8.1 first_project <br>[root@python ~]# pyenv virtualenv 3.8.1 second_projec<br></code></pre></td></tr></table></figure><h5 id="可以使用virtualenvs子命令查看工作环境"><strong>可以使用virtualenvs子命令查看工作环境</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# pyenv virtualenvs<br>  3.8.1/envs/first_project (created from /root/.pyenv/versions/3.8.1)<br>  3.8.1/envs/second_projec (created from /root/.pyenv/versions/3.8.1)<br>  first_project (created from /root/.pyenv/versions/3.8.1)<br>  second_projec (created from /root/.pyenv/versions/3.8.1)<br></code></pre></td></tr></table></figure><p><strong>创建完工作环境以后，可以通过activate和deactivate子命令进入或退出一个工作环境。进入工作环境 以后，左边的提示符会显示你当前所在的工作环境，以免因为环境太多导致操作错误。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">(first_project) [root@python ~]# pip install flask==1.1.1 <br>Looking in indexes: https://pypi.doubanio.com/simple<br>Collecting flask==1.1.1<br>  Downloading https://pypi.doubanio.com/packages/9b/93/628509b8d5dc749656a9641f4caf13540e2cdec85276964ff8f43bbb1d3b/Flask-1.1.1-py2.py3-none-any.whl (94kB)<br>     |███▌                            | 10kB 28.0MB/s eta 0:00:<br>     |███████                         | 20kB 1.8MB/s eta 0:00:0<br>     |██████████▍                     | 30kB 2.7MB/s eta 0:00:0<br>     |█████████████▉                  | 40kB 1.8MB/s eta 0:00:0<br>     |█████████████████▍              | 51kB 1.3MB/s eta 0:00:0<br>     |████████████████████▉           | 61kB 1.5MB/s eta 0:00:0<br>     |████████████████████████▎       | 71kB 1.4MB/s eta 0:00:0<br>     |███████████████████████████▊    | 81kB 1.3MB/s eta 0:00:0<br>     |███████████████████████████████▏| 92kB 1.4MB/s eta 0:00:0<br>     |████████████████████████████████| 102kB 1.6MB/s <br>Collecting itsdangerous&gt;=0.24 (from flask==1.1.1)<br>(first_project) [root@python ~]# pyenv deactivate<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#退出first_project环境</span></span><br>[root@python ~]#<br></code></pre></td></tr></table></figure><h2 id="接下来，我们看一下在不同的工作环境安装不同的Flask版本">接下来，我们看一下在不同的工作环境安装不同的Flask版本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# pyenv activate first_project <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#切换工作环境</span></span><br>(first_project) [root@python ~]# pip install flask==1.1.1 <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#安装1.1.1的flask</span></span><br>(first_project) [root@python ~]# pyenv deactivate <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#退出目前工作环境</span></span><br>[root@python ~]#<br><br>[root@python ~]# pyenv activate second_projec<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#切换工作环境</span></span><br>(second_project) [root@python ~]# pip install flask==0.10.1<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#安装0.10.1的flask</span></span><br>(second_project) [root@python ~]# pyenv deactivate <br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#退出目前工作环境</span></span><br>[root@python ~]#<br></code></pre></td></tr></table></figure><h5 id="查看一下两个工作环境源目录">查看一下两个工作环境源目录</h5><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200420160542051.png" alt="image-20200420160542051" style="zoom:100%;"><h2 id="如果想要删除虚拟环境，则使用：">如果想要删除虚拟环境，则使用：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(first_project) [root@python ~]# pyenv virtualenv-delete first_project<br></code></pre></td></tr></table></figure><p><strong>使用pyenv和python-virtualenv插件，我们就能够自由地在不同的版本之间进行切换，相比管理Python 版本，不但节省了时间，也避免了工作过程中的相互干扰。</strong></p><h1>三、更新 pyenv</h1><p><strong>由于我们是 git 克隆的，所以更新非常简单</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~/.pyenv` 或者 `cd $(pyenv root)`<br> `git pull<br></code></pre></td></tr></table></figure><h1>四、卸载 pyenv</h1><p><strong>由于 pyenv 把一切都放在 ~/.pyenv 下了，所以卸载很方便，两个步骤就行了</strong></p><p><strong>首先你需要删除环境变量</strong></p><p><strong>然后你需要执行：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf ~/.pyenv` 或者 `rm -rf $(pyenv root)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3+Django3开发简单的人员管理系统</title>
      <link href="/posts/68e5.html"/>
      <url>/posts/68e5.html</url>
      
        <content type="html"><![CDATA[<h1>1、使用PyCharm创建Django项目</h1><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200416214513169.png" alt="image-20200416214513169"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418122913463.png" alt="image-20200418122913463"></p><p><strong>记得安装mysqlclient</strong></p><h2 id="1-数据库配置">(1)数据库配置</h2><p><strong>我们在项目的 <a href="http://settings.py" target="_blank" rel="noopener">settings.py</a> 文件中找到 DATABASES 配置项，将其信息修改为：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">DATABASES = &#123;<br>    <span class="hljs-string">'default'</span>: &#123;<br>        <span class="hljs-string">'ENGINE'</span>: <span class="hljs-string">'django.db.backends.mysql'</span>,  <span class="hljs-comment"># 或者使用 mysql.connector.django</span><br>        <span class="hljs-string">'NAME'</span>: <span class="hljs-string">'userinfo'</span>,<br>        <span class="hljs-string">'USER'</span>: <span class="hljs-string">'root'</span>,<br>        <span class="hljs-string">'PASSWORD'</span>: <span class="hljs-string">'123456'</span>,<br>        <span class="hljs-string">'HOST'</span>: <span class="hljs-string">'localhost'</span>,<br>        <span class="hljs-string">'PORT'</span>: <span class="hljs-string">'3306'</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200415143234067.png" alt="image-20200415143234067"></p><p><strong>这里添加了中文注释，所以你需要在 HelloWorld/settings.py 文件头部添加 # -*- coding: UTF-8 -*-。</strong></p><p><strong>上面包含数据库名称和用户的信息，它们与 MySQL 中对应数据库和用户的设置相同。Django 根据这一设置，与 MySQL 中相应的数据库和用户连接起来。</strong></p><h2 id="2-更改语言、时区-和-所有主机都可访问">(2)更改语言、时区 和 所有主机都可访问</h2><p><strong>我们在项目的 <a href="http://settings.py" target="_blank" rel="noopener">settings.py</a> 文件中找到<code>ALLOWED_HOSTS</code>、<code>LANGUAGE_CODE</code>和<code>TIME_ZONE</code>配置项，将其信息修改为：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">ALLOWED_HOSTS = [<span class="hljs-string">'*'</span>]<br><br><span class="hljs-comment"># LANGUAGE_CODE = 'en-us'</span><br>LANGUAGE_CODE = <span class="hljs-string">'zh-Hans'</span><br><br><span class="hljs-comment"># TIME_ZONE = 'UTC'</span><br>TIME_ZONE = <span class="hljs-string">'Asia/Shanghai'</span><br></code></pre></td></tr></table></figure><h2 id="3-修改-TestModel-models-py-文件：">(3)修改 TestModel/models.py 文件：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-comment"># Create your models here</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span><span class="hljs-params">(models.Model)</span>:</span><br>    GENDER_CHOICES = (<br>        (<span class="hljs-string">'男'</span>,<span class="hljs-string">'男'</span>), (<span class="hljs-string">'女'</span>,<span class="hljs-string">'女'</span>),<br>    )<br>    name = models.CharField(max_length=<span class="hljs-number">20</span>, verbose_name=<span class="hljs-string">'姓名'</span>, unique=<span class="hljs-literal">True</span>)<br>    birthday = models.DateTimeField(max_length=<span class="hljs-number">10</span>,verbose_name=<span class="hljs-string">'生日'</span>, null=<span class="hljs-literal">True</span>,blank=<span class="hljs-literal">True</span>)<br>    gender = models.CharField(max_length=<span class="hljs-number">30</span>, choices=GENDER_CHOICES, verbose_name=<span class="hljs-string">'性别'</span>)<br>    account = models.IntegerField(default=<span class="hljs-number">0</span>,verbose_name=<span class="hljs-string">'工号'</span>)<br>    age = models.IntegerField(default=<span class="hljs-number">18</span>, verbose_name=<span class="hljs-string">'年龄'</span>)<br></code></pre></td></tr></table></figure><p><strong>以上的类名代表了数据库表名，且继承了<code>models.Model</code>，类里面的字段代表数据表中的字段(name)，数据类型则由CharField（相当于<code>varchar</code>）、<code>DateField</code>（相当于<code>datetime</code>）， max_length 参数限定长度。</strong></p><h2 id="4-创建数据库">(4)创建数据库</h2><p><strong>记得在数据库创建<code>UserInfo数据库</code></strong></p><h3 id="1-可在cmd命令行中创建数据库">&lt;1&gt;可在cmd命令行中创建数据库</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">G:\四期\<span class="hljs-title">python</span>\<span class="hljs-title">UserSystem</span>&gt;<span class="hljs-title">mysql</span> -<span class="hljs-title">uroot</span> -<span class="hljs-title">p</span> </span><br><span class="hljs-function">#登陆数据库</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">mysql</span>&gt; <span class="hljs-title">CREATE</span> <span class="hljs-title">DATABASE</span> <span class="hljs-title">xgp</span> <span class="hljs-title">DEFAULT</span> <span class="hljs-title">CHARACTER</span> <span class="hljs-title">SET</span> <span class="hljs-title">utf8</span> <span class="hljs-title">COLLATE</span> <span class="hljs-title">utf8_general_ci</span>;</span><br><span class="hljs-function">#创建<span class="hljs-title">utf8</span>的数据库</span><br></code></pre></td></tr></table></figure><h3 id="2-mysql管理器中创建数据库">&lt;2&gt;mysql管理器中创建数据库</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418190908470.png" alt="image-20200418190908470"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418191031146.png" alt="image-20200418191031146"></p><h2 id="5-创建表结构">(5)创建表结构</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">$ python manage.py migrate   <span class="hljs-comment"># 创建表结构</span><br>//失败了可用python manage.py migrate UserInfo<br>//失败了可用python3 manage.py migrate UserInfo<br><br>$ python manage.py makemigrations UserInfo  <span class="hljs-comment"># 让 Django 知道我们在我们的模型有一些变更</span><br>$ python manage.py migrate UserInfo   <span class="hljs-comment"># 创建表结构</span><br></code></pre></td></tr></table></figure><h3 id="数据库生成以下表：">数据库生成以下表：</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418202004594.png" alt="image-20200418202004594"></p><h2 id="6-访问一下">(6)<a href="http://127.0.0.1:8000/" target="_blank" rel="noopener">访问一下</a></h2><p><em><strong>记得启动项目</strong></em></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418130806806.png" alt="image-20200418130806806"></p><h1>2、Django Admin 管理工具</h1><p><strong>Django 提供了基于 web 的管理工具。</strong></p><p><strong>Django 自动管理工具是 django.contrib 的一部分。你可以在项目的 <a href="http://settings.py" target="_blank" rel="noopener">settings.py</a> 中的 INSTALLED_APPS 看到它：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/HelloWorld/HelloWorld/settings.py 文件代码：</span><br>INSTALLED_APPS = [<br>    <span class="hljs-string">'django.contrib.admin'</span>,<br>    <span class="hljs-string">'django.contrib.auth'</span>,<br>    <span class="hljs-string">'django.contrib.contenttypes'</span>,<br>    <span class="hljs-string">'django.contrib.sessions'</span>,<br>    <span class="hljs-string">'django.contrib.messages'</span>,<br>    <span class="hljs-string">'django.contrib.staticfiles'</span>,<br>    <span class="hljs-string">'UserInfo.apps.UserinfoConfig'</span>,<br>]<br></code></pre></td></tr></table></figure><p><strong>django.contrib是一套庞大的功能集，它是Django基本代码的组成部分。</strong></p><h2 id="（1）激活管理工具">（1）激活管理工具</h2><p><strong>通常我们在生成项目时会在 <a href="http://urls.py" target="_blank" rel="noopener">urls.py</a> 中自动设置好，我们只需去掉注释即可。</strong></p><p><strong>配置项如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/HelloWorld/HelloWorld/urls.py 文件代码：</span><br><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><br>urlpatterns = [<br>    path(<span class="hljs-string">'admin/'</span>, admin.site.urls),<br>]<br></code></pre></td></tr></table></figure><p><strong>当这一切都配置好后，Django 管理工具就可以运行了。</strong></p><h2 id="（2）使用管理工具">（2）使用管理工具</h2><p><strong>启动开发服务器，然后在浏览器中访问 <a href="http://127.0.0.1:8000/admin/%EF%BC%8C%E5%BE%97%E5%88%B0%E5%A6%82%E4%B8%8B%E7%95%8C%E9%9D%A2%EF%BC%9A" target="_blank" rel="noopener">http://127.0.0.1:8000/admin/，得到如下界面：</a></strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417154111687.png" alt="image-20200417154111687"></p><h4 id="因为我现在是新建了个项目所以需要创建表结构：">因为我现在是新建了个项目所以需要创建表结构：</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmd">$ python manage.py migrate UserInfo   # 创建表结构，指定数据库<br>//失败了可用python3 manage.py migrate<br><br>$ python manage.py makemigrations UserInfo  # 让 Django 知道我们在我们的模型有一些变更<br>$ python manage.py migrate UserInfo   # 创建表结构<br></code></pre></td></tr></table></figure><h4 id="你可以通过命令-python-manage-py-createsuperuser-来创建超级用户，如下所示：">你可以通过命令 <strong>python <a href="http://manage.py" target="_blank" rel="noopener">manage.py</a> createsuperuser</strong> 来创建超级用户，如下所示：</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># python manage.py createsuperuser<br>Username (leave blank to use 'root'): admin<br>Email address: admin@runoob.com<br><span class="hljs-function">Password:</span><br><span class="hljs-function"><span class="hljs-title">Password</span> (<span class="hljs-title">again</span>):</span><br><span class="hljs-function"><span class="hljs-title">Superuser</span> <span class="hljs-title">created</span> <span class="hljs-title">successfully</span>.</span><br></code></pre></td></tr></table></figure><h4 id="之后输入用户名密码登录，界面如下：">之后输入用户名密码登录，界面如下：</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417155335794.png" alt="image-20200417155335794"></p><h2 id="（3）为了让-admin-界面管理某个数据模型，我们需要先注册该数据模型到-admin。">（3）为了让 admin 界面管理某个数据模型，我们需要先注册该数据模型到 admin。</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> . models <span class="hljs-keyword">import</span> User<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HostAdmin</span><span class="hljs-params">(admin.ModelAdmin)</span>:</span><br>    list_display = [<br>        <span class="hljs-string">'name'</span>, <span class="hljs-string">'birthday'</span>, <span class="hljs-string">'gender'</span>, <span class="hljs-string">'account'</span>, <span class="hljs-string">'age'</span>,<br>    ]<br>    search_fields = (<span class="hljs-string">'name'</span>,)<br>admin.site.register(User,HostAdmin)<br>admin.AdminSite.site_header = <span class="hljs-string">'运维系统管理后台'</span><br>admin.AdminSite.site_title = <span class="hljs-string">'运维系统'</span><br></code></pre></td></tr></table></figure><h3 id="浏览器访问一下"><a href="http://127.0.0.1:8000/admin/" target="_blank" rel="noopener">浏览器访问一下</a></h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418135819778.png" alt="image-20200418135819778"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418135851821.png" alt="image-20200418135851821"></p><h3 id="设置两个员工信息并查看一下">设置两个员工信息并查看一下</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418201709272.png" alt="image-20200418201709272"></p><h3 id="userinfo数据库的userinfo-user表会保存员工信息：">userinfo数据库的userinfo_user表会保存员工信息：</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418201903611.png" alt="image-20200418201903611"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyCharm实现（Django的模型、表单、管理工具、引入静态文件）</title>
      <link href="/posts/1b1f.html"/>
      <url>/posts/1b1f.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">镜像列表<br>http://mirrors.aliyun.com/pypi/simple/ //阿里<br>https://pypi.tuna.tsinghua.edu.cn/simple/ //清华<br>http://pypi.douban.com/ //豆瓣<br>http://pypi.hustunique.com/ //华中理工大学<br>http://pypi.sdutlinux.org/ //山东理工大学<br>http://pypi.mirrors.ustc.edu.cn/ //中国科学技术大学<br></code></pre></td></tr></table></figure><h1>一、Django 模型（PyCharm实现）</h1><p><strong>Django 对各种数据库提供了很好的支持，包括：PostgreSQL、MySQL、SQLite、Oracle。</strong></p><p><strong>Django 为这些数据库提供了统一的调用API。 我们可以根据自己业务需求选择不同的数据库。</strong></p><p><strong>MySQL 是 Web 应用中最常用的数据库。本章节我们将以 Mysql 作为实例进行介绍。你可以通过本站的<a href="https://www.runoob.com/django/mysql/mysql-tutorial.html" target="_blank" rel="noopener"> MySQL 教程</a> 了解更多Mysql的基础知识。</strong></p><p><strong>如果你没安装 mysql 驱动，可以执行以下命令安装：</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">sudo pip install mysqlclient  #较慢<br>pip install -i https://pypi.douban.com/simple/  mysqlclient  #较快<br></code></pre></td></tr></table></figure><h2 id="1、PyCharm创建Django">1、PyCharm创建Django</h2><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200416214513169.png" alt="image-20200416214513169"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200416214638731.png" alt="image-20200416214638731"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200416214650636.png" alt="image-20200416214650636"></p><h2 id="2、数据库配置">2、数据库配置</h2><p><strong>我们在项目的 <a href="http://settings.py" target="_blank" rel="noopener">settings.py</a> 文件中找到 DATABASES 配置项，将其信息修改为：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">DATABASES = &#123;<br>    <span class="hljs-string">'default'</span>: &#123;<br>        <span class="hljs-string">'ENGINE'</span>: <span class="hljs-string">'django.db.backends.mysql'</span>,  <span class="hljs-comment"># 或者使用 mysql.connector.django</span><br>        <span class="hljs-string">'NAME'</span>: <span class="hljs-string">'test'</span>,<br>        <span class="hljs-string">'USER'</span>: <span class="hljs-string">'root'</span>,<br>        <span class="hljs-string">'PASSWORD'</span>: <span class="hljs-string">'123456'</span>,<br>        <span class="hljs-string">'HOST'</span>:<span class="hljs-string">'localhost'</span>,<br>        <span class="hljs-string">'PORT'</span>:<span class="hljs-string">'3306'</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200415143234067.png" alt="image-20200415143234067"></p><p><strong>这里添加了中文注释，所以你需要在 HelloWorld/settings.py 文件头部添加 # -*- coding: UTF-8 -*-。</strong></p><p><strong>上面包含数据库名称和用户的信息，它们与 MySQL 中对应数据库和用户的设置相同。Django 根据这一设置，与 MySQL 中相应的数据库和用户连接起来。</strong></p><h2 id="3、定义模型">3、定义模型</h2><h3 id="创建-APP">创建 APP</h3><p><strong>Django规定，如果要使用模型，必须要创建一个app。我们使用以下命令创建一个 TestModel 的 app:</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">django-admin startapp TestModel<br></code></pre></td></tr></table></figure><p><strong>目录结构如下：</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmd">HelloWorld<br>|-- TestModel<br>|   |-- __init__.py<br>|   |-- admin.py<br>|   |-- models.py<br>|   |-- tests.py<br>|   `-- views.py<br></code></pre></td></tr></table></figure><p><strong>我们修改 TestModel/models.py 文件，代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># models.py</span><br><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span><span class="hljs-params">(models.Model)</span>:</span><br>    name = models.CharField(max_length=<span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><p><strong>以上的类名代表了数据库表名，且继承了<code>models.Model</code>，类里面的字段代表数据表中的字段(name)，数据类型则由CharField（相当于<code>varchar</code>）、<code>DateField</code>（相当于<code>datetime</code>）， max_length 参数限定长度。</strong></p><p><strong>接下来在settings.py中找到INSTALLED_APPS这一项，如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">INSTALLED_APPS = (<br>    <span class="hljs-string">'django.contrib.admin'</span>,<br>    <span class="hljs-string">'django.contrib.auth'</span>,<br>    <span class="hljs-string">'django.contrib.contenttypes'</span>,<br>    <span class="hljs-string">'django.contrib.sessions'</span>,<br>    <span class="hljs-string">'django.contrib.messages'</span>,<br>    <span class="hljs-string">'django.contrib.staticfiles'</span>,<br>    <span class="hljs-string">'TestModel'</span>,               <span class="hljs-comment"># 添加此项</span><br>)<br></code></pre></td></tr></table></figure><p><strong>在命令行中运行：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">$ python manage.py migrate   <span class="hljs-comment"># 创建表结构</span><br>//失败了可用python3 manage.py migrate<br><br>$ python manage.py makemigrations TestModel  <span class="hljs-comment"># 让 Django 知道我们在我们的模型有一些变更</span><br>$ python manage.py migrate TestModel   <span class="hljs-comment"># 创建表结构</span><br></code></pre></td></tr></table></figure><p><strong>看到几行 “Creating table…” 的字样，你的数据表就创建好了。</strong></p><h4 id="创建好了之后可在Navicat-for-MySQL查看到："><strong>创建好了之后可在Navicat for MySQL查看到：</strong></h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200416220944048.png" alt="image-20200416220944048"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Creating tables ...<br>……<br>Creating table TestModel_test  <span class="hljs-comment">#我们自定义的表</span><br>……<br></code></pre></td></tr></table></figure><p><strong>表名组成结构为：应用名_类名（如：TestModel_test）。</strong></p><p><strong>注意：尽管我们没有在models给表设置主键，但是Django会自动添加一个id作为主键。</strong></p><h2 id="4、数据库操作">4、数据库操作</h2><p><strong>接下来我们在 HelloWorld 目录中添加 <a href="http://testdb.py" target="_blank" rel="noopener">testdb.py</a> 文件（下面介绍），并修改 <a href="http://urls.py" target="_blank" rel="noopener">urls.py</a>：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> testdb<br><br>urlpatterns = [<br>    path(<span class="hljs-string">'admin/'</span>, admin.site.urls),<br>    path(<span class="hljs-string">'testdb/'</span>, testdb.testdb),<br>]<br></code></pre></td></tr></table></figure><h3 id="添加数据">添加数据</h3><p><strong>添加数据需要先创建对象，然后再执行 save 函数，相当于SQL中的INSERT：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#HelloWorld/HelloWorld/testdb.py文件代码</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br> <br><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br> <br><span class="hljs-keyword">from</span> TestModel.models <span class="hljs-keyword">import</span> Test<br> <br><span class="hljs-comment"># 数据库操作</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">testdb</span><span class="hljs-params">(request)</span>:</span><br>    test1 = Test(name=<span class="hljs-string">'runoob'</span>)<br>    test1.save()<br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">"&lt;p&gt;数据添加成功！&lt;/p&gt;"</span>)<br></code></pre></td></tr></table></figure><p><strong>访问 <a href="http://127.0.0.1:8000/testdb" target="_blank" rel="noopener">http://127.0.0.1:8000/testdb</a> 就可以看到数据添加成功的提示。</strong></p><h5 id="输出结果如下："><strong>输出结果如下：</strong></h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200416220758839.png" alt="image-20200416220758839"></p><h5 id="数据库可看到：">数据库可看到：</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200416221340509.png" alt="image-20200416221340509"></p><p><em><strong>当浏览器每刷新一下，数据库里的信息就会增加一条。</strong></em></p><h1>二、重新创建一个Django</h1><p><em><strong>要提前把数据库里创建的表删除</strong></em></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417105056336.png" alt="image-20200417105056336"></p><h5 id="创建好之后运行一下这个项目">创建好之后运行一下这个项目</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417102532689.png" alt="image-20200417102532689"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417102604557.png" alt="image-20200417102604557"></p><h5 id="会自动跳到浏览器">会自动跳到浏览器</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417102612522.png" alt="image-20200417102612522"></p><h2 id="1、如果你是按上面继续做的，需要以下步骤：">1、如果你是按上面继续做的，需要以下步骤：</h2><p><em><strong>（还原为，原始状态）</strong></em></p><ul><li><strong>删除test的表文件</strong></li><li><strong>删除之前创建的XGPtest/XGPtest/testdb.py文件</strong></li><li><strong>XGPtest/TestModel/models.py文件内容删除</strong></li><li><strong>注释XGPtest/XGPtest/urls.py中关于testdb的内容</strong></li><li><strong>然后重新启动</strong></li></ul><p><strong>浏览器访问http://127.0.0.1:8000/会和之前的界面一样，有个小火箭！</strong></p><ul><li><strong>删除XGPtest/TestModel/migrations/0001_initial.py文件</strong></li></ul><h2 id="2、重新生成表单">2、重新生成表单</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmd">$ python manage.py migrate   # 创建表结构<br>//失败了可用python3 manage.py migrate<br><br>$ python manage.py makemigrations TestModel  # 让 Django 知道我们在我们的模型有一些变更<br>$ python manage.py migrate TestModel   # 创建表结构<br></code></pre></td></tr></table></figure><h2 id="3、models-py文件添加类型">3、models.py文件添加类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#XGPtest/TestModel/models.py</span><br><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span><span class="hljs-params">(models.Model)</span>:</span><br>    name = models.CharField(max_length=<span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><p><em><strong>创建完成之后，数据库中就生成testmodel_test表</strong></em></p><h2 id="4、XGPtest-XGPtest-urls-py中关于testdb的内容，解除注释">4、XGPtest/XGPtest/urls.py中关于testdb的内容，解除注释</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> testdb<br><br>urlpatterns = [<br>    path(<span class="hljs-string">'admin/'</span>, admin.site.urls),<br>    path(<span class="hljs-string">'testdb/'</span>, testdb.testdb),<br>]<br></code></pre></td></tr></table></figure><h2 id="3、创建XGPtest-XGPtest-testdb-py测试文件">3、创建XGPtest/XGPtest/testdb.py测试文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><br><span class="hljs-keyword">from</span> TestModel.models <span class="hljs-keyword">import</span> Test<br><br><br><span class="hljs-comment"># 数据库操作</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">testdb</span><span class="hljs-params">(request)</span>:</span><br>    test1 = Test(name=<span class="hljs-string">'runoob'</span>)<br>    test1.save()<br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">"&lt;p&gt;数据添加成功！&lt;/p&gt;"</span>)<br></code></pre></td></tr></table></figure><h2 id="4、获取数据">4、获取数据</h2><p><strong>首先多访问几次http://127.0.0.1:8000/testdb生成数据</strong></p><p><strong>数据库更改一下其中内容（随意编写）</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417130401673.png" alt="image-20200417130401673"></p><h4 id="Django提供了多种方式来获取数据库的内容，如下代码所示："><strong>Django提供了多种方式来获取数据库的内容，如下代码所示：</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#XGPtest/XGPtest/testdb.py#XGPtest/XGPtest/testdb.py 文件尾部添加</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getdb</span><span class="hljs-params">(request)</span>:</span><br>    <span class="hljs-comment"># 初始化</span><br>    response = <span class="hljs-string">""</span><br>    response1 = <span class="hljs-string">""</span><br><br>    <span class="hljs-comment"># 通过objects这个模型管理器的all()获得所有数据行，相当于SQL中的SELECT * FROM</span><br>    list = Test.objects.all()<br><br>    <span class="hljs-comment"># filter相当于SQL中的WHERE，可设置条件过滤结果</span><br>    response2 = Test.objects.filter(id=<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># 获取单个对象</span><br>    response3 = Test.objects.get(id=<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># 限制返回的数据 相当于 SQL 中的 OFFSET 0 LIMIT 2;</span><br>    <span class="hljs-comment"># Test.objects.order_by('name')[0:2]</span><br><br>    <span class="hljs-comment"># 数据排序</span><br>    Test.objects.order_by(<span class="hljs-string">"id"</span>)<br><br>    <span class="hljs-comment"># 上面的方法可以连锁使用</span><br>    Test.objects.filter(name=<span class="hljs-string">"runoob"</span>).order_by(<span class="hljs-string">"id"</span>)<br><br>    <span class="hljs-comment"># 输出所有数据</span><br>    <span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> list:<br>        response1 += var.name + <span class="hljs-string">" "</span><br>    response = response1<br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">"&lt;p&gt;"</span> + response + <span class="hljs-string">"&lt;/p&gt;"</span>)<br></code></pre></td></tr></table></figure><h4 id="XGPtest-XGPtest-urls-py文件添加"><strong>XGPtest/XGPtest/urls.py文件添加</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> testdb<br><br>urlpatterns = [<br>    path(<span class="hljs-string">'admin/'</span>, admin.site.urls),<br>    path(<span class="hljs-string">'testdb/'</span>, testdb.testdb),<br>    path(<span class="hljs-string">'gitdb/'</span>, testdb.gitdb),         <span class="hljs-comment">#添加</span><br>]<br></code></pre></td></tr></table></figure><h5 id="浏览器访问https-www-runoob-com-django-django-model-html">浏览器访问https://www.runoob.com/django/django-model.html</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417131131585.png" alt="image-20200417131131585"></p><h2 id="5、更新数据">5、更新数据</h2><h4 id="修改数据可以使用-save-或-update"><strong>修改数据可以使用 save() 或 update():</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#XGPtest/XGPtest/testdb.py#XGPtest/XGPtest/testdb.py 文件尾部添加</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modify</span><span class="hljs-params">(request)</span>:</span><br>    <span class="hljs-comment"># 修改其中一个id=1的name字段，再save，相当于SQL中的UPDATE</span><br>    test1 = Test.objects.get(id=<span class="hljs-number">1</span>)<br>    test1.name = <span class="hljs-string">'Google'</span><br>    test1.save()<br>    <br>    <span class="hljs-comment"># 另外一种方式</span><br>    <span class="hljs-comment">#Test.objects.filter(id=1).update(name='Google')</span><br>    <br>    <span class="hljs-comment"># 修改所有的列</span><br>    <span class="hljs-comment"># Test.objects.all().update(name='Google')</span><br>    <br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">"&lt;p&gt;修改成功&lt;/p&gt;"</span>)<br></code></pre></td></tr></table></figure><h4 id="XGPtest-XGPtest-urls-py文件添加-2"><strong>XGPtest/XGPtest/urls.py文件添加</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> testdb<br><br>urlpatterns = [<br>    path(<span class="hljs-string">'admin/'</span>, admin.site.urls),<br>    path(<span class="hljs-string">'testdb/'</span>, testdb.testdb),<br>    path(<span class="hljs-string">'gitdb/'</span>, testdb.gitdb),         <span class="hljs-comment">#添加</span><br>    path(<span class="hljs-string">'modify/'</span>, testdb.modify), <br>]<br></code></pre></td></tr></table></figure><h5 id="浏览器访问http-127-0-0-1-8000-modify">浏览器访问http://127.0.0.1:8000/modify/</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417131456890.png" alt="image-20200417131456890"></p><h4 id="查看test数据库testmodel-test表">查看test数据库testmodel_test表</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417131732385.png" alt="image-20200417131732385"></p><h2 id="6、删除数据">6、删除数据</h2><h4 id="删除数据库中的对象只需调用该对象的delete-方法即可："><strong>删除数据库中的对象只需调用该对象的delete()方法即可：</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#XGPtest/XGPtest/testdb.py#XGPtest/XGPtest/testdb.py 文件尾部添加</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">del</span><span class="hljs-params">(request)</span>:</span><br>    <span class="hljs-comment"># 删除id=1的数据</span><br>    test1 = Test.objects.get(id=<span class="hljs-number">1</span>)<br>    test1.delete()<br>    <br>    <span class="hljs-comment"># 另外一种方式</span><br>    <span class="hljs-comment"># Test.objects.filter(id=1).delete()</span><br>    <br>    <span class="hljs-comment"># 删除所有数据</span><br>    <span class="hljs-comment"># Test.objects.all().delete()</span><br>    <br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">"&lt;p&gt;删除成功&lt;/p&gt;"</span>)<br></code></pre></td></tr></table></figure><h4 id="XGPtest-XGPtest-urls-py文件添加-3"><strong>XGPtest/XGPtest/urls.py文件添加</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> testdb<br><br>urlpatterns = [<br>    path(<span class="hljs-string">'admin/'</span>, admin.site.urls),<br>    path(<span class="hljs-string">'testdb/'</span>, testdb.testdb),<br>    path(<span class="hljs-string">'gitdb/'</span>, testdb.gitdb),         <span class="hljs-comment">#添加</span><br>    path(<span class="hljs-string">'modify/'</span>, testdb.modify), <br>    path(<span class="hljs-string">'del/'</span>, testdb.<span class="hljs-keyword">del</span>),<br>]<br></code></pre></td></tr></table></figure><h5 id="浏览器访问http-127-0-0-1-8000-del">浏览器访问http://127.0.0.1:8000/del</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417132243092.png" alt="image-20200417132243092"></p><h4 id="数据库查看第一个数据是否删除">数据库查看第一个数据是否删除</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417132551220.png" alt="image-20200417132551220"></p><h1>三、Django 表单</h1><p><strong>HTML表单是网站交互性的经典方式。 本章将介绍如何用Django对用户提交的表单数据进行处理。</strong></p><h2 id="1、HTTP-请求"><strong>1、HTTP 请求</strong></h2><p><strong>HTTP协议以&quot;请求－回复&quot;的方式工作。客户发送请求时，可以在请求中附加数据。服务器通过解析请求，就可以获得客户传来的数据，并根据URL来提供特定的服务。</strong></p><h2 id="2、GET-方法"><strong>2、GET 方法</strong></h2><p><strong>我们在之前的项目中创建一个 <a href="http://search.py" target="_blank" rel="noopener">search.py</a> 文件，用于接收用户的请求：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/HelloWorld/HelloWorld/search.py 文件代码：</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><br><br><span class="hljs-comment"># 表单</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search_form</span><span class="hljs-params">(request)</span>:</span><br>    <span class="hljs-keyword">return</span> render(request,<span class="hljs-string">'search_form.html'</span>,&#123;&#125;)<br><br><br><span class="hljs-comment"># 接收请求数据</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span><span class="hljs-params">(request)</span>:</span><br>    request.encoding = <span class="hljs-string">'utf-8'</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">'q'</span> <span class="hljs-keyword">in</span> request.GET <span class="hljs-keyword">and</span> request.GET[<span class="hljs-string">'q'</span>]:<br>        message = <span class="hljs-string">'你搜索的内容为: '</span> + request.GET[<span class="hljs-string">'q'</span>]<br>    <span class="hljs-keyword">else</span>:<br>        message = <span class="hljs-string">'你提交了空表单'</span><br>    <span class="hljs-keyword">return</span> HttpResponse(message)<br></code></pre></td></tr></table></figure><h4 id="在模板目录-templates-中添加-search-form-html-表单：">在模板目录 templates 中添加 search_form.html 表单：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/HelloWorld/templates/search_form.html 文件代码：</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">"utf-8"</span>&gt;<br>    &lt;title&gt;xgp666&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;form action=<span class="hljs-string">"/search"</span> method=<span class="hljs-string">"get"</span>&gt;<br>    &lt;input type=<span class="hljs-string">"text"</span> name=<span class="hljs-string">"q"</span>&gt;<br>    &lt;input type=<span class="hljs-string">"submit"</span> value=<span class="hljs-string">"搜索"</span>&gt;<br>    &lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><em><strong>可在浏览器打开是一个搜索框</strong></em></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417152534782.png" alt="image-20200417152534782"></p><h4 id="urls-py-规则修改为如下形式："><a href="http://urls.py" target="_blank" rel="noopener">urls.py</a> 规则修改为如下形式：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/HelloWorld/HelloWorld/urls.py 文件代码：</span><br><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> testdb<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> search<br><br>urlpatterns = [<br>    path(<span class="hljs-string">'admin/'</span>, admin.site.urls),<br>    path(<span class="hljs-string">'testdb/'</span>, testdb.testdb),<br>    path(<span class="hljs-string">'gitdb/'</span>, testdb.getdb),<br>    path(<span class="hljs-string">'modify/'</span>, testdb.modify),<br>    path(<span class="hljs-string">'del/'</span>, testdb.dl),<br>    path(<span class="hljs-string">'search/'</span>, search.search),<br>    path(<span class="hljs-string">'search-from/'</span>, search.search_form),<br>]<br></code></pre></td></tr></table></figure><h4 id="访问地址-http-127-0-0-1-8000-search-form-并搜索，结果如下所示">访问地址 <a href="http://127.0.0.1:8000/search-form" target="_blank" rel="noopener">http://127.0.0.1:8000/search-form</a> 并搜索，结果如下所示:</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417151517338.png" alt="image-20200417151517338"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417151524789.png" alt="image-20200417151524789"></p><h3 id="分析一下">分析一下</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417152614087.png" alt="image-20200417152614087"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417152643385.png" alt="image-20200417152643385"></p><h2 id="3、POST-方法">3、POST 方法</h2><p><strong>上面我们使用了GET方法。视图显示和请求处理分成两个函数处理。</strong></p><p><strong>提交数据时更常用POST方法。我们下面使用该方法，并用一个URL和处理函数，同时显示视图和处理请求。</strong></p><h4 id="我们在-templates-创建-post-html："><strong>我们在 templates 创建 post.html：</strong></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html">#/HelloWorld/templates/post.html 文件代码：<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>xgp666<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/search-post/"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span><br>        &#123;% csrf_token %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"q"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Submit"</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; rlt &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>在模板的末尾，我们增加一个 rlt 记号，为表格处理结果预留位置。</strong></p><p><strong>表格后面还有一个{% csrf_token %}的标签。csrf 全称是 Cross Site Request Forgery。这是Django提供的防止伪装提交请求的功能。POST 方法提交的表格，必须有此标签。</strong></p><h4 id="在HelloWorld目录下新建-search2-py-文件并使用-search-post-函数来处理-POST-请求："><strong>在HelloWorld目录下新建 <a href="http://search2.py" target="_blank" rel="noopener">search2.py</a> 文件并使用 search_post 函数来处理 POST 请求：</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/HelloWorld/HelloWorld/search2.py 文件代码：</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br> <br><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><span class="hljs-keyword">from</span> django.views.decorators <span class="hljs-keyword">import</span> csrf<br> <br><span class="hljs-comment"># 接收POST请求数据</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search_post</span><span class="hljs-params">(request)</span>:</span><br>    ctx =&#123;&#125;<br>    <span class="hljs-keyword">if</span> request.POST:<br>        ctx[<span class="hljs-string">'rlt'</span>] = request.POST[<span class="hljs-string">'q'</span>]<br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">"post.html"</span>, ctx)<br></code></pre></td></tr></table></figure><h4 id="urls-py-规则修改为如下形式：-2"><a href="http://urls.py" target="_blank" rel="noopener">urls.py</a> 规则修改为如下形式：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/HelloWorld/HelloWorld/urls.py 文件代码：</span><br><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> testdb<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> search<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> search2<br><br>urlpatterns = [<br>    path(<span class="hljs-string">'admin/'</span>, admin.site.urls),<br>    path(<span class="hljs-string">'testdb/'</span>, testdb.testdb),<br>    path(<span class="hljs-string">'gitdb/'</span>, testdb.getdb),<br>    path(<span class="hljs-string">'modify/'</span>, testdb.modify),<br>    path(<span class="hljs-string">'del/'</span>, testdb.dl),<br>    path(<span class="hljs-string">'search/'</span>, search.search),<br>    path(<span class="hljs-string">'search-from/'</span>, search.search_form),<br>    path(<span class="hljs-string">'search-post/'</span>, search2.search_post),<br>]<br></code></pre></td></tr></table></figure><h4 id="访问-http-127-0-0-1-8000-search-post-显示结果如下：">访问 <a href="http://127.0.0.1:8000/search-post" target="_blank" rel="noopener">http://127.0.0.1:8000/search-post</a> 显示结果如下：</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417152446910.png" alt="image-20200417152446910"></p><h2 id="3、Request-对象"><strong>3、Request 对象</strong></h2><h4 id="每个-view-函数的第一个参数是一个-HttpRequest-对象，就像下面这个-hello-函数"><strong>每个 view 函数的第一个参数是一个 HttpRequest 对象，就像下面这个 hello() 函数:</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span><span class="hljs-params">(request)</span>:</span><br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">"Hello world"</span>)<br></code></pre></td></tr></table></figure><h4 id="HttpRequest对象包含当前请求URL的一些信息："><strong>HttpRequest对象包含当前请求URL的一些信息：</strong></h4><table><thead><tr><th><strong>属性</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>path</strong></td><td><strong>请求页面的全路径,不包括域名—例如, “/hello/”。</strong></td></tr><tr><td><strong>method</strong></td><td><strong>请求中使用的HTTP方法的字符串表示。全大写表示。例如:if request.method == ‘GET’:   do_something() elif request.method == ‘POST’:   do_something_else()</strong></td></tr><tr><td><strong>GET</strong></td><td><strong>包含所有HTTP GET参数的类字典对象。参见QueryDict 文档。</strong></td></tr><tr><td><strong>POST</strong></td><td><strong>包含所有HTTP POST参数的类字典对象。参见QueryDict 文档。服务器收到空的POST请求的情况也是有可能发生的。也就是说，表单form通过HTTP POST方法提交请求，但是表单中可以没有数据。因此，不能使用语句if request.POST来判断是否使用HTTP POST方法；应该使用if request.method == “POST” (参见本表的method属性)。注意: POST不包括file-upload信息。参见FILES属性。</strong></td></tr><tr><td><strong>REQUEST</strong></td><td><strong>为了方便，该属性是POST和GET属性的集合体，但是有特殊性，先查找POST属性，然后再查找GET属性。借鉴PHP’s $_REQUEST。例如，如果GET = {“name”: “john”} 和POST = {“age”: ‘34’},则 REQUEST[“name”] 的值是&quot;john&quot;, REQUEST[“age”]的值是&quot;34&quot;.强烈建议使用GET and POST,因为这两个属性更加显式化，写出的代码也更易理解。</strong></td></tr><tr><td><strong>COOKIES</strong></td><td><strong>包含所有cookies的标准Python字典对象。Keys和values都是字符串。</strong></td></tr><tr><td><strong>FILES</strong></td><td><strong>包含所有上传文件的类字典对象。FILES中的每个Key都是<input type="file" name>标签中name属性的值. FILES中的每个value 同时也是一个标准Python字典对象，包含下面三个Keys:filename: 上传文件名,用Python字符串表示content-type: 上传文件的Content typecontent: 上传文件的原始内容注意：只有在请求方法是POST，并且请求页面中<form>有enctype=&quot;multipart/form-data&quot;属性时FILES才拥有数据。否则，FILES 是一个空字典。</form></strong></td></tr><tr><td><strong>META</strong></td><td><strong>包含所有可用HTTP头部信息的字典。 例如:CONTENT_LENGTHCONTENT_TYPEQUERY_STRING: 未解析的原始查询字符串REMOTE_ADDR: 客户端IP地址REMOTE_HOST: 客户端主机名SERVER_NAME: 服务器主机名SERVER_PORT: 服务器端口META 中这些头加上前缀 HTTP_ 为 Key, 冒号(:)后面的为 Value， 例如:HTTP_ACCEPT_ENCODINGHTTP_ACCEPT_LANGUAGEHTTP_HOST: 客户发送的HTTP主机头信息HTTP_REFERER: referring页HTTP_USER_AGENT: 客户端的user-agent字符串HTTP_X_BENDER: X-Bender头信息</strong></td></tr><tr><td><strong>user</strong></td><td><strong>是一个django.contrib.auth.models.User 对象，代表当前登录的用户。如果访问用户当前没有登录，user将被初始化为django.contrib.auth.models.AnonymousUser的实例。你可以通过user的is_authenticated()方法来辨别用户是否登录：<code>if request.user.is_authenticated():    # Do something for logged-in users. else:    # Do something for anonymous users.</code>只有激活Django中的AuthenticationMiddleware时该属性才可用</strong></td></tr><tr><td><strong>session</strong></td><td><strong>唯一可读写的属性，代表当前会话的字典对象。只有激活Django中的session支持时该属性才可用。</strong></td></tr><tr><td><strong>raw_post_data</strong></td><td><strong>原始HTTP POST数据，未解析过。 高级处理时会有用处。</strong></td></tr></tbody></table><h4 id="Request对象也有一些有用的方法："><strong>Request对象也有一些有用的方法：</strong></h4><table><thead><tr><th style="text-align:left"><strong>方法</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>getitem(key)</strong></td><td style="text-align:left"><strong>返回GET/POST的键值,先取POST,后取GET。如果键不存在抛出 KeyError。 这是我们可以使用字典语法访问HttpRequest对象。 例如,request[“foo”]等同于先request.POST[“foo”] 然后 request.GET[“foo”]的操作。</strong></td></tr><tr><td style="text-align:left"><strong>has_key()</strong></td><td style="text-align:left"><strong>检查request.GET or request.POST中是否包含参数指定的Key。</strong></td></tr><tr><td style="text-align:left"><strong>get_full_path()</strong></td><td style="text-align:left"><strong>返回包含查询字符串的请求路径。例如， &quot;/music/bands/the_beatles/?print=true&quot;</strong></td></tr><tr><td style="text-align:left"><strong>is_secure()</strong></td><td style="text-align:left"><strong>如果请求是安全的，返回True，就是说，发出的是HTTPS请求。</strong></td></tr></tbody></table><h2 id="4、QueryDict对象"><strong>4、QueryDict对象</strong></h2><p><strong>在HttpRequest对象中, GET和POST属性是django.http.QueryDict类的实例。</strong></p><p><strong>QueryDict类似字典的自定义类，用来处理单键对应多值的情况。</strong></p><h4 id="QueryDict实现所有标准的词典方法。还包括一些特有的方法："><strong>QueryDict实现所有标准的词典方法。还包括一些特有的方法：</strong></h4><table><thead><tr><th style="text-align:left"><strong>方法</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>getitem</strong></td><td style="text-align:left"><strong>和标准字典的处理有一点不同，就是，如果Key对应多个Value，getitem()返回最后一个value。</strong></td></tr><tr><td style="text-align:left"><strong>setitem</strong></td><td style="text-align:left"><strong>设置参数指定key的value列表(一个Python list)。注意：它只能在一个mutable QueryDict 对象上被调用(就是通过copy()产生的一个QueryDict对象的拷贝).</strong></td></tr><tr><td style="text-align:left"><strong>get()</strong></td><td style="text-align:left"><strong>如果key对应多个value，get()返回最后一个value。</strong></td></tr><tr><td style="text-align:left"><strong>update()</strong></td><td style="text-align:left"><strong>参数可以是QueryDict，也可以是标准字典。和标准字典的update方法不同，该方法添加字典 items，而不是替换它们:<code>&gt;&gt;&gt; q = QueryDict('a=1') &gt;&gt;&gt; q = q.copy() # to make it mutable &gt;&gt;&gt; q.update({'a': '2'}) &gt;&gt;&gt; q.getlist('a')  ['1', '2'] &gt;&gt;&gt; q['a'] # returns the last ['2']</code></strong></td></tr><tr><td style="text-align:left"><strong>items()</strong></td><td style="text-align:left"><strong>和标准字典的items()方法有一点不同,该方法使用单值逻辑的getitem():<code>&gt;&gt;&gt; q = QueryDict('a=1&amp;a=2&amp;a=3') &gt;&gt;&gt; q.items() [('a', '3')]</code></strong></td></tr><tr><td style="text-align:left"><strong>values()</strong></td><td style="text-align:left"><strong>和标准字典的values()方法有一点不同,该方法使用单值逻辑的getitem():</strong></td></tr></tbody></table><h4 id="此外-QueryDict也有一些方法，如下表："><strong>此外, QueryDict也有一些方法，如下表：</strong></h4><table><thead><tr><th style="text-align:left"><strong>方法</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>copy()</strong></td><td style="text-align:left"><strong>返回对象的拷贝，内部实现是用Python标准库的copy.deepcopy()。该拷贝是mutable(可更改的) — 就是说，可以更改该拷贝的值。</strong></td></tr><tr><td style="text-align:left"><strong>getlist(key)</strong></td><td style="text-align:left"><strong>返回和参数key对应的所有值，作为一个Python list返回。如果key不存在，则返回空list。 It’s guaranteed to return a list of some sort…</strong></td></tr><tr><td style="text-align:left"><strong>setlist(key,list_)</strong></td><td style="text-align:left"><strong>设置key的值为list_ (unlike setitem()).</strong></td></tr><tr><td style="text-align:left"><strong>appendlist(key,item)</strong></td><td style="text-align:left"><strong>添加item到和key关联的内部list.</strong></td></tr><tr><td style="text-align:left"><strong>setlistdefault(key,list)</strong></td><td style="text-align:left"><strong>和setdefault有一点不同，它接受list而不是单个value作为参数。</strong></td></tr><tr><td style="text-align:left"><strong>lists()</strong></td><td style="text-align:left"><strong>和items()有一点不同, 它会返回key的所有值，作为一个list, 例如:<code>&gt;&gt;&gt; q = QueryDict('a=1&amp;a=2&amp;a=3') &gt;&gt;&gt; q.lists() [('a', ['1', '2', '3'])] </code></strong></td></tr><tr><td style="text-align:left"><strong>urlencode()</strong></td><td style="text-align:left"><strong>返回一个以查询字符串格式进行格式化后的字符串(例如：“a=2&amp;b=3&amp;b=5”)。</strong></td></tr></tbody></table><h1>四、Django Admin 管理工具</h1><p><strong>Django 提供了基于 web 的管理工具。</strong></p><p><strong>Django 自动管理工具是 django.contrib 的一部分。你可以在项目的 <a href="http://settings.py" target="_blank" rel="noopener">settings.py</a> 中的 INSTALLED_APPS 看到它：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/HelloWorld/HelloWorld/settings.py 文件代码：</span><br>INSTALLED_APPS = (<br>    <span class="hljs-string">'django.contrib.admin'</span>,<br>    <span class="hljs-string">'django.contrib.auth'</span>,<br>    <span class="hljs-string">'django.contrib.contenttypes'</span>,<br>    <span class="hljs-string">'django.contrib.sessions'</span>,<br>    <span class="hljs-string">'django.contrib.messages'</span>,<br>    <span class="hljs-string">'django.contrib.staticfiles'</span>,<br>)<br></code></pre></td></tr></table></figure><p><strong>django.contrib是一套庞大的功能集，它是Django基本代码的组成部分。</strong></p><h2 id="1、激活管理工具">1、激活管理工具</h2><p><strong>通常我们在生成项目时会在 <a href="http://urls.py" target="_blank" rel="noopener">urls.py</a> 中自动设置好，我们只需去掉注释即可。</strong></p><p><strong>配置项如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#/HelloWorld/HelloWorld/urls.py 文件代码：</span><br><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> testdb<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> search<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> search2<br><br>urlpatterns = [<br>    path(<span class="hljs-string">'admin/'</span>, admin.site.urls),<br>    path(<span class="hljs-string">'testdb/'</span>, testdb.testdb),<br>    path(<span class="hljs-string">'gitdb/'</span>, testdb.getdb),<br>    path(<span class="hljs-string">'modify/'</span>, testdb.modify),<br>    path(<span class="hljs-string">'del/'</span>, testdb.dl),<br>    path(<span class="hljs-string">'search/'</span>, search.search),<br>    path(<span class="hljs-string">'search-from/'</span>, search.search_form),<br>    path(<span class="hljs-string">'search-post/'</span>, search2.search_post),<br>]<br></code></pre></td></tr></table></figure><p><strong>当这一切都配置好后，Django 管理工具就可以运行了。</strong></p><h2 id="2、使用管理工具">2、使用管理工具</h2><p><strong>启动开发服务器，然后在浏览器中访问 <a href="http://127.0.0.1:8000/admin/%EF%BC%8C%E5%BE%97%E5%88%B0%E5%A6%82%E4%B8%8B%E7%95%8C%E9%9D%A2%EF%BC%9A" target="_blank" rel="noopener">http://127.0.0.1:8000/admin/，得到如下界面：</a></strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417154111687.png" alt="image-20200417154111687"></p><h4 id="因为我现在是新建了个项目所以需要创建表结构：">因为我现在是新建了个项目所以需要创建表结构：</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmd">$ python manage.py migrate   # 创建表结构<br>//失败了可用python3 manage.py migrate<br><br>$ python manage.py makemigrations TestModel  # 让 Django 知道我们在我们的模型有一些变更<br>$ python manage.py migrate TestModel   # 创建表结构<br></code></pre></td></tr></table></figure><h4 id="你可以通过命令-python-manage-py-createsuperuser-来创建超级用户，如下所示：">你可以通过命令 <strong>python <a href="http://manage.py" target="_blank" rel="noopener">manage.py</a> createsuperuser</strong> 来创建超级用户，如下所示：</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># python manage.py createsuperuser<br>Username (leave blank to use 'root'): admin<br>Email address: admin@runoob.com<br><span class="hljs-function">Password:</span><br><span class="hljs-function"><span class="hljs-title">Password</span> (<span class="hljs-title">again</span>):</span><br><span class="hljs-function"><span class="hljs-title">Superuser</span> <span class="hljs-title">created</span> <span class="hljs-title">successfully</span>.</span><br></code></pre></td></tr></table></figure><h4 id="之后输入用户名密码登录，界面如下：">之后输入用户名密码登录，界面如下：</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417155335794.png" alt="image-20200417155335794"></p><h4 id="models-py文件添加类型">models.py文件添加类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#XGPtest/TestModel/models.py</span><br><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span><span class="hljs-params">(models.Model)</span>:</span><br>    name = models.CharField(max_length=<span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><p><em><strong>创建完成之后，数据库中就生成testmodel_test表</strong></em></p><h4 id="为了让-admin-界面管理某个数据模型，我们需要先注册该数据模型到-admin。比如，我们之前在-TestModel-中已经创建了模型-Test-。修改-TestModel-admin-py">为了让 admin 界面管理某个数据模型，我们需要先注册该数据模型到 admin。比如，我们之前在 TestModel 中已经创建了模型 Test 。修改 TestModel/admin.py:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#HelloWorld/TestModel/admin.py: 文件代码：</span><br><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span>. models <span class="hljs-keyword">import</span> Test<br><br><span class="hljs-comment"># Register your models here.</span><br>admin.site.register(Test)<br></code></pre></td></tr></table></figure><h5 id="刷新后即可看到-Testmodel-数据表">刷新后即可看到 Testmodel 数据表:</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417155913316.png" alt="image-20200417155913316"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418105501617.png" alt="image-20200418105501617"></p><p><em><strong>可以简单的添加、修改、删除。</strong></em></p><h2 id="3、使用管理工具添加一个用户">3、使用管理工具添加一个用户</h2><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417160738745.png" alt="image-20200417160738745"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417160851085.png" alt="image-20200417160851085"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417160938480.png" alt="image-20200417160938480"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417161058691.png" alt="image-20200417161058691"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417161110515.png" alt="image-20200417161110515"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417161131331.png" alt="image-20200417161131331"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417161211723.png" alt="image-20200417161211723"></p><h2 id="4、复杂模型">4、复杂模型</h2><p><strong>管理页面的功能强大，完全有能力处理更加复杂的数据模型。</strong></p><p><strong>先在 TestModel/models.py 中增加一个更复杂的数据模型：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br> <br><span class="hljs-comment"># Create your models here.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span><span class="hljs-params">(models.Model)</span>:</span><br>    name = models.CharField(max_length=<span class="hljs-number">20</span>)<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Contact</span><span class="hljs-params">(models.Model)</span>:</span><br>    name   = models.CharField(max_length=<span class="hljs-number">20</span>)<br>    age    = models.IntegerField(default=<span class="hljs-number">0</span>)<br>    email  = models.EmailField()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__unicode__</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">return</span> self.name<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tag</span><span class="hljs-params">(models.Model)</span>:</span><br>    contact = models.ForeignKey(Contact, on_delete=models.CASCADE,)<br>    name    = models.CharField(max_length=<span class="hljs-number">50</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__unicode__</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">return</span> self.name<br></code></pre></td></tr></table></figure><p><strong>这里有两个表。Tag 以 Contact 为外部键。一个 Contact 可以对应多个 Tag。</strong></p><p><strong>我们还可以看到许多在之前没有见过的属性类型，比如 IntegerField 用于存储整数。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417161438555.png" alt="image-20200417161438555"></p><h5 id="在-TestModel-admin-py-注册多个模型并显示："><strong>在 TestModel/admin.py 注册多个模型并显示：</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> TestModel.models <span class="hljs-keyword">import</span> Test,Contact,Tag<br><br><span class="hljs-comment"># Register your models here.</span><br>admin.site.register([Test, Contact, Tag])<br></code></pre></td></tr></table></figure><h4 id="刷新管理页面，显示结果如下：">刷新管理页面，显示结果如下：</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417161612003.png" alt="image-20200417161612003"></p><p><em><strong>在以上管理工具我们就能进行复杂模型操作。</strong></em></p><blockquote><p><strong>如果你之前还未创建表结构，可使用以下命令创建：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">$ python manage.py makemigrations TestModel  <span class="hljs-comment"># 让 Django 知道我们在我们的模型有一些变更</span><br>$ python manage.py migrate TestModel   <span class="hljs-comment"># 创建表结构</span><br></code></pre></td></tr></table></figure><p>**<em>数据库会生成新的表单<code>testmodel tag</code>和</em><code>testmodel Contacts</code>)</p></blockquote><h2 id="5、自定义表单">5、自定义表单</h2><p><strong>我们可以自定义管理页面，来取代默认的页面。比如上面的 “add” 页面。我们想只显示 name 和 email 部分。修改 TestModel/admin.py:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#HelloWorld/TestModel/admin.py: 文件代码：</span><br><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> . models <span class="hljs-keyword">import</span> Test,Contact,Tag<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContactAdmin</span><span class="hljs-params">(admin.ModelAdmin)</span>:</span><br>    fields = (<span class="hljs-string">'name'</span>, <span class="hljs-string">'email'</span>)<br><br><span class="hljs-comment"># Register your models here.</span><br>admin.site.register(Contact, ContactAdmin)<br>admin.site.register([Test, Tag])<br></code></pre></td></tr></table></figure><p><strong>以上代码定义了一个 ContactAdmin 类，用以说明管理页面的显示格式。</strong></p><p><strong>里面的 fields 属性定义了要显示的字段。</strong></p><p><strong>由于该类对应的是 Contact 数据模型，我们在注册的时候，需要将它们一起注册。显示效果如下：</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417162438916.png" alt="image-20200417162438916"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417162558100.png" alt="image-20200417162558100"></p><h4 id="我们还可以将输入栏分块，每个栏也可以定义自己的格式。修改-TestModel-admin-py为：">我们还可以将输入栏分块，每个栏也可以定义自己的格式。修改 TestModel/admin.py为：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> TestModel.models <span class="hljs-keyword">import</span> Test, Contact, Tag<br><br><br><span class="hljs-comment"># Register your models here.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContactAdmin</span><span class="hljs-params">(admin.ModelAdmin)</span>:</span><br>    fieldsets = (<br>        [<span class="hljs-string">'Main'</span>, &#123;<br>            <span class="hljs-string">'fields'</span>: (<span class="hljs-string">'name'</span>, <span class="hljs-string">'email'</span>),<br>        &#125;],<br>        [<span class="hljs-string">'Advance'</span>, &#123;<br>            <span class="hljs-string">'classes'</span>: (<span class="hljs-string">'collapse'</span>,),  <span class="hljs-comment"># CSS</span><br>            <span class="hljs-string">'fields'</span>: (<span class="hljs-string">'age'</span>,),<br>        &#125;]<br>    )<br><br><br>admin.site.register(Contact, ContactAdmin)<br>admin.site.register([Test, Tag])<br></code></pre></td></tr></table></figure><h4 id="上面的栏目分为了-Main-和-Advance-两部分。classes-说明它所在的部分的-CSS-格式。这里让-Advance-部分隐藏：">上面的栏目分为了 Main 和 Advance 两部分。classes 说明它所在的部分的 CSS 格式。这里让 Advance 部分隐藏：</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417162947876.png" alt="image-20200417162947876"></p><h4 id="Advance-部分旁边有一个-Show-按钮，用于展开，展开后可点击-Hide-将其隐藏，如下图所示：">Advance 部分旁边有一个 Show 按钮，用于展开，展开后可点击 Hide 将其隐藏，如下图所示：</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417162916369.png" alt="image-20200417162916369"></p><h2 id="6、内联-Inline-显示">6、内联(Inline)显示</h2><p><strong>上面的 Contact 是 Tag 的外部键，所以有外部参考的关系。</strong></p><p><strong>而在默认的页面显示中，将两者分离开来，无法体现出两者的从属关系。我们可以使用内联显示，让 Tag 附加在 Contact 的编辑页面上显示。</strong></p><p><strong>修改TestModel/admin.py：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> TestModel.models <span class="hljs-keyword">import</span> Test, Contact, Tag<br><br><br><span class="hljs-comment"># Register your models here.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TagInline</span><span class="hljs-params">(admin.TabularInline)</span>:</span><br>    model = Tag<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContactAdmin</span><span class="hljs-params">(admin.ModelAdmin)</span>:</span><br>    inlines = [TagInline]  <span class="hljs-comment"># Inline</span><br>    fieldsets = (<br>        [<span class="hljs-string">'Main'</span>, &#123;<br>            <span class="hljs-string">'fields'</span>: (<span class="hljs-string">'name'</span>, <span class="hljs-string">'email'</span>),<br>        &#125;],<br>        [<span class="hljs-string">'Advance'</span>, &#123;<br>            <span class="hljs-string">'classes'</span>: (<span class="hljs-string">'collapse'</span>,),<br>            <span class="hljs-string">'fields'</span>: (<span class="hljs-string">'age'</span>,),<br>        &#125;]<br>        <br>admin.site.register(Contact, ContactAdmin)<br>admin.site.register([Test, Tag])<br></code></pre></td></tr></table></figure><h5 id="显示效果如下：">显示效果如下：</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417163454194.png" alt="image-20200417163454194"></p><h2 id="7、列表页的显示">7、列表页的显示</h2><p><strong>在 Contact 输入数条记录后，Contact 的列表页看起来如下:</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200417164137321.png" alt="image-20200417164137321"></p><p><strong>我们也可以自定义该页面的显示，比如在列表中显示更多的栏目，只需要在 ContactAdmin 中增加 list_display 属性:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#HelloWorld/TestModel/admin.py: 文件代码：</span><br><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> TestModel.models <span class="hljs-keyword">import</span> Test,Contact,Tag<br> <br><span class="hljs-comment"># Register your models here.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TagInline</span><span class="hljs-params">(admin.TabularInline)</span>:</span><br>    model = Tag<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContactAdmin</span><span class="hljs-params">(admin.ModelAdmin)</span>:</span><br>    list_display = (<span class="hljs-string">'name'</span>,<span class="hljs-string">'age'</span>, <span class="hljs-string">'email'</span>) <span class="hljs-comment"># list</span><br>    inlines = [TagInline]  <span class="hljs-comment"># Inline</span><br>    fieldsets = (<br>        [<span class="hljs-string">'Main'</span>,&#123;<br>            <span class="hljs-string">'fields'</span>:(<span class="hljs-string">'name'</span>,<span class="hljs-string">'email'</span>),<br>        &#125;],<br>        [<span class="hljs-string">'Advance'</span>,&#123;<br>            <span class="hljs-string">'classes'</span>: (<span class="hljs-string">'collapse'</span>,),<br>            <span class="hljs-string">'fields'</span>: (<span class="hljs-string">'age'</span>,),<br>        &#125;]<br> <br>    )<br> <br>admin.site.register(Contact, ContactAdmin)<br>admin.site.register([Test])<br></code></pre></td></tr></table></figure><h5 id="刷新页面显示效果如下："><strong>刷新页面显示效果如下：</strong></h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418112720304.png" alt="image-20200418112720304"></p><h4 id="搜索功能在管理大量记录时非常有，我们可以使用-search-fields-为该列表页增加搜索栏：">搜索功能在管理大量记录时非常有，我们可以使用 search_fields 为该列表页增加搜索栏：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#HelloWorld/TestModel/admin.py: 文件代码：</span><br><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> TestModel.models <span class="hljs-keyword">import</span> Test,Contact,Tag<br> <br><span class="hljs-comment"># Register your models here.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TagInline</span><span class="hljs-params">(admin.TabularInline)</span>:</span><br>    model = Tag<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContactAdmin</span><span class="hljs-params">(admin.ModelAdmin)</span>:</span><br>    list_display = (<span class="hljs-string">'name'</span>,<span class="hljs-string">'age'</span>, <span class="hljs-string">'email'</span>)<br>    search_fields = (<span class="hljs-string">'name'</span>,)               <span class="hljs-comment">#search</span><br>    inlines = [TagInline]  <span class="hljs-comment"># Inline</span><br>    fieldsets = (<br>        [<span class="hljs-string">'Main'</span>,&#123;<br>            <span class="hljs-string">'fields'</span>:(<span class="hljs-string">'name'</span>,<span class="hljs-string">'email'</span>),<br>        &#125;],<br>        [<span class="hljs-string">'Advance'</span>,&#123;<br>            <span class="hljs-string">'classes'</span>: (<span class="hljs-string">'collapse'</span>,),<br>            <span class="hljs-string">'fields'</span>: (<span class="hljs-string">'age'</span>,),<br>        &#125;]<br> <br>    )<br> <br>admin.site.register(Contact, ContactAdmin)<br>admin.site.register([Test])<br></code></pre></td></tr></table></figure><h5 id="在本实例中我们搜索了-name-为xgp的记录，显示结果如下：">在本实例中我们搜索了 name 为xgp的记录，显示结果如下：</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418112732683.png" alt="image-20200418112732683"></p><h1>五、引入静态文件</h1><p><em><strong>文件链接《链接: <a href="https://pan.baidu.com/s/133f0ypYOsAi8s8DdV_Uduw" target="_blank" rel="noopener">https://pan.baidu.com/s/133f0ypYOsAi8s8DdV_Uduw</a> 提取码: 4847》</strong></em></p><p><strong>需要将一些静态资源引入项目，新建一个static目录，可以将js、css等文件放入这个目录中：</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418113756299.png" alt="image-20200418113756299"></p><h3 id="1、urls-py-规则修改为如下形式：">1、<a href="http://urls.py" target="_blank" rel="noopener">urls.py</a> 规则修改为如下形式：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> testdb<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> search<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> search2<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> index<br><br>urlpatterns = [<br>    path(<span class="hljs-string">'admin/'</span>, admin.site.urls),<br>    path(<span class="hljs-string">'testdb/'</span>, testdb.testdb),<br>    path(<span class="hljs-string">'gitdb/'</span>, testdb.getdb),<br>    path(<span class="hljs-string">'modify/'</span>, testdb.modify),<br>    path(<span class="hljs-string">'del/'</span>, testdb.dl),<br>    path(<span class="hljs-string">'search/'</span>, search.search),<br>    path(<span class="hljs-string">'search-from/'</span>, search.search_form),<br>    path(<span class="hljs-string">'search-post/'</span>, search2.search_post),<br>    path(<span class="hljs-string">'index/'</span>, index.index),<br>]<br></code></pre></td></tr></table></figure><h3 id="2、本目录创建index-py文件">2、本目录创建index.py文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span><span class="hljs-params">(request)</span>:</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">'index.html'</span> ,&#123;&#125;)<br></code></pre></td></tr></table></figure><h4 id="浏览器查看一下">浏览器<a href="http://127.0.0.1:8000/index" target="_blank" rel="noopener">查看一下</a></h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418115340307.png" alt="image-20200418115340307"></p><h3 id="3、需要让Django找到这个目录，需要在setting文件中进行配置：">3、需要让Django找到这个目录，需要在setting文件中进行配置：</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418114859747.png" alt="image-20200418114859747"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">STATICFILES_DIRS = (<br>    os.path.join(BASE_DIR, <span class="hljs-string">'static'</span>),<br>)<br></code></pre></td></tr></table></figure><h3 id="4、修改一下index-html文件">4、修改一下index.html文件</h3><p><strong>在html文件中引入静态资源：</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418121043637.png" alt="image-20200418121043637"></p><p><strong>把index.html文件中所有的<code>image</code>替换为<code>/image</code>！</strong></p><p><strong>ctrl+F：替换</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418121247927.png" alt="image-20200418121247927"></p><h4 id="浏览器查看一下-2">浏览器<a href="http://127.0.0.1:8000/index" target="_blank" rel="noopener">查看一下</a></h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418121310112.png" alt="image-20200418121310112"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows10安装 mysql数据库和Navicat for MySQL(MySQL管理工具)</title>
      <link href="/posts/3eca.html"/>
      <url>/posts/3eca.html</url>
      
        <content type="html"><![CDATA[<h1>windows10上安装mysql（详细步骤）</h1><blockquote><p><strong>环境：windwos 10（1511） 64bit、mysql 5.7.14</strong><br><strong>时间：2020年4月18日</strong></p></blockquote><h1>一、下载mysql</h1><h4 id="1、在浏览器里打开mysql的官网http-www-mysql-com">1、在浏览器里打开mysql的官网http://www.mysql.com/</h4><h4 id="2、进入页面顶部的-Downloads">2、进入页面顶部的&quot;Downloads&quot;</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418202931924.png" alt="image-20200418202931924"></p><h4 id="3、打开页面底部的“Community-GPL-Downloads”">3、打开页面底部的“Community(GPL) Downloads”</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418203044211.png" alt="image-20200418203044211"></p><h4 id="4、在页面中间的位置找到我们windows上要用的下载页面“MySQL-Installer-for-Windows”">4、在页面中间的位置找到我们windows上要用的下载页面“<code>MySQL Installer for Windows</code>”</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418203609812.png" alt="image-20200418203609812"></p><h4 id="5、页面底端找到下载入口“Windows-x86-32-bit-MSI-Installer”，点击Download按钮开始下载，共381-4M">5、页面底端找到下载入口“<strong>Windows (x86, 32-bit), MSI Installer</strong>”，点击Download按钮开始下载，共381.4M</h4><p><em><strong>注意：MSI格式是指windows的安装程序，下载后直接双击就能进入安装向导的那种，区别于对文件进行解压的安装方式；</strong></em></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418203925709.png" alt="image-20200418203925709"></p><h4 id="6、这个页面告诉询问你是否登录，告诉你登录之后有哪些好处，我们不登录，点击页面底部的“No-thanks-just-start-my-download-”按钮进入下载页面">6、这个页面告诉询问你是否登录，告诉你登录之后有哪些好处，我们不登录，点击页面底部的“No thanks, just start my download.”按钮进入下载页面</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418204041557.png" alt="image-20200418204041557"></p><h4 id="7、开始下载，等待下载完成（由于直接下载速度太慢，之后我用迅雷下载完成的）">7、开始下载，等待下载完成（由于直接下载速度太慢，之后我用迅雷下载完成的）</h4><p><strong>链接: <a href="https://pan.baidu.com/s/1p6Dy6YAT-FS0DLOUbuXTmw" target="_blank" rel="noopener">https://pan.baidu.com/s/1p6Dy6YAT-FS0DLOUbuXTmw</a> 提取码: 4847</strong></p><h4 id="8、下载完成">8、下载完成</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418204356586.png" alt="image-20200418204356586"></p><h1>二、安装mysql</h1><h4 id="1、双击下载好的mysql安装文件“mysql-installer-community-5-7-14-0-msi”打开安装程序，打开后需要稍等一下">1、双击下载好的mysql安装文件“mysql-installer-community-5.7.14.0.msi”打开安装程序，打开后需要稍等一下</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418204422584.png" alt="image-20200418204422584"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418204447314.png" alt="image-20200418204447314"></p><h4 id="2、选择安装类型（根据个人需要）">2、选择安装类型（根据个人需要）</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418204514887.png" alt="image-20200418204514887"></p><h4 id="3、我只需要安装mysql-server，所以选择最后一项“Custom”，选择Custom之后左边的安装流程和右边的描述文字会改变，然后点击-Next-按钮继续">3、我只需要安装mysql server，所以选择最后一项“Custom”，选择Custom之后左边的安装流程和右边的描述文字会改变，然后点击&quot;Next&quot;按钮继续</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418204549590.png" alt="image-20200418204549590"></p><h4 id="4、在这里我们需要从安装程序提供的可安装的产品（Products）中选择我们需要的mysql-server">4、在这里我们需要从安装程序提供的可安装的产品（Products）中选择我们需要的mysql server</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418204605326.png" alt="image-20200418204605326"></p><p><strong>我们展开Available Products里的第一项“MySQL Servers”，依次展开其子结点，直到其终端结点，我的操作是64位的，所以选中“MySQL Server 5.7.14 - X64”</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418204628103.png" alt="image-20200418204628103"></p><p><strong>然后点击绿色的向右箭头，将当前Product移动需要安装的列表，然后在右边展开“MySQL Server 5.7.14 - X64”项，取消“Development Components”的勾选（因为我们只需要安装mysql server），之后点击“Next”按钮进入下一步</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418204648289.png" alt="image-20200418204648289"></p><h4 id="5、点击“Execute”（执行）开始安装，安装过程中会显示安装的Progress（进度），等待安装完成后Status会显示Complete，mysql图标前会出现一个绿色的勾，然后点击“Next”按钮进入产品配置界面">5、点击“Execute”（执行）开始安装，安装过程中会显示安装的Progress（进度），等待安装完成后Status会显示Complete，mysql图标前会出现一个绿色的勾，然后点击“Next”按钮进入产品配置界面</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418204712902.png" alt="image-20200418204712902"></p><h4 id="6、点击“Next”按钮进入MySQL-Server-的配置">6、点击“Next”按钮进入MySQL Server 的配置</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418204746455.png" alt="image-20200418204746455"></p><p><strong>Config Type选择“Development Machine”，选择此项将使用较小的内容来运行我们的mysql server，对应小型软件、学习是完全够用的。之后“Next”</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418204812768.png" alt="image-20200418204812768"></p><p><strong>在Root Account Password设置数据库root账号的密码，我填的是123456所以程序提醒我密码强度为弱，我们需要牢记这个密码，然后点击“Next”</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418204829767.png" alt="image-20200418204829767"></p><p><strong>这里可以设置mysql server的名称和是否开机启动，我把名称改为了“MySQLZzz1”，取消了开机启动，其它的没改，点击“Next”</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418204845791.png" alt="image-20200418204845791"></p><p><strong>点击“Next”</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418204859303.png" alt="image-20200418204859303"></p><p><strong>此界面将之前设置的配置内容应用到我们的mysql server，点击“Execute”，等待完成就可以了</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418204929360.png" alt="image-20200418204929360"></p><p><strong>配置完成，点击“Finish”完成配置环节</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418204942585.png" alt="image-20200418204942585"></p><h4 id="7、配置完成后将回到安装程序，我们点击“Next”继续">7、配置完成后将回到安装程序，我们点击“Next”继续</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418204959992.png" alt="image-20200418204959992"></p><p><strong>提示我们安装完成，点击“Finish”</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418205015304.png" alt="image-20200418205015304"></p><p><strong>8、在上一步点击“Finish”之后电脑是如此的平静，让人不知道接下来干什么！按以往安装软件的经验这个时候电脑应该要自动启动刚刚安装好的软件的。所以我在进程里找了一下，确实没有发现类似mysql的进程，那么我们进入下一步。</strong></p><h1>三、配置mysql环境变量（非必要）</h1><p><em><strong>说明：给mysql配置环境变量后我们就可以在cmd里运行mysql（开启、停止等操作）</strong></em></p><h4 id="1、和其实环境变量的配置方法一样，我们打开环境变量配置窗口（组合键win-Pause-更改设置-系统属性里选择“高级”-环境变量）">1、和其实环境变量的配置方法一样，我们打开环境变量配置窗口（组合键win+Pause -&gt; 更改设置 -&gt; 系统属性里选择“高级” -&gt; 环境变量）</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418210243116.png" alt="image-20200418210243116"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418210258370.png" alt="image-20200418210258370"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418210314189.png" alt="image-20200418210314189"></p><h4 id="2、选中系统变量中的“path”，在path值开头处输入mysql安装目录下的bin文件夹所在路径：C-Program-Files-MySQL-MySQL-Server-5-7-bin，保存退出">2、选中系统变量中的“path”，在path值开头处输入mysql安装目录下的bin文件夹所在路径：C:\Program Files\MySQL\MySQL Server 5.7\bin，保存退出</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418210358173.png" alt="image-20200418210358173"></p><p><strong>之后一路确定</strong></p><p><em><strong>注意：mysql server安装的默认路径为：C:\Program Files\MySQL\MySQL Server 5.7</strong></em></p><h4 id="3、测试是否配置成功：打开cmd，输入“mysql-u-root-p”回车，然后输入mysql安装时设置的root账号的密码（123456），若提示“Welcome-to-the-MySQL-monitor-”说明配置成功了。">3、测试是否配置成功：打开cmd，输入“mysql -u root -p”回车，然后输入mysql安装时设置的root账号的密码（123456），若提示“Welcome to the MySQL monitor.”说明配置成功了。</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418210529165.png" alt="xgp"></p><h1>四、启动mysql</h1><p><em><strong>是的，到现在我们还没有启动我们的mysql！那么要怎么启动呢？</strong></em><br><em><strong>（基于已配置环境变量的情况）</strong></em></p><h4 id="1、以管理员的身份运行cmd，输入“net-start-mysqlzzz1”（MySQLZzz1是配置mysql-server时填写的服务器名称，cmd里不区分大小写也可以使用）">1、以管理员的身份运行cmd，输入“net start mysqlzzz1”（MySQLZzz1是配置mysql server时填写的服务器名称，cmd里不区分大小写也可以使用）</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418205036242.png" alt="image-20200418205036242"></p><h4 id="2、提示启动成功后我们便可以在任务管理器的进程里看到“mysqld-exe”的进程了。">2、提示启动成功后我们便可以在任务管理器的进程里看到“mysqld.exe”的进程了。</h4><blockquote><p><strong>附：</strong><br><strong>若执行命令时提示：服务名无效。请键入 NET HELPMSG 2185 以获得更多的帮助。</strong><br><strong>解决办法： 在 mysql bin目录下 以管理员的权限 执行 mysqld -install命令</strong></p><p><strong>附：卸载mysql服务的方法。</strong><br><strong>1、以管理员的权限 net stop mysql ，关闭mysql服务</strong><br><strong>2、以管理员的权限 mysqld -remove ，卸载mysql服务</strong></p></blockquote><h1>五、测试是否安装成功</h1><p><strong>我们使用MySQL管理软件（Navicat for MySQL）进行连接测试，确保mysql已经可以使用：</strong></p><h4 id="1、安装Navicat-for-MySQL">1、安装Navicat for MySQL</h4><blockquote><p><strong>下载地址如下：（直接点击<code>navicat.exe</code>文件运行就可以）</strong></p><p><strong>链接  :<a href="https://pan.baidu.com/s/1rkOowXtvIBUhLJawT43boA" target="_blank" rel="noopener">https://pan.baidu.com/s/1rkOowXtvIBUhLJawT43boA</a> 密码: rcup</strong></p><p><strong>注册码: NAVH-WK6A-DMVK-DKW3</strong>**</p></blockquote><h4 id="2、打开Navicat-for-MySQL">2、打开Navicat for MySQL</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418205206453.png" alt="image-20200418205206453"></p><h4 id="3、新建一个连接，填写连接信息：">3、新建一个连接，填写连接信息：</h4><blockquote><p><strong>连接名称：用于区分不同的连接，自己命名即可</strong><br><strong>主机名：localhost</strong><br><strong>端口：3306</strong><br><strong>用户名：root</strong><br><strong>密码：123456（之前配置mysql的时候填写的密码）</strong></p></blockquote><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418205357830.png" alt="image-20200418205357830"></p><h4 id="4、点击“连接测试”按钮，弹出连接成功对话框即表示mysql-server已开启">4、点击“连接测试”按钮，弹出连接成功对话框即表示mysql server已开启</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418205413861.png" alt="image-20200418205413861"></p><h4 id="5、之后就是Navicat-for-MySQL软件的使用">5、之后就是Navicat for MySQL软件的使用</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200418205441215.png" alt="image-20200418205441215"></p><blockquote><p><strong>另：</strong><br><strong>我们也可以在cmd里，再次输入“net start mysqlzzz1”，若提示“请求的服务已经启动。”表示mysql server已正常启动；</strong></p></blockquote><p><strong>至此，mysql server在windows 10 64位上就安装完成了。</strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Django和宝塔面板</title>
      <link href="/posts/10c6.html"/>
      <url>/posts/10c6.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 中国">镜像列表<br>http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F; &#x2F;&#x2F;阿里<br>https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple&#x2F; &#x2F;&#x2F;清华<br>http:&#x2F;&#x2F;pypi.douban.com&#x2F; &#x2F;&#x2F;豆瓣<br>http:&#x2F;&#x2F;pypi.hustunique.com&#x2F; &#x2F;&#x2F;华中理工大学<br>http:&#x2F;&#x2F;pypi.sdutlinux.org&#x2F; &#x2F;&#x2F;山东理工大学<br>http:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F; &#x2F;&#x2F;中国科学技术大学<br></code></pre></td></tr></table></figure><h1>一、linux安装“<a href="https://www.bt.cn/bbs/thread-19376-1-1.html" target="_blank" rel="noopener">宝塔面板</a>”</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs linux">[root@python ~]# yum install -y wget &amp;&amp; wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install_6.0.sh &amp;&amp; sh install.sh<br>&#x2F;&#x2F;一键安装<br></code></pre></td></tr></table></figure><h3 id="安装完成界面">安装完成界面</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200413142432289.png" alt="image-20200413142432289"></p><h3 id="浏览器访问">浏览器<a href="http://192.168.1.80:8888/35142f4b/" target="_blank" rel="noopener">访问</a></h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200413142632626.png" alt="image-20200413142632626"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200413142720687.png" alt="image-20200413142720687"></p><p><em><strong>接下来就可以在这里体验一下，非常方便的一个工具！！！</strong></em></p><h2 id="1、宝塔面板是什么？">1、宝塔面板是什么？</h2><p><strong>宝塔面板是一款服务器管理软件，支持windows和linux系统，可以通过Web端轻松管理服务器，提升运维效率。例如：创建管理网站、FTP、数据库，拥有可视化文件管理器，可视化软件管理器，可视化CPU、内存、流量监控图表，计划任务等功能。</strong></p><h2 id="2、宝塔面板可以做什么？"><strong>2、宝塔面板可以做什么？</strong></h2><p><strong>宝塔面板拥有极速方便的一键配置与管理，可一键配置服务器环境（LAMP/LNMP/Tomcat/Node.js），一键部署SSL，异地备份；提供SSH开启关闭服务，SSH端口更改，禁ping，防火墙端口放行以及操作日志查看；CPU、内存、磁盘IO、网络IO数据监测，可设置记录保存天数以及任意查看某天数据；计划任务可按周期添加执行，支持SHELL脚本，提供网站、数据库备份以及日志切割，且支持一键备份到又拍云存储空间，或者其他云存储空间里；通过web界面就可以轻松管理安装所用的服务器软件，还有实用的扩展插件；集成方便高效的文件管理器，支持上传、下载、打包、解压以及文件编辑查看。</strong></p><h2 id="3、有哪些特色？"><strong>3、有哪些特色？</strong></h2><p><strong>为了方便用户建立网站，宝塔面板上的一键部署源码插件，可一键部署：discuz,wordpress,ecshop,thinkphp,z-blog,dedecms等程序。还有极其方便的一键迁移，两台服务器安装宝塔Linux面板5.2版本，可实现一键迁移服务器网站、FTP、数据库。</strong></p><h2 id="4、定位"><strong>4、定位</strong></h2><p><strong>总的来说宝塔面板是众多服务器管理软件中拥有友好的界面交互体验、功能完善且每周更新的一款产品。宝塔面板做的就是一款简单好用的服务器管理软件。</strong></p><h1>二、Django 的简便实用</h1><h2 id="1、简介">1、简介</h2><ul><li><strong>Python下有许多款不同的 Web 框架。Django是重量级选手中最有代表性的一位。许多成功的网站和APP都基于Django。</strong></li><li><strong>Django是一个开放源代码的Web应用框架，由Python写成。</strong></li><li><strong>Django遵守BSD版权，初次发布于2005年7月, 并于2008年9月发布了第一个正式版本1.0 。</strong></li><li><strong>Django采用了MVC的软件设计模式，即模型M，视图V和控制器C。</strong></li></ul><h2 id="2-特点">2. 特点</h2><h3 id="1）-重量级框架">1） 重量级框架</h3><p><strong>对比Flask框架，Django原生提供了众多的功能组件，让开发更简便快速。</strong></p><ul><li><p><strong>提供项目工程管理的自动化脚本工具</strong></p></li><li><p><strong>数据库ORM支持（对象关系映射，英语：Object Relational Mapping）</strong></p></li><li><p><strong>模板</strong></p></li><li><p><strong>表单</strong></p></li><li><p><strong>Admin管理站点</strong></p></li><li><p><strong>文件管理</strong></p></li><li><p><strong>认证权限</strong></p></li><li><p><strong>session机制</strong></p></li><li><p><strong>缓存</strong></p></li></ul><h3 id="2）MVT模式">2）MVT模式</h3><p><strong>有一种程序设计模式叫MVC，其核心思想是分工、解耦，让不同的代码块之间降低耦合，增强代码的可扩展性和可移植性，实现向后兼容。</strong></p><blockquote><p><strong>MVC的全拼为Model-View-Controller，最早由TrygveReenskaug在1978年提出，是施乐帕罗奥多研究中心(Xerox PARC)在20世纪80年代为程序语言Smalltalk发明的一种软件设计模式，是为了将传统的输入（input）、处理（processing）、输出（output）任务运用到图形化用户交互模型中而设计的。随着标准输入输出设备的出现，开发人员只需要将精力集中在业务逻辑的分析与实现上。后来被推荐为Oracle旗下Sun公司Java EE平台的设计模式，并且受到越来越多的使用ColdFusion和PHP的开发者的欢迎。现在虽然不再使用原来的分工方式，但是这种分工的思想被沿用下来，广泛应用于软件工程中，是一种典型并且应用广泛的软件架构模式。后来，MVC的思想被应用在了Ｗeb开发方面，被称为Ｗeb MVC框架。</strong></p></blockquote><h4 id="1、MVC模式说明">1、MVC模式说明</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200413144343706.png" alt="image-20200413144343706"></p><ul><li><strong>M全拼为Model，主要封装对数据库层的访问，对数据库中的数据进行增、删、改、查操作。</strong></li><li><strong>V全拼为View，用于封装结果，生成页面展示的html内容。</strong></li><li><strong>C全拼为Controller，用于接收请求，处理业务逻辑，与Model和View交互，返回结果。</strong></li></ul><h4 id="2、Django的MVT">2、Django的MVT</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200413144359898.png" alt="image-20200413144359898"></p><ul><li><strong>M全拼为Model，与MVC中的M功能相同，负责和数据库交互，进行数据处理。</strong></li><li><strong>V全拼为View，与MVC中的C功能相同，接收请求，进行业务处理，返回应答。</strong></li><li><strong>T全拼为Template，与MVC中的V功能相同，负责封装构造要返回的html。</strong></li></ul><p><strong>注：差异就在于黑线黑箭头标识出来的部分</strong></p><h2 id="3、windows安装Django">3、windows安装Django</h2><h3 id="（1）版本对应">（1）版本对应</h3><table><thead><tr><th style="text-align:left">Django 版本</th><th style="text-align:left">Python 版本</th></tr></thead><tbody><tr><td style="text-align:left">1.8</td><td style="text-align:left">2.7, 3.2 , 3.3, 3.4, 3.5</td></tr><tr><td style="text-align:left">1.9, 1.10</td><td style="text-align:left">2.7, 3.4, 3.5</td></tr><tr><td style="text-align:left">1.11</td><td style="text-align:left">2.7, 3.4, 3.5, 3.6</td></tr><tr><td style="text-align:left">2.0</td><td style="text-align:left">3.4, 3.5, 3.6, 3.7</td></tr><tr><td style="text-align:left">2.1, 2.2</td><td style="text-align:left">3.5, 3.6, 3.7</td></tr></tbody></table><h3 id="（2）cmd安装">（2）cmd安装</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">pip install -i https://pypi.douban.com/simple/ django #较快<br>pip install Django #较慢<br></code></pre></td></tr></table></figure><h3 id="（3）检查是否安装成功">（3）检查是否安装成功</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">C:\<span class="hljs-title">WINDOWS</span>\<span class="hljs-title">system32</span>&gt;<span class="hljs-title">python</span>  #进入<span class="hljs-title">python</span>命令行</span><br><span class="hljs-function"><span class="hljs-title">Python</span> 3.8.2 (<span class="hljs-title">tags</span>/<span class="hljs-title">v3</span>.8.2:7<span class="hljs-title">b3ab59</span>, <span class="hljs-title">Feb</span> 25 2020, 23:03:10) [<span class="hljs-title">MSC</span> <span class="hljs-title">v</span>.1916 64 <span class="hljs-title">bit</span> (<span class="hljs-title">AMD64</span>)] <span class="hljs-title">on</span> <span class="hljs-title">win32</span></span><br><span class="hljs-function"><span class="hljs-title">Type</span> "<span class="hljs-title">help</span>", "<span class="hljs-title">copyright</span>", "<span class="hljs-title">credits</span>" <span class="hljs-title">or</span> "<span class="hljs-title">license</span>" <span class="hljs-title">for</span> <span class="hljs-title">more</span> <span class="hljs-title">information</span>.</span><br><span class="hljs-function">&gt;&gt;&gt; <span class="hljs-title">import</span> <span class="hljs-title">django</span></span><br><span class="hljs-function">&gt;&gt;&gt; <span class="hljs-title">django.VERSION</span>    #查看版本号</span><br><span class="hljs-function">(3, 0, 5, '<span class="hljs-title">final</span>', 0)</span><br></code></pre></td></tr></table></figure><p><em><strong>如果输出了Django的版本号说明安装正确。</strong></em></p><h1>三、Django 创建第一个项目</h1><p><strong>本章我们将介绍<code>Django</code> 管理工具及如何使用 <code>Django</code> 来创建项目，第一个项目我们以 <code>HelloWorld</code> 来命令项目。</strong></p><h2 id="1、Django-管理工具">1、Django 管理工具</h2><p><strong>安装 <code>Django</code> 之后，您现在应该已经有了可用的管理工具 <code>django-admin</code>。我们可以使用 <code>django-admin</code> 来创建一个项目:</strong></p><p><strong>我们可以来看下<code>django-admin</code> 的命令介绍:</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200413151626181.png" alt="image-20200413151626181"></p><h2 id="2、创建第一个项目">2、创建第一个项目</h2><p><strong>使用 <code>django-admin</code> 来创建 <code>HelloWorld</code> 项目：</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">django-admin startproject HelloWorld<br></code></pre></td></tr></table></figure><p><strong>创建完成后我们可以查看下项目的目录结构：</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cmd">PS G:\四期\python\<span class="hljs-number">5</span>\test&gt; <span class="hljs-built_in">cd</span> .\HelloWorld\<br>PS G:\四期\python\<span class="hljs-number">5</span>\test\HelloWorld&gt; <span class="hljs-built_in">tree</span> /f<br>卷 学习 的文件夹 <span class="hljs-built_in">PATH</span> 列表<br>卷序列号为 <span class="hljs-number">7</span>C11-<span class="hljs-number">994</span>A<br><span class="hljs-function">G:.</span><br><span class="hljs-function">│  <span class="hljs-title">manage.py</span></span><br><span class="hljs-function">│</span><br><span class="hljs-function">└─<span class="hljs-title">HelloWorld</span></span><br><span class="hljs-function">        <span class="hljs-title">asgi.py</span></span><br><span class="hljs-function">        <span class="hljs-title">settings.py</span></span><br><span class="hljs-function">        <span class="hljs-title">urls.py</span></span><br><span class="hljs-function">        <span class="hljs-title">wsgi.py</span></span><br><span class="hljs-function">        <span class="hljs-title">__init__.py</span></span><br></code></pre></td></tr></table></figure><h4 id="目录说明：">目录说明：</h4><ul><li><strong><code>HelloWorld</code>: 项目的容器。</strong></li><li><strong><code>manage.py</code>: 一个实用的命令行工具，可让你以各种方式与该 <code>Django</code> 项目进行交互。</strong></li><li><strong><code>HelloWorld/init.py</code>: 一个空文件，告诉 Python 该目录是一个 Python 包。</strong></li><li><strong><code>HelloWorld/settings.py</code>: 该 <code>Django</code> 项目的设置/配置。</strong></li><li><strong><code>HelloWorld/urls.py</code>: 该 <code>Django</code> 项目的 URL 声明; 一份由 <code>Django</code> 驱动的网站&quot;目录&quot;。</strong></li><li><strong><code>HelloWorld/wsgi.py</code>: 一个 <code>WSGI</code> 兼容的 Web 服务器的入口，以便运行你的项目。</strong></li></ul><p><strong>接下来我们进入 <code>HelloWorld</code> 目录输入以下命令，启动服务器：</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">PS G:\四期\python\<span class="hljs-number">5</span>\test\HelloWorld&gt; python  .\manage.py runserver<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200413152839995.png" alt="image-20200413152839995"></p><p><strong>0.0.0.0 让其它电脑可连接到开发服务器，8000 为端口号。如果不说明，那么端口号默认为 8000。</strong></p><p><strong>在浏览器输入你服务器的 <code>ip</code>（这里我们输入本机 <code>IP</code> 地址： <code>**127.0.0.1:8000**</code>） 及端口号，如果正常启动，输出结果如下：</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200413153017415.png" alt="image-20200413153017415"></p><h2 id="3、视图和-URL-配置">3、视图和 URL 配置</h2><p><strong>在先前创建的 <code>HelloWorld</code> 目录下的 <code>HelloWorld</code> 目录新建一个 <code>view.py</code> 文件，并输入代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span><span class="hljs-params">(request)</span>:</span><br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">"Hello world ! "</span>)<br></code></pre></td></tr></table></figure><p><strong>接着，绑定 URL 与视图函数。打开 <a href="http://urls.py" target="_blank" rel="noopener">urls.py</a> 文件，删除原来代码，将以下代码复制粘贴到 <a href="http://urls.py" target="_blank" rel="noopener">urls.py</a> 文件中：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> view<br><span class="hljs-comment">#引用之前创建的view文件</span><br><br>urlpatterns = [<br>    path(<span class="hljs-string">'admin/'</span>, admin.site.urls),<br>    <span class="hljs-comment">#关联新创建的view.py</span><br>true<span class="hljs-comment">#在浏览器输入127.0.0.1:8000/hel1o/,输出view. py中he11o函数返回的内容。</span><br>    path(<span class="hljs-string">'hello/'</span>, view.hello)<br>    <span class="hljs-comment">#引用函数</span><br>]<br></code></pre></td></tr></table></figure><p><strong>完成后，启动 <code>Django</code> 开发服务器，并在浏览器访问打开浏览器并访问：</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200413155255661.png" alt="image-20200413155255661"></p><p><strong>我们也可以在 <code>urls.py</code>添加以下规则：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br> <br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> view<br> <br>urlpatterns = [<br>    path(<span class="hljs-string">'hello/'</span>, view.hello),<br>]<br></code></pre></td></tr></table></figure><p><em><strong><code>注意：</code>项目中如果代码有改动，服务器会自动监测代码的改动并自动重新载入，所以如果你已经启动了服务器则不需手动重启。</strong></em></p><h1>四、path() 函数</h1><p><strong>Django path() 可以接收四个参数，分别是两个必选参数：route、view 和两个可选参数：kwargs、name。</strong></p><p><strong>语法格式：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">path(route, view, kwargs=<span class="hljs-literal">None</span>, name=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><ul><li><strong><code>route</code>: 字符串，表示 <code>URL</code> 规则，与之匹配的 <code>URL</code> 会执行对应的第二个参数 <code>view</code>。</strong></li><li><strong><code>view</code>: 用于执行与正则表达式匹配的 <code>URL</code> 请求。</strong></li><li><strong><code>kwargs</code>: 视图使用的字典类型的参数。</strong></li><li><strong><code>name</code>: 用来反向获取 URL。</strong></li></ul><p><strong><code>Django2. 0</code>中可以使用 <code>re_path()</code> 方法来兼容 1.x 版本中的 <code>url()</code> 方法，一些正则表达式的规则也可以通过 <code>re_path()</code> 来实现 。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> include, re_path<br><br>urlpatterns = [<br>    re_path(<span class="hljs-string">r'^index/$'</span>, views.index, name=<span class="hljs-string">'index'</span>),<br>    re_path(<span class="hljs-string">r'^bio/(?P&lt;username&gt;\w+)/$'</span>, views.bio, name=<span class="hljs-string">'bio'</span>),<br>    re_path(<span class="hljs-string">r'^weblog/'</span>, include(<span class="hljs-string">'blog.urls'</span>)),<br>    ...<br>]<br></code></pre></td></tr></table></figure><h1>五、Django 模板</h1><p><strong>Django 模板的应用，模板是一个文本，用于分离文档的表现形式和内容。</strong></p><h2 id="模板应用实例">模板应用实例</h2><p><strong>我们接着上一章节的项目将在 HelloWorld 目录底下创建 templates 目录并建立 hello.html文件，整个目录结构如下：</strong></p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">HelloWorld/<br>|<span class="hljs-string">-- HelloWorld</span><br>|<span class="hljs-string">   </span>|<span class="hljs-string">-- __init__.py</span><br>|<span class="hljs-string">   </span>|<span class="hljs-string">-- __init__.pyc</span><br>|<span class="hljs-string">   </span>|<span class="hljs-string">-- settings.py</span><br>|<span class="hljs-string">   </span>|<span class="hljs-string">-- settings.pyc</span><br>|<span class="hljs-string">   </span>|<span class="hljs-string">-- urls.py</span><br>|<span class="hljs-string">   </span>|<span class="hljs-string">-- urls.pyc</span><br>|<span class="hljs-string">   </span>|<span class="hljs-string">-- view.py</span><br>|<span class="hljs-string">   </span>|<span class="hljs-string">-- view.pyc</span><br>|<span class="hljs-string">   </span>|<span class="hljs-string">-- wsgi.py</span><br>|<span class="hljs-string">   `-- wsgi.pyc</span><br>|<span class="hljs-string">-- manage.py</span><br><span class="hljs-string">`-- templates</span><br><span class="hljs-string">    `-- hello.html</span><br></code></pre></td></tr></table></figure><p><strong>hello.html 文件代码如下：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http">&lt;!DOCTYPE html&gt;<br>&lt;html lang="en"&gt;<br>&lt;head&gt;<br>  &lt;meta charset="UTF-8"&gt;<br>  &lt;title&gt;我的第一个Django项目&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  &lt;h1&gt;&#123;&#123; 'hello' &#125;&#125;&lt;/h1&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><strong>从模板中我们知道变量使用了双括号。</strong></p><p><strong>接下来我们需要向Django说明模板文件的路径，修改HelloWorld/settings.py，修改 TEMPLATES 中的 DIRS 为 <code>[BASE_DIR+&quot;/templates&quot;,]</code>，如下所示:d</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">...TEMPLATES = [<br>    &#123;<br>        <span class="hljs-string">'BACKEND'</span>: <span class="hljs-string">'django.template.backends.django.DjangoTemplates'</span>,<br>        <span class="hljs-string">'DIRS'</span>: [BASE_DIR+<span class="hljs-string">"/templates"</span>,],    <span class="hljs-comment"># 修改位置</span><br>        <span class="hljs-string">'APP_DIRS'</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">'OPTIONS'</span>: &#123;<br>            <span class="hljs-string">'context_processors'</span>: [<br>                <span class="hljs-string">'django.template.context_processors.debug'</span>,<br>                <span class="hljs-string">'django.template.context_processors.request'</span>,<br>                <span class="hljs-string">'django.contrib.auth.context_processors.auth'</span>,<br>                <span class="hljs-string">'django.contrib.messages.context_processors.messages'</span>,<br>            ],<br>        &#125;,<br>    &#125;,<br>]<br>...<br></code></pre></td></tr></table></figure><p><strong>我们现在修改 <code>view.py</code>，增加一个新的对象，用于向模板提交数据：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span><span class="hljs-params">(request)</span>:</span><br>    context          = &#123;&#125;<br>    context[<span class="hljs-string">'hello'</span>] = <span class="hljs-string">'Hello World!'</span><br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">'hello.html'</span>, context)<br></code></pre></td></tr></table></figure><p><strong>可以看到，我们这里使用 render 来替代之前使用的 HttpResponse。render 还使用了一个字典 context 作为参数。</strong></p><p><strong>context 字典中元素的键值 “hello” 对应了模板中的变量 “”。</strong></p><p><strong>再访问访问 <a href="http://127.0.0.1:8000/hello%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E9%A1%B5%E9%9D%A2%EF%BC%9A" target="_blank" rel="noopener">http://127.0.0.1:8000/hello，可以看到页面：</a></strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200413165003606.png" alt="image-20200413165003606"></p><h1>六、Django 模板标签</h1><h2 id="1、if-else-标签">1、if/else 标签</h2><p><strong>基本语法格式如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;% <span class="hljs-keyword">if</span> condition %&#125;<br>     ... display<br>&#123;% endif %&#125;<br></code></pre></td></tr></table></figure><p><strong>或者：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;% <span class="hljs-keyword">if</span> condition1 %&#125;<br>   ... display <span class="hljs-number">1</span><br>&#123;% <span class="hljs-keyword">elif</span> condition2 %&#125;<br>   ... display <span class="hljs-number">2</span><br>&#123;% <span class="hljs-keyword">else</span> %&#125;<br>   ... display <span class="hljs-number">3</span><br>&#123;% endif %&#125;<br></code></pre></td></tr></table></figure><p><strong>根据条件判断是否输出。if/else 支持嵌套。</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">&#123;% if %&#125; 标签接受 and ， or 或者 not 关键字来对多个变量做判断 ，或者对变量取反（ not )，例如：<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;% <span class="hljs-keyword">if</span> athlete_list <span class="hljs-keyword">and</span> coach_list %&#125;<br>     athletes 和 coaches 变量都是可用的。<br>&#123;% endif %&#125;<br></code></pre></td></tr></table></figure><h2 id="2、for-标签">2、for 标签</h2><p><strong>例如，给定一个运动员列表 athlete_list 变量，我们可以使用下面的代码来显示这个列表：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;ul&gt;<br>&#123;% <span class="hljs-keyword">for</span> athlete <span class="hljs-keyword">in</span> athlete_list %&#125;<br>    &lt;li&gt;&#123;&#123; athlete.name &#125;&#125;&lt;/li&gt;<br>&#123;% endfor %&#125;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p><strong>给标签增加一个 reversed 使得该列表被反向迭代：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;% <span class="hljs-keyword">for</span> athlete <span class="hljs-keyword">in</span> athlete_list reversed %&#125;<br>...<br>&#123;% endfor %&#125;<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">可以嵌套使用 &#123;% for %&#125; 标签：<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;% <span class="hljs-keyword">for</span> athlete <span class="hljs-keyword">in</span> athlete_list %&#125;<br>    &lt;h1&gt;&#123;&#123; athlete.name &#125;&#125;&lt;/h1&gt;<br>    &lt;ul&gt;<br>    &#123;% <span class="hljs-keyword">for</span> sport <span class="hljs-keyword">in</span> athlete.sports_played %&#125;<br>        &lt;li&gt;&#123;&#123; sport &#125;&#125;&lt;/li&gt;<br>    &#123;% endfor %&#125;<br>    &lt;/ul&gt;<br>&#123;% endfor %&#125;<br></code></pre></td></tr></table></figure><h2 id="3、ifequal-ifnotequal-标签">3、ifequal/ifnotequal 标签</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">&#123;% ifequal %&#125; 标签比较两个值，当他们相等时，显示在 &#123;% ifequal %&#125; 和 &#123;% endifequal %&#125; 之中所有的值。<br></code></pre></td></tr></table></figure></blockquote><p><strong>下面的例子比较两个模板变量 user 和 currentuser :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;% ifequal user currentuser %&#125;<br>    &lt;h1&gt;Welcome!&lt;/h1&gt;<br>&#123;% endifequal %&#125;<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">和 &#123;% if %&#125; 类似， &#123;% ifequal %&#125; 支持可选的 &#123;% else%&#125; 标签：8<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;% ifequal section <span class="hljs-string">'sitenews'</span> %&#125;<br>    &lt;h1&gt;Site News&lt;/h1&gt;<br>&#123;% <span class="hljs-keyword">else</span> %&#125;<br>    &lt;h1&gt;No News Here&lt;/h1&gt;<br>&#123;% endifequal %&#125;<br></code></pre></td></tr></table></figure><h2 id="4、注释标签">4、注释标签</h2><p><strong>Django 注释使用 。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-comment"># 这是一个注释 #&#125;</span><br></code></pre></td></tr></table></figure><h2 id="5、过滤器">5、过滤器</h2><p><strong>模板过滤器可以在变量被显示前修改它，过滤器使用管道字符，如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;&#123; name|lower &#125;&#125;<br></code></pre></td></tr></table></figure><p><strong> 变量被过滤器 lower 处理后，文档大写转换文本为小写。</strong></p><p><em><em>过滤管道可以被</em> 套接 <em>，既是说，一个过滤器管道的输出又可以作为下一个管道的输入：</em></em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;&#123; my_list|first|upper &#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>以上实例将第一个元素并将其转化为大写。</strong></p><p><strong>有些过滤器有参数。 过滤器的参数跟随冒号之后并且总是以双引号包含。 例如：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;&#123; bio|truncatewords:<span class="hljs-string">"30"</span> &#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>这个将显示变量 bio 的前30个词。</strong></p><p><strong>其他过滤器：</strong></p><ul><li><p><strong>addslashes : 添加反斜杠到任何反斜杠、单引号或者双引号前面。</strong></p></li><li><p><strong>date : 按指定的格式字符串参数格式化 date 或者 datetime 对象，实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;&#123; pub_date|date:<span class="hljs-string">"F j, Y"</span> &#125;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>length : 返回变量的长度。</strong></p></li></ul><h2 id="6、include-标签">6、include 标签</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">&#123;% include %&#125; 标签允许在模板中包含其它的模板的内容。<br></code></pre></td></tr></table></figure></blockquote><p><strong>下面这个例子都包含了 nav.html 模板：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;% include <span class="hljs-string">"nav.html"</span> %&#125;<br></code></pre></td></tr></table></figure><h1>七、模板继承</h1><p><strong>模板可以用继承的方式来实现复用。</strong></p><p><strong>接下来我们先创建之前项目的 templates 目录中添加 base.html 文件，代码如下：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs http">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;meta charset="utf-8"&gt;<br>&lt;title&gt; xgp &lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;h1&gt;Hello World!&lt;/h1&gt;<br>    &lt;p&gt;xgp Django 测试。&lt;/p&gt;<br>    &#123;% block mainbody %&#125;<br>       &lt;p&gt;original&lt;/p&gt;<br>    &#123;% endblock %&#125;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><strong>以上代码中，名为 <code>mainbody</code> 的 block 标签是可以被继承者们替换掉的部分。</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">所有的 &#123;% block %&#125; 标签告诉模板引擎，子模板可以重载这些部分。<br></code></pre></td></tr></table></figure></blockquote><p><strong>hello.html 中继承 base.html，并替换特定 block，hello.html 修改后的代码如下：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http">&#123;%extends "base.html" %&#125;<br> <br>&#123;% block mainbody %&#125;<br>&lt;p&gt;xgp 继承了 base.html 文件&lt;/p&gt;<br>&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure><p><strong>第一行代码说明 <code>hello.html</code> 继承了 <code>base.html</code> 文件。可以看到，这里相同名字的 block 标签用以替换 <code>base.html</code> 的相应 block。</strong></p><p><strong>重新访问地址 <a href="http://127.0.0.1:8000/hello%EF%BC%8C%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A" target="_blank" rel="noopener">http://127.0.0.1:8000/hello，输出结果如下：</a></strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200413175404185.png" alt="image-20200413175404185"></p><h1>八、Linux开发Django</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@python ~]# cd /opt/<br>[root@python opt]# mkdir django_prject<br>[root@python opt]# cd django_prject/<br>[root@python django_prject]# pip3 install -i https://pypi.douban.com/simple/ django<br>//下载django工具<br><br>[root@python django_prject]# django-admin startproject HelloWorld<br>//创建第一个项目（HelloWorld）<br><br>[root@python django_prject]# python3  ./manage.py runserver<br>//进入HelloWorld 目录，启动服务器<br></code></pre></td></tr></table></figure><p><strong>报错使用以下命令降低版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip3 uninstall django<br>pip3 install django==2.1.8<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据可视化之Pygal图表类型</title>
      <link href="/posts/c970.html"/>
      <url>/posts/c970.html</url>
      
        <content type="html"><![CDATA[<h1>一、pygal（图表类型Bar）</h1><p><strong>将使用Python可视化包Pygal来生成可缩放的矢量图形文件</strong></p><p><strong><a href="http://www.pygal.org/en/stable/" target="_blank" rel="noopener">pygal官方文档</a></strong></p><h2 id="1、安装pygal">1、安装pygal</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">pip install pygal -i https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure><h2 id="2、简单的python图表">2、简单的python图表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal<br>pygal.Bar()(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>)(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>).render()<br></code></pre></td></tr></table></figure><h3 id="生成svg图表">生成svg图表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pygal.Bar()(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>)(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>).render_to_file(<span class="hljs-string">"simple.svg"</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410195036567.png" alt="image-20200410195036567"></p><p><em><strong>需要查看它的源文件，才能显示图片。</strong></em></p><h2 id="3、制作多系列图标（Bar）">3、制作多系列图标（Bar）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal<br><br><span class="hljs-comment"># pygal.Bar()(1, 3, 3, 7)(1, 6, 6, 4)(5,7,8,13)(5,7,4,9).render_to_file("xgp.svg")</span><br><br>py_bar = pygal.Bar()<br>py_bar.add(<span class="hljs-string">"大标题"</span>,[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>])<br>py_bar.add(<span class="hljs-string">"小标题"</span>,[<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>])<br>py_bar.render_to_file(<span class="hljs-string">"wsd.svg"</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410195740063.png" alt="image-20200410195740063"></p><h2 id="4、堆叠图表（StackedBar）">4、堆叠图表（StackedBar）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal<br><br><span class="hljs-comment"># pygal.Bar()(1, 3, 3, 7)(1, 6, 6, 4)(5,7,8,13)(5,7,4,9).render_to_file("xgp.svg")</span><br><br>py_bar = pygal.StackedBar()<br>py_bar.add(<span class="hljs-string">"大标题"</span>,[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>])<br>py_bar.add(<span class="hljs-string">"小标题"</span>,[<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>])<br>py_bar.render_to_file(<span class="hljs-string">"wsd.svg"</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410195605126.png" alt="image-20200410195605126"></p><h2 id="5、将上面的图表水平（HorizontalStackedBar）">5、将上面的图表水平（HorizontalStackedBar）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal<br><br><span class="hljs-comment"># pygal.Bar()(1, 3, 3, 7)(1, 6, 6, 4)(5,7,8,13)(5,7,4,9).render_to_file("xgp.svg")</span><br><br>py_bar = pygal.HorizontalStackedBar()<br>py_bar.add(<span class="hljs-string">"大标题"</span>,[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>])<br>py_bar.add(<span class="hljs-string">"小标题"</span>,[<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>])<br>py_bar.render_to_file(<span class="hljs-string">"wsd.svg"</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410195907528.png" alt="image-20200410195907528"></p><h1>二、pygal（各种图表类型）</h1><h2 id="1、基本的简单线形图（Line）">1、基本的简单线形图（Line）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal<br><br><span class="hljs-comment"># pygal.Bar()(1, 3, 3, 7)(1, 6, 6, 4)(5,7,8,13)(5,7,4,9).render_to_file("xgp.svg")</span><br><br>py_bar = pygal.Line()<br>py_bar.add(<span class="hljs-string">"大标题"</span>,[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>])<br>py_bar.add(<span class="hljs-string">"小标题"</span>,[<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>])<br>py_bar.render_to_file(<span class="hljs-string">"wsd.svg"</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410201821552.png" alt="image-20200410201821552"></p><h2 id="2、Horizontal-Line">2、Horizontal Line</h2><p><strong>相同的图形但水平，范围为0-100。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal<br><br><span class="hljs-comment"># pygal.Bar()(1, 3, 3, 7)(1, 6, 6, 4)(5,7,8,13)(5,7,4,9).render_to_file("xgp.svg")</span><br><br>py_bar = pygal.HorizontalLine()<br>py_bar.add(<span class="hljs-string">"大标题"</span>,[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>])<br>py_bar.add(<span class="hljs-string">"小标题"</span>,[<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>])<br>py_bar.range = [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>]<br>py_bar.render_to_file(<span class="hljs-string">"wsd.svg"</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410202050274.png" alt="image-20200410202050274"></p><h2 id="3、Stacked">3、Stacked</h2><p><strong>相同的图形但具有堆叠值和填充渲染</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal<br><br><span class="hljs-comment"># pygal.Bar()(1, 3, 3, 7)(1, 6, 6, 4)(5,7,8,13)(5,7,4,9).render_to_file("xgp.svg")</span><br><br>py_bar = pygal.StackedLine(fill=<span class="hljs-literal">True</span>)<br>py_bar.add(<span class="hljs-string">"大标题"</span>,[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>])<br>py_bar.add(<span class="hljs-string">"小标题"</span>,[<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>])<br>py_bar.range = [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>]<br>py_bar.render_to_file(<span class="hljs-string">"wsd.svg"</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410202212443.png" alt="image-20200410202212443"></p><h2 id="4、Time">4、Time</h2><p><strong>对于与时间相关的图，只需格式化标签或使用xy图表的一种变体</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-comment"># x_label_rotation=20是指x轴标签右旋转20度，可负数，负数向左旋转</span><br>date_chart = pygal.Line(x_label_rotation=<span class="hljs-number">-20</span>)<br>date_chart.x_labels = map(<span class="hljs-keyword">lambda</span> d: d.strftime(<span class="hljs-string">'%Y-%m-%d'</span>), [<br> datetime(<span class="hljs-number">2013</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>),<br> datetime(<span class="hljs-number">2013</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>),<br> datetime(<span class="hljs-number">2013</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>),<br> datetime(<span class="hljs-number">2013</span>, <span class="hljs-number">2</span>, <span class="hljs-number">22</span>)])<br>date_chart.add(<span class="hljs-string">"Visits"</span>, [<span class="hljs-number">300</span>, <span class="hljs-number">412</span>, <span class="hljs-number">823</span>, <span class="hljs-number">672</span>])<br>date_chart.render_to_file(<span class="hljs-string">"line-time.svg"</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410202406370.png" alt="image-20200410202406370"></p><p><strong>Lambda是一个表达式，也可以是一个匿名函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span><span class="hljs-params">(x, y)</span>:</span><br>    <span class="hljs-keyword">return</span> x + y<br></code></pre></td></tr></table></figure><p><strong>在Lambda中可以这样写</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p = <span class="hljs-keyword">lambda</span> x, y: x + y<br></code></pre></td></tr></table></figure><h2 id="5、Histogram">5、Histogram</h2><h3 id="Basic">Basic</h3><p><strong>直方图是特殊条形，它为条形图取3个值：纵坐标高度，横坐标开始和横坐标结束。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal<br><br>hist = pygal.Histogram()<br>hist.add(<span class="hljs-string">'Wide bars'</span>, [(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">13</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">15</span>)])<br>hist.add(<span class="hljs-string">'Narrow bars'</span>,  [(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4.5</span>), (<span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>)])<br>hist.render_to_file(<span class="hljs-string">"histogram-basic.svg"</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410203221260.png" alt="image-20200410203221260"></p><h2 id="6、Scatter-Plot">6、Scatter Plot</h2><p><strong>禁用点和点之间的连线而获得散点图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> cos<br><br>xy_chart = pygal.XY()<br>xy_chart.title = <span class="hljs-string">'XY Cosinus'</span><br>xy_chart.add(<span class="hljs-string">'x = cos(y)'</span>, [(cos(x / <span class="hljs-number">10.</span>), x / <span class="hljs-number">10.</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">-50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">5</span>)])<br>xy_chart.add(<span class="hljs-string">'y = cos(x)'</span>, [(x / <span class="hljs-number">10.</span>, cos(x / <span class="hljs-number">10.</span>)) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">-50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">5</span>)])<br>xy_chart.add(<span class="hljs-string">'x = 1'</span>,  [(<span class="hljs-number">1</span>, <span class="hljs-number">-5</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)])<br>xy_chart.add(<span class="hljs-string">'x = -1'</span>, [(<span class="hljs-number">-1</span>, <span class="hljs-number">-5</span>), (<span class="hljs-number">-1</span>, <span class="hljs-number">5</span>)])<br>xy_chart.add(<span class="hljs-string">'y = 1'</span>,  [(<span class="hljs-number">-5</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">5</span>, <span class="hljs-number">1</span>)])<br>xy_chart.add(<span class="hljs-string">'y = -1'</span>, [(<span class="hljs-number">-5</span>, <span class="hljs-number">-1</span>), (<span class="hljs-number">5</span>, <span class="hljs-number">-1</span>)])<br>xy_chart.render_to_file(<span class="hljs-string">"xy-basic.svg"</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410203355995.png" alt="image-20200410203355995"></p><h2 id="7、Pie">7、Pie</h2><p><strong>简单的饼图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal<br><br>pie_chart = pygal.Pie()<br>pie_chart.title = <span class="hljs-string">'Browser usage in February 2012 (in %)'</span><br>pie_chart.add(<span class="hljs-string">'IE'</span>, <span class="hljs-number">19.5</span>)<br>pie_chart.add(<span class="hljs-string">'Firefox'</span>, <span class="hljs-number">36.6</span>)<br>pie_chart.add(<span class="hljs-string">'Chrome'</span>, <span class="hljs-number">36.3</span>)<br>pie_chart.add(<span class="hljs-string">'Safari'</span>, <span class="hljs-number">4.5</span>)<br>pie_chart.add(<span class="hljs-string">'Opera'</span>, <span class="hljs-number">2.3</span>)<br>pie_chart.render_to_file(<span class="hljs-string">"pie-basic.svg"</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410203646231.png" alt="image-20200410203646231"></p><h2 id="8、Multi-series-pie">8、Multi-series pie</h2><p><strong>相同的饼图，但分为子类别</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal<br><br>pie_chart = pygal.Pie()<br>pie_chart.title = <span class="hljs-string">'Browser usage by version in February 2012 (in %)'</span><br>pie_chart.add(<span class="hljs-string">'IE'</span>, [<span class="hljs-number">5.7</span>, <span class="hljs-number">10.2</span>, <span class="hljs-number">2.6</span>, <span class="hljs-number">1</span>])<br>pie_chart.add(<span class="hljs-string">'Firefox'</span>, [<span class="hljs-number">.6</span>, <span class="hljs-number">16.8</span>, <span class="hljs-number">7.4</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">1.2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1.1</span>, <span class="hljs-number">4.3</span>, <span class="hljs-number">1</span>])<br>pie_chart.add(<span class="hljs-string">'Chrome'</span>, [<span class="hljs-number">.3</span>, <span class="hljs-number">.9</span>, <span class="hljs-number">17.1</span>, <span class="hljs-number">15.3</span>, <span class="hljs-number">.6</span>, <span class="hljs-number">.5</span>, <span class="hljs-number">1.6</span>])<br>pie_chart.add(<span class="hljs-string">'Safari'</span>, [<span class="hljs-number">4.4</span>, <span class="hljs-number">.1</span>])<br>pie_chart.add(<span class="hljs-string">'Opera'</span>, [<span class="hljs-number">.1</span>, <span class="hljs-number">1.6</span>, <span class="hljs-number">.1</span>, <span class="hljs-number">.5</span>])<br>pie_chart.render_to_file(<span class="hljs-string">"pie-multi-series.svg"</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410203714833.png" alt="image-20200410203714833"></p><h2 id="9、Radar">9、Radar</h2><p><strong>简单的Kiviat图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal<br><br><span class="hljs-comment"># pygal.Bar()(1, 3, 3, 7)(1, 6, 6, 4)(5,7,8,13)(5,7,4,9).render_to_file("xgp.svg")</span><br><br>py_bar = pygal.Radar()<br>py_bar.add(<span class="hljs-string">"大标题"</span>,[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>])<br>py_bar.add(<span class="hljs-string">"小标题"</span>,[<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>])<br>py_bar.range = [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>]<br>py_bar.render_to_file(<span class="hljs-string">"wsd.svg"</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410203833741.png" alt="image-20200410203833741"></p><h2 id="10、Box">10、Box</h2><h3 id="Extremes-default">Extremes (default)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal<br><br>box_plot = pygal.Box()<br>box_plot.title = <span class="hljs-string">'V8 benchmark results'</span><br>box_plot.add(<span class="hljs-string">'Chrome'</span>, [<span class="hljs-number">6395</span>, <span class="hljs-number">8212</span>, <span class="hljs-number">7520</span>, <span class="hljs-number">7218</span>, <span class="hljs-number">12464</span>, <span class="hljs-number">1660</span>, <span class="hljs-number">2123</span>, <span class="hljs-number">8607</span>])<br>box_plot.add(<span class="hljs-string">'Firefox'</span>, [<span class="hljs-number">7473</span>, <span class="hljs-number">8099</span>, <span class="hljs-number">11700</span>, <span class="hljs-number">2651</span>, <span class="hljs-number">6361</span>, <span class="hljs-number">1044</span>, <span class="hljs-number">3797</span>, <span class="hljs-number">9450</span>])<br>box_plot.add(<span class="hljs-string">'Opera'</span>, [<span class="hljs-number">3472</span>, <span class="hljs-number">2933</span>, <span class="hljs-number">4203</span>, <span class="hljs-number">5229</span>, <span class="hljs-number">5810</span>, <span class="hljs-number">1828</span>, <span class="hljs-number">9013</span>, <span class="hljs-number">4669</span>])<br>box_plot.add(<span class="hljs-string">'IE'</span>, [<span class="hljs-number">43</span>, <span class="hljs-number">41</span>, <span class="hljs-number">59</span>, <span class="hljs-number">79</span>, <span class="hljs-number">144</span>, <span class="hljs-number">136</span>, <span class="hljs-number">34</span>, <span class="hljs-number">102</span>])<br>box_plot.render_to_file(<span class="hljs-string">"box-extremes.svg"</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410203936368.png" alt="image-20200410203936368"></p><h2 id="11、Dot">11、Dot</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal<br><br><span class="hljs-comment"># pygal.Bar()(1, 3, 3, 7)(1, 6, 6, 4)(5,7,8,13)(5,7,4,9).render_to_file("xgp.svg")</span><br><br>py_bar = pygal.Dot(x_label_rotation=<span class="hljs-number">30</span>)<br>py_bar.add(<span class="hljs-string">"大标题"</span>,[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>])<br>py_bar.add(<span class="hljs-string">"小标题"</span>,[<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>])<br>py_bar.range = [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>]<br>py_bar.render_to_file(<span class="hljs-string">"wsd.svg"</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410204030917.png" alt="image-20200410204030917"></p><h2 id="12、Funnel">12、Funnel</h2><p><strong>漏斗图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal<br><br>funnel_chart = pygal.Funnel()<br>funnel_chart.title = <span class="hljs-string">'V8 benchmark results'</span><br>funnel_chart.x_labels = [<span class="hljs-string">'Richards'</span>, <span class="hljs-string">'DeltaBlue'</span>, <span class="hljs-string">'Crypto'</span>, <span class="hljs-string">'RayTrace'</span>, <span class="hljs-string">'EarleyBoyer'</span>, <span class="hljs-string">'RegExp'</span>, <span class="hljs-string">'Splay'</span>, <span class="hljs-string">'NavierStokes'</span>]<br>funnel_chart.add(<span class="hljs-string">'Opera'</span>, [<span class="hljs-number">3472</span>, <span class="hljs-number">2933</span>, <span class="hljs-number">4203</span>, <span class="hljs-number">5229</span>, <span class="hljs-number">5810</span>, <span class="hljs-number">1828</span>, <span class="hljs-number">9013</span>, <span class="hljs-number">4669</span>])<br>funnel_chart.add(<span class="hljs-string">'Firefox'</span>, [<span class="hljs-number">7473</span>, <span class="hljs-number">8099</span>, <span class="hljs-number">11700</span>, <span class="hljs-number">2651</span>, <span class="hljs-number">6361</span>, <span class="hljs-number">1044</span>, <span class="hljs-number">3797</span>, <span class="hljs-number">9450</span>])<br>funnel_chart.add(<span class="hljs-string">'Chrome'</span>, [<span class="hljs-number">6395</span>, <span class="hljs-number">8212</span>, <span class="hljs-number">7520</span>, <span class="hljs-number">7218</span>, <span class="hljs-number">12464</span>, <span class="hljs-number">1660</span>, <span class="hljs-number">2123</span>, <span class="hljs-number">8607</span>])<br>funnel_chart.render_to_file(<span class="hljs-string">'funnel-basic.svg'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410204250966.png" alt="image-20200410204250966"></p><h2 id="13、SolidGauge">13、SolidGauge</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal<br><br>gauge = pygal.SolidGauge(inner_radius=<span class="hljs-number">0.70</span>)<br><span class="hljs-comment"># 百分格式</span><br>percent_formatter = <span class="hljs-keyword">lambda</span> x: <span class="hljs-string">'&#123;:.10g&#125;%'</span>.format(x)<br><span class="hljs-comment"># 美元格式</span><br>dollar_formatter = <span class="hljs-keyword">lambda</span> x: <span class="hljs-string">'&#123;:.10g&#125;$'</span>.format(x)<br>gauge.value_formatter = percent_formatter<br><br>gauge.add(<span class="hljs-string">'Series 1'</span>, [&#123;<span class="hljs-string">'value'</span>: <span class="hljs-number">225000</span>, <span class="hljs-string">'max_value'</span>: <span class="hljs-number">1275000</span>&#125;],<br>          formatter=dollar_formatter)<br>gauge.add(<span class="hljs-string">'Series 2'</span>, [&#123;<span class="hljs-string">'value'</span>: <span class="hljs-number">110</span>, <span class="hljs-string">'max_value'</span>: <span class="hljs-number">100</span>&#125;])<br>gauge.add(<span class="hljs-string">'Series 3'</span>, [&#123;<span class="hljs-string">'value'</span>: <span class="hljs-number">3</span>&#125;])<br>gauge.add(<br>    <span class="hljs-string">'Series 4'</span>, [<br>        &#123;<span class="hljs-string">'value'</span>: <span class="hljs-number">51</span>, <span class="hljs-string">'max_value'</span>: <span class="hljs-number">100</span>&#125;,<br>        &#123;<span class="hljs-string">'value'</span>: <span class="hljs-number">12</span>, <span class="hljs-string">'max_value'</span>: <span class="hljs-number">100</span>&#125;])<br>gauge.add(<span class="hljs-string">'Series 5'</span>, [&#123;<span class="hljs-string">'value'</span>: <span class="hljs-number">79</span>, <span class="hljs-string">'max_value'</span>: <span class="hljs-number">100</span>&#125;])<br>gauge.add(<span class="hljs-string">'Series 6'</span>, <span class="hljs-number">99</span>)<br>gauge.add(<span class="hljs-string">'Series 7'</span>, [&#123;<span class="hljs-string">'value'</span>: <span class="hljs-number">100</span>, <span class="hljs-string">'max_value'</span>: <span class="hljs-number">100</span>&#125;])<br>gauge.render_to_file(<span class="hljs-string">'solidgauge-normal.svg'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410204353786.png" alt="image-20200410204353786"></p><h2 id="14、Gauge">14、Gauge</h2><p><strong>仪表图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal<br><br>gauge_chart = pygal.Gauge(human_readable=<span class="hljs-literal">True</span>)<br>gauge_chart.title = <span class="hljs-string">'DeltaBlue V8 benchmark results'</span><br>gauge_chart.range = [<span class="hljs-number">0</span>, <span class="hljs-number">10000</span>]<br>gauge_chart.add(<span class="hljs-string">'Chrome'</span>, <span class="hljs-number">8212</span>)<br>gauge_chart.add(<span class="hljs-string">'Firefox'</span>, <span class="hljs-number">8099</span>)<br>gauge_chart.add(<span class="hljs-string">'Opera'</span>, <span class="hljs-number">2933</span>)<br>gauge_chart.add(<span class="hljs-string">'IE'</span>, <span class="hljs-number">41</span>)<br>gauge_chart.render_to_file(<span class="hljs-string">'gauge-basic.svg'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410204511013.png" alt="image-20200410204511013"></p><h2 id="15、Maps">15、Maps</h2><h3 id="World-map">World map</h3><h4 id="安装">安装</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install pygal_maps_world<br></code></pre></td></tr></table></figure><h4 id="Countries">Countries</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal<br><br>worldmap_chart = pygal.maps.world.World()<br>worldmap_chart.title = <span class="hljs-string">'Some countries'</span><br>worldmap_chart.add(<span class="hljs-string">'C countries'</span>, [<span class="hljs-string">'cn'</span>, <span class="hljs-string">'ca'</span>, <span class="hljs-string">'ch'</span>, <span class="hljs-string">'cg'</span>])<br>worldmap_chart.add(<span class="hljs-string">'F countries'</span>, [<span class="hljs-string">'fr'</span>, <span class="hljs-string">'fi'</span>])<br>worldmap_chart.add(<span class="hljs-string">'M countries'</span>, [<span class="hljs-string">'ma'</span>, <span class="hljs-string">'mc'</span>, <span class="hljs-string">'md'</span>, <span class="hljs-string">'me'</span>, <span class="hljs-string">'mg'</span>,<br>                                   <span class="hljs-string">'mk'</span>, <span class="hljs-string">'ml'</span>, <span class="hljs-string">'mm'</span>, <span class="hljs-string">'mn'</span>, <span class="hljs-string">'mo'</span>,<br>                                   <span class="hljs-string">'mr'</span>, <span class="hljs-string">'mt'</span>, <span class="hljs-string">'mu'</span>, <span class="hljs-string">'mv'</span>, <span class="hljs-string">'mw'</span>,<br>                                   <span class="hljs-string">'mx'</span>, <span class="hljs-string">'my'</span>, <span class="hljs-string">'mz'</span>])<br>worldmap_chart.add(<span class="hljs-string">'U countries'</span>, [<span class="hljs-string">'ua'</span>, <span class="hljs-string">'ug'</span>, <span class="hljs-string">'us'</span>, <span class="hljs-string">'uy'</span>, <span class="hljs-string">'uz'</span>])<br>worldmap_chart.render_to_file(<span class="hljs-string">'world-map-countries.svg'</span>)<br></code></pre></td></tr></table></figure><h2 id="image-2020041021153284316、Continents"><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410211532843.png" alt="image-20200410211532843">16、Continents</h2><p><strong>访问各大洲</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal<br><br>supra = pygal.maps.world.SupranationalWorld()<br>supra.add(<span class="hljs-string">'Asia'</span>, [(<span class="hljs-string">'asia'</span>, <span class="hljs-number">1</span>)])<br>supra.add(<span class="hljs-string">'Europe'</span>, [(<span class="hljs-string">'europe'</span>, <span class="hljs-number">1</span>)])<br>supra.add(<span class="hljs-string">'Africa'</span>, [(<span class="hljs-string">'africa'</span>, <span class="hljs-number">1</span>)])<br>supra.add(<span class="hljs-string">'North america'</span>, [(<span class="hljs-string">'north_america'</span>, <span class="hljs-number">1</span>)])<br>supra.add(<span class="hljs-string">'South america'</span>, [(<span class="hljs-string">'south_america'</span>, <span class="hljs-number">1</span>)])<br>supra.add(<span class="hljs-string">'Oceania'</span>, [(<span class="hljs-string">'oceania'</span>, <span class="hljs-number">1</span>)])<br>supra.add(<span class="hljs-string">'Antartica'</span>, [(<span class="hljs-string">'antartica'</span>, <span class="hljs-number">1</span>)])<br>supra.render_to_file(<span class="hljs-string">'world-map-continents.svg'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410211724152.png" alt="image-20200410211724152"></p><h1>三、掷色子</h1><p><strong>分析点数概率并且绘制直方图</strong></p><h2 id="1、创建源文件（引用所需）">1、创建源文件（引用所需）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Die</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-string">"""表示一个色子的类"""</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,num_sides=<span class="hljs-number">6</span>)</span>:</span><br>        <span class="hljs-string">"""色子默认为6面"""</span><br>        self.num_sides=num_sides<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">roll</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""返回一个位于1和色子面数之间的随机值"""</span><br>        <span class="hljs-keyword">return</span> randint(<span class="hljs-number">1</span>, self.num_sides)<br></code></pre></td></tr></table></figure><h2 id="2、创建一个色子">2、创建一个色子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Pygal.示例.die <span class="hljs-keyword">import</span> Die<br><span class="hljs-keyword">import</span> pygal<br><span class="hljs-comment"># 创建一个色子</span><br>die = Die()<br><br><span class="hljs-comment"># 掷几次色子，并且将结果存储在一个列表中</span><br>results = []<br><span class="hljs-keyword">for</span> roll <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):<br>    r = die.roll()<br>    results.append(r)<br><br>print(results)<br><br><span class="hljs-comment"># 分析结果</span><br>frequencies = []<br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, die.num_sides+<span class="hljs-number">1</span>):<br>    frequency = results.count(value)<br>    frequencies.append(frequency)<br><br>print(frequencies)<br><br><span class="hljs-comment"># 对结果进行可视化</span><br>hist = pygal.Bar()<br>hist.title=<span class="hljs-string">'掷色子1000次的结果'</span><br>hist.x_labels = [<span class="hljs-string">'1'</span>,<span class="hljs-string">'2'</span>,<span class="hljs-string">'3'</span>,<span class="hljs-string">'4'</span>,<span class="hljs-string">'5'</span>,<span class="hljs-string">'6'</span>]<br>hist.x_title=<span class="hljs-string">'Result'</span><br>hist.y_title=<span class="hljs-string">'概率'</span><br><br>hist.add(<span class="hljs-string">'D6'</span>,frequencies)<br>hist.render_to_file(<span class="hljs-string">'die_visual.svg'</span>)<br></code></pre></td></tr></table></figure><p><strong>使用浏览器打开这个文件，鼠标指向数据，可以看到显示了标题“D6”， x轴的坐标以及y轴坐标。</strong></p><p><strong>可以发现，六个数字出现的频次是差不多的（理论上概率是1/6， 随着实验次数的增加，趋势越来越明显）</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410204948255.png" alt="image-20200410204948255"></p><h2 id="3、同时掷两个骰子">3、同时掷两个骰子</h2><p><strong>稍微改下代码就行，再实例化一个骰子</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Pygal.示例.die <span class="hljs-keyword">import</span> Die<br><span class="hljs-keyword">import</span> pygal<br><span class="hljs-comment"># 创建两个色子</span><br>die_1 = Die()<br>die_2 = Die()<br><br><span class="hljs-comment"># 掷几次色子，并且将结果存储在一个列表中</span><br>results = []<br><span class="hljs-keyword">for</span> roll <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):<br>    r = die_1.roll() + die_2.roll()<br>    results.append(r)<br>print(results)<br><br><span class="hljs-comment"># 分析结果</span><br>frequencies = []<br>max_result= die_1.num_sides + die_2.num_sides<br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, max_result + <span class="hljs-number">1</span>):<br>    frequency = results.count(value)<br>    frequencies.append(frequency)<br><br>print(frequencies)<br><br><span class="hljs-comment"># 对结果进行可视化</span><br>hist = pygal.Bar()<br>hist.title=<span class="hljs-string">'掷色子1000次的结果'</span><br>hist.x_labels = [<span class="hljs-string">'2'</span>,<span class="hljs-string">'3'</span>,<span class="hljs-string">'4'</span>,<span class="hljs-string">'5'</span>,<span class="hljs-string">'6'</span>,<span class="hljs-string">'7'</span>,<span class="hljs-string">'8'</span>,<span class="hljs-string">'9'</span>,<span class="hljs-string">'10'</span>,<span class="hljs-string">'11'</span>,<span class="hljs-string">'12'</span>]<br>hist.x_title=<span class="hljs-string">'Result'</span><br>hist.y_title=<span class="hljs-string">'概率'</span><br><br>hist.add(<span class="hljs-string">'D6 + D6'</span>,frequencies)<br>hist.render_to_file(<span class="hljs-string">'die_visualc.svg'</span>)****<br></code></pre></td></tr></table></figure><p><strong>从图中可以看出，两个骰子之和为7的次数最多，和为2的次数最少。因为能掷出2的只有一种情况 -&gt; (1, 1);而掷出7的情况有(1, 6) , (2, 5), (3, 4), (4, 3), (5, 2), (6, 1)共6种情况，其余数字的情况都没有7的多，故掷得7得概率最大。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410205059337.png" alt="image-20200410205059337"></p><h2 id="4、同时掷两个骰子（六和十的）">4、同时掷两个骰子（六和十的）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Pygal.示例.die <span class="hljs-keyword">import</span> Die<br><span class="hljs-keyword">import</span> pygal<br><span class="hljs-comment"># 创建两个色子</span><br>die_1 = Die()<br>die_2 = Die(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># 掷几次色子，并且将结果存储在一个列表中</span><br>results = []<br><span class="hljs-keyword">for</span> roll <span class="hljs-keyword">in</span> range(<span class="hljs-number">50000</span>):<br>    r = die_1.roll() + die_2.roll()<br>    results.append(r)<br>print(results)<br><br><span class="hljs-comment"># 分析结果</span><br>frequencies = []<br>max_result= die_1.num_sides + die_2.num_sides<br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, max_result + <span class="hljs-number">1</span>):<br>    frequency = results.count(value)<br>    frequencies.append(frequency)<br><br>print(frequencies)<br><br><span class="hljs-comment"># 对结果进行可视化</span><br>hist = pygal.Bar()<br>hist.title=<span class="hljs-string">'掷色子1000次的结果'</span><br><span class="hljs-comment"># hist.x_labels = ['2','3','4','5','6','7','8','9','10','11','12','13','14','15','16']</span><br>hist.x_labels = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,max_result+<span class="hljs-number">1</span>)]<br>hist.x_title=<span class="hljs-string">'Result'</span><br>hist.y_title=<span class="hljs-string">'概率'</span><br>hist.add(<span class="hljs-string">'D6 + D6'</span>,frequencies)<br>hist.render_to_file(<span class="hljs-string">'die_visualcc.svg'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410205340452.png" alt="image-20200410205340452"></p><h1>四、Python处理csv文件</h1><p><strong>CSV(Comma-Separated Values)即逗号分隔值，可以用Excel打开查看。由于是纯文本，任何编辑器也都可打开。与Excel文件不同，CSV文件中：</strong></p><ul><li><strong>值没有类型，所有值都是字符串</strong></li><li><strong>不能指定字体颜色等样式</strong></li><li><strong>不能指定单元格的宽高，不能合并单元格</strong></li><li><strong>没有多个工作表</strong></li><li><strong>不能嵌入图像图表</strong></li></ul><p><strong>在CSV文件中，以<code>,</code>作为分隔符，分隔两个单元格。像这样<code>a,,c</code>表示单元格<code>a</code>和单元格<code>c</code>之间有个空白的单元格。依此类推。</strong></p><p><strong>不是每个逗号都表示单元格之间的分界。所以即使CSV是纯文本文件，也坚持使用专门的模块进行处理。Python内置了csv模块。先看看一个简单的例子。</strong></p><h2 id="1、从CSV文件中读取数据">1、从CSV文件中读取数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br><br>filename = <span class="hljs-string">'F:/Jupyter Notebook/matplotlib_pygal_csv_json/sitka_weather_2014.csv'</span><br><span class="hljs-keyword">with</span> open(filename) <span class="hljs-keyword">as</span> f:<br>    reader = csv.reader(f)<br>    print(list(reader))<br></code></pre></td></tr></table></figure><p><code>**data</code>不能直接打印，list(data)最外层是list，里层的每一行数据都在一个list中，有点像这样**</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[[<span class="hljs-string">'name'</span>, <span class="hljs-string">'age'</span>], [<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'14'</span>], [<span class="hljs-string">'Tom'</span>, <span class="hljs-string">'23'</span>], ...]<br></code></pre></td></tr></table></figure><p><strong>于是我们可以这样访问到Bob的年龄<code>reader[1][1]</code>, 在for循环中遍历如下</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br><br>filename = <span class="hljs-string">'F:/Jupyter Notebook/matplotlib_pygal_csv_json/sitka_weather_2014.csv'</span><br><span class="hljs-keyword">with</span> open(filename) <span class="hljs-keyword">as</span> f:<br>    reader = csv.reader(f)<br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader:<br>        <span class="hljs-comment"># 行号从1开始</span><br>        print(reader.line_num, row)<br></code></pre></td></tr></table></figure><h5 id="截取一部分输出"><strong>截取一部分输出</strong></h5><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">1 [<span class="hljs-string">'AKST'</span>, <span class="hljs-string">'Max TemperatureF]</span><br><span class="hljs-string">2 ['</span>2014-1-1<span class="hljs-string">', '</span>46<span class="hljs-string">', '</span>42<span class="hljs-string">', '</span>37<span class="hljs-string">', '</span>40<span class="hljs-string">', '</span>38<span class="hljs-string">', '</span>36<span class="hljs-string">', '</span>97<span class="hljs-string">', 138'</span>]<br>...<br></code></pre></td></tr></table></figure></blockquote><p><strong>前面的数字是行号，从1开始，可以用<code>reader.line_num</code>获取。</strong></p><p><strong>要注意的是，reader只能被遍历一次。由于reader是可迭代对象，可以使用<code>next</code>方法一次获取一行。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br><br>filename = <span class="hljs-string">'F:/Jupyter Notebook/matplotlib_pygal_csv_json/sitka_weather_2014.csv'</span><br><span class="hljs-keyword">with</span> open(filename) <span class="hljs-keyword">as</span> f:<br>    reader = csv.reader(f)<br>    <span class="hljs-comment"># 读取一行，下面的reader中已经没有该行了</span><br>    head_row = next(reader)<br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader:<br>        <span class="hljs-comment"># 行号从2开始</span><br>        print(reader.line_num, row)<br></code></pre></td></tr></table></figure><h2 id="2、写数据到csv文件中">2、写数据到csv文件中</h2><p><strong>有reader可以读取，当然也有writer可以写入。一次写入一行，一次写入多行都可以。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br><br><span class="hljs-comment"># 使用数字和字符串的数字都可以</span><br>datas = [[<span class="hljs-string">'name'</span>, <span class="hljs-string">'age'</span>],<br>         [<span class="hljs-string">'Bob'</span>, <span class="hljs-number">14</span>],<br>         [<span class="hljs-string">'Tom'</span>, <span class="hljs-number">23</span>],<br>        [<span class="hljs-string">'Jerry'</span>, <span class="hljs-string">'18'</span>]]<br><br><span class="hljs-keyword">with</span> open(<span class="hljs-string">'example.csv'</span>, <span class="hljs-string">'w'</span>, newline=<span class="hljs-string">''</span>) <span class="hljs-keyword">as</span> f:<br>    writer = csv.writer(f)<br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> datas:<br>        writer.writerow(row)<br>        <br>    <span class="hljs-comment"># 还可以写入多行</span><br>    writer.writerows(datas)<br></code></pre></td></tr></table></figure><p><strong>如果不指定<code>newline=''</code>,则每写入一行将有一空行被写入。上面的代码生成如下内容。</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">name,age<br>Bob,14<br>Tom,23<br>Jerry,18<br>name,age<br>Bob,14<br>Tom,23<br>Jerry,18<br></code></pre></td></tr></table></figure></blockquote><h2 id="3、DictReader和DictWriter对象">3、DictReader和DictWriter对象</h2><p><strong>使用DictReader可以像操作字典那样获取数据，把表的第一行（一般是标头）作为key。可访问每一行中那个某个key对应的数据。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br><br>filename = <span class="hljs-string">'F:/Jupyter Notebook/matplotlib_pygal_csv_json/sitka_weather_2014.csv'</span><br><span class="hljs-keyword">with</span> open(filename) <span class="hljs-keyword">as</span> f:<br>    reader = csv.DictReader(f)<br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader:<br>        <span class="hljs-comment"># Max TemperatureF是表第一行的某个数据，作为key</span><br>        max_temp = row[<span class="hljs-string">'Max TemperatureF'</span>]<br>        print(max_temp)<br></code></pre></td></tr></table></figure><p><strong>使用DictWriter类，可以写入字典形式的数据，同样键也是标头（表格第一行）。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br><br>headers = [<span class="hljs-string">'name'</span>, <span class="hljs-string">'age'</span>]<br><br>datas = [&#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'age'</span>:<span class="hljs-number">23</span>&#125;,<br>        &#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'Jerry'</span>, <span class="hljs-string">'age'</span>:<span class="hljs-number">44</span>&#125;,<br>        &#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'Tom'</span>, <span class="hljs-string">'age'</span>:<span class="hljs-number">15</span>&#125;<br>        ]<br><br><span class="hljs-keyword">with</span> open(<span class="hljs-string">'example.csv'</span>, <span class="hljs-string">'w'</span>, newline=<span class="hljs-string">''</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-comment"># 标头在这里传入，作为第一行数据</span><br>    writer = csv.DictWriter(f, headers)<br>    writer.writeheader()<br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> datas:<br>        writer.writerow(row)<br>        <br>    <span class="hljs-comment"># 还可以写入多行</span><br>    writer.writerows(datas)<br></code></pre></td></tr></table></figure><h2 id="4、统计每月最高温度">4、统计每月最高温度</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br>plt.rcParams[<span class="hljs-string">'font.sans-serif'</span>]=[<span class="hljs-string">'SimHei'</span>] <span class="hljs-comment">#用来正常显示中文标签</span><br>plt.rcParams[<span class="hljs-string">'axes.unicode_minus'</span>]=<span class="hljs-literal">False</span> <span class="hljs-comment">#用来正常显示负号</span><br><br>filename = <span class="hljs-string">'Python-sitka_weather_2014.csv'</span><br><span class="hljs-keyword">with</span> open(filename) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-comment"># 调用reader()函数，将f对象作为参数传递给它，从而创建一个与该文件相关联的阅读器对象</span><br>    reader = csv.reader(f)<br>    <span class="hljs-comment"># 返回文件中的下一行</span><br>    header_row = next(reader)<br>    <span class="hljs-comment"># print(header_row)</span><br><br>    <span class="hljs-comment"># for index, column_header in enumerate(header_row):</span><br>    <span class="hljs-comment">#     print(index, column_header)</span><br><br>    highs = []<br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader:<br>        <span class="hljs-comment"># 使用int()将字符串转换为数字，让matplotlib能够读取它们</span><br>        high = int(row[<span class="hljs-number">1</span>])<br>        highs.append(high)<br><br>    print(highs)<br><br>    <span class="hljs-comment"># 根据数据绘制图形</span><br>    fig = plt.figure(dpi=<span class="hljs-number">128</span>, figsize=(<span class="hljs-number">16</span>, <span class="hljs-number">9</span>))<br>    plt.plot(highs, c=<span class="hljs-string">'red'</span>)<br><br>    <span class="hljs-comment"># 设置图形格式</span><br>    plt.title(<span class="hljs-string">'2014年最高气温'</span>, fontsize=<span class="hljs-number">24</span>)<br>    plt.xlabel(<span class="hljs-string">''</span>, fontsize=<span class="hljs-number">16</span>)<br>    plt.ylabel(<span class="hljs-string">'最高气温'</span>, fontsize=<span class="hljs-number">16</span>)<br>    plt.tick_params(axis=<span class="hljs-string">'both'</span>, which=<span class="hljs-string">'major'</span>, labelsize=<span class="hljs-number">16</span>)<br><br>    plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410210903957.png" alt="image-20200410210903957"></p><h2 id="5、统计每月最高温度和最低温度">5、统计每月最高温度和最低温度</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br>plt.rcParams[<span class="hljs-string">'font.sans-serif'</span>] = [<span class="hljs-string">'SimHei'</span>]  <span class="hljs-comment"># 用来正常显示中文标签</span><br>plt.rcParams[<span class="hljs-string">'axes.unicode_minus'</span>] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 用来正常显示负号</span><br><br>filename = <span class="hljs-string">'Python-sitka_weather_2014.csv'</span><br><span class="hljs-keyword">with</span> open(filename) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-comment"># 调用reader()函数，将f对象作为参数传递给它，从而创建一个与该文件相关联的阅读器对象</span><br>    reader = csv.reader(f)<br>    <span class="hljs-comment"># 返回文件中的下一行</span><br>    header_row = next(reader)<br>    <span class="hljs-comment"># print(header_row)</span><br><br>    dates, highs, lows = [], [], []<br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader:<br>        current_date = datetime.strptime(row[<span class="hljs-number">0</span>], <span class="hljs-string">"%Y/%m/%d"</span>)<br>        dates.append(current_date)<br>        <span class="hljs-comment"># print(current_date)</span><br><br>        <span class="hljs-comment"># 使用int()将字符串转换为数字，让matplotlib能够读取它们</span><br>        high = int(row[<span class="hljs-number">1</span>])<br>        highs.append(high)<br><br>        low = int(row[<span class="hljs-number">3</span>])<br>        lows.append(low)<br><br>    <span class="hljs-comment"># print(highs)</span><br><br>    <span class="hljs-comment"># 根据数据绘制图形</span><br>    fig = plt.figure(dpi=<span class="hljs-number">128</span>, figsize=(<span class="hljs-number">16</span>, <span class="hljs-number">9</span>))<br>    plt.plot(dates, highs, c=<span class="hljs-string">'red'</span>, alpha=<span class="hljs-number">0.5</span>)<br>    plt.plot(dates, lows, c=<span class="hljs-string">'blue'</span>, alpha=<span class="hljs-number">0.5</span>)<br>    plt.fill_between(dates, highs, lows, facecolor=<span class="hljs-string">'blue'</span>, alpha=<span class="hljs-number">0.1</span>)<br><br>    <span class="hljs-comment"># 设置图形格式</span><br>    plt.title(<span class="hljs-string">'2014年最高气温'</span>, fontsize=<span class="hljs-number">24</span>)<br>    plt.xlabel(<span class="hljs-string">''</span>, fontsize=<span class="hljs-number">16</span>)<br>    <span class="hljs-comment"># 绘制斜线标签</span><br>    fig.autofmt_xdate()<br>    plt.ylabel(<span class="hljs-string">'最高气温'</span>, fontsize=<span class="hljs-number">16</span>)<br>    plt.tick_params(axis=<span class="hljs-string">'both'</span>, which=<span class="hljs-string">'major'</span>, labelsize=<span class="hljs-number">16</span>)<br><br>    plt.show()<br>    <span class="hljs-comment"># plt.savefig('hish.png')</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200410210953610.png" alt="image-20200410210953610"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据可视化</title>
      <link href="/posts/ed47.html"/>
      <url>/posts/ed47.html</url>
      
        <content type="html"><![CDATA[<h1>数据可视化</h1><h2 id="1-matplotlib">1.matplotlib</h2><p><strong>Matplotlib 可能是 Python 2D-绘图领域使用最广泛的套件。它能让使用者很轻松地将数据图形化，并且提供多样化的输出格式。这里将会探索 matplotlib 的常见用法。</strong></p><p><strong>安装matplotib</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">pip install -i https://pypi.douban.com/simple/ matplotlib<br></code></pre></td></tr></table></figure><p><strong>测试matplotib</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd">$python<br>&gt;&gt;&gt;import matplotlib<br>&gt;&gt;&gt;<br>#没有错误信息输出，则表示matplotlib安装成功。<br></code></pre></td></tr></table></figure><p><strong>这个可能pyCharm识别不了，可以进行以下操作</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409194840174.png" alt="image-20200409194840174"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409194847258.png" alt="image-20200409194847258"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409194959961.png" alt="image-20200409194959961"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409195008919.png" alt="image-20200409195008919"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409194856667.png" alt="image-20200409194856667"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409194928981.png" alt="image-20200409194928981"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409194940573.png" alt="image-20200409194940573"></p><h3 id="实例一（线条）">实例一（线条）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>squares = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">16</span>,<span class="hljs-number">25</span>]<br>plt.plot(squares)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409195942625.png" alt="image-20200409195942625"></p><h3 id="实例二（线条）">实例二（线条）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>squares = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">16</span>,<span class="hljs-number">25</span>]<br><br><span class="hljs-comment">#修改线条的宽度: linewidth</span><br>plt.plot(squares,linewidth=<span class="hljs-number">5</span>)<br><br><span class="hljs-comment">#设置图标的标题，并且给坐标轴加上标签</span><br>plt.title(<span class="hljs-string">'queares number'</span>,fontsize=<span class="hljs-number">24</span>)<br>plt.xlabel(<span class="hljs-string">'value'</span>,fontsize=<span class="hljs-number">24</span>)<br>plt.ylabel(<span class="hljs-string">'quares value'</span>,fontsize=<span class="hljs-number">24</span>)<br><br><span class="hljs-comment"># 设置刻度标记的大小</span><br>plt.tick_params(axis=<span class="hljs-string">"both"</span>,labelsize=<span class="hljs-number">14</span>)<br><br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409200005226.png" alt="image-20200409200005226"></p><h3 id="实例三（线条）">实例三（线条）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment">#捕入值</span><br>input_values = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-comment">#输出值</span><br>squares = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">16</span>,<span class="hljs-number">25</span>]<br><br><span class="hljs-comment">#修改线条的宽度: linewidth</span><br>plt.plot(input_values,squares,linewidth=<span class="hljs-number">5</span>)<br><br><span class="hljs-comment">#设置图标的标题，并且给坐标轴加上标签</span><br>plt.title(<span class="hljs-string">'queares number'</span>,fontsize=<span class="hljs-number">24</span>)<br>plt.xlabel(<span class="hljs-string">'value'</span>,fontsize=<span class="hljs-number">24</span>)<br>plt.ylabel(<span class="hljs-string">'quares value'</span>,fontsize=<span class="hljs-number">24</span>)<br><br><span class="hljs-comment"># 设置刻度标记的大小</span><br>plt.tick_params(axis=<span class="hljs-string">"both"</span>,labelsize=<span class="hljs-number">14</span>)<br><br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409200137816.png" alt="image-20200409200137816"></p><h3 id="实例四（单点）">实例四（单点）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.scatter(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409200205964.png" alt="image-20200409200205964"></p><h3 id="实例五（单点）">实例五（单点）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.scatter(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br><br><span class="hljs-comment">#设置图标标题,并且给坐标轴加上标签</span><br>plt.title(<span class="hljs-string">'squares numbers'</span>,fontsize=<span class="hljs-number">24</span>)<br>plt.xlabel(<span class="hljs-string">'value'</span>,fontsize=<span class="hljs-number">24</span>)<br>plt.ylabel(<span class="hljs-string">'squares of value'</span>,fontsize=<span class="hljs-number">14</span>)<br><br><span class="hljs-comment"># 设置刻度标记的大小</span><br>plt.tick_params(axis=<span class="hljs-string">"both"</span>,which=<span class="hljs-string">'major'</span>,labelsize=<span class="hljs-number">14</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409200205964.png" alt="image-20200409200205964"></p><h3 id="实例六（多点）">实例六（多点）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>x_values = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>y_values = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">16</span>,<span class="hljs-number">25</span>]<br>plt.scatter(x_values,y_values,s=<span class="hljs-number">100</span>)<br><br><span class="hljs-comment">#设置图标标题,并且给坐标轴加上标签</span><br>plt.title(<span class="hljs-string">'squares numbers'</span>,fontsize=<span class="hljs-number">24</span>)<br>plt.xlabel(<span class="hljs-string">'value'</span>,fontsize=<span class="hljs-number">24</span>)<br>plt.ylabel(<span class="hljs-string">'squares of value'</span>,fontsize=<span class="hljs-number">14</span>)<br><br><span class="hljs-comment"># 设置刻度标记的大小</span><br>plt.tick_params(axis=<span class="hljs-string">"both"</span>,which=<span class="hljs-string">'major'</span>,labelsize=<span class="hljs-number">14</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409200429931.png" alt="image-20200409200429931"></p><h3 id="实例七（多点连线）">实例七（多点连线）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>x_values = list(range(<span class="hljs-number">1</span>,<span class="hljs-number">1001</span>))<br>y_values = [x ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> x_values]<br>plt.scatter(x_values,y_values,s=<span class="hljs-number">100</span>)<br><br><span class="hljs-comment">#设置图标标题,并且给坐标轴加上标签</span><br>plt.title(<span class="hljs-string">'squares numbers'</span>,fontsize=<span class="hljs-number">24</span>)<br>plt.xlabel(<span class="hljs-string">'value'</span>,fontsize=<span class="hljs-number">24</span>)<br>plt.ylabel(<span class="hljs-string">'squares of value'</span>,fontsize=<span class="hljs-number">14</span>)<br><br><span class="hljs-comment"># 设置刻度标记的大小</span><br>plt.tick_params(axis=<span class="hljs-string">"both"</span>,which=<span class="hljs-string">'major'</span>,labelsize=<span class="hljs-number">14</span>)<br><br><span class="hljs-comment">#设置每个坐标轴的取值范围</span><br>plt.axis([<span class="hljs-number">0</span>,<span class="hljs-number">1100</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1100000</span>])<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409200418203.png" alt="image-20200409200418203"></p><h4 id="分析一下">分析一下</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409202507456.png" alt="image-20200409202507456"></p><h3 id="实例八（多点连线、自定义颜色）">实例八（多点连线、自定义颜色）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自定义颜色</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>x_values = list(range(<span class="hljs-number">1</span>,<span class="hljs-number">1001</span>))<br>y_values = [x ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> x_values]<br>plt.scatter(x_values,y_values,c=<span class="hljs-string">'red'</span>,s=<span class="hljs-number">100</span>)<br><br><span class="hljs-comment">#设置图标标题,并且给坐标轴加上标签</span><br>plt.title(<span class="hljs-string">'squares numbers'</span>,fontsize=<span class="hljs-number">24</span>)<br>plt.xlabel(<span class="hljs-string">'value'</span>,fontsize=<span class="hljs-number">24</span>)<br>plt.ylabel(<span class="hljs-string">'squares of value'</span>,fontsize=<span class="hljs-number">14</span>)<br><br><span class="hljs-comment"># 设置刻度标记的大小</span><br>plt.tick_params(axis=<span class="hljs-string">"both"</span>,which=<span class="hljs-string">'major'</span>,labelsize=<span class="hljs-number">14</span>)<br><br><span class="hljs-comment">#设置每个坐标轴的取值范围</span><br>plt.axis([<span class="hljs-number">0</span>,<span class="hljs-number">1100</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1100000</span>])<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409200405247.png" alt="image-20200409200405247"></p><h3 id="实例九（多点连线、自定义颜色）">实例九（多点连线、自定义颜色）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自定义颜色</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>x_values = list(range(<span class="hljs-number">1</span>,<span class="hljs-number">1001</span>))<br>y_values = [x ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> x_values]<br><br><span class="hljs-comment">#参数c表示紅绿蓝3种颜色的分量</span><br>plt.scatter(x_values,y_values,c=(<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.2</span>),s=<span class="hljs-number">100</span>)<br><br><span class="hljs-comment">#设置图标标题,并且给坐标轴加上标签</span><br>plt.title(<span class="hljs-string">'squares numbers'</span>,fontsize=<span class="hljs-number">24</span>)<br>plt.xlabel(<span class="hljs-string">'value'</span>,fontsize=<span class="hljs-number">24</span>)<br>plt.ylabel(<span class="hljs-string">'squares of value'</span>,fontsize=<span class="hljs-number">14</span>)<br><br><span class="hljs-comment"># 设置刻度标记的大小</span><br>plt.tick_params(axis=<span class="hljs-string">"both"</span>,which=<span class="hljs-string">'major'</span>,labelsize=<span class="hljs-number">14</span>)<br><br><span class="hljs-comment">#设置每个坐标轴的取值范围</span><br>plt.axis([<span class="hljs-number">0</span>,<span class="hljs-number">1100</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1100000</span>])<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409200355195.png" alt="image-20200409200355195"></p><h3 id="实例十（多点连线、自定义颜色，渐变色，保存图片）">实例十（多点连线、自定义颜色，渐变色，保存图片）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自定义颜色</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>x_values = list(range(<span class="hljs-number">1</span>,<span class="hljs-number">1001</span>))<br>y_values = [x ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> x_values]<br><br><span class="hljs-comment"># 将参数c设置为一个y值的列表，使用参数cmap告诉plot使用哪个颜色映射</span><br>plt.scatter(x_values,y_values,c=y_values,cmap=plt.cm.Blues,s=<span class="hljs-number">100</span>)<br><br><span class="hljs-comment">#设置图标标题,并且给坐标轴加上标签</span><br>plt.title(<span class="hljs-string">'squares numbers'</span>,fontsize=<span class="hljs-number">24</span>)<br>plt.xlabel(<span class="hljs-string">'value'</span>,fontsize=<span class="hljs-number">24</span>)<br>plt.ylabel(<span class="hljs-string">'squares of value'</span>,fontsize=<span class="hljs-number">14</span>)<br><br><span class="hljs-comment"># 设置刻度标记的大小</span><br>plt.tick_params(axis=<span class="hljs-string">"both"</span>,which=<span class="hljs-string">'major'</span>,labelsize=<span class="hljs-number">14</span>)<br><br><span class="hljs-comment">#设置每个坐标轴的取值范围</span><br>plt.axis([<span class="hljs-number">0</span>,<span class="hljs-number">1100</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1100000</span>])<br><br><span class="hljs-comment"># plt.show()</span><br><br><span class="hljs-comment"># bbox_inches='tight' --&gt;将图表多余的空白区域哉减掉</span><br><span class="hljs-comment"># 保存图片为squares1.png</span><br>plt.savefig(<span class="hljs-string">'squares1.png'</span>,bbox_inches=<span class="hljs-string">'tight'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409200506542.png" alt="image-20200409200506542"></p><h3 id="实例十一（多点连线、自定义颜色，渐变色，保存图片）">实例十一（多点连线、自定义颜色，渐变色，保存图片）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># plt.scatter(2,4)</span><br>x_values = list(range(<span class="hljs-number">1</span>, <span class="hljs-number">1001</span>))<br>y_values = [x ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> x_values]<br><span class="hljs-comment"># plt.scatter(x_values, y_values,c='red', s=50)</span><br><span class="hljs-comment">## 参数c表示红绿蓝3种颜色的分量</span><br><span class="hljs-comment"># plt.scatter(x_values, y_values,c=(0,0.5,0.2), s=50)</span><br><span class="hljs-comment">## 将参数c设置为一个y值的列表，使用参数cmap告诉plot使用哪个颜色映射</span><br>plt.scatter(x_values, y_values,c=y_values,cmap=plt.cm.Reds, s=<span class="hljs-number">50</span>)<br><br><span class="hljs-comment"># 设置图标标题，并且 给坐标轴加上标签</span><br>plt.title(<span class="hljs-string">'squares numbers'</span>, fontsize=<span class="hljs-number">24</span>)<br>plt.xlabel(<span class="hljs-string">'value'</span>, fontsize=<span class="hljs-number">24</span>)<br>plt.ylabel(<span class="hljs-string">'square of value'</span>, fontsize=<span class="hljs-number">14</span>)<br><br><span class="hljs-comment"># 设置刻度的标记大小</span><br>plt.tick_params(axis=<span class="hljs-string">'both'</span>, which=<span class="hljs-string">'major'</span>, labelsize=<span class="hljs-number">14</span>)<br><br><span class="hljs-comment"># 设置每个坐标轴的取值范围</span><br>plt.axis([<span class="hljs-number">0</span>,<span class="hljs-number">1100</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1100000</span>])<br><br><span class="hljs-comment"># plt.show()</span><br><span class="hljs-comment"># 保存图片为squares22.png</span><br>plt.savefig(<span class="hljs-string">'squares22.png'</span>,bbox_inches=<span class="hljs-string">'tight'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409200518698.png" alt="image-20200409200518698"></p><h2 id="2、随机漫步">2、随机漫步</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 随机漫步</span><br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choice<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomWalk</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-string">"""-个生成随机漫步数据的类"""</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,num_points=<span class="hljs-number">5000</span>)</span>:</span><br>        <span class="hljs-string">"""初始化随机漫步的属性"""</span><br>        self.num_points = num_points<br>        <br>        <span class="hljs-comment"># 所有随机漫步都始于(0,0)</span><br>        self.x_values = [<span class="hljs-number">0</span>]<br>        self.y_values = [<span class="hljs-number">0</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fill_walk</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""计算随机漫步包含的所有点"""</span><br>        <br>        <span class="hljs-comment"># 不断漫步,直到列表达到指定的长度</span><br>        <span class="hljs-keyword">while</span> len(self.x_values) &lt; self.num_points:<br>            <span class="hljs-comment"># 决定前进方向以及沿着这个方向前进的距离</span><br>            x_direction = choice([<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>])<br>            x_distance = choice([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>            x_step = x_direction * x_distance<br>            <br>            y_direction = choice([<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>])<br>            y_distance = choice([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>            y_step = y_direction * y_distance<br>            <br>            <span class="hljs-comment"># 拒绝原地踏步</span><br>            <span class="hljs-keyword">if</span> x_step == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> y_step ==<span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">continue</span><br>                <br>            <span class="hljs-comment"># 计算下一个点的x和y的值</span><br>            next_x =self.x_values[<span class="hljs-number">-1</span>] + x_step<br>            next_y =self.y_values[<span class="hljs-number">-1</span>] + y_step<br>            <br>            <span class="hljs-comment">#</span><br>            <span class="hljs-comment"># 不断漫步，直到列表达到指定的长度</span><br>        <span class="hljs-keyword">while</span> len(self.x_values) &lt; self.num_points:<br>            <span class="hljs-comment"># 决定前进方向以及沿着这个方向前进的距离</span><br>            x_direction = choice([<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>])<br>            x_distance = choice([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br>            x_step = x_direction * x_distance<br><br>            y_direction = choice([<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>])<br>            y_distance = choice([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br>            y_step = y_direction * y_distance<br><br>            <span class="hljs-comment"># 决绝原地踏步</span><br>            <span class="hljs-keyword">if</span> x_step == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> y_step == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">continue</span><br><br>            <span class="hljs-comment"># 计算下一个点的x和y的值</span><br>            next_x = self.x_values[<span class="hljs-number">-1</span>] + x_step<br>            next_y = self.y_values[<span class="hljs-number">-1</span>] + y_step<br><br>            <span class="hljs-comment">#</span><br>            self.x_values.append(next_x)<br>            self.y_values.append(next_y)<br></code></pre></td></tr></table></figure><h3 id="实例一（随机漫步，自定义颜色）">实例一（随机漫步，自定义颜色）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> 示例.mpl_squares <span class="hljs-keyword">import</span> RandomWalk<br><br><span class="hljs-comment"># 创建RandomWalk实例，并且将包含的点都绘制出来</span><br>rw = RandomWalk()<br>rw.fill_walk()<br><br><span class="hljs-comment"># 给点着色</span><br>point_numbers = list(range(rw.num_points))<br>plt.scatter(rw.x_values, rw.y_values, c=point_numbers,cmap=plt.cm.Greens,s=<span class="hljs-number">15</span>)<br><br><span class="hljs-comment"># 隐藏边框</span><br><span class="hljs-comment"># plt.axes().get_xaxis().set_visible(False)</span><br><span class="hljs-comment"># plt.axes().get_yaxis().set_visible(False)</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409201208904.png" alt="image-20200409201208904"></p><h3 id="实例二（随机漫步，是否继续生成）">实例二（随机漫步，是否继续生成）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> 示例.mpl_squares <span class="hljs-keyword">import</span> RandomWalk<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 创建RandomWalk实例，并且将包含的点都绘制出来</span><br>    rw = RandomWalk()<br>    rw.fill_walk()<br>    plt.scatter(rw.x_values, rw.y_values, s=<span class="hljs-number">15</span>)<br><br>    <span class="hljs-comment"># 隐藏边框</span><br>    <span class="hljs-comment"># plt.axes().get_xaxis().set_visible(False)</span><br>    <span class="hljs-comment"># plt.axes().get_yaxis().set_visible(False)</span><br><br>    plt.show()<br><br>    keep_running = input(<span class="hljs-string">'继续漫步吗？(y/n)'</span>)<br>    <span class="hljs-keyword">if</span> keep_running == <span class="hljs-string">'n'</span>:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409201429594.png" alt="image-20200409201429594"></p><h5 id="输出结果：">输出结果：</h5><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">继续漫步吗？(<span class="hljs-symbol">y</span>/n) <span class="hljs-symbol">y</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409201352417.png" alt="image-20200409201352417"></p><h3 id="实例三（随机漫步，控制点数，多点之间的距离）">实例三（随机漫步，控制点数，多点之间的距离）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> 示例.mpl_squares <span class="hljs-keyword">import</span> RandomWalk<br><br><span class="hljs-comment"># 创建RandomWalk实例，并且将包含的点都绘制出来</span><br>rw = RandomWalk()<br>rw.fill_walk()<br><br><span class="hljs-comment"># 给点着色</span><br>point_numbers = list(range(rw.num_points))<br><br>plt.scatter(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,c=<span class="hljs-string">'green'</span>,s=<span class="hljs-number">100</span>)<br>plt.scatter(rw.x_values[<span class="hljs-number">-1</span>],rw.y_values[<span class="hljs-number">-1</span>],c=<span class="hljs-string">'red'</span>,s=<span class="hljs-number">100</span>)<br><br><span class="hljs-comment"># plt.scatter(rw.x_values, rw.y_values, c=point_numbers,cmap=plt.cm.Greens,s=15)</span><br><br><span class="hljs-comment"># 隐藏边框</span><br><span class="hljs-comment"># plt.axes().get_xaxis().set_visible(False)</span><br><span class="hljs-comment"># plt.axes().get_yaxis().set_visible(False)</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409201720296.png" alt="image-20200409201720296"></p><h3 id="实例四（随机漫步，控制点数（控制多点之间的距离）-自定义点数）">实例四（随机漫步，控制点数（控制多点之间的距离）+自定义点数）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> 示例.mpl_squares <span class="hljs-keyword">import</span> RandomWalk<br><br><span class="hljs-comment"># 创建RandomWalk实例，并且将包含的点都绘制出来</span><br>rw = RandomWalk(<span class="hljs-number">500000</span>)<br>rw.fill_walk()<br><br><span class="hljs-comment"># 给点着色</span><br>point_numbers = list(range(rw.num_points))<br><br>plt.scatter(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,c=<span class="hljs-string">'green'</span>,s=<span class="hljs-number">100</span>)<br>plt.scatter(rw.x_values[<span class="hljs-number">-1</span>],rw.y_values[<span class="hljs-number">-1</span>],c=<span class="hljs-string">'red'</span>,s=<span class="hljs-number">100</span>)<br>plt.scatter(rw.x_values, rw.y_values, c=point_numbers,cmap=plt.cm.Blues,s=<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 隐藏边框</span><br><span class="hljs-comment"># plt.axes().get_xaxis().set_visible(False)</span><br><span class="hljs-comment"># plt.axes().get_yaxis().set_visible(False)</span><br><br>plt.figure(dpi=<span class="hljs-number">128</span>, figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">6</span>))<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409201922267.png" alt="image-20200409201922267"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python文本文件的（读、写、追加）</title>
      <link href="/posts/5641.html"/>
      <url>/posts/5641.html</url>
      
        <content type="html"><![CDATA[<h1>一、open() 函数</h1><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409164411124.png" alt="image-20200409164411124"></p><p><strong>Python open() 函数用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。</strong></p><p><strong>注意：使用 open() 函数一定要保证关闭文件对象，即调用 close() 函数。</strong></p><p><strong>open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">open(file, mode=<span class="hljs-string">'r'</span>)<br></code></pre></td></tr></table></figure><p><strong>完整的语法格式为：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">open(file, mode=<span class="hljs-string">'r'</span>, buffering=<span class="hljs-number">-1</span>, encoding=<span class="hljs-literal">None</span>, errors=<span class="hljs-literal">None</span>, newline=<span class="hljs-literal">None</span>, closefd=<span class="hljs-literal">True</span>, opener=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><ul><li><strong>file: 必需，文件路径（相对或者绝对路径）。</strong></li><li><strong>mode: 可选，文件打开模式</strong></li><li><strong>buffering: 设置缓冲</strong></li><li><strong>encoding: 一般使用utf8</strong></li><li><strong>errors: 报错级别</strong></li><li><strong>newline: 区分换行符</strong></li><li><strong>closefd: 传入的file参数类型</strong></li><li><strong>opener:</strong></li></ul><p><strong>mode 参数有：</strong></p><table><thead><tr><th style="text-align:left"><strong>模式</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>t</strong></td><td style="text-align:left"><strong>文本模式 (默认)。</strong></td></tr><tr><td style="text-align:left"><strong>x</strong></td><td style="text-align:left"><strong>写模式，新建一个文件，如果该文件已存在则会报错。</strong></td></tr><tr><td style="text-align:left"><strong>b</strong></td><td style="text-align:left"><strong>二进制模式。</strong></td></tr><tr><td style="text-align:left"><strong>+</strong></td><td style="text-align:left"><strong>打开一个文件进行更新(可读可写)。</strong></td></tr><tr><td style="text-align:left"><strong>U</strong></td><td style="text-align:left"><strong>通用换行模式（不推荐）。</strong></td></tr><tr><td style="text-align:left"><strong>r</strong></td><td style="text-align:left"><strong>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</strong></td></tr><tr><td style="text-align:left"><strong>rb</strong></td><td style="text-align:left"><strong>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</strong></td></tr><tr><td style="text-align:left"><strong>r+</strong></td><td style="text-align:left"><strong>打开一个文件用于读写。文件指针将会放在文件的开头。</strong></td></tr><tr><td style="text-align:left"><strong>rb+</strong></td><td style="text-align:left"><strong>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</strong></td></tr><tr><td style="text-align:left"><strong>w</strong></td><td style="text-align:left"><strong>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</strong></td></tr><tr><td style="text-align:left"><strong>wb</strong></td><td style="text-align:left"><strong>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</strong></td></tr><tr><td style="text-align:left"><strong>w+</strong></td><td style="text-align:left"><strong>打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</strong></td></tr><tr><td style="text-align:left"><strong>wb+</strong></td><td style="text-align:left"><strong>以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</strong></td></tr><tr><td style="text-align:left"><strong>a</strong></td><td style="text-align:left"><strong>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</strong></td></tr><tr><td style="text-align:left"><strong>ab</strong></td><td style="text-align:left"><strong>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</strong></td></tr><tr><td style="text-align:left"><strong>a+</strong></td><td style="text-align:left"><strong>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</strong></td></tr><tr><td style="text-align:left"><strong>ab+</strong></td><td style="text-align:left"><strong>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</strong></td></tr></tbody></table><p><strong>默认为文本模式，如果要以二进制模式打开，加上 <code>b</code> 。</strong></p><h2 id="1、写入和读取文件">1、写入和读取文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">content = <span class="hljs-string">'Python与Linux自动化运维'</span><br><span class="hljs-keyword">with</span> open(<span class="hljs-string">'read.txt'</span>,mode=<span class="hljs-string">'w'</span>,encoding=<span class="hljs-string">'utf-8'</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(content)<br><br><span class="hljs-keyword">with</span> open(<span class="hljs-string">'read.txt'</span>,mode=<span class="hljs-string">'r'</span>,encoding=<span class="hljs-string">'utf-8'</span>) <span class="hljs-keyword">as</span> f:<br>    print(f.read())<br></code></pre></td></tr></table></figure><h5 id="执行结果：">执行结果：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Python与Linux自动化运维<br></code></pre></td></tr></table></figure></blockquote><h5 id="分析一下">分析一下</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409165114726.png" alt="image-20200409165114726"></p><h2 id="2、追加文件内容">2、追加文件内容</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> open(<span class="hljs-string">'read.txt'</span>,mode=<span class="hljs-string">'a'</span>,encoding=<span class="hljs-string">'utf-8'</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">'\nhello word\t你好'</span>)<br><br><span class="hljs-keyword">with</span> open(<span class="hljs-string">'read.txt'</span>,mode=<span class="hljs-string">'r'</span>,encoding=<span class="hljs-string">'utf-8'</span>) <span class="hljs-keyword">as</span> f:<br>    print(f.read())<br></code></pre></td></tr></table></figure><h5 id="输出结果">输出结果</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">Python与Linux自动化运维<br>hello word你好<br></code></pre></td></tr></table></figure></blockquote><h5 id="分析一下-2">分析一下</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409165418680.png" alt="image-20200409165418680"></p><h2 id="3、读取图片和视频（二进制）">3、读取图片和视频（二进制）</h2><h3 id="（1）图片">（1）图片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">img = <span class="hljs-string">''</span><br><span class="hljs-keyword">with</span> open(<span class="hljs-string">r"E:\软件\360壁纸\323244.jpg"</span>,mode=<span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:<br>    img = f.read()<br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'11.jpg'</span>,mode=<span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f1:<br>        f1.write(img)<br></code></pre></td></tr></table></figure><h5 id="可查看到读取图片">可查看到读取图片</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409165712927.png" alt="image-20200409165712927"></p><h3 id="（2）视频">（2）视频</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> open(<span class="hljs-string">r'C:\Users\huawei\Desktop\11.ts'</span>,mode=<span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:<br>    video = f.read()<br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'11.ts'</span>,mode=<span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f1:<br>        f1.write(video)<br></code></pre></td></tr></table></figure><h5 id="可查看到读取视频（需在文件路径中查看）">可查看到读取视频（需在文件路径中查看）</h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409165900486.png" alt="image-20200409165900486"></p><p><strong>点开即可查看视频</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409165936540.png" alt="image-20200409165936540"></p><h1>二、文件的异常</h1><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409170506285.png" alt="image-20200409170506285"></p><h2 id="1、什么是异常？">1、什么是异常？</h2><p><strong>异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。</strong></p><p><strong>一般情况下，在Python无法正常处理程序时就会发生一个异常。</strong></p><p><strong>异常是Python对象，表示一个错误。</strong></p><p><strong>当Python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。</strong></p><h2 id="2、异常处理">2、异常处理</h2><p><strong>捕捉异常可以使用try/except语句。</strong></p><p><strong>try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。</strong></p><p><strong>如果你不想在异常发生时结束你的程序，只需在try里捕获它。</strong></p><h4 id="语法："><strong>语法：</strong></h4><p><strong>以下为简单的<em>try…except…else</em>的语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>&lt;语句&gt;        <span class="hljs-comment">#运行别的代码</span><br><span class="hljs-keyword">except</span> &lt;名字&gt;：<br>&lt;语句&gt;        <span class="hljs-comment">#如果在try部份引发了'name'异常</span><br><span class="hljs-keyword">except</span> &lt;名字&gt;，&lt;数据&gt;:<br>&lt;语句&gt;        <span class="hljs-comment">#如果引发了'name'异常，获得附加的数据</span><br><span class="hljs-keyword">else</span>:<br>&lt;语句&gt;        <span class="hljs-comment">#如果没有异常发生</span><br></code></pre></td></tr></table></figure><p><strong>try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。</strong></p><ul><li><strong>如果当try后的语句执行时发生异常，python就跳回到try并执行第一个匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。</strong></li><li><strong>如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印默认的出错信息）。</strong></li><li><strong>如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。</strong></li></ul><h3 id="（1）异常处理">（1）异常处理</h3><p><strong>你可以不带任何异常类型使用except，如下实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    正常的操作<br>   ......................<br><span class="hljs-keyword">except</span>:<br>    发生异常，执行这块代码<br>   ......................<br><span class="hljs-keyword">else</span>:<br>    如果没有异常执行这块代码<br></code></pre></td></tr></table></figure><p><strong>以上方式try-except语句捕获所有发生的异常。但这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息。因为它捕获所有的异常。</strong></p><h3 id="实例">实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment">#正常的代码</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">r'E:\软件\360壁纸\32324.jpg'</span>,mode=<span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:<br>        img = f.read()<br>        <span class="hljs-keyword">with</span> open(<span class="hljs-string">'b.jpg'</span>,mode=<span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f1:<br>            f1.write(img)<br><span class="hljs-keyword">except</span> FileNotFoundError:<br>    <span class="hljs-comment">#出现错误后执行的代码</span><br>    print(<span class="hljs-string">'文件路径错误'</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果：">输出结果：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">文件路径错误<br></code></pre></td></tr></table></figure></blockquote><h3 id="（2）0做除数的错误">（2）0做除数的错误</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 根据运算符号确定运算规则</span><br>    <span class="hljs-keyword">if</span> opt == <span class="hljs-string">'+'</span>:<br>        result = one + two<br>    <span class="hljs-keyword">elif</span> opt == <span class="hljs-string">'-'</span>:<br>        result = one - two<br>    <span class="hljs-keyword">elif</span> opt == <span class="hljs-string">'*'</span>:<br>        result = one * two<br>    <span class="hljs-keyword">elif</span> opt == <span class="hljs-string">'/'</span>:<br>        <span class="hljs-keyword">if</span> two ==<span class="hljs-number">0</span>:<br>            print(<span class="hljs-string">'0不能做除数'</span>)<br>        result = one /two<br><br>    print(result)<br><span class="hljs-keyword">except</span> ZeroDivisionError:<br>    print(<span class="hljs-string">'需不能做除数!'</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果：-2">输出结果：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">请输入第一个数:<span class="hljs-number">1</span><br>请输入运算符号:/<br>请输入第二个数:<span class="hljs-number">0</span><br><span class="hljs-number">0</span>不能做除数<br>需不能做除数!<br></code></pre></td></tr></table></figure></blockquote><h3 id="（3）索引溢出的错误">（3）索引溢出的错误</h3><p><strong>使用except而带多种异常类型</strong></p><p><strong>你也可以使用相同的except语句来处理多个异常信息，如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    正常的操作<br>   ......................<br><span class="hljs-keyword">except</span>(Exception1[, Exception2[,...ExceptionN]]]):<br>   发生以上多个异常中的一个，执行这块代码<br>   ......................<br><span class="hljs-keyword">else</span>:<br>    如果没有异常执行这块代码<br></code></pre></td></tr></table></figure><h3 id="实例-2">实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    num = input(<span class="hljs-string">'请输入数字'</span>)<br>    <span class="hljs-keyword">print</span> (num+str(<span class="hljs-number">10</span>))<br><span class="hljs-keyword">except</span> BaseException:<br>    print(<span class="hljs-string">'输入类型错误! '</span>)<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'hello'</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果：-3">输出结果：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">请输入数字<span class="hljs-number">11</span><br><span class="hljs-number">1110</span><br>hello<br></code></pre></td></tr></table></figure></blockquote><h3 id="（4）try-finally-语句">（4）try-finally 语句</h3><p><strong>try-finally 语句无论是否发生异常都将执行最后的代码。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409191132230.png" alt="image-20200409191132230"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>&lt;语句&gt;<br><span class="hljs-keyword">finally</span>:<br>&lt;语句&gt;    <span class="hljs-comment">#退出try时总会执行</span><br><span class="hljs-keyword">raise</span><br></code></pre></td></tr></table></figure><h3 id="实例-3">实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    fh = open(<span class="hljs-string">"testfile"</span>, <span class="hljs-string">"w"</span>)<br>    fh.write(<span class="hljs-string">"这是一个测试文件，用于测试异常!!"</span>)<br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">"Error: 没有找到文件或读取文件失败"</span><br></code></pre></td></tr></table></figure><h5 id="输出结果：-4">输出结果：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">$ python test.py <br>Error: 没有找到文件或读取文件失败<br></code></pre></td></tr></table></figure></blockquote><h3 id="同样的例子也可以写成如下方式：">同样的例子也可以写成如下方式：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    fh = open(<span class="hljs-string">"testfile"</span>, <span class="hljs-string">"w"</span>)<br>    <span class="hljs-keyword">try</span>:<br>        fh.write(<span class="hljs-string">"这是一个测试文件，用于测试异常!!"</span>)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-keyword">print</span> <span class="hljs-string">"关闭文件"</span><br>        fh.close()<br><span class="hljs-keyword">except</span> IOError:<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">"Error: 没有找到文件或读取文件失败"</span><br></code></pre></td></tr></table></figure><p><strong>当在try块中抛出一个异常，立即执行finally块代码。</strong></p><p><strong>finally块中的所有语句执行后，异常被再次触发，并执行except块代码。</strong></p><p><strong>参数的内容不同于异常。</strong></p><h3 id="（5）抛出异常">（5）抛出异常</h3><p><strong>Python 使用 raise 语句抛出一个指定的异常。</strong></p><p><strong>raise语法格式如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">raise</span> [Exception [, args [, traceback]]]<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409191346593.png" alt="image-20200409191346593"></p><h5 id="以下实例如果-x-大于-5-就触发异常"><strong>以下实例如果 x 大于 5 就触发异常:</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">10</span><br><span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">5</span>:<br>    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'x 不能大于 5。x 的值为: &#123;&#125;'</span>.format(x))<br></code></pre></td></tr></table></figure><h5 id="执行以上代码会触发异常："><strong>执行以上代码会触发异常：</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Traceback (most recent call last):<br>  File <span class="hljs-string">"test.py"</span>, line <span class="hljs-number">3</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'x 不能大于 5。x 的值为: &#123;&#125;'</span>.format(x))<br>Exception: x 不能大于 <span class="hljs-number">5</span>。x 的值为: <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。</strong></p><p><strong>如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">raise</span> NameError(<span class="hljs-string">'HiThere'</span>)<br>    <span class="hljs-keyword">except</span> NameError:<br>        print(<span class="hljs-string">'An exception flew by!'</span>)<br>        <span class="hljs-keyword">raise</span><br>   <br>An exception flew by!<br>Traceback (most recent call last):<br>  File "&lt;stdin&gt;", line 2, in ?<br>NameError: HiThere<br></code></pre></td></tr></table></figure><h2 id="3、异常类型">3、异常类型</h2><p><strong>一个异常可以带上参数，可作为输出的异常信息参数。</strong></p><p><strong>你可以通过except语句来捕获异常的参数，如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    正常的操作<br>   ......................<br><span class="hljs-keyword">except</span> ExceptionType, Argument:<br>    你可以在这输出 Argument 的值...<br></code></pre></td></tr></table></figure><p><strong>变量接收的异常值通常包含在异常的语句中。在元组的表单中变量可以接收一个或者多个值。</strong></p><p><strong>元组通常包含错误字符串，错误数字，错误位置。</strong></p><table><thead><tr><th style="text-align:left"><strong>异常名称</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><strong>BaseException</strong></td><td style="text-align:left"><strong>所有异常的基类</strong></td></tr><tr><td style="text-align:left"><strong>SystemExit</strong></td><td style="text-align:left"><strong>解释器请求退出</strong></td></tr><tr><td style="text-align:left"><strong>KeyboardInterrupt</strong></td><td style="text-align:left"><strong>用户中断执行(通常是输入^C)</strong></td></tr><tr><td style="text-align:left"><strong>Exception</strong></td><td style="text-align:left"><strong>常规错误的基类</strong></td></tr><tr><td style="text-align:left"><strong>StopIteration</strong></td><td style="text-align:left"><strong>迭代器没有更多的值</strong></td></tr><tr><td style="text-align:left"><strong>GeneratorExit</strong></td><td style="text-align:left"><strong>生成器(generator)发生异常来通知退出</strong></td></tr><tr><td style="text-align:left"><strong>StandardError</strong></td><td style="text-align:left"><strong>所有的内建标准异常的基类</strong></td></tr><tr><td style="text-align:left"><strong>ArithmeticError</strong></td><td style="text-align:left"><strong>所有数值计算错误的基类</strong></td></tr><tr><td style="text-align:left"><strong>FloatingPointError</strong></td><td style="text-align:left"><strong>浮点计算错误</strong></td></tr><tr><td style="text-align:left"><strong>OverflowError</strong></td><td style="text-align:left"><strong>数值运算超出最大限制</strong></td></tr><tr><td style="text-align:left"><strong>ZeroDivisionError</strong></td><td style="text-align:left"><strong>除(或取模)零 (所有数据类型)</strong></td></tr><tr><td style="text-align:left"><strong>AssertionError</strong></td><td style="text-align:left"><strong>断言语句失败</strong></td></tr><tr><td style="text-align:left"><strong>AttributeError</strong></td><td style="text-align:left"><strong>对象没有这个属性</strong></td></tr><tr><td style="text-align:left"><strong>EOFError</strong></td><td style="text-align:left"><strong>没有内建输入,到达EOF 标记</strong></td></tr><tr><td style="text-align:left"><strong>EnvironmentError</strong></td><td style="text-align:left"><strong>操作系统错误的基类</strong></td></tr><tr><td style="text-align:left"><strong>IOError</strong></td><td style="text-align:left"><strong>输入/输出操作失败</strong></td></tr><tr><td style="text-align:left"><strong>OSError</strong></td><td style="text-align:left"><strong>操作系统错误</strong></td></tr><tr><td style="text-align:left"><strong>WindowsError</strong></td><td style="text-align:left"><strong>系统调用失败</strong></td></tr><tr><td style="text-align:left"><strong>ImportError</strong></td><td style="text-align:left"><strong>导入模块/对象失败</strong></td></tr><tr><td style="text-align:left"><strong>LookupError</strong></td><td style="text-align:left"><strong>无效数据查询的基类</strong></td></tr><tr><td style="text-align:left"><strong>IndexError</strong></td><td style="text-align:left"><strong>序列中没有此索引(index)</strong></td></tr><tr><td style="text-align:left"><strong>KeyError</strong></td><td style="text-align:left"><strong>映射中没有这个键</strong></td></tr><tr><td style="text-align:left"><strong>MemoryError</strong></td><td style="text-align:left"><strong>内存溢出错误(对于Python 解释器不是致命的)</strong></td></tr><tr><td style="text-align:left"><strong>NameError</strong></td><td style="text-align:left"><strong>未声明/初始化对象 (没有属性)</strong></td></tr><tr><td style="text-align:left"><strong>UnboundLocalError</strong></td><td style="text-align:left"><strong>访问未初始化的本地变量</strong></td></tr><tr><td style="text-align:left"><strong>ReferenceError</strong></td><td style="text-align:left"><strong>弱引用(Weak reference)试图访问已经垃圾回收了的对象</strong></td></tr><tr><td style="text-align:left"><strong>RuntimeError</strong></td><td style="text-align:left"><strong>一般的运行时错误</strong></td></tr><tr><td style="text-align:left"><strong>NotImplementedError</strong></td><td style="text-align:left"><strong>尚未实现的方法</strong></td></tr><tr><td style="text-align:left"><strong>SyntaxError</strong></td><td style="text-align:left"><strong>Python 语法错误</strong></td></tr><tr><td style="text-align:left"><strong>IndentationError</strong></td><td style="text-align:left"><strong>缩进错误</strong></td></tr><tr><td style="text-align:left"><strong>TabError</strong></td><td style="text-align:left"><strong>Tab 和空格混用</strong></td></tr><tr><td style="text-align:left"><strong>SystemError</strong></td><td style="text-align:left"><strong>一般的解释器系统错误</strong></td></tr><tr><td style="text-align:left"><strong>TypeError</strong></td><td style="text-align:left"><strong>对类型无效的操作</strong></td></tr><tr><td style="text-align:left"><strong>ValueError</strong></td><td style="text-align:left"><strong>传入无效的参数</strong></td></tr><tr><td style="text-align:left"><strong>UnicodeError</strong></td><td style="text-align:left"><strong>Unicode 相关的错误</strong></td></tr><tr><td style="text-align:left"><strong>UnicodeDecodeError</strong></td><td style="text-align:left"><strong>Unicode 解码时的错误</strong></td></tr><tr><td style="text-align:left"><strong>UnicodeEncodeError</strong></td><td style="text-align:left"><strong>Unicode 编码时错误</strong></td></tr><tr><td style="text-align:left"><strong>UnicodeTranslateError</strong></td><td style="text-align:left"><strong>Unicode 转换时错误</strong></td></tr><tr><td style="text-align:left"><strong>Warning</strong></td><td style="text-align:left"><strong>警告的基类</strong></td></tr><tr><td style="text-align:left"><strong>DeprecationWarning</strong></td><td style="text-align:left"><strong>关于被弃用的特征的警告</strong></td></tr><tr><td style="text-align:left"><strong>FutureWarning</strong></td><td style="text-align:left"><strong>关于构造将来语义会有改变的警告</strong></td></tr><tr><td style="text-align:left"><strong>OverflowWarning</strong></td><td style="text-align:left"><strong>旧的关于自动提升为长整型(long)的警告</strong></td></tr><tr><td style="text-align:left"><strong>PendingDeprecationWarning</strong></td><td style="text-align:left"><strong>关于特性将会被废弃的警告</strong></td></tr><tr><td style="text-align:left"><strong>RuntimeWarning</strong></td><td style="text-align:left"><strong>可疑的运行时行为(runtime behavior)的警告</strong></td></tr><tr><td style="text-align:left"><strong>SyntaxWarning</strong></td><td style="text-align:left"><strong>可疑的语法的警告</strong></td></tr><tr><td style="text-align:left"><strong>UserWarning</strong></td><td style="text-align:left"><strong>用户代码生成的警告</strong></td></tr></tbody></table><h3 id="（1）实例">（1）实例</h3><p><strong>以下为单个异常的实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-comment"># 定义函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">temp_convert</span><span class="hljs-params">(var)</span>:</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> int(var)<br>    <span class="hljs-keyword">except</span> ValueError, Argument:<br>        <span class="hljs-keyword">print</span> <span class="hljs-string">"参数没有包含数字\n"</span>, Argument<br><br><span class="hljs-comment"># 调用函数</span><br>temp_convert(<span class="hljs-string">"xyz"</span>);<br></code></pre></td></tr></table></figure><p><strong>以上程序执行结果如下：</strong></p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">$ python test.py <br>参数没有包含数字<br>invalid literal <span class="hljs-keyword">for</span> int() <span class="hljs-keyword">with</span> base <span class="hljs-number">10</span>: <span class="hljs-string">'xyz'</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="（2）触发异常"><strong>（2）触发异常</strong></h3><p><strong>我们可以使用raise语句自己触发异常</strong></p><p><strong>raise语法格式如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">raise</span> [Exception [, args [, traceback]]]<br></code></pre></td></tr></table></figure><p><strong>语句中 Exception 是异常的类型（例如，NameError）参数标准异常中任一种，args 是自已提供的异常参数。</strong></p><p><strong>最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象。</strong></p><h3 id="（3）实例"><strong>（3）实例</strong></h3><p><strong>一个异常可以是一个字符串，类或对象。 Python的内核提供的异常，大多数都是实例化的类，这是一个类的实例的参数。</strong></p><p><strong>定义一个异常非常简单，如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">functionName</span><span class="hljs-params">( level )</span>:</span><br>    <span class="hljs-keyword">if</span> level &lt; <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">"Invalid level!"</span>, level)<br>        <span class="hljs-comment"># 触发异常后，后面的代码就不会再执行</span><br></code></pre></td></tr></table></figure><p><strong>注意：为了能够捕获异常，&quot;except&quot;语句必须有用相同的异常来抛出类对象或者字符串。</strong></p><p><strong>例如我们捕获以上异常，&quot;except&quot;语句如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    正常逻辑<br><span class="hljs-keyword">except</span> Exception,err:<br>    触发自定义异常    <br><span class="hljs-keyword">else</span>:<br>    其余代码<br></code></pre></td></tr></table></figure><h3 id="（4）实例"><strong>（4）实例</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><br><span class="hljs-comment"># 定义函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mye</span><span class="hljs-params">( level )</span>:</span><br>    <span class="hljs-keyword">if</span> level &lt; <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">raise</span> Exception,<span class="hljs-string">"Invalid level!"</span><br>        <span class="hljs-comment"># 触发异常后，后面的代码就不会再执行</span><br><span class="hljs-keyword">try</span>:<br>    mye(<span class="hljs-number">0</span>)            <span class="hljs-comment"># 触发异常</span><br><span class="hljs-keyword">except</span> Exception,err:<br>    <span class="hljs-keyword">print</span> <span class="hljs-number">1</span>,err<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">print</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>执行以上代码，输出结果为：</strong></p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">$ python test.py <br><span class="hljs-number">1</span> Invalid level!<br></code></pre></td></tr></table></figure></blockquote><h2 id="4、用户自定义异常">4、用户自定义异常</h2><p><strong>通过创建一个新的异常类，程序可以命名它们自己的异常。异常应该是典型的继承自Exception类，通过直接或间接的方式。</strong></p><p><strong>以下为与RuntimeError相关的实例,实例中创建了一个类，基类为RuntimeError，用于在异常触发时输出更多的信息。</strong></p><p><strong>在try语句块中，用户自定义的异常后执行except块语句，变量 e 是用于创建Networkerror类的实例。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Networkerror</span><span class="hljs-params">(RuntimeError)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, arg)</span>:</span><br>        self.args = arg<br></code></pre></td></tr></table></figure><p><strong>在你定义以上类后，你可以触发该异常，如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">raise</span> Networkerror(<span class="hljs-string">"Bad hostname"</span>)<br><span class="hljs-keyword">except</span> Networkerror,e:<br>    <span class="hljs-keyword">print</span> e.args<br></code></pre></td></tr></table></figure><h2 id="5、文件和异常的总结">5、文件和异常的总结</h2><h3 id="（1）network文件写入">（1）network文件写入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> 文件和异常.总结.network_error <span class="hljs-keyword">import</span> NetWorkError<br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">r"E:\软件\360壁纸\323244.jpg"</span>, mode=<span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:<br>        img = f.read()<br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'b.jpg'</span>, mode=<span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f1:<br>        f1.write(img)<br><span class="hljs-keyword">except</span> (FileNotFoundError,IndexError, ValueError):<br>    print(<span class="hljs-string">'except'</span>)<br>    <span class="hljs-keyword">raise</span> NetWorkError(<span class="hljs-string">'application bad ...'</span>)<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'else'</span>)<br><span class="hljs-keyword">finally</span>:<br>    print(<span class="hljs-string">'finally'</span>)<br></code></pre></td></tr></table></figure><h3 id="（2）network-error写入">（2）network_error写入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetWorkError</span><span class="hljs-params">(RuntimeError)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,arg)</span>:</span><br>        self.arg=arg<br></code></pre></td></tr></table></figure><h1>三、json库存储数据</h1><p><strong>JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。</strong></p><p><strong>Python3 中可以使用 json 模块来对 JSON 数据进行编解码，它包含了两个函数：</strong></p><ul><li><strong>json.dumps(): 对数据进行编码。</strong></li><li><strong>json.loads(): 对数据进行解码。</strong></li></ul><p><strong>在json的编解码过程中，python 的原始类型与json类型会相互转换，具体的转化对照如下：</strong></p><h3 id="Python-编码为-JSON-类型转换对应表：">Python 编码为 JSON 类型转换对应表：</h3><table><thead><tr><th style="text-align:left">Python</th><th style="text-align:left">JSON</th></tr></thead><tbody><tr><td style="text-align:left">dict</td><td style="text-align:left">object</td></tr><tr><td style="text-align:left">list, tuple</td><td style="text-align:left">array</td></tr><tr><td style="text-align:left">str</td><td style="text-align:left">string</td></tr><tr><td style="text-align:left">int, float, int- &amp; float-derived Enums</td><td style="text-align:left">number</td></tr><tr><td style="text-align:left">True</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left">False</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">None</td><td style="text-align:left">null</td></tr></tbody></table><h3 id="（1）存入数据到user-json">（1）存入数据到user.json</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><br>username = input(<span class="hljs-string">'请输入用户名：'</span>)<br><br>filename = <span class="hljs-string">'user.json'</span><br><span class="hljs-keyword">with</span> open(filename,<span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f:<br>    json.dump(username,f)<br>    print(<span class="hljs-string">'您输入的用户名已保存到json文件中。'</span>)<br></code></pre></td></tr></table></figure><h5 id="执行结果：-2">执行结果：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">请输入用户名：xgp<br>您输入的用户名已保存到json文件中。<br></code></pre></td></tr></table></figure></blockquote><h3 id="（2）引用json库数据">（2）引用json库数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><br>filename = <span class="hljs-string">'user.json'</span><br><span class="hljs-keyword">with</span> open(filename) <span class="hljs-keyword">as</span> f:<br>    username = json.load(f)<br>    print(<span class="hljs-string">'欢迎'</span>+username+<span class="hljs-string">"."</span>)<br></code></pre></td></tr></table></figure><h5 id="执行结果：-3">执行结果：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">欢迎xgp.<br></code></pre></td></tr></table></figure></blockquote><h3 id="（3）存入—指定数据—到-num-json">（3）存入—指定数据—到---num.json</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><br>numbers = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>filename = <span class="hljs-string">'num.json'</span><br><span class="hljs-keyword">with</span> open(filename,<span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f:<br>    json.dump(numbers,f)<br></code></pre></td></tr></table></figure><h3 id="1、son-dumps-与-json-loads-实例">1、son.dumps 与 json.loads 实例</h3><p><strong>以下实例演示了 Python 数据结构转换为JSON：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br> <br><span class="hljs-comment"># Python 字典类型转换为 JSON 对象</span><br>data = &#123;<br>    <span class="hljs-string">'no'</span> : <span class="hljs-number">1</span>,<br>    <span class="hljs-string">'name'</span> : <span class="hljs-string">'Runoob'</span>,<br>    <span class="hljs-string">'url'</span> : <span class="hljs-string">'http://www.runoob.com'</span><br>&#125;<br> <br>json_str = json.dumps(data)<br><span class="hljs-keyword">print</span> (<span class="hljs-string">"Python 原始数据："</span>, repr(data))<br><span class="hljs-keyword">print</span> (<span class="hljs-string">"JSON 对象："</span>, json_str)<br></code></pre></td></tr></table></figure><h5 id="输出结果：-5">输出结果：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">Python 原始数据： &#123;<span class="hljs-string">'url'</span>: <span class="hljs-string">'http://www.runoob.com'</span>, <span class="hljs-string">'no'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'name'</span>: <span class="hljs-string">'Runoob'</span>&#125;<br>JSON 对象： &#123;<span class="hljs-string">"url"</span>: <span class="hljs-string">"http://www.runoob.com"</span>, <span class="hljs-string">"no"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"name"</span>: <span class="hljs-string">"Runoob"</span>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><strong>通过输出的结果可以看出，简单类型通过编码后跟其原始的repr()输出结果非常相似。</strong></p><p><strong>接着以上实例，我们可以将一个JSON编码的字符串转换回一个Python数据结构：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br> <br><span class="hljs-comment"># Python 字典类型转换为 JSON 对象</span><br>data1 = &#123;<br>    <span class="hljs-string">'no'</span> : <span class="hljs-number">1</span>,<br>    <span class="hljs-string">'name'</span> : <span class="hljs-string">'Runoob'</span>,<br>    <span class="hljs-string">'url'</span> : <span class="hljs-string">'http://www.runoob.com'</span><br>&#125;<br> <br>json_str = json.dumps(data1)<br><span class="hljs-keyword">print</span> (<span class="hljs-string">"Python 原始数据："</span>, repr(data1))<br><span class="hljs-keyword">print</span> (<span class="hljs-string">"JSON 对象："</span>, json_str)<br> <br><span class="hljs-comment"># 将 JSON 对象转换为 Python 字典</span><br>data2 = json.loads(json_str)<br><span class="hljs-keyword">print</span> (<span class="hljs-string">"data2['name']: "</span>, data2[<span class="hljs-string">'name'</span>])<br><span class="hljs-keyword">print</span> (<span class="hljs-string">"data2['url']: "</span>, data2[<span class="hljs-string">'url'</span>])<br></code></pre></td></tr></table></figure><h5 id="输出结果：-6">输出结果：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Python 原始数据： &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'Runoob'</span>, <span class="hljs-string">'no'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'url'</span>: <span class="hljs-string">'http://www.runoob.com'</span>&#125;<br>JSON 对象： &#123;<span class="hljs-string">"name"</span>: <span class="hljs-string">"Runoob"</span>, <span class="hljs-string">"no"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"url"</span>: <span class="hljs-string">"http://www.runoob.com"</span>&#125;<br>data2[<span class="hljs-string">'name'</span>]:  Runoob<br>data2[<span class="hljs-string">'url'</span>]:  http://www.runoob.com<br></code></pre></td></tr></table></figure></blockquote><p><strong>如果你要处理的是文件而不是字符串，你可以使用 <code>json.dump()</code> 和 <code>json.load()</code> 来编码和解码JSON数据。例如：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 写入 JSON 数据</span><br><span class="hljs-keyword">with</span> open(<span class="hljs-string">'data.json'</span>, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f:<br>    json.dump(data, f)<br> <br><span class="hljs-comment"># 读取数据</span><br><span class="hljs-keyword">with</span> open(<span class="hljs-string">'data.json'</span>, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:<br>    data = json.load(f)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的正则表达式</title>
      <link href="/posts/6618.html"/>
      <url>/posts/6618.html</url>
      
        <content type="html"><![CDATA[<h1>我们连接Linux来实现正则表达式</h1><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200402154629683.png" alt="image-20200402154629683"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200402154601127.png" alt="image-20200402154601127"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200402154657823.png" alt="image-20200402154657823"></p><h1>一、Python3 正则表达式</h1><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200402153606461.png" alt="image-20200402153606461"></p><p><strong>正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。</strong></p><p><strong>Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。</strong></p><p><strong>re 模块使 Python 语言拥有全部的正则表达式功能。</strong></p><p><strong>compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。</strong></p><p><strong>re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。</strong></p><p><strong>本章节主要介绍 Python 中常用的正则表达式处理函数，如果你对正则表达式不了解，可以查看我们的 <a href="https://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">正则表达式 - 教程</a>。</strong></p><h2 id="1、re-split">1、re.split</h2><p><strong>split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">re.split(pattern, string[, <span class="hljs-attribute">maxsplit</span>=0, <span class="hljs-attribute">flags</span>=0])<br></code></pre></td></tr></table></figure><p><strong>参数：</strong></p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">pattern</td><td style="text-align:left">匹配的正则表达式</td></tr><tr><td style="text-align:left">string</td><td style="text-align:left">要匹配的字符串。</td></tr><tr><td style="text-align:left">maxsplit</td><td style="text-align:left">分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。</td></tr><tr><td style="text-align:left">flags</td><td style="text-align:left">标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：<a href="https://www.runoob.com/python3/python3-reg-expressions.html#flags" target="_blank" rel="noopener">正则表达式修饰符 - 可选标志</a></td></tr></tbody></table><h3 id="例子">例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br><span class="hljs-comment"># fLags=re.IGNORECASE:忽略大小写</span><br>data = <span class="hljs-string">'Last login: Tue Mar 31 17:56:11 2020 from 192.168.1.80'</span><br>new_data = re.split(<span class="hljs-string">'[:.]\s*'</span>, data)<br>print(new_data)<br><br>print(data.split(<span class="hljs-string">': '</span>))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">'Last login'</span>, <span class="hljs-string">'Tue Mar 31 17'</span>, <span class="hljs-string">'56'</span>, <span class="hljs-string">'11 2020 from 192'</span>, <span class="hljs-string">'168'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'80'</span>]<br>[<span class="hljs-string">'Last login'</span>, <span class="hljs-string">'Tue Mar 31 17:56:11 2020 from 192.168.1.80'</span>]<br></code></pre></td></tr></table></figure></blockquote><h3 id="以下是正则表达式的基本语法">以下是正则表达式的基本语法:</h3><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">^</td><td style="text-align:left">匹配字符串的开头</td></tr><tr><td style="text-align:left">$</td><td style="text-align:left">匹配字符串的末尾。</td></tr><tr><td style="text-align:left">.</td><td style="text-align:left">匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。</td></tr><tr><td style="text-align:left">[…]</td><td style="text-align:left">用来表示一组字符,单独列出：[amk] 匹配 ‘a’，‘m’或’k’</td></tr><tr><td style="text-align:left">[^…]</td><td style="text-align:left">不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。</td></tr><tr><td style="text-align:left">re*</td><td style="text-align:left">匹配0个或多个的表达式。</td></tr><tr><td style="text-align:left">re+</td><td style="text-align:left">匹配1个或多个的表达式。</td></tr><tr><td style="text-align:left">re?</td><td style="text-align:left">匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式</td></tr><tr><td style="text-align:left">re{ n}</td><td style="text-align:left">匹配n个前面表达式。例如，&quot;o{2}“不能匹配&quot;Bob&quot;中的&quot;o”，但是能匹配&quot;food&quot;中的两个o。</td></tr><tr><td style="text-align:left">re{ n,}</td><td style="text-align:left">精确匹配n个前面表达式。例如，&quot;o{2,}“不能匹配&quot;Bob&quot;中的&quot;o”，但能匹配&quot;foooood&quot;中的所有o。&quot;o{1,}“等价于&quot;o+”。&quot;o{0,}“则等价于&quot;o*”。</td></tr><tr><td style="text-align:left">re{ n, m}</td><td style="text-align:left">匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式</td></tr></tbody></table><h2 id="2、特殊字符类">2、特殊字符类</h2><table><thead><tr><th style="text-align:left">实例</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">.</td><td style="text-align:left">匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。</td></tr><tr><td style="text-align:left">\d</td><td style="text-align:left">匹配一个数字字符。等价于 [0-9]。</td></tr><tr><td style="text-align:left">\D</td><td style="text-align:left">匹配一个非数字字符。等价于 [^0-9]。</td></tr><tr><td style="text-align:left">\s</td><td style="text-align:left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td style="text-align:left">\S</td><td style="text-align:left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td style="text-align:left">\w</td><td style="text-align:left">匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。</td></tr><tr><td style="text-align:left">\W</td><td style="text-align:left">匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ?[a-zA-Z]+</span><br><span class="hljs-comment"># ?用来匹配单词前后可能出现的空格，[a-zA-Z]代表一个或多个英文字母</span><br><br><span class="hljs-comment"># 匹配一个IP地址 192.168.1.80</span><br><span class="hljs-comment"># [0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;</span><br></code></pre></td></tr></table></figure><h2 id="3、findall-函数">3、findall 函数</h2><p><strong>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。</strong></p><p><strong>注意： match 和 search 是匹配一次 findall 匹配所有。</strong></p><p><strong>语法格式为：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">re</span><span class="hljs-selector-class">.findall</span>(<span class="hljs-selector-tag">string</span><span class="hljs-selector-attr">[, pos[, endpos]</span>])<br></code></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><strong>string</strong> 待匹配的字符串。</li><li><strong>pos</strong> 可选参数，指定字符串的起始位置，默认为 0。</li><li><strong>endpos</strong> 可选参数，指定字符串的结束位置，默认为字符串的长度。</li></ul><h3 id="查找字符串中的所有数字：">查找字符串中的所有数字：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br> <br>pattern = re.compile(<span class="hljs-string">r'\d+'</span>)   <span class="hljs-comment"># 查找数字</span><br>result1 = pattern.findall(<span class="hljs-string">'runoob 123 google 456'</span>)<br>result2 = pattern.findall(<span class="hljs-string">'run88oob123google456'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>)<br> <br>print(result1)<br>print(result2)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-2">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">'123'</span>, <span class="hljs-string">'456'</span>]<br>[<span class="hljs-string">'88'</span>, <span class="hljs-string">'12'</span>]<br></code></pre></td></tr></table></figure></blockquote><h2 id="4、compile-函数">4、compile 函数</h2><p><strong>compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。</strong></p><p><strong>语法格式为：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.compile(pattern[, flags])<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li><strong>pattern : 一个字符串形式的正则表达式</strong></li><li><strong>flags 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：</strong></li><li><ul><li><p><strong>re.I 忽略大小写</strong></p></li><li><p><strong>re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境</strong></p></li><li><p><strong>re.M 多行模式</strong></p></li><li><p><strong>re.S 即为’ . ‘并且包括换行符在内的任意字符（’ . '不包括换行符）</strong></p></li><li><p><strong>re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库</strong></p></li><li><p><strong>re.X 为了增加可读性，忽略空格和’ # '后面的注释</strong></p></li></ul></li></ul><h3 id="例子1">例子1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">import</span> re<br><span class="hljs-meta">&gt;&gt;&gt; </span>pattern = re.compile(<span class="hljs-string">r'\d+'</span>)                    <span class="hljs-comment"># 用于匹配至少一个数字</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m = pattern.match(<span class="hljs-string">'one12twothree34four'</span>)        <span class="hljs-comment"># 查找头部，没有匹配</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>print( m )<br><span class="hljs-literal">None</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m = pattern.match(<span class="hljs-string">'one12twothree34four'</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>) <span class="hljs-comment"># 从'e'的位置开始匹配，没有匹配</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>print( m )<br><span class="hljs-literal">None</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m = pattern.match(<span class="hljs-string">'one12twothree34four'</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>) <span class="hljs-comment"># 从'1'的位置开始匹配，正好匹配</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>print( m )                                        <span class="hljs-comment"># 返回一个 Match 对象</span><br>&lt;_sre.SRE_Match object at <span class="hljs-number">0x10a42aac0</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>m.group(<span class="hljs-number">0</span>)   <span class="hljs-comment"># 可省略 0</span><br><span class="hljs-string">'12'</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m.start(<span class="hljs-number">0</span>)   <span class="hljs-comment"># 可省略 0</span><br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m.end(<span class="hljs-number">0</span>)     <span class="hljs-comment"># 可省略 0</span><br><span class="hljs-number">5</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m.span(<span class="hljs-number">0</span>)    <span class="hljs-comment"># 可省略 0</span><br>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p><strong>在上面，当匹配成功时返回一个 Match 对象，其中：</strong></p><ul><li><strong><code>group([group1, …])</code> 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 <code>group()</code> 或 <code>group(0)</code>；</strong></li><li><strong><code>start([group])</code> 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；</strong></li><li><strong><code>end([group])</code> 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；</strong></li><li><strong><code>span([group])</code> 方法返回 <code>(start(group), end(group))</code>。</strong></li></ul><h3 id="例子2">例子2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-comment"># flags=re. IGNORECASE:忽略大小写</span><br>data = <span class="hljs-string">'Linux系统内置Python 2.7.5,我们安装了Python 3.8.1。'</span><br>print(re.findall( <span class="hljs-string">'python [0-9]\.[0-9]\.[0-9]'</span>, data, flags=re.IGNORECASE))<br><span class="hljs-comment">#</span><br>re_obj = re.compile(<span class="hljs-string">'python [0-9]\.[0-9]\.[0-9]'</span>, flags=re.IGNORECASE)<br>print(re_obj.findall(data))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-3">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">'Python 2.7.5'</span>, <span class="hljs-string">'Python 3.8.1'</span>]<br>[<span class="hljs-string">'Python 2.7.5'</span>, <span class="hljs-string">'Python 3.8.1'</span>]<br></code></pre></td></tr></table></figure></blockquote><h2 id="5、测试findall和compile的读取速度">5、测试findall和compile的读取速度</h2><h3 id="（1）Linux生成数字文件">（1）Linux生成数字文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">[root@python ~]# seq 10000 &gt; data.txt<br></code></pre></td></tr></table></figure><h3 id="（2）pycharm创建findall和compile的读取data-txt的文件">（2）pycharm创建findall和compile的读取data.txt的文件</h3><h4 id="findall">findall</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    pattern = <span class="hljs-string">"[0-9]+"</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'~/data.txt'</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>            re.findall(pattern, line)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'main'</span>:<br>    main()<br></code></pre></td></tr></table></figure><h4 id="compile">compile</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> :</span><br>    pattern = <span class="hljs-string">"[0-9]+"</span><br>    re_obj = re.compile(pattern)<br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">"~/data.txt"</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>            re_obj.findall(line)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"main"</span>:<br>    main( )<br></code></pre></td></tr></table></figure><h3 id="（3）上传文件到Linux">（3）上传文件到Linux</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200402163840213.png" alt="image-20200402163840213"></p><p><strong>底部出现以下信息，上传成功</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200402163900697.png" alt="image-20200402163900697"></p><h3 id="（4）Linux测试下载速度">（4）Linux测试下载速度</h3><h4 id="进入上传的目录-opt">进入上传的目录/opt</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs linux">[root@python ~]# cd &#x2F;opt&#x2F;<br>[root@python opt]# cd 练习<br>[root@python 练习]# ls<br>001.py  findall.py  compile.py<br></code></pre></td></tr></table></figure><h4 id="测试">测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs linux">[root@python 练习]# time python3 findall.py<br>real0m0.058s<br>user0m0.005s<br>sys0m0.029s<br><br>[root@python 练习]# time python3 compile.py <br><br>real0m0.018s<br>user0m0.014s<br>sys0m0.004s<br></code></pre></td></tr></table></figure><p><em><strong>经测试可看出compile读取的方式更快</strong></em></p><h1>二、常用的re函数</h1><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200408202305268.png" alt="image-20200408202305268"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python">data = <span class="hljs-string">'What is the difference between python 2.7.5 and Python 3.8.1 ?'</span><br><span class="hljs-keyword">import</span> re<br>print(re.findall(<span class="hljs-string">'[0-9]\.[0-9]\.[0-9]'</span>,data))<br>print(re.findall(<span class="hljs-string">'python [0-9]\.[0-9]\.[0-9]'</span>,data))<br>print(re.findall(<span class="hljs-string">'Python [0-9]\.[0-9]\.[0-9]'</span>,data))<br>print(re.findall(<span class="hljs-string">'ython [0-9]\.[0-9]\.[0-9]'</span>,data))<br><br>print(data.startswith(<span class="hljs-string">'What'</span>))<br>print(data.endswith(<span class="hljs-string">'?'</span>))<br>print(re.match(<span class="hljs-string">'What'</span>,data))<br><br>word = <span class="hljs-string">"123 is one hender and twentyu-there"</span><br>print(re.match(<span class="hljs-string">'\d+'</span>,word))<br>r = re.match(<span class="hljs-string">'\d+'</span>,word)<br>print(r)<br><br>print(r.start())<br>print(r.end())<br>print(r.re)<br>print(r.group())<br>print(r.string)<br><br>rr = re.finditer(<span class="hljs-string">'[0-9]\.[0-9]\.[0-9]'</span>,data)<br>print(rr)<br><span class="hljs-comment"># print([r for r in rr])</span><br><span class="hljs-keyword">for</span> it <span class="hljs-keyword">in</span> rr:<br>    print(it.group(<span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果："><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 输出'x.x.x'类型的数字</span><br>[<span class="hljs-string">'2.7.5'</span>, <span class="hljs-string">'3.8.1'</span>]<br><span class="hljs-comment"># 输出'python x.x.x'类型的数字</span><br>[<span class="hljs-string">'python 2.7.5'</span>]<br><span class="hljs-comment"># 输出'Python x.x.x'类型的数字</span><br>[<span class="hljs-string">'Python 3.8.1'</span>]<br><span class="hljs-comment"># 输出'ython x.x.x'类型的数字</span><br>[<span class="hljs-string">'ython 2.7.5'</span>, <span class="hljs-string">'ython 3.8.1'</span>]<br><span class="hljs-comment"># 查找data中是否有'What'</span><br><span class="hljs-literal">True</span><br><span class="hljs-comment"># 查找data中是否有'J'</span><br><span class="hljs-literal">True</span><br><span class="hljs-comment"># 查找data中是否有'What'</span><br>&lt;re.Match object; span=(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>), match=<span class="hljs-string">'What'</span>&gt;<br><span class="hljs-comment"># 查找data中是否有'数字字符'</span><br>&lt;re.Match object; span=(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>), match=<span class="hljs-string">'123'</span>&gt;<br><span class="hljs-comment"># 查找data中是否有'数字字符'</span><br>&lt;re.Match object; span=(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>), match=<span class="hljs-string">'123'</span>&gt;<br><span class="hljs-comment"># 匹配的子串在整个字符串中的起始位置</span><br><span class="hljs-number">0</span><br><span class="hljs-comment"># 匹配的子串在整个字符串中的结束位置</span><br><span class="hljs-number">3</span><br><span class="hljs-comment"># 获取re函数的类型</span><br>re.compile(<span class="hljs-string">'\\d+'</span>)<br><span class="hljs-comment"># 获得一个或多个分组匹配的字符串</span><br><span class="hljs-number">123</span><br><span class="hljs-comment"># 匹配的字符串</span><br><span class="hljs-number">123</span> <span class="hljs-keyword">is</span> one hender <span class="hljs-keyword">and</span> twentyu-there<br><span class="hljs-comment"># 输出rr</span><br>&lt;callable_iterator object at <span class="hljs-number">0x000001B92D1613D0</span>&gt;<br><span class="hljs-comment"># 一行一行输出rr文件的'x.x.x'类型的数字</span><br><span class="hljs-number">2.7</span><span class="hljs-number">.5</span><br><span class="hljs-number">3.8</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="（一）匹配类">（一）匹配类</h2><h3 id="1、re-match函数">1、re.match函数</h3><p><strong>re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。</strong></p><p><strong>函数语法</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.match(pattern, string, flags=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><strong>函数参数说明：</strong></p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">pattern</td><td style="text-align:left">匹配的正则表达式</td></tr><tr><td style="text-align:left">string</td><td style="text-align:left">要匹配的字符串。</td></tr><tr><td style="text-align:left">flags</td><td style="text-align:left">标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：<a href="https://www.runoob.com/python3/python3-reg-expressions.html#flags" target="_blank" rel="noopener">正则表达式修饰符 - 可选标志</a></td></tr></tbody></table><p><strong>匹配成功re.match方法返回一个匹配的对象，否则返回None。</strong></p><p><strong>我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。</strong></p><table><thead><tr><th style="text-align:left">匹配对象方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">group(num=0)</td><td style="text-align:left">匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。</td></tr><tr><td style="text-align:left">groups()</td><td style="text-align:left">返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br>print(re.match(<span class="hljs-string">'www'</span>, <span class="hljs-string">'www.runoob.com'</span>).span())  <span class="hljs-comment"># 在起始位置匹配</span><br>print(re.match(<span class="hljs-string">'com'</span>, <span class="hljs-string">'www.runoob.com'</span>))         <span class="hljs-comment"># 不在起始位置匹配</span><br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-2"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>line = <span class="hljs-string">"Cats are smarter than dogs"</span><br><span class="hljs-comment"># .* 表示任意匹配除换行符（\n、\r）之外的任何单个或多个字符</span><br>matchObj = re.match( <span class="hljs-string">r'(.*) are (.*?) .*'</span>, line, re.M|re.I)<br> <br><span class="hljs-keyword">if</span> matchObj:<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"matchObj.group() : "</span>, matchObj.group())<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"matchObj.group(1) : "</span>, matchObj.group(<span class="hljs-number">1</span>))<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"matchObj.group(2) : "</span>, matchObj.group(<span class="hljs-number">2</span>))<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"No match!!"</span>)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-3"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">matchObj.group() :  Cats are smarter than dogs<br>matchObj.group(<span class="hljs-number">1</span>) :  Cats<br>matchObj.group(<span class="hljs-number">2</span>) :  smarter<br></code></pre></td></tr></table></figure></blockquote><h3 id="2、compile-函数">2、compile 函数</h3><p><strong>compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。</strong></p><p><strong>语法格式为：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">re</span><span class="hljs-selector-class">.compile</span>(<span class="hljs-selector-tag">pattern</span><span class="hljs-selector-attr">[, flags]</span>)<br></code></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><strong>pattern : 一个字符串形式的正则表达式</strong></li><li><strong>flags 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：</strong></li><li><ul><li><p><strong>re.I 忽略大小写</strong></p></li><li><p><strong>re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境</strong></p></li><li><p><strong>re.M 多行模式</strong></p></li><li><p><strong>re.S 即为’ . ‘并且包括换行符在内的任意字符（’ . '不包括换行符）</strong></p></li><li><p><strong>re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库</strong></p></li><li><p><strong>re.X 为了增加可读性，忽略空格和’ # '后面的注释</strong></p></li></ul></li></ul><h4 id="实例">实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">import</span> re<br><span class="hljs-meta">&gt;&gt;&gt; </span>pattern = re.compile(<span class="hljs-string">r'([a-z]+) ([a-z]+)'</span>, re.I)   <span class="hljs-comment"># re.I 表示忽略大小写</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m = pattern.match(<span class="hljs-string">'Hello World Wide Web'</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>print( m )                            <span class="hljs-comment"># 匹配成功，返回一个 Match 对象</span><br>&lt;_sre.SRE_Match object at <span class="hljs-number">0x10bea83e8</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>m.group(<span class="hljs-number">0</span>)                            <span class="hljs-comment"># 返回匹配成功的整个子串</span><br><span class="hljs-string">'Hello World'</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m.span(<span class="hljs-number">0</span>)                             <span class="hljs-comment"># 返回匹配成功的整个子串的索引</span><br>(<span class="hljs-number">0</span>, <span class="hljs-number">11</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>m.group(<span class="hljs-number">1</span>)                            <span class="hljs-comment"># 返回第一个分组匹配成功的子串</span><br><span class="hljs-string">'Hello'</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m.span(<span class="hljs-number">1</span>)                             <span class="hljs-comment"># 返回第一个分组匹配成功的子串的索引</span><br>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>m.group(<span class="hljs-number">2</span>)                            <span class="hljs-comment"># 返回第二个分组匹配成功的子串</span><br><span class="hljs-string">'World'</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>m.span(<span class="hljs-number">2</span>)                             <span class="hljs-comment"># 返回第二个分组匹配成功的子串索引</span><br>(<span class="hljs-number">6</span>, <span class="hljs-number">11</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>m.groups()                            <span class="hljs-comment"># 等价于 (m.group(1), m.group(2), ...)</span><br>(<span class="hljs-string">'Hello'</span>, <span class="hljs-string">'World'</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>m.group(<span class="hljs-number">3</span>)                            <span class="hljs-comment"># 不存在第三个分组</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>IndexError: no such group<br></code></pre></td></tr></table></figure><p><strong>在上面，当匹配成功时返回一个 Match 对象，其中：</strong></p><ul><li><strong><code>group([group1, …])</code> 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 <code>group()</code> 或 <code>group(0)</code>；</strong></li><li><strong><code>start([group])</code> 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；</strong></li><li><strong><code>end([group])</code> 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；</strong></li><li><strong><code>span([group])</code> 方法返回 <code>(start(group), end(group))</code>。</strong></li></ul><h3 id="3、re-search方法">3、re.search方法</h3><p><strong>re.search 扫描整个字符串并返回第一个成功的匹配。</strong></p><p><strong>函数语法：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">re.search(pattern, <span class="hljs-built_in">string</span>, flags=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><strong>函数参数说明：</strong></p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">pattern</td><td style="text-align:left">匹配的正则表达式</td></tr><tr><td style="text-align:left">string</td><td style="text-align:left">要匹配的字符串。</td></tr><tr><td style="text-align:left">flags</td><td style="text-align:left">标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：<a href="https://www.runoob.com/python3/python3-reg-expressions.html#flags" target="_blank" rel="noopener">正则表达式修饰符 - 可选标志</a></td></tr></tbody></table><p><strong>匹配成功re.search方法返回一个匹配的对象，否则返回None。</strong></p><p><strong>我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。</strong></p><table><thead><tr><th style="text-align:left">匹配对象方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">group(num=0)</td><td style="text-align:left">匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。</td></tr><tr><td style="text-align:left">groups()</td><td style="text-align:left">返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。</td></tr></tbody></table><h4 id="实例-2">实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br> <br>print(re.search(<span class="hljs-string">'www'</span>, <span class="hljs-string">'www.runoob.com'</span>).span())  <span class="hljs-comment"># 在起始位置匹配</span><br>print(re.search(<span class="hljs-string">'com'</span>, <span class="hljs-string">'www.runoob.com'</span>).span())         <span class="hljs-comment"># 不在起始位置匹配</span><br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-4"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">11</span>, <span class="hljs-number">14</span>)<br></code></pre></td></tr></table></figure></blockquote><h3 id="4、re-match与re-search的区别">4、re.match与re.search的区别</h3><p><strong>re.match 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None，而 re.search 匹配整个字符串，直到找到一个匹配。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br> <br>line = <span class="hljs-string">"Cats are smarter than dogs"</span><br> <br>matchObj = re.match( <span class="hljs-string">r'dogs'</span>, line, re.M|re.I)<br><span class="hljs-keyword">if</span> matchObj:<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"match --&gt; matchObj.group() : "</span>, matchObj.group())<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"No match!!"</span>)<br> <br>matchObj = re.search( <span class="hljs-string">r'dogs'</span>, line, re.M|re.I)<br><span class="hljs-keyword">if</span> matchObj:<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"search --&gt; matchObj.group() : "</span>, matchObj.group())<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"No match!!"</span>)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-5"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">No match!!<br>search --&gt; matchObj.group() :  dogs<br></code></pre></td></tr></table></figure></blockquote><h3 id="5、参数：">5、参数：</h3><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">pattern</td><td style="text-align:left">匹配的正则表达式</td></tr><tr><td style="text-align:left">string</td><td style="text-align:left">要匹配的字符串。</td></tr><tr><td style="text-align:left">flags</td><td style="text-align:left">标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：<a href="https://www.runoob.com/python3/python3-reg-expressions.html#flags" target="_blank" rel="noopener">正则表达式修饰符 - 可选标志</a></td></tr></tbody></table><h2 id="实例-3">实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br> <br>it = re.finditer(<span class="hljs-string">r"\d+"</span>,<span class="hljs-string">"12a32bc43jf3"</span>) <br><span class="hljs-keyword">for</span> match <span class="hljs-keyword">in</span> it: <br>    <span class="hljs-keyword">print</span> (match.group() )<br></code></pre></td></tr></table></figure><h5 id="输出结果：">输出结果：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">12</span> <br><span class="hljs-number">32</span> <br><span class="hljs-number">43</span> <br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="（二）修改类">（二）修改类</h2><h3 id="1、检索和替换">1、检索和替换</h3><p><strong>Python 的re模块提供了re.sub用于替换字符串中的匹配项。</strong></p><p><strong>语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.sub(pattern, repl, string, count=<span class="hljs-number">0</span>, flags=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><strong>pattern : 正则中的模式字符串。</strong></li><li><strong>repl : 替换的字符串，也可为一个函数。</strong></li><li><strong>string : 要被查找替换的原始字符串。</strong></li><li><strong>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</strong></li><li><strong>flags : 编译时用的匹配模式，数字形式。</strong></li></ul><p><strong>前三个为必选参数，后两个为可选参数。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br> <br>phone = <span class="hljs-string">"2004-959-559 # 这是一个电话号码"</span><br> <br><span class="hljs-comment"># 删除注释</span><br>num = re.sub(<span class="hljs-string">r'#.*$'</span>, <span class="hljs-string">""</span>, phone)<br><span class="hljs-keyword">print</span> (<span class="hljs-string">"电话号码 : "</span>, num)<br> <br><span class="hljs-comment"># 移除非数字的内容</span><br>num = re.sub(<span class="hljs-string">r'\D'</span>, <span class="hljs-string">""</span>, phone)<br><span class="hljs-keyword">print</span> (<span class="hljs-string">"电话号码 : "</span>, num)<br></code></pre></td></tr></table></figure><h5 id="输出结果：-2">输出结果：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">电话号码 :  <span class="hljs-number">2004</span><span class="hljs-number">-959</span><span class="hljs-number">-559</span> <br>电话号码 :  <span class="hljs-number">2004959559</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="repl-参数是一个函数">repl 参数是一个函数</h4><p><strong>以下实例中将字符串中的匹配的数字乘于 2：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br> <br><span class="hljs-comment"># 将匹配的数字乘于 2</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">double</span><span class="hljs-params">(matched)</span>:</span><br>    value = int(matched.group(<span class="hljs-string">'value'</span>))<br>    <span class="hljs-keyword">return</span> str(value * <span class="hljs-number">2</span>)<br> <br>s = <span class="hljs-string">'A23G4HFD567'</span><br>print(re.sub(<span class="hljs-string">'(?P&lt;value&gt;\d+)'</span>, double, s))<br></code></pre></td></tr></table></figure><h5 id="输出结果：-3">输出结果：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">A46G8HFD1134<br></code></pre></td></tr></table></figure></blockquote><h3 id="2、re-split">2、re.split</h3><p><strong>split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.split(pattern, string[, maxsplit=<span class="hljs-number">0</span>, flags=<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">pattern</td><td style="text-align:left">匹配的正则表达式</td></tr><tr><td style="text-align:left">string</td><td style="text-align:left">要匹配的字符串。</td></tr><tr><td style="text-align:left">maxsplit</td><td style="text-align:left">分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。</td></tr><tr><td style="text-align:left">flags</td><td style="text-align:left">标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：<a href="https://www.runoob.com/python3/python3-reg-expressions.html#flags" target="_blank" rel="noopener">正则表达式修饰符 - 可选标志</a></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">import</span> re<br><span class="hljs-meta">&gt;&gt;&gt; </span>re.split(<span class="hljs-string">'\W+'</span>, <span class="hljs-string">'runoob, runoob, runoob.'</span>)<br>[<span class="hljs-string">'runoob'</span>, <span class="hljs-string">'runoob'</span>, <span class="hljs-string">'runoob'</span>, <span class="hljs-string">''</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>re.split(<span class="hljs-string">'(\W+)'</span>, <span class="hljs-string">' runoob, runoob, runoob.'</span>) <br>[<span class="hljs-string">''</span>, <span class="hljs-string">' '</span>, <span class="hljs-string">'runoob'</span>, <span class="hljs-string">', '</span>, <span class="hljs-string">'runoob'</span>, <span class="hljs-string">', '</span>, <span class="hljs-string">'runoob'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">''</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>re.split(<span class="hljs-string">'\W+'</span>, <span class="hljs-string">' runoob, runoob, runoob.'</span>, <span class="hljs-number">1</span>) <br>[<span class="hljs-string">''</span>, <span class="hljs-string">'runoob, runoob, runoob.'</span>]<br> <br><span class="hljs-meta">&gt;&gt;&gt; </span>re.split(<span class="hljs-string">'a*'</span>, <span class="hljs-string">'hello world'</span>)   <span class="hljs-comment"># 对于一个找不到匹配的字符串而言，split 不会对其作出分割</span><br>[<span class="hljs-string">'hello world'</span>]<br></code></pre></td></tr></table></figure><h2 id="（三）贪婪和非贪婪模式">（三）贪婪和非贪婪模式</h2><h3 id="1、概念">1、概念</h3><p><strong>首先举个例子：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">example = <span class="hljs-string">"abbbbbbc"</span><br>pattern = re.compile(<span class="hljs-string">"ab+"</span>)<br></code></pre></td></tr></table></figure><p><strong>贪婪模式：正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。如上面使用模式pattern 匹配字符串example，匹配到的结果就是”abbbbbb”整个字符串。</strong></p><p><strong>非贪婪模式：在整个表达式匹配成功的前提下，尽可能少的匹配。如上面使用模式pattern 匹配字符串example，匹配到的结果就只是”ab”整个字符串。</strong></p><h3 id="2、使用方法">2、使用方法</h3><p><strong>在python中默认采用的是贪婪模式，使用非贪婪模式的话，只需要在量词后面直接加上一个问号”?”。</strong><br><strong>在第一篇文章中介绍了正则表达式当中的量词一共有五种：</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409160934674.png" alt="image-20200409160934674"></p><h3 id="3、原理分析">3、原理分析</h3><p><strong>在正则表达式中一般默认采用的是贪婪模式，在上面的例子当中已经匹配到了“ab”时已经可以使整个表达式匹配成功，但是由于采用的是贪婪模式，所以还需要往后继续匹配，检查时候存在更长的可以匹配成功的字符串。一直到匹配到最后一个”b”的时候，后面已经没有可以成功匹配的字符串了，匹配结束。返回匹配结果“abbbbbb”。</strong><br><strong>所以，我们可以将贪婪模式理解为：在整个表达式匹配成功的前提下，尽可能多的匹配。</strong></p><p><strong>非贪婪模式也就是将我们例子中的正则表达式“ab+”改为”ab+?”，当匹配到“ab”时，已经匹配成功，直接结束匹配，不在向后继续尝试，返回匹配成功的字符串”ab”。</strong><br><strong>所以，我们可以将非贪婪模式理解为：在整个表达式匹配成功的前提下，尽可能少的匹配</strong></p><h3 id="4、实例">4、实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br>text = <span class="hljs-string">'Beautifulis better than ugly. Explicit is better than implicit.'</span><br>print(re.findall(<span class="hljs-string">'Beautifulis.*\.'</span>,text))<br>print(re.findall(<span class="hljs-string">'Beautifulis.*?\.'</span>,text))<br></code></pre></td></tr></table></figure><h5 id="输出结果：-4">输出结果：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">'Beautifulis better than ugly. Explicit is better than implicit.'</span>]<br>[<span class="hljs-string">'Beautifulis better than ugly.'</span>]<br></code></pre></td></tr></table></figure></blockquote><h3 id="5、总结">5、总结</h3><h4 id="1-从应用角度看贪婪与非贪婪">1.从应用角度看贪婪与非贪婪</h4><p><strong>贪婪与非贪婪模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配；而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配。</strong></p><h4 id="2-从匹配原理角度看贪婪与非贪婪">2.从匹配原理角度看贪婪与非贪婪</h4><p><strong>能达到同样匹配结果的贪婪与非贪婪模式，通常是贪婪模式的匹配效率较高。 所有的非贪婪模式，都可以通过修改量词修饰的子表达式，转换为贪婪模式。 贪婪模式可以与固化分组结合，提升匹配效率，而非贪婪模式却不可以。</strong></p><h2 id="（四）Python3-replace-方法">（四）Python3 replace()方法</h2><h2 id="描述">描述</h2><p><strong>replace() 方法把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。</strong></p><h2 id="语法">语法</h2><p><strong>replace()方法语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">str.replace(old, new[, max])<br></code></pre></td></tr></table></figure><h2 id="参数">参数</h2><ul><li><strong>old – 将被替换的子字符串。</strong></li><li><strong>new – 新字符串，用于替换old子字符串。</strong></li><li><strong>max – 可选字符串, 替换不超过 max 次</strong></li></ul><h2 id="返回值">返回值</h2><p><strong>返回字符串中的 old（旧字符串） 替换成 new(新字符串)后生成的新字符串，如果指定第三个参数max，则替换不超过 max 次。</strong></p><h2 id="实例-4">实例</h2><p><strong>以下实例展示了replace()函数的使用方法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">data = <span class="hljs-string">'What is the difference between python 2.7.5 and Python 3.8.1 ?'</span><br>print(data)<br><br><span class="hljs-keyword">import</span> re<br>r_data = data.replace(<span class="hljs-string">'2.7.5'</span>,<span class="hljs-string">'x.x.x'</span>)<br>r_data2 = r_data.replace(<span class="hljs-string">'3.8.1'</span>,<span class="hljs-string">'x.x.x'</span>)<br>print(r_data2)<br><br>print(re.sub(<span class="hljs-string">'[0-9]\.[0-9]\.[0-9]'</span>,<span class="hljs-string">'x.x.x'</span>,data))<br><br>print(data.split())<br>print(re.split(<span class="hljs-string">'[ .]+'</span>,data))<br></code></pre></td></tr></table></figure><h5 id="输出结果：-5">输出结果：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">What is the difference between python 2.7.5 and Python 3.8.1 ?<br>What is the difference between python x.x.x and Python x.x.x ?<br>What is the difference between python x.x.x and Python x.x.x ?<br>[<span class="hljs-string">'What'</span>, <span class="hljs-string">'is'</span>, <span class="hljs-string">'the'</span>, <span class="hljs-string">'difference'</span>, <span class="hljs-string">'between'</span>, <span class="hljs-string">'python'</span>, <span class="hljs-string">'2.7.5'</span>, <span class="hljs-string">'and'</span>, <span class="hljs-string">'Python'</span>, <span class="hljs-string">'3.8.1'</span>, <span class="hljs-string">'?'</span>]<br>[<span class="hljs-string">'What'</span>, <span class="hljs-string">'is'</span>, <span class="hljs-string">'the'</span>, <span class="hljs-string">'difference'</span>, <span class="hljs-string">'between'</span>, <span class="hljs-string">'python'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'7'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'and'</span>, <span class="hljs-string">'Python'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'?'</span>]<br></code></pre></td></tr></table></figure></blockquote><h2 id="（五）绘制一个简单的疫情地图">（五）绘制一个简单的疫情地图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pyecharts.charts <span class="hljs-keyword">import</span> Map<br><span class="hljs-keyword">from</span> pyecharts <span class="hljs-keyword">import</span> options <span class="hljs-keyword">as</span> opt<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-comment">#获取数据</span><br>data = requests.get( <span class="hljs-string">'https://gwpre.sina.cn/interface/fymap2020_data.json'</span>).content<br>data = json.loads(data)<br>print(data)<br><br><span class="hljs-comment">#筛选数据</span><br>sub_data = list()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data[<span class="hljs-string">'data'</span>][<span class="hljs-string">'list'</span>]:<br>    sub_data.append((i[<span class="hljs-string">'name'</span>],i[<span class="hljs-string">'value'</span>]))<br>print(sub_data)<br><br><span class="hljs-comment">#绘制中国地图</span><br>map_info = Map()<br><br><span class="hljs-comment">#设置地图的基本信息</span><br>map_info.set_global_opts(title_opts=opt.TitleOpts(<span class="hljs-string">'实时疫情地图——'</span>+data[<span class="hljs-string">'data'</span> ][<span class="hljs-string">'times'</span>]<br>                                                  ,subtitle=<span class="hljs-string">'数据来源'</span>,<br>                                                  subtitle_link=<span class="hljs-string">'https://news.sina.cn/zt_d/yiqing0121?vt=4&amp;pos=222'</span>)<br>                         ,visualmap_opts=opt.VisualMapOpts (max_=<span class="hljs-number">1500</span>,is_piecewise=<span class="hljs-literal">True</span>))<br>map_info.add(<span class="hljs-string">'确诊'</span>, sub_data, maptype=<span class="hljs-string">'china'</span>)<br><br><span class="hljs-comment">#生成网页文件</span><br>map_info.render( <span class="hljs-string">'20200403.html'</span> )<br></code></pre></td></tr></table></figure><h5 id="输出之后会生成一个网页信息，执行一下这个网页即可看到："><strong>输出之后会生成一个网页信息，执行一下这个网页即可看到：</strong></h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200409162512237.png" alt="image-20200409162512237"></p><h2 id="（六）使用正则表达式解析拉勾网某页面内的所有http或者https链接">（六）使用正则表达式解析拉勾网某页面内的所有http或者https链接</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> requests<br>r = requests.get(<span class="hljs-string">'https://www.lagou.com/beijing'</span>)<br><span class="hljs-comment"># print(r)</span><br>result = re.findall(<span class="hljs-string">'"(https?://.*?)"'</span>,r.content.decode(<span class="hljs-string">'utf-8'</span>))<br>print(result)<br></code></pre></td></tr></table></figure><h5 id="输出结果：-6">输出结果：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">'https://www.lagou.com/beijing/'</span>, <span class="hljs-string">'https://www.lagou.com/'</span>, <span class="hljs-string">'https://www.lagou.com/about.html'</span>, <span class="hljs-string">'http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802024043'</span>, <span class="hljs-string">'https://www.lagou.com/upload/oss.js?v=1010'</span>]<br>-----<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python创建和使用类</title>
      <link href="/posts/fec4.html"/>
      <url>/posts/fec4.html</url>
      
        <content type="html"><![CDATA[<h1>一、通用操作</h1><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200402134441262.png" alt="image-20200402134441262"></p><h2 id="1、Python-len">1、Python len()</h2><p><strong>方法返回对象（字符、列表、元组等）长度或项目个数。</strong></p><h2 id="语法">语法</h2><p><strong>len()方法语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">len( q )<br></code></pre></td></tr></table></figure><h3 id="参数">参数</h3><ul><li><strong>q – 对象。</strong></li></ul><h3 id="返回值">返回值</h3><p><strong>返回对象长度。</strong></p><h2 id="实例">实例</h2><p><strong>以下实例展示了 len() 的使用方法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;str = <span class="hljs-string">"runoob"</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>len(str)             <span class="hljs-comment"># 字符串长度</span><br><span class="hljs-number">6</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>l = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>len(l)               <span class="hljs-comment"># 列表元素个数</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="2、python-成员运算符-in-和-not-in">2、python 成员运算符 in 和 not in</h2><p><strong>Python成员运算符测试给定值是否为序列中的成员，例如字符串，列表或元组。 有两个成员运算符，如下所述 -</strong></p><p><strong>in 如果在指定的序列中找到一个变量的值，则返回true，否则返回false。</strong><br><strong>not in 如果在指定序列中找不到变量的值，则返回true，否则返回false。</strong></p><table><thead><tr><th>in</th><th>如果在指定的序列中找到值返回 True，否则返回 False。</th><th>x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</th></tr></thead><tbody><tr><td>not in</td><td>如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td>x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table><h3 id="以下实例演示了Python所有成员运算符的操作："><strong>以下实例演示了Python所有成员运算符的操作：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br>a = <span class="hljs-number">10</span><br>b = <span class="hljs-number">20</span><br>list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ];<br> <br><span class="hljs-keyword">if</span> ( a <span class="hljs-keyword">in</span> list ):<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"1 - 变量 a 在给定的列表中 list 中"</span>)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"1 - 变量 a 不在给定的列表中 list 中"</span>)<br> <br><span class="hljs-keyword">if</span> ( b <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> list ):<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"2 - 变量 b 不在给定的列表中 list 中"</span>)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"2 - 变量 b 在给定的列表中 list 中"</span>)<br> <br><span class="hljs-comment"># 修改变量 a 的值</span><br>a = <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> ( a <span class="hljs-keyword">in</span> list ):<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"3 - 变量 a 在给定的列表中 list 中"</span>)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"3 - 变量 a 不在给定的列表中 list 中"</span>)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果："><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span> - 变量 a 不在给定的列表中 list 中<br><span class="hljs-number">2</span> - 变量 b 不在给定的列表中 list 中<br><span class="hljs-number">3</span> - 变量 a 在给定的列表中 list 中<br></code></pre></td></tr></table></figure></blockquote><h2 id="3、Python身份运算符">3、Python身份运算符</h2><p><strong>身份运算符用于比较两个对象的存储单元</strong></p><table><thead><tr><th>is</th><th>is 是判断两个标识符是不是引用自一个对象</th><th><strong>x is y</strong>, 类似 <strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</th></tr></thead><tbody><tr><td>is not</td><td>is not 是判断两个标识符是不是引用自不同对象</td><td><strong>x is not y</strong> ， 类似 <strong>id(a) != id(b)</strong>。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table><p><strong>注： <a href="https://www.runoob.com/python/python-func-id.html" target="_blank" rel="noopener">id()</a> 函数用于获取对象内存地址。</strong></p><h3 id="以下实例演示了Python所有身份运算符的操作："><strong>以下实例演示了Python所有身份运算符的操作：</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br> <br>a = <span class="hljs-number">20</span><br>b = <span class="hljs-number">20</span><br>  <br><span class="hljs-keyword">if</span> ( a <span class="hljs-keyword">is</span> b ):<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"1 - a 和 b 有相同的标识"</span>)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"1 - a 和 b 没有相同的标识"</span>)<br> <br><span class="hljs-keyword">if</span> ( id(a) == id(b) ):<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"2 - a 和 b 有相同的标识"</span>)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"2 - a 和 b 没有相同的标识"</span>)<br> <br><span class="hljs-comment"># 修改变量 b 的值</span><br>b = <span class="hljs-number">30</span><br><span class="hljs-keyword">if</span> ( a <span class="hljs-keyword">is</span> b ):<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"3 - a 和 b 有相同的标识"</span>)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"3 - a 和 b 没有相同的标识"</span>)<br> <br><span class="hljs-keyword">if</span> ( a <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> b ):<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"4 - a 和 b 没有相同的标识"</span>)<br><span class="hljs-keyword">else</span>:<br>   <span class="hljs-keyword">print</span> (<span class="hljs-string">"4 - a 和 b 有相同的标识"</span>)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-2"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span> - a 和 b 有相同的标识<br><span class="hljs-number">2</span> - a 和 b 有相同的标识<br><span class="hljs-number">3</span> - a 和 b 没有相同的标识<br><span class="hljs-number">4</span> - a 和 b 没有相同的标识<br></code></pre></td></tr></table></figure></blockquote><ul><li><p><strong>is 与 == 区别：</strong></p></li><li><p><strong>is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。</strong></p></li><li><pre><code class="language-python">&gt;&gt;&gt;a = [1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; b is a True&gt;&gt;&gt; b == aTrue&gt;&gt;&gt; b = a[:]&gt;&gt;&gt; b is aFalse&gt;&gt;&gt; b == aTrue<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><br>  <span class="hljs-comment">## 4、Python运算符优先级</span><br><br>  <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>以下表格列出了从最高到最低优先级的所有运算符：<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br><br>  |<span class="hljs-string"> 运算符                   </span>|<span class="hljs-string"> 描述                                                   </span>|<br>  |<span class="hljs-string"> :----------------------- </span>|<span class="hljs-string"> :----------------------------------------------------- </span>|<br>  |<span class="hljs-string"> **                       </span>|<span class="hljs-string"> 指数 (最高优先级)                                      </span>|<br>  |<span class="hljs-string"> ~ + -                    </span>|<span class="hljs-string"> 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) </span>|<br>  |<span class="hljs-string"> * / % //                 </span>|<span class="hljs-string"> 乘，除，求余数和取整除                                 </span>|<br>  |<span class="hljs-string"> + -                      </span>|<span class="hljs-string"> 加法减法                                               </span>|<br>  |<span class="hljs-string"> &gt;&gt; &lt;&lt;                    </span>|<span class="hljs-string"> 右移，左移运算符                                       </span>|<br>  |<span class="hljs-string"> &amp;                        </span>|<span class="hljs-string"> 位 'AND'                                               </span>|<br>  |<span class="hljs-string"> ^ \</span>|<span class="hljs-string">                     </span>|<span class="hljs-string"> 位运算符                                               </span>|<br>  |<span class="hljs-string"> &lt;= &lt; &gt; &gt;=                </span>|<span class="hljs-string"> 比较运算符                                             </span>|<br>  |<span class="hljs-string"> == !=                    </span>|<span class="hljs-string"> 等于运算符                                             </span>|<br>  |<span class="hljs-string"> = %= /= //= -= += *= **= </span>|<span class="hljs-string"> 赋值运算符                                             </span>|<br>  |<span class="hljs-string"> is is not                </span>|<span class="hljs-string"> 身份运算符                                             </span>|<br>  |<span class="hljs-string"> in not in                </span>|<span class="hljs-string"> 成员运算符                                             </span>|<br>  |<span class="hljs-string"> not and or               </span>|<span class="hljs-string"> 逻辑运算符                                             </span>|<br><br><span class="hljs-comment">### **以下实例演示了Python所有运算符优先级的操作：**</span><br><br>```python<br><span class="hljs-comment">#!/usr/bin/python3</span><br> <br>a = 20<br>b = 10<br>c = 15<br>d = 5<br>e = 0<br> <br>e = (a + b) <span class="hljs-symbol">*</span> c / d       <span class="hljs-comment">#( 30 * 15 ) / 5</span><br>print (<span class="hljs-string">"(a + b) * c / d 运算结果为："</span>,  e)<br> <br>e = ((a + b) <span class="hljs-symbol">*</span> c) / d     <span class="hljs-comment"># (30 * 15 ) / 5</span><br>print (<span class="hljs-string">"((a + b) * c) / d 运算结果为："</span>,  e)<br> <br>e = (a + b) <span class="hljs-symbol">*</span> (c / d);    <span class="hljs-comment"># (30) * (15/5)</span><br>print (<span class="hljs-string">"(a + b) * (c / d) 运算结果为："</span>,  e)<br> <br>e = a + (b <span class="hljs-symbol">*</span> c) / d;      <span class="hljs-comment">#  20 + (150/5)</span><br>print (<span class="hljs-string">"a + (b * c) / d 运算结果为："</span>,  e)<br></code></pre></td></tr></table></figure></code></pre></li></ul><h5 id="以上实例输出结果：-3"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">(a + b) * c / d 运算结果为： <span class="hljs-number">90.0</span><br>((a + b) * c) / d 运算结果为： <span class="hljs-number">90.0</span><br>(a + b) * (c / d) 运算结果为： <span class="hljs-number">90.0</span><br>a + (b * c) / d 运算结果为： <span class="hljs-number">50.0</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="and-拥有更高优先级">and 拥有更高优先级:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-literal">True</span><br>y = <span class="hljs-literal">False</span><br>z = <span class="hljs-literal">False</span><br> <br><span class="hljs-keyword">if</span> x <span class="hljs-keyword">or</span> y <span class="hljs-keyword">and</span> z:<br>    print(<span class="hljs-string">"yes"</span>)<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">"no"</span>)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-4">以上实例输出结果：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">yes<br></code></pre></td></tr></table></figure></blockquote><ul><li><p>**注意：**Pyhton3 已不支持 &lt;&gt; 运算符，可以使用 != 代替，如果你一定要使用这种比较运算符，可以使用以下的方式：</p></li><li><pre><code class="language-python">&gt;&gt;&gt; from __future__ import barry_as_FLUFL&gt;&gt;&gt; 1 &lt;&gt; 2True<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><br>[来自](https:<span class="hljs-comment">//www.runoob.com/python3/python3-basic-operators.html)</span><br><br><span class="hljs-meta"># 二、与大小写的相关方法</span><br><br>![image<span class="hljs-number">-20200402134458136</span>](https:<span class="hljs-comment">//gitee.com/xgpqq/tuchuang/raw/master/img/image-20200402134458136.png)</span><br><br>```python<br>xgp = 'hello,wsd'<br><span class="hljs-keyword">print</span>(xgp)<br><br><span class="hljs-meta"># upper():将字符串转换为大写</span><br>xgp1 = xgp.upper()<br><span class="hljs-keyword">print</span>(xgp1)<br><br><span class="hljs-meta"># isupper():判断字符串是否都为大写</span><br><span class="hljs-keyword">print</span>(xgp1.<span class="hljs-built_in">isupper</span>())<br><br><span class="hljs-meta"># lower():将字符串转换为小写</span><br>xgp2 = xgp1.lower()<br><span class="hljs-keyword">print</span>(xgp2)<br><br><span class="hljs-meta"># islower():判断字符串是否都为小写</span><br><span class="hljs-keyword">print</span>(xgp2.<span class="hljs-built_in">islower</span>())<br><br><span class="hljs-meta"># title():将字符串中的单词转换为标题格式，每个单词首字母大写，其余小写</span><br>xgp3 = xgp2.title()<br><span class="hljs-keyword">print</span>(xgp3)<br><br><span class="hljs-meta"># istitle():判断字符事是不是一个标题</span><br><span class="hljs-keyword">print</span>(xgp3.<span class="hljs-built_in">istitle</span>())<br><br><span class="hljs-meta"># swapcase():小写转大写，大写转小写</span><br>xgp4 = xgp3.swapcase()<br><span class="hljs-keyword">print</span>(xgp4)<br>xgp5 = xgp4.swapcase()<br><span class="hljs-keyword">print</span>(xgp5)<br><br><span class="hljs-meta"># capitalize():将首字母转换为大写</span><br>xgp6 = xgp5.capitalize()<br><span class="hljs-keyword">print</span>(xgp6)<br></code></pre></td></tr></table></figure></code></pre></li></ul><h5 id="以上实例输出结果：-5">以上实例输出结果：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 原始输出</span><br>hello,wsd<br><span class="hljs-comment"># 将字符串转换为大写</span><br>HELLO,WSD<br><span class="hljs-comment"># 判断字符串是否都为大写</span><br><span class="hljs-literal">True</span><br><span class="hljs-comment"># 将字符串转换为小写</span><br>hello,wsd<br><span class="hljs-comment"># 判断字符串是否都为小写</span><br><span class="hljs-literal">True</span><br><span class="hljs-comment"># 将字符串中的单词转换为标题格式，每个单词首字母大写，其余小写</span><br>Hello,Wsd<br><span class="hljs-comment"># 判断字符事是不是一个标题</span><br><span class="hljs-literal">True</span><br><span class="hljs-comment"># 小写转大写，大写转小写</span><br>hELLO,wSD<br>Hello,Wsd<br><span class="hljs-comment"># 将首字母转换为大写</span><br>Hello,wsd<br></code></pre></td></tr></table></figure></blockquote><h1>三、判断类方法</h1><p>![image-20200402115648558](G:\四期\python\python文档\12 python的字符串.assets\image-20200402115648558.png)</p><h2 id="1、Python3-isalpha-方法">1、Python3 isalpha()方法</h2><p><strong>Python isalpha() 方法检测字符串是否只由字母组成。</strong></p><h3 id="语法-2">语法</h3><p><strong>isalpha()方法语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">str.isalpha()<br></code></pre></td></tr></table></figure><h3 id="参数-2">参数</h3><ul><li>无。</li></ul><h3 id="返回值-2">返回值</h3><p><strong>如果字符串至少有一个字符并且所有字符都是字母则返回 True，否则返回 False。</strong></p><h3 id="实例-2">实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">str = <span class="hljs-string">"runoob"</span>;<br><span class="hljs-keyword">print</span> str.isalpha();<br><br>str = <span class="hljs-string">"runoob小钢炮"</span>;<br><span class="hljs-keyword">print</span> str.isalpha();<br><br>str = <span class="hljs-string">"this is string example....wow!!!"</span>;<br><span class="hljs-keyword">print</span> str.isalpha();<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="2、Python3-isalnum-方法">2、Python3 isalnum()方法</h2><p><strong>Python isalnum() 方法检测字符串是否由字母和数字组成。</strong></p><h3 id="语法-3">语法</h3><p><strong>isalnum()方法语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">str.isalnum()<br></code></pre></td></tr></table></figure><h3 id="参数-3">参数</h3><ul><li><strong>无。</strong></li></ul><h3 id="返回值-3">返回值</h3><p><strong>如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False</strong></p><h3 id="实例-3">实例</h3><p><strong>以下实例展示了isalnum()方法的实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">str = <span class="hljs-string">"this2009"</span>;  <span class="hljs-comment"># 字符中没有空格</span><br><span class="hljs-keyword">print</span> str.isalnum();<br> <br>str = <span class="hljs-string">"this is string example....wow!!!"</span>;<br><span class="hljs-keyword">print</span> str.isalnum();<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-2">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="3、Python3-isspace-方法">3、Python3 isspace()方法</h2><p><strong>Python isspace() 方法检测字符串是否只由空白字符组成。</strong></p><h3 id="语法-4">语法</h3><p><strong>isspace() 方法语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">str.isspace()<br></code></pre></td></tr></table></figure><h3 id="参数-4">参数</h3><ul><li><strong>无。</strong></li></ul><h3 id="返回值-4">返回值</h3><p><strong>如果字符串中只包含空格/指标位/换行符，则返回 True，否则返回 False.</strong></p><h3 id="实例-4">实例</h3><p><strong>以下实例展示了isspace()方法的实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">str = <span class="hljs-string">"       \n \t"</span> <br><span class="hljs-keyword">print</span> (str.isspace())<br> <br>str = <span class="hljs-string">"Runoob example....wow!!!"</span><br><span class="hljs-keyword">print</span> (str.isspace())<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-3">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="4、Python3-isdecimal-方法">4、Python3 isdecimal()方法</h2><p><strong>Python isdecimal() 方法检查字符串是否只包含十进制字符。这种方法只存在于unicode对象。</strong></p><p><strong>注意:定义一个十进制字符串，只需要在字符串前添加 ‘u’ 前缀即可。</strong></p><h3 id="语法-5">语法</h3><p><strong>isdecimal()方法语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">str.isdecimal()<br></code></pre></td></tr></table></figure><h3 id="参数-5">参数</h3><ul><li><strong>无</strong></li></ul><h3 id="返回值-5">返回值</h3><p><strong>如果字符串是否只包含十进制字符返回True，否则返回False。</strong></p><h2 id="实例-5">实例</h2><p><strong>以下实例展示了 isdecimal()函数的使用方法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">str = <span class="hljs-string">"runoob2016"</span><br><span class="hljs-keyword">print</span> (str.isdecimal())<br><br>str = <span class="hljs-string">"23443434"</span><br><span class="hljs-keyword">print</span> (str.isdecimal())<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-4">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="5、Python3-isdigit-方法">5、Python3 isdigit()方法</h2><p><strong>Python isdigit() 方法检测字符串是否只由数字组成。</strong></p><h3 id="语法-6">语法</h3><p><strong>isdigit()方法语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">str.isdigit()<br></code></pre></td></tr></table></figure><h3 id="参数-6">参数</h3><ul><li><strong>无。</strong></li></ul><h3 id="返回值-6">返回值</h3><p><strong>如果字符串只包含数字则返回 True 否则返回 False。</strong></p><h3 id="实例-6">实例</h3><p><strong>以下实例展示了isdigit()方法的实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">str = <span class="hljs-string">"123456"</span>; <br><span class="hljs-keyword">print</span> (str.isdigit())<br><br>str = <span class="hljs-string">"Runoob example....wow!!!"</span><br><span class="hljs-keyword">print</span> (str.isdigit())<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-5">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="6、Python3-startswith-方法">6、Python3 startswith()方法</h2><p><strong>startswith() 方法用于检查字符串是否是以指定子字符串开头，如果是则返回 True，否则返回 False。如果参数 beg 和 end 指定值，则在指定范围内检查。</strong></p><h3 id="语法-7">语法</h3><p>startswith()方法语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">str.startswith(substr, beg=<span class="hljs-number">0</span>,end=len(string));<br></code></pre></td></tr></table></figure><h3 id="参数-7">参数</h3><ul><li><strong>str – 检测的字符串。</strong></li><li><strong>substr – 指定的子字符串。</strong></li><li><strong>strbeg – 可选参数用于设置字符串检测的起始位置。</strong></li><li><strong>strend – 可选参数用于设置字符串检测的结束位置。</strong></li></ul><h3 id="返回值-7">返回值</h3><p><strong>如果检测到字符串则返回True，否则返回False。</strong></p><h3 id="实例-7">实例</h3><p><strong>以下实例展示了startswith()函数的使用方法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">str = <span class="hljs-string">"this is string example....wow!!!"</span><br><span class="hljs-keyword">print</span> (str.startswith( <span class="hljs-string">'this'</span> ))   <span class="hljs-comment"># 字符串是否以 this 开头</span><br><span class="hljs-keyword">print</span> (str.startswith( <span class="hljs-string">'string'</span>, <span class="hljs-number">8</span> ))  <span class="hljs-comment"># 从第八个字符开始的字符串是否以 string 开头</span><br><span class="hljs-keyword">print</span> (str.startswith( <span class="hljs-string">'this'</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span> )) <span class="hljs-comment"># 从第2个字符开始到第四个字符结束的字符串是否以 this 开头</span><br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-6">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="7、Python3-endswith-方法">7、Python3 endswith()方法</h2><p><strong>endswith() 方法用于判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回 True，否则返回 False。可选参数 “start” 与 “end” 为检索字符串的开始与结束位置。</strong></p><h3 id="语法-8">语法</h3><p><strong>endswith()方法语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">str.endswith(suffix[, start[, end]])<br></code></pre></td></tr></table></figure><h3 id="参数-8">参数</h3><ul><li><strong>suffix – 该参数可以是一个字符串或者是一个元素。</strong></li><li><strong>start – 字符串中的开始位置。</strong></li><li><strong>end – 字符中结束位置。</strong></li></ul><h3 id="返回值-8">返回值</h3><p><strong>如果字符串含有指定的后缀返回 True，否则返回 False。</strong></p><h3 id="实例-8">实例</h3><p><strong>以下实例展示了endswith()方法的实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">Str=<span class="hljs-string">'Runoob example....wow!!!'</span><br>suffix=<span class="hljs-string">'!!'</span><br><span class="hljs-keyword">print</span> (Str.endswith(suffix))<br><span class="hljs-keyword">print</span> (Str.endswith(suffix,<span class="hljs-number">20</span>))<br>suffix=<span class="hljs-string">'run'</span><br><span class="hljs-keyword">print</span> (Str.endswith(suffix))<br><span class="hljs-keyword">print</span> (Str.endswith(suffix, <span class="hljs-number">0</span>, <span class="hljs-number">19</span>))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-7">以上实例输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h1>四、小练习</h1><h3 id="模拟用户注册，要求：">模拟用户注册，要求：</h3><p><strong>1、用户名不能是纯数字，不能以数字开头，必须包含数字、字母或者下划线其中两项。</strong></p><p><strong>2、用户密码长度在6-12位之间，不能是纯数字或纯字母，必须包含数字、字母大写或小写两项。</strong></p><p><strong>3、符合以上要求，程序提示注册成功；否则在输入内容之后立即给出错误提示。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        username = input(<span class="hljs-string">'请输入要注册的账号(不能是纯数字，不能以数字开头，必须包含数字、字母或者下划线其中两项'</span>)<br>        <span class="hljs-keyword">if</span> username == <span class="hljs-string">''</span> :<br>            print(<span class="hljs-string">'用户名不能为空'</span>)<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">elif</span> username .isdecimal() <span class="hljs-keyword">or</span> username[<span class="hljs-number">0</span>].isdecimal() == <span class="hljs-literal">True</span>:<br>            print(<span class="hljs-string">'用户名首字母不能为数字或不能为纯数字用户名'</span> )<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">elif</span> username.isalpha() == <span class="hljs-literal">True</span>:<br>            print(<span class="hljs-string">'必须包含数字字母下 划线其中两项'</span> )<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> username<br>            <span class="hljs-keyword">break</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">password</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        passwd = input(<span class="hljs-string">' 请输入密码: '</span>)<br>        <span class="hljs-keyword">if</span> len(passwd) &lt; <span class="hljs-number">6</span> <span class="hljs-keyword">or</span> len(passwd) &gt; <span class="hljs-number">12</span>:<br>            print( <span class="hljs-string">'用户密码长度在6 -12位之间'</span>)<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">elif</span> passwd. isdecimal() <span class="hljs-keyword">or</span> passwd. isalpha():<br>            print(<span class="hljs-string">'用户密码不能是纯数字或纯字母,必须包含数字、字母大写或小写两项：'</span>)<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> passwd<br>            <span class="hljs-keyword">break</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">xgp</span><span class="hljs-params">()</span>:</span><br>    user()<br>    password()<br>    print(<span class="hljs-string">'注册成功'</span>)<br><br>xgp()<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-8">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">请输入要注册的账号(不能是纯数字，不能以数字开头，必须包含数字、字母或者下划线其中两项f123<br> 请输入密码: sdf456!weq.<br>注册成功<br></code></pre></td></tr></table></figure></blockquote><h1>五、查找类的方法</h1><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200402134823606.png" alt="image-20200402134823606"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">str = <span class="hljs-string">'hello,python'</span><br>print(str.find(<span class="hljs-string">'p'</span>))<br>print(str.index(<span class="hljs-string">'e'</span>))<br>print(str.rindex(<span class="hljs-string">'o'</span>))<br>print(str.rfind(<span class="hljs-string">'h'</span>))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-9">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">6</span><br><span class="hljs-number">1</span><br><span class="hljs-number">10</span><br><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="1、Python3-find-方法">1、Python3 find()方法</h2><p><strong>find() 方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果指定范围内如果包含指定索引值，返回的是索引值在字符串中的起始位置。如果不包含索引值，返回-1。</strong></p><h3 id="语法-9">语法</h3><p><strong>find()方法语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">str.find(str, beg=<span class="hljs-number">0</span>, end=len(string))<br></code></pre></td></tr></table></figure><h3 id="参数-9">参数</h3><ul><li><strong>str – 指定检索的字符串</strong></li><li><strong>beg – 开始索引，默认为0。</strong></li><li><strong>end – 结束索引，默认为字符串的长度。</strong></li></ul><h3 id="返回值-9">返回值</h3><p><strong>如果包含子字符串返回开始的索引值，否则返回-1。</strong></p><h3 id="实例-9">实例</h3><p><strong>以下实例展示了find()方法的实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">str1 = <span class="hljs-string">"Runoob example....wow!!!"</span><br>str2 = <span class="hljs-string">"exam"</span>;<br> <br><span class="hljs-keyword">print</span> (str1.find(str2))<br><span class="hljs-keyword">print</span> (str1.find(str2, <span class="hljs-number">5</span>))<br><span class="hljs-keyword">print</span> (str1.find(str2, <span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-10">以上实例输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">7</span><br><span class="hljs-number">7</span><br><span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><h3 id="例子">例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;info = <span class="hljs-string">'abca'</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>print(info.find(<span class="hljs-string">'a'</span>))      <span class="hljs-comment"># 从下标0开始，查找在字符串里第一个出现的子串，返回结果：0</span><br><span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>print(info.find(<span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>))   <span class="hljs-comment"># 从下标1开始，查找在字符串里第一个出现的子串：返回结果3</span><br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>print(info.find(<span class="hljs-string">'3'</span>))      <span class="hljs-comment"># 查找不到返回-1</span><br><span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><h2 id="2、Python3-index-方法">2、Python3 index()方法</h2><p><strong>index() 方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，该方法与 python find()方法一样，只不过如果str不在 string中会报一个异常。</strong></p><h3 id="语法-10">语法</h3><p><strong>index()方法语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">str.index(str, beg=<span class="hljs-number">0</span>, end=len(string))<br></code></pre></td></tr></table></figure><h3 id="参数-10">参数</h3><ul><li><strong>str – 指定检索的字符串</strong></li><li><strong>beg – 开始索引，默认为0。</strong></li><li><strong>end – 结束索引，默认为字符串的长度。</strong></li></ul><h3 id="返回值-10">返回值</h3><p><strong>如果包含子字符串返回开始的索引值，否则抛出异常。</strong></p><h3 id="实例-10">实例</h3><p><strong>以下实例展示了index()方法的实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">str1 = <span class="hljs-string">"Runoob example....wow!!!"</span><br>str2 = <span class="hljs-string">"exam"</span>;<br><br><span class="hljs-keyword">print</span> (str1.index(str2))<br><span class="hljs-keyword">print</span> (str1.index(str2, <span class="hljs-number">5</span>))<br><span class="hljs-keyword">print</span> (str1.index(str2, <span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下-未发现的会出现异常信息-：">以上实例输出结果如下(未发现的会出现异常信息)：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">7</span><br><span class="hljs-number">7</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">"test.py"</span>, line <span class="hljs-number">8</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-keyword">print</span> (str1.index(str2, <span class="hljs-number">10</span>))<br>ValueError: substring <span class="hljs-keyword">not</span> found<br></code></pre></td></tr></table></figure><h2 id="3、Python3-rfind-方法">3、Python3 rfind()方法</h2><p><strong>Python rfind() 返回字符串最后一次出现的位置，如果没有匹配项则返回-1。</strong></p><h3 id="语法-11">语法</h3><p><strong>rfind()方法语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">str.rfind(str, beg=<span class="hljs-number">0</span> end=len(string))<br></code></pre></td></tr></table></figure><h3 id="参数-11">参数</h3><ul><li><strong>str – 查找的字符串</strong></li><li><strong>beg – 开始查找的位置，默认为0</strong></li><li><strong>end – 结束查找位置，默认为字符串的长度。</strong></li></ul><h3 id="返回值-11">返回值</h3><p><strong>返回字符串最后一次出现的位置，如果没有匹配项则返回-1。</strong></p><h3 id="实例-11">实例</h3><p><strong>以下实例展示了rfind()函数的使用方法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">str1 = <span class="hljs-string">"this is really a string example....wow!!!"</span><br>str2 = <span class="hljs-string">"is"</span><br><br><span class="hljs-keyword">print</span> (str1.rfind(str2))<br><br><span class="hljs-keyword">print</span> (str1.rfind(str2, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>))<br><span class="hljs-keyword">print</span> (str1.rfind(str2, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>))<br><br><span class="hljs-keyword">print</span> (str1.find(str2))<br><span class="hljs-keyword">print</span> (str1.find(str2, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>))<br><span class="hljs-keyword">print</span> (str1.find(str2, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-11">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-number">-1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">2</span><br><span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="4、Python3-rindex-方法">4、Python3 rindex()方法</h2><p><strong>rindex() 返回子字符串 str 在字符串中最后出现的位置，如果没有匹配的字符串会报异常，你可以指定可选参数[beg:end]设置查找的区间。</strong></p><h3 id="语法-12">语法</h3><p><strong>rindex()方法语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">str.rindex(str, beg=<span class="hljs-number">0</span> end=len(string))<br></code></pre></td></tr></table></figure><h3 id="参数-12">参数</h3><ul><li><strong>str – 查找的字符串</strong></li><li><strong>beg – 开始查找的位置，默认为0</strong></li><li><strong>end – 结束查找位置，默认为字符串的长度。</strong></li></ul><h3 id="返回值-12">返回值</h3><p><strong>返回子字符串 str 在字符串中最后出现的位置，如果没有匹配的字符串会报异常。</strong></p><h3 id="实例-12"><strong>实例</strong></h3><p><strong>以下实例展示了rindex()函数的使用方法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">str1 = <span class="hljs-string">"this is really a string example....wow!!!"</span><br>str2 = <span class="hljs-string">"is"</span><br><br><span class="hljs-keyword">print</span> (str1.rindex(str2))<br><span class="hljs-keyword">print</span> (str1.rindex(str2,<span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-12">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">5</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">"test.py"</span>, line <span class="hljs-number">6</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-keyword">print</span> (str1.rindex(str2,<span class="hljs-number">10</span>))<br>ValueError: substring <span class="hljs-keyword">not</span> found<br></code></pre></td></tr></table></figure></blockquote><h1>六、小练习</h1><h3 id="（1）练习">（1）练习</h3><p><strong>验证规则：</strong></p><p><strong>正确格式：abc@163.com.cn</strong></p><p><strong>1、邮箱必须包含“@”和“.”</strong></p><p><strong>2、“@”在邮箱字符串中不能是第一个位置</strong></p><p><strong>3、“.”右侧至少应该有2-3个字符</strong></p><p><strong>4、“.”左侧不能是“@”</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">vanzheng</span><span class="hljs-params">()</span>:</span><br>    youxiang = input(<span class="hljs-string">' 输入您的邮箱:'</span>)<br>    num = youxiang.index(<span class="hljs-string">'.'</span>)<br>    qiepian = youxiang[num:<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">if</span> youxiang[<span class="hljs-number">0</span>] ==<span class="hljs-string">'@'</span> <span class="hljs-keyword">or</span> youxiang[<span class="hljs-number">0</span>] == <span class="hljs-string">'.'</span> :<br>        print(<span class="hljs-string">'邮箱第一位不能是@或者“.” '</span>)<br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">'.'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> youxiang <span class="hljs-keyword">or</span> <span class="hljs-string">'@'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> youxiang:<br>        print(<span class="hljs-string">'邮箱必须包含“@”和“”'</span>)<br>    <span class="hljs-keyword">elif</span> len(qiepian) &lt;= <span class="hljs-number">2</span>:<br>        print(<span class="hljs-string">'“.”右侧至少应该有2-3个字符'</span>)<br>    <span class="hljs-keyword">elif</span> youxiang[<span class="hljs-number">-1</span>] == <span class="hljs-string">'@'</span> <span class="hljs-keyword">or</span> youxiang[<span class="hljs-number">-1</span>] == <span class="hljs-string">'.'</span>:<br>        print(<span class="hljs-string">'邮箱最后一位不能是@或者.'</span>)<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">'邮箱正确'</span>)<br>vanzheng()<br><br>yx=input(<span class="hljs-string">'请输入您的邮箱'</span>)<br>at = yx.find(<span class="hljs-string">'@'</span> )<br>dian = yx. find(<span class="hljs-string">'.'</span>)<br><span class="hljs-keyword">if</span> (at &lt;= <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> dian &lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> yx[<span class="hljs-number">-1</span>]== <span class="hljs-string">'.'</span> <span class="hljs-keyword">or</span> (dian - at) &lt;=<span class="hljs-number">1</span> :<br>    print(<span class="hljs-string">'邮箱格式有误'</span> )<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-13">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"> 输入您的邮箱:<span class="hljs-number">123</span>@qq.com<br>邮箱正确<br></code></pre></td></tr></table></figure></blockquote><h3 id="（2）练习">（2）练习</h3><p><strong>1、提取passwd文件最后5个用户的记录</strong></p><p><strong>2、把每个用户的信息按“:”分别提取用户名、所属组、家目录、登录的shell类型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">user_info = <span class="hljs-string">'''postfix:x:89:89::/var/spool/postfix:/sbin/nologin</span><br><span class="hljs-string">tcpdump:x:72:72::/:/sbin/nologin</span><br><span class="hljs-string">test-07:x:1000:1000:test-07:/home/test-07:/bin/bash</span><br><span class="hljs-string">chou:x:1003:1003::/home/chouchou:/bin/bash</span><br><span class="hljs-string">test02:x:1002:1007::/home/test001:/bin/bash</span><br><span class="hljs-string">try:x:1004:1004::/home/try:/bin/bash</span><br><span class="hljs-string">laoyu:x:1005:1009::/home/laoyu:/bin/bash'''</span><br>new_info = user_info.split(<span class="hljs-string">'\n'</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> new_info:<br>    print(<span class="hljs-string">'用户名:'</span>+i.split(<span class="hljs-string">':'</span>)[<span class="hljs-number">0</span>]+<span class="hljs-string">'所属组:'</span>+i.split(<span class="hljs-string">':'</span>)[<span class="hljs-number">4</span>]+<span class="hljs-string">'家目录:'</span>+i.split(<span class="hljs-string">':'</span>)[<span class="hljs-number">5</span>]+<span class="hljs-string">'登录环境:'</span>+i.split(<span class="hljs-string">':'</span>)[<span class="hljs-number">6</span>])<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-14">以上实例输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">用户名:postfix所属组:家目录:/var/spool/postfix登录环境:/sbin/nologin<br>用户名:tcpdump所属组:家目录:/登录环境:/sbin/nologin<br>用户名:test<span class="hljs-number">-07</span>所属组:test<span class="hljs-number">-07</span>家目录:/home/test<span class="hljs-number">-07</span>登录环境:/bin/bash<br>用户名:chou所属组:家目录:/home/chouchou登录环境:/bin/bash<br>用户名:test02所属组:家目录:/home/test001登录环境:/bin/bash<br>用户名:<span class="hljs-keyword">try</span>所属组:家目录:/home/<span class="hljs-keyword">try</span>登录环境:/bin/bash<br>用户名:laoyu所属组:家目录:/home/laoyu登录环境:/bin/bash<br></code></pre></td></tr></table></figure><h1>七、其他方法</h1><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200402141033170.png" alt="image-20200402141033170"></p><h2 id="1、Python3-split-方法">1、Python3 split()方法</h2><p><strong>split() 通过指定分隔符对字符串进行切片，如果第二个参数 num 有指定值，则分割为 num+1 个子字符串。</strong></p><h3 id="语法-13">语法</h3><p><strong>split() 方法语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">str.split(str=<span class="hljs-string">""</span>, num=string.count(str))<br></code></pre></td></tr></table></figure><h3 id="参数-13">参数</h3><ul><li><strong>str – 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。</strong></li><li><strong>num – 分割次数。默认为 -1, 即分隔所有。</strong></li></ul><h3 id="返回值-13">返回值</h3><p><strong>返回分割后的字符串列表。</strong></p><h3 id="实例-13">实例</h3><p><strong>以下实例展示了 split() 函数的使用方法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">str = <span class="hljs-string">"this is string example....wow!!!"</span><br><span class="hljs-keyword">print</span> (str.split( ))       <span class="hljs-comment"># 以空格为分隔符</span><br><span class="hljs-keyword">print</span> (str.split(<span class="hljs-string">'i'</span>,<span class="hljs-number">1</span>))   <span class="hljs-comment"># 以 i 为分隔符</span><br><span class="hljs-keyword">print</span> (str.split(<span class="hljs-string">'w'</span>))     <span class="hljs-comment"># 以 w 为分隔符</span><br></code></pre></td></tr></table></figure><h4 id="（1）以下实例以-号为分隔符，指定第二个参数为-1，返回两个参数列表。">（1）以下实例以 # 号为分隔符，指定第二个参数为 1，返回两个参数列表。</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">txt = <span class="hljs-string">"Google#Runoob#Taobao#Facebook"</span><br> <br><span class="hljs-comment"># 第二个参数为 1，返回两个参数列表</span><br>x = txt.split(<span class="hljs-string">"#"</span>, <span class="hljs-number">1</span>)<br> <br>print(x)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-15">以上实例输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">'Google'</span>, <span class="hljs-string">'Runoob#Taobao#Facebook'</span>]<br></code></pre></td></tr></table></figure><h2 id="2、Python3-join-方法">2、Python3 join()方法</h2><p><strong>Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。</strong></p><h3 id="语法-14">语法</h3><p><strong>join()方法语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">str.join(sequence)<br></code></pre></td></tr></table></figure><h3 id="参数-14">参数</h3><ul><li><strong>sequence – 要连接的元素序列。</strong></li></ul><h3 id="返回值-14">返回值</h3><p><strong>返回通过指定字符连接序列中元素后生成的新字符串。</strong></p><h3 id="实例-14">实例</h3><p><strong>以下实例展示了join()的使用方法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">"-"</span><br>s2 = <span class="hljs-string">""</span><br>seq = (<span class="hljs-string">"r"</span>, <span class="hljs-string">"u"</span>, <span class="hljs-string">"n"</span>, <span class="hljs-string">"o"</span>, <span class="hljs-string">"o"</span>, <span class="hljs-string">"b"</span>) <span class="hljs-comment"># 字符串序列</span><br><span class="hljs-keyword">print</span> (s1.join( seq ))<br><span class="hljs-keyword">print</span> (s2.join( seq ))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-16">以上实例输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">r-u-n-o-o-b<br>runoob<br></code></pre></td></tr></table></figure><h2 id="3、Python3中-strip-lstrip-rstrip的使用方法">3、Python3中 strip lstrip rstrip的使用方法</h2><p><strong>简单来说，三种方法是为了删除字符串中不同位置的指定字符。其中，<code>strip</code>()用于去除字符串的首尾字符，同理，<code>lstrip()</code>用于去除左边的字符，<code>rstrip()</code>用于去除右边的字符</strong></p><h3 id="（1）strip">（1）strip()</h3><p>Python strip() 方法用于移除字符串头尾指定的字符（默认为空格）。<br><strong>若传入的是一个字符数组，编译器将去除字符串两端所有相应的字符，直到没有匹配的字符。</strong></p><h4 id="语法-15">语法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">str.strip([chars])<br></code></pre></td></tr></table></figure><h4 id="参数-15">参数</h4><ul><li><strong>chars – 移除字符串头尾指定的字符。</strong></li></ul><h4 id="实例-15">实例</h4><h4 id="1、默认方法">1、默认方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">string1 = <span class="hljs-string">'     Kobe Bryant     '</span> <br>print(string1.strip())<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-17">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">Kobe Bryant <br>    默认删除字符串前后的空格。<br></code></pre></td></tr></table></figure></blockquote><h4 id="2、-参数传递">2、 参数传递</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">string2 = <span class="hljs-string">'uuuussssaaaa china aaaassssuuu'</span><br>print(string2.strip(<span class="hljs-string">'usa'</span>))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-18">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">china<br>    其中， <span class="hljs-string">'u'</span>、<span class="hljs-string">'s'</span>、<span class="hljs-string">'a'</span> 的个数可以为任意，不影响最后输出 &gt; china<br></code></pre></td></tr></table></figure></blockquote><h3 id="（2）lstrip">（2）lstrip()</h3><p><strong>Python lstrip() 方法用于截掉字符串左边的空格或指定字符，默认为空格。</strong></p><h4 id="实例-16">实例</h4><h4 id="1、默认方法-2">1、默认方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">string1 = <span class="hljs-string">'     Kobe Bryant     '</span> <br>string1.lstrip()<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-19">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">'Kobe Bryant     '</span><br>默认删除字符串前的空格。<br></code></pre></td></tr></table></figure></blockquote><h4 id="2、-参数传递-2">2、 参数传递</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">string2 = <span class="hljs-string">'uuuussssaaaa china aaaassssuuu'</span><br>print(string2.strip(<span class="hljs-string">'usa'</span>))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-20">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">china aaaassssuuu<br></code></pre></td></tr></table></figure></blockquote><h3 id="（3）rstrip">（3）rstrip()</h3><p><strong>Python lstrip() 方法用于截掉字符串右边的空格或指定字符，默认为空格。</strong></p><h4 id="实例-17">实例</h4><h4 id="1、默认方法-3">1、默认方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">string1 = <span class="hljs-string">'     Kobe Bryant     '</span> <br>string1.lstrip()<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-21">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">Kobe Bryant<span class="hljs-string">'</span><br><span class="hljs-string">默认删除字符串后的空格。</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="2、参数传递">2、参数传递</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">string2 = <span class="hljs-string">'uuuussssaaaa china aaaassssuuu'</span><br>print(string2.strip(<span class="hljs-string">'usa'</span>))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-22">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">uuuussssaaaa china<br></code></pre></td></tr></table></figure></blockquote><h2 id="4、Python3-replace-方法">4、Python3 replace()方法</h2><h2 id="描述">描述</h2><p><strong>replace() 方法把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。</strong></p><h2 id="语法-16">语法</h2><p><strong>replace()方法语法：</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">str.<span class="hljs-built_in">replace</span>(old, <span class="hljs-built_in">new</span>[, <span class="hljs-built_in">max</span>])<br></code></pre></td></tr></table></figure><h2 id="参数-16">参数</h2><ul><li><strong>old – 将被替换的子字符串。</strong></li><li><strong>new – 新字符串，用于替换old子字符串。</strong></li><li><strong>max – 可选字符串, 替换不超过 max 次</strong></li></ul><h2 id="返回值-15">返回值</h2><p><strong>返回字符串中的 old（旧字符串） 替换成 new(新字符串)后生成的新字符串，如果指定第三个参数max，则替换不超过 max 次。</strong></p><h2 id="实例-18">实例</h2><p><strong>以下实例展示了replace()函数的使用方法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">str = <span class="hljs-string">"wsdixgp.top"</span><br><span class="hljs-keyword">print</span> (<span class="hljs-string">"xgp旧地址："</span>, str)<br><span class="hljs-keyword">print</span> (<span class="hljs-string">"xgp新地址："</span>, str.replace(<span class="hljs-string">"wsdixgp.top"</span>, <span class="hljs-string">"wsdlxgp.top"</span>))<br> <br>str = <span class="hljs-string">"this is string example....wow!!!"</span><br><span class="hljs-keyword">print</span> (str.replace(<span class="hljs-string">"is"</span>, <span class="hljs-string">"was"</span>, <span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-23">以上实例输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">xgp旧地址： wsdixgp.top<br>xgp新地址： wsdlxgp.top<br>thwas was string example....wow!!!<br></code></pre></td></tr></table></figure><h1>八、使用Python分析Apache的访问日志</h1><h2 id="1、字符串分割">1、字符串分割</h2><h3 id="创建access-log文件（存放日志信息即可）">创建access.log文件（存放日志信息即可）</h3><ul><li><strong>log = '182.19.31.129 - - [16/JAN/2020:06:05:35 +0200] “GET /index.php HTTP/1.1” 200 0 “-” “Mozilla/5.0 (compatible; PJBot/3.0; +http://craw1.pagesjaunes.fr/robot)” “-”'</strong></li><li><strong>log_temp = log.split()</strong></li><li><strong>print(log_temp)</strong></li><li><strong>print(‘用户IP：’+log_temp[0])</strong></li><li><strong>print(‘访问页面：’+log_temp[6])</strong></li><li><strong>print(‘状态码：’+log_temp[8])</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> __future__  <span class="hljs-keyword">import</span> print_function<br><br>ips = []<br><span class="hljs-keyword">with</span> open(<span class="hljs-string">'access.log'</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>        ips.append(line.split()[<span class="hljs-number">0</span>])<br><br>print(<span class="hljs-string">'网站请求数[PV]：'</span>+ str(len(ips)))<br>print(<span class="hljs-string">'网站独立的访客数[UV]：'</span>+ str(len(set(ips))))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-24">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">网站请求数[PV]：<span class="hljs-number">120</span><br>网站独立的访客数[UV]：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="2、使用counter类统计PV和UV">2、使用counter类统计PV和UV</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> __future__  <span class="hljs-keyword">import</span> print_function<br><br>d = &#123;&#125;<br><span class="hljs-keyword">with</span> open(<span class="hljs-string">'access.log'</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>        key = line.split()[<span class="hljs-number">8</span>]<br>        d.setdefault(key,<span class="hljs-number">0</span>)<br>        d[key] += <span class="hljs-number">1</span><br><br>print(d)<br><br><span class="hljs-comment"># 出错的页面数量</span><br>error_requests = <span class="hljs-number">0</span><br><span class="hljs-comment"># 页面总访问量</span><br>sum_requests = <span class="hljs-number">0</span><br><span class="hljs-comment"># 遍历字典</span><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> d.items():<br>    <span class="hljs-keyword">if</span> int(key) &gt;= <span class="hljs-number">400</span>:<br>        error_requests += value<br>    sum_requests += value<br><br>print(<span class="hljs-string">'页面出错率：&#123;0:2f&#125;%'</span>.format(error_requests * <span class="hljs-number">100.0</span>/sum_requests))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-25">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">'200'</span>: <span class="hljs-number">115</span>, <span class="hljs-string">'500'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'248'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'210'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'203'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'400'</span>: <span class="hljs-number">1</span>&#125;<br>页面出错率：<span class="hljs-number">1.666667</span>%<br></code></pre></td></tr></table></figure></blockquote><h1>九、格式化</h1><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200402144751352.png" alt="image-20200402144751352"></p><h2 id="1、Python字符串格式化">1、Python字符串格式化</h2><p><strong>Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。</strong></p><p><strong>在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">print</span> (<span class="hljs-string">"我叫 %s 今年 %d 岁!"</span> % (<span class="hljs-string">'小明'</span>, <span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-6">以上实例输出结果：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">我叫 小明 今年 <span class="hljs-number">10</span> 岁!<br></code></pre></td></tr></table></figure></blockquote><h3 id="python字符串格式化符号">python字符串格式化符号:</h3><table><thead><tr><th style="text-align:left">符  号</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">%c</td><td style="text-align:left">格式化字符及其ASCII码</td></tr><tr><td style="text-align:left">%s</td><td style="text-align:left">格式化字符串</td></tr><tr><td style="text-align:left">%d</td><td style="text-align:left">格式化整数</td></tr><tr><td style="text-align:left">%u</td><td style="text-align:left">格式化无符号整型</td></tr><tr><td style="text-align:left">%o</td><td style="text-align:left">格式化无符号八进制数</td></tr><tr><td style="text-align:left">%x</td><td style="text-align:left">格式化无符号十六进制数</td></tr><tr><td style="text-align:left">%X</td><td style="text-align:left">格式化无符号十六进制数（大写）</td></tr><tr><td style="text-align:left">%f</td><td style="text-align:left">格式化浮点数字，可指定小数点后的精度</td></tr><tr><td style="text-align:left">%e</td><td style="text-align:left">用科学计数法格式化浮点数</td></tr><tr><td style="text-align:left">%E</td><td style="text-align:left">作用同%e，用科学计数法格式化浮点数</td></tr><tr><td style="text-align:left">%g</td><td style="text-align:left">%f和%e的简写</td></tr><tr><td style="text-align:left">%G</td><td style="text-align:left">%f 和 %E 的简写</td></tr><tr><td style="text-align:left">%p</td><td style="text-align:left">用十六进制数格式化变量的地址</td></tr></tbody></table><p><strong>格式化操作符辅助指令:</strong></p><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">*</td><td style="text-align:left">定义宽度或者小数点精度</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">用做左对齐</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">在正数前面显示加号( + )</td></tr><tr><td style="text-align:left"><sp></sp></td><td style="text-align:left">在正数前面显示空格</td></tr><tr><td style="text-align:left">#</td><td style="text-align:left">在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</td></tr><tr><td style="text-align:left">0</td><td style="text-align:left">显示的数字前面填充’0’而不是默认的空格</td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">‘%%‘输出一个单一的’%’</td></tr><tr><td style="text-align:left">(var)</td><td style="text-align:left">映射变量(字典参数)</td></tr><tr><td style="text-align:left">m.n.</td><td style="text-align:left">m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td></tr></tbody></table><p><strong>Python2.6 开始，新增了一种格式化字符串的函数 <a href="https://www.runoob.com/python/att-string-format.html" target="_blank" rel="noopener">str.format()</a>，它增强了字符串格式化的功能。</strong></p><h3 id="练习">练习</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">print( <span class="hljs-string">'%d'</span> % <span class="hljs-number">3</span>)<br>print( <span class="hljs-string">'%09f'</span> % <span class="hljs-number">3.14</span>)<br>print(<span class="hljs-string">'%s'</span> % <span class="hljs-string">'hello'</span>)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-26">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">3</span><br><span class="hljs-number">03.140000</span><br>hello<br></code></pre></td></tr></table></figure></blockquote><h2 id="2、format函数">2、format函数</h2><p><strong>Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。</strong></p><p><strong>基本语法是通过 {} 和 : 来代替以前的 % 。</strong></p><p><strong>format 函数可以接受不限个参数，位置可以不按顺序。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-string">"&#123;&#125; &#123;&#125;"</span>.format(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>)    <span class="hljs-comment"># 不设置指定位置，按默认顺序</span><br><span class="hljs-string">'hello world'</span><br> <br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">"&#123;0&#125; &#123;1&#125;"</span>.format(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>)  <span class="hljs-comment"># 设置指定位置</span><br><span class="hljs-string">'hello world'</span><br> <br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">"&#123;1&#125; &#123;0&#125; &#123;1&#125;"</span>.format(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>)  <span class="hljs-comment"># 设置指定位置</span><br><span class="hljs-string">'world hello world'</span><br></code></pre></td></tr></table></figure><p><strong>也可以设置参数：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">print(<span class="hljs-string">"网站名：&#123;name&#125;, 地址 &#123;url&#125;"</span>.format(name=<span class="hljs-string">"xgp"</span>, url=<span class="hljs-string">"wsdlxgp.top"</span>))<br> <br><span class="hljs-comment"># 通过字典设置参数</span><br>site = &#123;<span class="hljs-string">"name"</span>: <span class="hljs-string">"xgp"</span>, <span class="hljs-string">"url"</span>: <span class="hljs-string">"wsdlxgp.top"</span>&#125;<br>print(<span class="hljs-string">"网站名：&#123;name&#125;, 地址 &#123;url&#125;"</span>.format(**site))<br> <br><span class="hljs-comment"># 通过列表索引设置参数</span><br>my_list = [<span class="hljs-string">'xgp'</span>, <span class="hljs-string">'wsdlxgp.top'</span>]<br>print(<span class="hljs-string">"网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;"</span>.format(my_list))  <span class="hljs-comment"># "0" 是必须的</span><br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-27">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">网站名：xgp, 地址 wsdlxgp.top<br>网站名：xgp, 地址 wsdlxgp.top<br>网站名：xgp, 地址 wsdlxgp.top<br></code></pre></td></tr></table></figure></blockquote><p><strong>也可以向 <code>str.format()</code> 传入对象：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AssignValue</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, value)</span>:</span><br>        self.value = value<br>my_value = AssignValue(<span class="hljs-number">6</span>)<br>print(<span class="hljs-string">'value 为: &#123;0.value&#125;'</span>.format(my_value))  <span class="hljs-comment"># "0" 是可选的</span><br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-28">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">value 为: <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="3、数字格式化">3、数字格式化</h2><p><strong>下表展示了 str.format() 格式化数字的多种方法：</strong></p><table><thead><tr><th style="text-align:left">数字</th><th style="text-align:left">格式</th><th style="text-align:left">输出</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">3.1415926</td><td style="text-align:left">{:.2f}</td><td style="text-align:left">3.14</td><td style="text-align:left">保留小数点后两位</td></tr><tr><td style="text-align:left">3.1415926</td><td style="text-align:left">{:+.2f}</td><td style="text-align:left">+3.14</td><td style="text-align:left">带符号保留小数点后两位</td></tr><tr><td style="text-align:left">-1</td><td style="text-align:left">{:+.2f}</td><td style="text-align:left">-1.00</td><td style="text-align:left">带符号保留小数点后两位</td></tr><tr><td style="text-align:left">2.71828</td><td style="text-align:left">{:.0f}</td><td style="text-align:left">3</td><td style="text-align:left">不带小数</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">{:0&gt;2d}</td><td style="text-align:left">05</td><td style="text-align:left">数字补零 (填充左边, 宽度为2)</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">{:x&lt;4d}</td><td style="text-align:left">5xxx</td><td style="text-align:left">数字补x (填充右边, 宽度为4)</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">{:x&lt;4d}</td><td style="text-align:left">10xx</td><td style="text-align:left">数字补x (填充右边, 宽度为4)</td></tr><tr><td style="text-align:left">1000000</td><td style="text-align:left">{:,}</td><td style="text-align:left">1,000,000</td><td style="text-align:left">以逗号分隔的数字格式</td></tr><tr><td style="text-align:left">0.25</td><td style="text-align:left">{:.2%}</td><td style="text-align:left">25.00%</td><td style="text-align:left">百分比格式</td></tr><tr><td style="text-align:left">1000000000</td><td style="text-align:left">{:.2e}</td><td style="text-align:left">1.00e+09</td><td style="text-align:left">指数记法</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">{:&gt;10d}</td><td style="text-align:left">13</td><td style="text-align:left">右对齐 (默认, 宽度为10)</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">{:&lt;10d}</td><td style="text-align:left">13</td><td style="text-align:left">左对齐 (宽度为10)</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">{:^10d}</td><td style="text-align:left">13</td><td style="text-align:left">中间对齐 (宽度为10)</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><code>'{:b}'.format(11) '{:d}'.format(11) '{:o}'.format(11) '{:x}'.format(11) '{:#x}'.format(11) '{:#X}'.format(11)</code></td><td style="text-align:left"><code>1011 11 13 b 0xb 0XB</code></td><td style="text-align:left"></td></tr></tbody></table><p><strong>^, &lt;, &gt; 分别是居中、左对齐、右对齐，后面带宽度， : 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。</strong></p><p><strong>+ 表示在正数前显示 +，负数前显示 -； （空格）表示在正数前加空格</strong></p><p><strong>b、d、o、x 分别是二进制、十进制、八进制、十六进制。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 精度</span><br>print(<span class="hljs-string">'&#123;: .2f&#125;'</span>.format(<span class="hljs-number">3.141592656535897</span>))<br><span class="hljs-comment"># 符号</span><br>print(<span class="hljs-string">'&#123;: .2f&#125;'</span>.format(<span class="hljs-number">3.141592656535897</span>))<br><span class="hljs-comment"># 宽度</span><br>print( <span class="hljs-string">'&#123;:10.2f&#125;'</span>.format(<span class="hljs-number">3.141592656535897</span>))<br><span class="hljs-comment"># 对齐方式</span><br>print(<span class="hljs-string">'&#123;:^10.2f&#125;'</span>.format(<span class="hljs-number">3.141592656535897</span>))<br><span class="hljs-comment"># 逗号分隔</span><br>print(<span class="hljs-string">'&#123;:,&#125;'</span>.format(<span class="hljs-number">23421424231</span>))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-29">以上实例输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"> <span class="hljs-number">3.14</span><br> <span class="hljs-number">3.14</span><br>      <span class="hljs-number">3.14</span><br>   <span class="hljs-number">3.14</span>   <br><span class="hljs-number">23</span>,<span class="hljs-number">421</span>,<span class="hljs-number">424</span>,<span class="hljs-number">231</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="此外我们可以使用大括号-来转义大括号，如下实例：">此外我们可以使用大括号 <strong>{}</strong> 来转义大括号，如下实例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">print</span> (<span class="hljs-string">"&#123;&#125; 对应的位置是 &#123;&#123;0&#125;&#125;"</span>.format(<span class="hljs-string">"runoob"</span>))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果如下：-30">以上实例输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">runoob 对应的位置是 &#123;<span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识python</title>
      <link href="/posts/e939.html"/>
      <url>/posts/e939.html</url>
      
        <content type="html"><![CDATA[<h1>Python 面向对象</h1><p><strong>记住一句话：类是模板，而实例则是根据类创建的对象。</strong></p><p><strong>初学时对类的理解是从类的字面上，可以片面的认为它是一个种类，它是相似特征的抽像，也就是相似的东西，可以把相似特征的事务抽象成一个类。（事务可以是具体的物体或行为）</strong></p><p><strong>以圆为例，圆是具有圆周率(pi)和半径®两个相似特征的属性。根据相似特征抽象出圆类，每个圆的半径可以不同，那么半径可以作为圆的实例属性；而每个圆的圆周率pi是相同的，那么圆周率pi就可以作为类属性，这样就定义出了一个圆类。而我们要知道圆的面积，周长等可以通过类方法计算出来。</strong></p><p><strong>（看完整篇文章，还是对类不理解，回过头在来看这部分，对照列子多理解。）</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200326144410989.png" alt="image-20200326144410989"></p><h3 id="类的应用场景："><strong>类的应用场景：</strong></h3><blockquote><p><strong>零散代码(代码块)–&gt;函数(方法)–&gt;类–&gt;模块(文件)</strong><br><strong>类:表示抽象(模糊)的事物</strong><br><strong>对象:表示具体(清晰)的事物</strong></p></blockquote><h2 id="1、面向对象技术简介">1、面向对象技术简介</h2><ul><li><strong>类(Class):</strong> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li>**类变量：**类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li>**数据成员：**类变量或者实例变量, 用于处理类及其实例对象的相关的数据。</li><li>**方法重写：**如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li><li>**局部变量：**定义在方法中的变量，只作用于当前实例的类。</li><li>**实例变量：**在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。</li><li>**继承：**即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟&quot;是一个（is-a）&quot;关系（例图，Dog是一个Animal）。</li><li>**实例化：**创建一个类的实例，类的具体对象。</li><li>**方法：**类中定义的函数。</li><li>**对象：**通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ul><h2 id="2、创建类">2、创建类</h2><p><strong>使用 class 语句来创建一个新类，class 之后为类的名称并以冒号结尾:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ClassName:<br>  <span class="hljs-string">'类的帮助信息'</span>   <span class="hljs-comment">#类文档字符串</span><br>  class_suite  <span class="hljs-comment">#类体</span><br></code></pre></td></tr></table></figure><p><strong>类的帮助信息可以通过ClassName.doc查看。</strong></p><p><strong>class_suite 由类成员，方法，数据属性组成。</strong></p><h3 id="（1）例子">（1）例子</h3><p><strong>描述人类的文件</strong><br><strong>类的结构：</strong><br><strong>1、动态的行为（动词）：speak、sing</strong><br><strong>2、静态的属性（名词）：gender、user_name</strong><br><strong>（1）全局：在类中的任何地方都能使用</strong><br><strong>（2）局部：只能够在方法内部使用</strong><br><strong>使用类：</strong><br><strong>实例化对象：对象名 = 类名 ( 参数【可选的】)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-string">"""模拟人类"""</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, sex, name)</span>:</span><br>        <span class="hljs-string">"""初始化属性：gender和user_name"""</span><br>        self.gender = sex<br>        self.user_name = name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""模拟人类说话"""</span><br>        print(self.user_name.title() + <span class="hljs-string">"正在说话。"</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sing</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""模拟人类唱歌"""</span><br>        print(self.user_name.title() + <span class="hljs-string">"正在唱歌。"</span>)<br></code></pre></td></tr></table></figure><ul><li><strong><code>empCount</code> 变量是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类使用 <code>Employee.empCount</code> 访问。</strong></li><li><strong>第一种方法<code>__init__()</code>方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法</strong></li><li><strong><code>self</code> 代表类的实例，<code>self</code> 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。</strong></li></ul><h5 id="输出结果如下：">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用类</span><br>man = Human(<span class="hljs-string">'男'</span>,<span class="hljs-string">'xgp'</span>)<br>man.speak()<br><br>lz = Human(<span class="hljs-string">'男'</span>,<span class="hljs-string">'kk'</span>)<br>lz.sing()<br></code></pre></td></tr></table></figure></blockquote><h3 id="（2）修改初始值">（2）修改初始值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span><span class="hljs-params">()</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,sex,strain)</span>:</span><br>        <span class="hljs-string">"""给属性赋初始值（默认值）"""</span><br>        self.nick_name = <span class="hljs-string">'咪咪'</span><br>        self.gender = sex<br>        self.stain = strain<br><br><br>cat = Pet(<span class="hljs-string">'公'</span>,<span class="hljs-string">'土猫'</span>)<br><span class="hljs-comment"># 修改初始值</span><br>cat.nick_name = <span class="hljs-string">'妙妙'</span><br>print(cat.nick_name)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-2">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">妙妙<br></code></pre></td></tr></table></figure></blockquote><h2 id="3、self代表类的实例，而非类">3、self代表类的实例，而非类</h2><p><strong>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的<code>第一个参数名称</code>, 按照惯例它的名称是 self。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">prt</span><span class="hljs-params">(self)</span>:</span><br>        print(self)<br>        print(self.__class__)<br> <br>t = Test()<br>t.prt()<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-3">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;__main__.Test instance at <span class="hljs-number">0x10d066878</span>&gt;<br>__main__.Test<br></code></pre></td></tr></table></figure></blockquote><p><strong>从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 <code>self.__class__</code> 则指向类。</strong></p><p><strong>self 不是 python 关键字，我们把他换成 <code>runoob</code> 也是可以正常执行的:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">prt</span><span class="hljs-params">(runoob)</span>:</span><br>        print(runoob)<br>        print(runoob.__class__)<br> <br>t = Test()<br>t.prt()<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-4">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;__main__.Test instance at <span class="hljs-number">0x10d066878</span>&gt;<br>__main__.Test<br></code></pre></td></tr></table></figure></blockquote><h2 id="4、创建实例对象">4、创建实例对象</h2><p><strong>实例化类其他编程语言中一般用关键字 new，但是在 Python 中并没有这个关键字，类的实例化类似函数调用方式。</strong></p><p><strong>以下使用类的名称 <code>Dn</code> 来实例化，并通过 <code>__init__</code> 方法接收参数。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">"""</span><br><span class="hljs-string">小明和小红各自买了一台笔记本电脑,</span><br><span class="hljs-string">其中小明的电脑品牌是联想, CPU8核, 512G固态硬盘,双飞燕鼠标</span><br><span class="hljs-string">省红的电脑品牌是机械师, CPU4核, 256G固态硬盘+1T普通硬盘，机械师鼠标</span><br><span class="hljs-string">使用面向对象的思维，编写代码完成以 上描述。</span><br><span class="hljs-string">"""</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dn</span><span class="hljs-params">()</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,name,brand,cpu,disk,mouse)</span>:</span><br>        self.nice_name = name<br>        self.nice_pp = brand<br>        self.nice_cpu = cpu<br>        self.nice_disk = disk<br>        self.nice_mouse = mouse<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">xgp</span><span class="hljs-params">(self)</span>:</span><br>        print(self.nice_name + <span class="hljs-string">'的电脑配置：“'</span><br>              + <span class="hljs-string">'品牌：'</span> + self.nice_pp + <span class="hljs-string">','</span><br>              + <span class="hljs-string">'cpu：'</span> +self.nice_cpu + <span class="hljs-string">','</span><br>              + <span class="hljs-string">'硬盘：'</span> +self.nice_disk + <span class="hljs-string">','</span><br>              + <span class="hljs-string">'鼠标：'</span> + self.nice_mouse + <span class="hljs-string">','</span><br>              + <span class="hljs-string">'”。'</span>)<br><span class="hljs-comment"># 可以使用点号 . 来访问对象的属性。使用如下类的名称访问类变量</span><br>Dn1 = Dn(<span class="hljs-string">'小明'</span>,<span class="hljs-string">'联想'</span>,<span class="hljs-string">'8核'</span>,<span class="hljs-string">'512固态硬盘'</span>,<span class="hljs-string">'双飞燕'</span>)<br>Dn1.xgp()<br><br>Dn2 = Dn(<span class="hljs-string">'小米'</span>,<span class="hljs-string">'机械师'</span>,<span class="hljs-string">'4核'</span>,<span class="hljs-string">'256G固态硬盘+1T普通硬盘'</span>,<span class="hljs-string">'机械师鼠标'</span>)<br>Dn2.xgp()<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-5">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">小明的电脑配置：“品牌：联想,cpu：<span class="hljs-number">8</span>核,固态硬盘：<span class="hljs-number">512</span>固态硬盘,鼠标：双飞燕”。<br>小明的电脑配置：“品牌：机械师,cpu：<span class="hljs-number">4</span>核,固态硬盘：<span class="hljs-number">256</span>G固态硬盘,机械硬盘<span class="hljs-number">1</span>T普通硬盘,鼠标：机械师鼠标”。<br></code></pre></td></tr></table></figure></blockquote><h2 id="5、类的继承">5、类的继承</h2><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200327211119750.png" alt="image-20200327211119750"></p><p><strong>面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。</strong></p><p><strong>通过继承创建的新类称为<code>子类</code>或派生类，被继承的类称为<code>基类</code>、<code>父类</code>或<code>超类</code>。</strong></p><p><strong>继承语法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> 派生类名<span class="hljs-params">(基类名)</span></span><br><span class="hljs-class">    ...</span><br></code></pre></td></tr></table></figure><p><strong>在python中继承中的一些特点：</strong></p><ul><li><strong>1、如果在子类中需要父类的构造方法就需要显示的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看：<a href="https://www.runoob.com/w3cnote/python-extends-init.html" target="_blank" rel="noopener">python 子类继承父类构造函数说明</a>。</strong></li><li><strong>2、在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别在于类中调用普通函数时并不需要带上 self 参数</strong></li><li><strong>3、Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。</strong></li></ul><p><strong>如果在继承元组中列了一个以上的类，那么它就被称作&quot;多重继承&quot; 。</strong></p><h4 id="语法："><strong>语法：</strong></h4><p><strong>派生类的声明，与他们的父类类似，继承的基类列表跟在类名之后，如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubClassName</span> <span class="hljs-params">(ParentClass1[, ParentClass2, ...])</span>:</span><br>    ...<br></code></pre></td></tr></table></figure><h3 id="（1）例子-2">（1）例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>:</span>        <span class="hljs-comment"># 定义父类</span><br>   parentAttr = <span class="hljs-number">100</span><br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span><br>      <span class="hljs-keyword">print</span> (<span class="hljs-string">"调用父类构造函数"</span>)<br><br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parentMethod</span><span class="hljs-params">(self)</span>:</span><br>      print(<span class="hljs-string">'调用父类方法'</span>)<br><br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setAttr</span><span class="hljs-params">(self, attr)</span>:</span><br>      Parent.parentAttr = attr<br><br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getAttr</span><span class="hljs-params">(self)</span>:</span><br>      <span class="hljs-keyword">print</span> (<span class="hljs-string">"父类属性 :"</span>, Parent.parentAttr)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span><span class="hljs-params">(Parent)</span>:</span> <span class="hljs-comment"># 定义子类</span><br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span><br>      <span class="hljs-keyword">print</span> (<span class="hljs-string">"调用子类构造方法"</span>)<br><br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">childMethod</span><span class="hljs-params">(self)</span>:</span><br>      <span class="hljs-keyword">print</span> (<span class="hljs-string">'调用子类方法'</span>)<br><br>c = Child()          <span class="hljs-comment"># 实例化子类</span><br>c.childMethod()      <span class="hljs-comment"># 调用子类的方法</span><br>c.parentMethod()     <span class="hljs-comment"># 调用父类方法</span><br>c.setAttr(<span class="hljs-number">200</span>)       <span class="hljs-comment"># 再次调用父类的方法 - 设置属性值</span><br>c.getAttr()          <span class="hljs-comment"># 再次调用父类的方法 - 获取属性值</span><br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-6">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">调用子类构造方法<br>调用子类方法<br>调用父类方法<br>父类属性 : <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="（2）例子">（2）例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">"""</span><br><span class="hljs-string">小明和小红各自买了一台笔记本电脑,</span><br><span class="hljs-string">其中小明的电脑品牌是联想, CPU8核, 512G固态硬盘,双飞燕鼠标</span><br><span class="hljs-string">省红的电脑品牌是机械师, CPU4核, 256G固态硬盘+1T普通硬盘，机械师鼠标</span><br><span class="hljs-string">使用面向对象的思维，编写代码完成以 上描述。</span><br><span class="hljs-string">"""</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dn</span><span class="hljs-params">()</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,brand,cpu,disk,mouse)</span>:</span><br>        self.nice_pp = brand<br>        self.nice_cpu = cpu<br>        self.nice_disk = disk<br>        self.nice_mouse = mouse<br>        <br><span class="hljs-comment"># 继承:共享某个类的代码</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XiaoMing</span><span class="hljs-params">(Dn)</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,brand,cpu,disk,mouse)</span>:</span><br>        super().__init__(brand,cpu,disk,mouse)<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">xgp</span><span class="hljs-params">(self,name)</span>:</span><br>        print(name + <span class="hljs-string">'的电脑配置：“'</span><br>                      + <span class="hljs-string">'品牌：'</span> + self.nice_pp + <span class="hljs-string">','</span><br>                      + <span class="hljs-string">'cpu：'</span> +self.nice_cpu + <span class="hljs-string">','</span><br>                      + <span class="hljs-string">'固态硬盘：'</span> +self.nice_disk + <span class="hljs-string">','</span><br>                      + <span class="hljs-string">'鼠标：'</span> + self.nice_mouse<br>                      + <span class="hljs-string">'”。'</span>)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XiaoHong</span><span class="hljs-params">(Dn)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,brand,cpu,disk,sim_disk,mouse)</span>:</span><br>        self.sim_disk = sim_disk<br>        super() . __init__(brand,cpu,disk,mouse)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wsd</span><span class="hljs-params">(self,name)</span>:</span><br>        print(name + <span class="hljs-string">'的电脑配置：“'</span><br>              + <span class="hljs-string">'品牌：'</span> + self.nice_pp + <span class="hljs-string">','</span><br>              + <span class="hljs-string">'cpu：'</span> + self.nice_cpu + <span class="hljs-string">','</span><br>              + <span class="hljs-string">'固态硬盘：'</span> + self.nice_disk + <span class="hljs-string">','</span><br>              + <span class="hljs-string">'机械硬盘'</span> + self.sim_disk + <span class="hljs-string">','</span><br>              + <span class="hljs-string">'鼠标：'</span> + self.nice_mouse<br>              + <span class="hljs-string">'”。'</span>)<br><br>xiaoming = XiaoMing(<span class="hljs-string">'联想'</span>,<span class="hljs-string">'8核'</span>,<span class="hljs-string">'512固态硬盘'</span>,<span class="hljs-string">'双飞燕'</span>)<br>xiaoming.xgp(<span class="hljs-string">'小明'</span>)<br>xiaohong = XiaoHong(<span class="hljs-string">'机械师'</span>,<span class="hljs-string">'4核'</span>,<span class="hljs-string">'256G固态硬盘'</span>,<span class="hljs-string">'1T普通硬盘'</span>,<span class="hljs-string">'机械师鼠标'</span>)<br>xiaohong.wsd(<span class="hljs-string">'小明'</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-7">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">小明的电脑配置：“品牌：联想,cpu：<span class="hljs-number">8</span>核,固态硬盘：<span class="hljs-number">512</span>固态硬盘,鼠标：双飞燕”。<br>小明的电脑配置：“品牌：机械师,cpu：<span class="hljs-number">4</span>核,固态硬盘：<span class="hljs-number">256</span>G固态硬盘,机械硬盘<span class="hljs-number">1</span>T普通硬盘,鼠标：机械师鼠标”。<br></code></pre></td></tr></table></figure></blockquote><h3 id="（3）方法重写（员工自我介绍）">（3）方法重写（员工自我介绍）</h3><p><strong>如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Empoyee</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-string">"""员工类"""</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,name,years_old,money)</span>:</span><br>        <span class="hljs-string">"""初始化普通员工属性"""</span><br>        self.user_name = name<br>        self.user_years_old = years_old<br>        self.user_money = money<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hi</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""模拟员工自我介绍的方法"""</span><br>        print(<span class="hljs-string">'我叫'</span>+self.user_name<br>              +<span class="hljs-string">',工龄'</span> + self.user_years_old<br>              +<span class="hljs-string">'年，年工资为'</span> + self.user_money<br>              +<span class="hljs-string">'元。'</span><br>              )<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SE</span><span class="hljs-params">(Empoyee)</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,name,years_old,money)</span>:</span><br>        super().__init__(name,years_old,money)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hi</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""模拟员工自我介绍的方法"""</span><br>        print(<span class="hljs-string">'我叫'</span>+self.user_name<br>              +<span class="hljs-string">',工龄'</span> + self.user_years_old<br>              +<span class="hljs-string">'年，年工资为'</span> + self.user_money<br>              +<span class="hljs-string">'元。'</span><br>              )<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PM</span><span class="hljs-params">(Empoyee)</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,name,years_old,money,bonus)</span>:</span><br>        super().__init__(name,years_old,money)<br>        <span class="hljs-comment"># 编写子类特有的属性</span><br>        self.pm_bonus = bonus<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hi</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""模拟项目经理自我介绍的方法"""</span><br>        print(<span class="hljs-string">'我叫'</span>+self.user_name<br>              +<span class="hljs-string">',工龄'</span> + self.user_years_old<br>              +<span class="hljs-string">'年，月工资为'</span> + self.user_money<br>              +<span class="hljs-string">'元，'</span><br>              + <span class="hljs-string">'管理奖金'</span> + self.pm_bonus + <span class="hljs-string">'元。'</span><br>              )<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CTO</span><span class="hljs-params">(Empoyee)</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,name,years_old,money,bonus,annual_bonus)</span>:</span><br>        super().__init__(name,years_old,money)<br>        self.cto_bonus = bonus<br>        self.cto_annual_bonus = annual_bonus<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hi</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""模拟项目经理自我介绍的方法"""</span><br>        print(<span class="hljs-string">'我叫'</span>+self.user_name<br>              +<span class="hljs-string">',工龄'</span> + self.user_years_old<br>              +<span class="hljs-string">'年，月工资为'</span> + self.user_money<br>              +<span class="hljs-string">'元，'</span><br>              + <span class="hljs-string">'管理奖金'</span> + self.cto_bonus + <span class="hljs-string">'元，'</span><br>              + <span class="hljs-string">'年终奖'</span> + self.cto_annual_bonus + <span class="hljs-string">'元。'</span><br>              )<br><br><br><span class="hljs-comment"># 使用类：实例化对象</span><br>se = SE(<span class="hljs-string">'xgp'</span>,<span class="hljs-string">'4'</span>,<span class="hljs-string">'8k'</span>)<br>se.say_hi()<br><br>pm = PM(<span class="hljs-string">'wsd'</span>,<span class="hljs-string">'6'</span>,<span class="hljs-string">'10000'</span>,<span class="hljs-string">'5000'</span>)<br>pm.say_hi()<br><br>cto = CTO(<span class="hljs-string">'xgp'</span>,<span class="hljs-string">'10'</span>,<span class="hljs-string">'30000'</span>,<span class="hljs-string">'6000'</span>,<span class="hljs-string">'12000'</span>)<br>cto.say_hi()<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-8">输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">我叫xgp,工龄<span class="hljs-number">4</span>年，年工资为<span class="hljs-number">8</span>k元。<br>我叫wsd,工龄<span class="hljs-number">6</span>年，月工资为<span class="hljs-number">10000</span>元，管理奖金<span class="hljs-number">5000</span>元。<br>我叫xgp,工龄<span class="hljs-number">10</span>年，月工资为<span class="hljs-number">30000</span>元，管理奖金<span class="hljs-number">6000</span>元，年终奖<span class="hljs-number">12000</span>元。<br></code></pre></td></tr></table></figure><h4 id="分析以上代码">分析以上代码</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200327211430114.png" alt="image-20200327211430114"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200327211446178.png" alt="image-20200327211446178"></p><h2 id="6、Python内置类属性">6、Python内置类属性</h2><ul><li><strong><code>__dict__</code> : 类的属性（包含一个字典，由类的数据属性组成）</strong></li><li><strong>~ :类的文档字符串</strong></li><li><strong><code>__name__</code>: 类名</strong></li><li><strong><code>__module__</code>: 类定义所在的模块（类的全名是’<code>__main__.className</code>’，如果类位于一个导入模块mymod中，那么<code>className.__module__</code> 等于 mymod）</strong></li><li><strong><code>__bases__</code> : 类的所有父类构成元素（包含了一个由所有父类组成的元组）</strong></li></ul><h3 id="Python内置类属性调用实例如下：">Python内置类属性调用实例如下：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span>:</span><br>   <span class="hljs-string">'所有员工的基类'</span><br>   empCount = <span class="hljs-number">0</span><br> <br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, salary)</span>:</span><br>      self.name = name<br>      self.salary = salary<br>      Employee.empCount += <span class="hljs-number">1</span><br>   <br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">displayCount</span><span class="hljs-params">(self)</span>:</span><br>     <span class="hljs-keyword">print</span> <span class="hljs-string">"Total Employee %d"</span> % Employee.empCount<br> <br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">displayEmployee</span><span class="hljs-params">(self)</span>:</span><br>      <span class="hljs-keyword">print</span> <span class="hljs-string">"Name : "</span>, self.name,  <span class="hljs-string">", Salary: "</span>, self.salary<br> <br><span class="hljs-keyword">print</span> <span class="hljs-string">"Employee.__doc__:"</span>, Employee.__doc__<br><span class="hljs-keyword">print</span> <span class="hljs-string">"Employee.__name__:"</span>, Employee.__name__<br><span class="hljs-keyword">print</span> <span class="hljs-string">"Employee.__module__:"</span>, Employee.__module__<br><span class="hljs-keyword">print</span> <span class="hljs-string">"Employee.__bases__:"</span>, Employee.__bases__<br><span class="hljs-keyword">print</span> <span class="hljs-string">"Employee.__dict__:"</span>, Employee.__dict__<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-9">输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">Employee.__doc__: 所有员工的基类<br>Employee.__name__: Employee<br>Employee.__module__: __main__<br>Employee.__bases__: ()<br>Employee.__dict__: &#123;<span class="hljs-string">'__module__'</span>: <span class="hljs-string">'__main__'</span>, <span class="hljs-string">'displayCount'</span>: &lt;function displayCount at <span class="hljs-number">0x10a939c80</span>&gt;, <span class="hljs-string">'empCount'</span>: <span class="hljs-number">0</span>, <span class="hljs-string">'displayEmployee'</span>: &lt;function displayEmployee at <span class="hljs-number">0x10a93caa0</span>&gt;, <span class="hljs-string">'__doc__'</span>: <span class="hljs-string">'\xe6\x89\x80\xe6\x9c\x89\xe5\x91\x98\xe5\xb7\xa5\xe7\x9a\x84\xe5\x9f\xba\xe7\xb1\xbb'</span>, <span class="hljs-string">'__init__'</span>: &lt;function __init__ at <span class="hljs-number">0x10a939578</span>&gt;&#125;<br></code></pre></td></tr></table></figure><h2 id="7、python对象销毁-垃圾回收">7、python对象销毁(垃圾回收)</h2><p><strong>Python 使用了引用计数这一简单技术来跟踪和回收垃圾。</strong></p><p><strong>在 Python 内部记录着所有使用中的对象各有多少引用。</strong></p><p><strong>一个内部跟踪变量，称为一个引用计数器。</strong></p><p><strong>当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是&quot;立即&quot;的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">a = <span class="hljs-number">40</span>      # 创建对象  &lt;<span class="hljs-number">40</span>&gt;<br>b = a       # 增加引用， &lt;<span class="hljs-number">40</span>&gt; 的计数<br>c = [b]     # 增加引用.  &lt;<span class="hljs-number">40</span>&gt; 的计数<br><br>del a       # 减少引用 &lt;<span class="hljs-number">40</span>&gt; 的计数<br>b = <span class="hljs-number">100</span>     # 减少引用 &lt;<span class="hljs-number">40</span>&gt; 的计数<br>c[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>   # 减少引用 &lt;<span class="hljs-number">40</span>&gt; 的计数<br></code></pre></td></tr></table></figure><p><strong>垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（及未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。</strong></p><h3 id="实例">实例</h3><p><strong>析构函数 <code>__del__</code> ，<code>__del__</code>在对象销毁的时候被调用，当对象不再被使用时，<code>__del__</code>方法运行：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>:</span><br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">( self, x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>)</span>:</span><br>      self.x = x<br>      self.y = y<br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span><span class="hljs-params">(self)</span>:</span><br>      class_name = self.__class__.__name__<br>      <span class="hljs-keyword">print</span> class_name, <span class="hljs-string">"销毁"</span><br> <br>pt1 = Point()<br>pt2 = pt1<br>pt3 = pt1<br><span class="hljs-keyword">print</span> id(pt1), id(pt2), id(pt3) <span class="hljs-comment"># 打印对象的id</span><br><span class="hljs-keyword">del</span> pt1<br><span class="hljs-keyword">del</span> pt2<br><span class="hljs-keyword">del</span> pt3<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-10">输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">3083401324</span> <span class="hljs-number">3083401324</span> <span class="hljs-number">3083401324</span><br>Point 销毁<br></code></pre></td></tr></table></figure><p>**注意：**通常你需要在单独的文件中定义一个类</p><h2 id="8、总结">8、总结</h2><p><strong>参数的传递图，翻译与<a href="https://link.zhihu.com/?target=http%3A//pythoncentral.io/difference-between-staticmethod-and-classmethod-in-python/">pythoncentral</a>网</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200326153551044.png" alt="image-20200326153551044"></p><ul><li><strong>In 1 and 2,</strong> the arguments are passed to the method.</li><li><strong>1和2</strong>参数传递给**<strong>init</strong><strong>方法中的</strong>data参数**。</li><li><strong>On 3,</strong> the self argument refers to the instance.</li><li><strong>3****self</strong> 参数指向当前实例自身，self代表创建的实例变量 <strong>ik1</strong> 或者 <strong>Kls(‘arun’)。</strong></li><li><strong>At 4,</strong> we do not need to provide the instance to the method, as it is handled by the interpretor itself.</li><li><strong>4</strong> 我们不需要传递实例自身给方法，Python解释器自己会做这些操作的；<strong>ik14</strong> 会自动作为第一个实例参数(<strong>self</strong>)传入方法中。</li></ul><p><img src="https://pic2.zhimg.com/80/v2-21b16776e5a46e666a6af75a973c4ae5_720w.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python练习题</title>
      <link href="/posts/d262.html"/>
      <url>/posts/d262.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、使用while实现：输出摄氏温度与华氏温度的对照表，要求它从摄氏温度0度到250度，每隔20度为一项，对照表中的条目不超过10条。">1、使用while实现：输出摄氏温度与华氏温度的对照表，要求它从摄氏温度0度到250度，每隔20度为一项，对照表中的条目不超过10条。</h3><ul><li><strong>转换关系：华氏温度 = 摄氏温度 * 9 / 5.0 + 32</strong></li><li><strong>循环操作：计算摄氏温度，并输出对照条目</strong></li><li><strong>循环条件：</strong></li><li><strong>条目&lt;=10 &amp;&amp; 摄氏温度 &lt;= 250</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">xgp</span><span class="hljs-params">()</span>:</span><br>    t = <span class="hljs-number">1</span><br>    w = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> (t &lt;= <span class="hljs-number">10</span> <span class="hljs-keyword">and</span> w &lt;= <span class="hljs-number">250</span>):<br>        t = t + <span class="hljs-number">1</span><br>        w = w + <span class="hljs-number">20</span><br>        s = w*<span class="hljs-number">9</span>/<span class="hljs-number">5.0</span>+<span class="hljs-number">32</span><br>        print(w,s,end=<span class="hljs-string">" "</span>)<br>        print()<br>xgp()<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">20</span> <span class="hljs-number">68.0</span> <br><span class="hljs-number">40</span> <span class="hljs-number">104.0</span> <br><span class="hljs-number">60</span> <span class="hljs-number">140.0</span> <br><span class="hljs-number">80</span> <span class="hljs-number">176.0</span> <br><span class="hljs-number">100</span> <span class="hljs-number">212.0</span> <br><span class="hljs-number">120</span> <span class="hljs-number">248.0</span> <br><span class="hljs-number">140</span> <span class="hljs-number">284.0</span> <br><span class="hljs-number">160</span> <span class="hljs-number">320.0</span> <br><span class="hljs-number">180</span> <span class="hljs-number">356.0</span> <br><span class="hljs-number">200</span> <span class="hljs-number">392.0</span> <br></code></pre></td></tr></table></figure></blockquote><h3 id="2、输入一个4位数，如果各个数字之和大于20，则为幸运数。">2、输入一个4位数，如果各个数字之和大于20，则为幸运数。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sw</span><span class="hljs-params">()</span>:</span><br>    num = int(input(<span class="hljs-string">"请您输入四位数的号码："</span>))<br>    print(<span class="hljs-string">'您输入的是：'</span>+str(num))<br>    <span class="hljs-comment"># 分解四位数，获取各位数字</span><br>    <span class="hljs-comment"># 获取个位数字</span><br>    gw = num%<span class="hljs-number">10</span><br>    <span class="hljs-comment"># 获取十位数字</span><br>    xw = int(num%<span class="hljs-number">100</span>/<span class="hljs-number">10</span>)<br>    <span class="hljs-comment"># 获取百位数字</span><br>    bw = int(num/<span class="hljs-number">1000</span>%<span class="hljs-number">10</span>)<br>    <span class="hljs-comment"># 获取千位数字</span><br>    qw = int(num/<span class="hljs-number">1000</span>)<br>    <span class="hljs-comment"># 求4个数值的和，并进行判断, 如果大于20, 则输出提示: 是幸运数</span><br>    <span class="hljs-keyword">if</span> (gw+xw+bw+qw) &gt; <span class="hljs-number">20</span>:<br>        print(<span class="hljs-string">'是幸运数字！'</span>)<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">'谢谢参与'</span>)<br>sw()<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-2">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">请您输入四位数的号码：<span class="hljs-number">9999</span><br>您输入的是：<span class="hljs-number">9999</span><br>是幸运数字！<br></code></pre></td></tr></table></figure></blockquote><h3 id="3、编写程序，使用嵌套的if语句，为小飞制定学习计划，星期一、星期三、星期五学习编程，星期二、星期四、星期六学习英语，星期日休息。">3、编写程序，使用嵌套的if语句，为小飞制定学习计划，星期一、星期三、星期五学习编程，星期二、星期四、星期六学习英语，星期日休息。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">xuexi</span><span class="hljs-params">()</span>:</span><br>    ss = input(<span class="hljs-string">"今天是周几:"</span>)<br>    <span class="hljs-keyword">for</span>  i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>):<br>            <span class="hljs-keyword">if</span> ss == <span class="hljs-string">"周一"</span>:<br>                print(<span class="hljs-string">"周1学习编程"</span>)<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">elif</span> ss == <span class="hljs-string">"周二"</span>:<br>                print(<span class="hljs-string">"周2学习英语"</span>)<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">elif</span> ss == <span class="hljs-string">"周三"</span>:<br>                print(<span class="hljs-string">"周3学习编程"</span>)<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">elif</span> ss == <span class="hljs-string">"周四"</span>:<br>                print(<span class="hljs-string">"周4学习英语"</span>)<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">elif</span> ss == <span class="hljs-string">"周五"</span>:<br>                print(<span class="hljs-string">"周5学习编程"</span>)<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">elif</span> ss == <span class="hljs-string">"周六"</span>:<br>                print(<span class="hljs-string">"周6学习英语"</span>)<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">elif</span> ss == <span class="hljs-string">"周日"</span>:<br>                print(<span class="hljs-string">"周日放假!!!"</span>)<br>                <span class="hljs-keyword">break</span><br>xuexi()<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-3">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">今天是周几:周一<br>周<span class="hljs-number">1</span>学习编程<br></code></pre></td></tr></table></figure></blockquote><h3 id="4、编写一个计数器，能够根据提示输入两个操作数和运算符号，计算出结果。">4、编写一个计数器，能够根据提示输入两个操作数和运算符号，计算出结果。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">num</span><span class="hljs-params">()</span>:</span><br>    a = int(input(<span class="hljs-string">"请输入第一个数:"</span>))<br>    fh = input(<span class="hljs-string">"+,-,*,/,%:"</span>)<br>    b = int(input(<span class="hljs-string">"请输入第二个数:"</span>))<br>    <span class="hljs-keyword">if</span> fh == <span class="hljs-string">"+"</span>:<br>        print(<span class="hljs-string">"%s%s%s=%s"</span>%(a,fh,b,a+b))<br>    <span class="hljs-keyword">elif</span> fh == <span class="hljs-string">"-"</span>:<br>        print(<span class="hljs-string">"%s%s%s=%s"</span>%(a,fh,b,a-b))<br>    <span class="hljs-keyword">elif</span> fh == <span class="hljs-string">"*"</span>:<br>        print(<span class="hljs-string">"%s%s%s=%s"</span>%(a,fh,b,a*b))<br>    <span class="hljs-keyword">elif</span> fh == <span class="hljs-string">"%"</span>:<br>        print(<span class="hljs-string">"%s%s%s=%s"</span>%(a,fh,b,a%b))<br>    <span class="hljs-keyword">elif</span> fh == <span class="hljs-string">"/"</span>:<br>        <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>:<br>            print(<span class="hljs-string">"除数不能是0"</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">"%s%s%s=%s"</span>%(a,fh,b,a/b))<br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">"输入符号有误"</span>)<br>num()<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-4">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">请输入第一个数:<span class="hljs-number">1</span><br>+,-,*,/,%:+<br>请输入第二个数:<span class="hljs-number">595</span><br><span class="hljs-number">1</span>+<span class="hljs-number">595</span>=<span class="hljs-number">596</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="5、猜拳游戏：预先定义一个数值，根据用户输入的数字，分别给出提示：“猜大了”或“猜小了”或“猜对了”，只有3次机会，否则退出程序。">5、猜拳游戏：预先定义一个数值，根据用户输入的数字，分别给出提示：“猜大了”或“猜小了”或“猜对了”，只有3次机会，否则退出程序。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cai</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">import</span> random<br>    a = random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>  i &lt; <span class="hljs-number">3</span>:<br>        s = int(input(<span class="hljs-string">"请您输入数字："</span>))<br>        <span class="hljs-keyword">if</span> s &gt; a:<br>            print(<span class="hljs-string">"猜大了"</span>)<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> s &lt; a:<br>            print(<span class="hljs-string">"猜小了"</span>)<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">"恭喜你，答对了！"</span>)<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">3</span>:<br>            x = input(<span class="hljs-string">"三次都没对，是否还猜？y/n："</span>)<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-string">'y'</span> <span class="hljs-keyword">or</span> x == <span class="hljs-string">'Y'</span>:<br>                i = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">elif</span> x == <span class="hljs-string">'N'</span> <span class="hljs-keyword">or</span> x == <span class="hljs-string">'n'</span>:<br>                <span class="hljs-keyword">break</span><br>cai()<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-5">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">请您输入数字：<span class="hljs-number">5</span><br>猜小了<br>请您输入数字：<span class="hljs-number">8</span><br>猜小了<br>请您输入数字：<span class="hljs-number">10</span><br>猜大了<br>三次都没对，是否还猜？y/n：y<br>请您输入数字：<span class="hljs-number">9</span><br>恭喜你，答对了！<br></code></pre></td></tr></table></figure></blockquote><h3 id="6、跑马灯特效">6、跑马灯特效</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    content=<span class="hljs-string">'免疫靠尿，戒严靠揍'</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        os.system(<span class="hljs-string">'cls'</span>)<br>        print(content)<br>        time.sleep(<span class="hljs-number">0.2</span>)<br>        content=content[<span class="hljs-number">1</span>:]+content[<span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-6">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">免疫靠尿，戒严靠揍<br>疫靠尿，戒严靠揍免<br>靠尿，戒严靠揍免疫<br>尿，戒严靠揍免疫靠<br>，戒严靠揍免疫靠尿<br>戒严靠揍免疫靠尿，<br>严靠揍免疫靠尿，戒<br>靠揍免疫靠尿，戒严<br>揍免疫靠尿，戒严靠<br>免疫靠尿，戒严靠揍<br></code></pre></td></tr></table></figure></blockquote><h3 id="7、某人准备去南方旅游，现在要订购机票。机票的价格受季节旺季、淡季的影响，头等舱和经济舱价格也不同。">7、某人准备去南方旅游，现在要订购机票。机票的价格受季节旺季、淡季的影响，头等舱和经济舱价格也不同。</h3><p><strong>假设机票原价为5000元，4~10月为旺季，旺季头等舱打9折，经济舱打8折；淡季头等舱打5折，经济舱打4折。</strong></p><p><strong>编写程序，使用嵌套的if语句，根据出行的月份和选择的舱位输出实际的机票价格。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hxq</span><span class="hljs-params">()</span>:</span><br>    wj = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]<br>    y = int(input(<span class="hljs-string">"你打算购买几月份的机票呢?"</span>))<br>    c = input(<span class="hljs-string">"你打算坐头等舱还是经济舱呢?"</span>)<br>    <span class="hljs-keyword">if</span> y <span class="hljs-keyword">in</span> wj:<br>        <span class="hljs-keyword">if</span> c == <span class="hljs-string">"头等舱"</span>:<br>            print(<span class="hljs-string">"请您支付:"</span> + str(<span class="hljs-number">5000</span> * <span class="hljs-number">0.9</span>) + <span class="hljs-string">"元"</span>)<br>        <span class="hljs-keyword">if</span> c == <span class="hljs-string">"经济舱"</span>:<br>            print(<span class="hljs-string">"请您支付:"</span> + str(<span class="hljs-number">5000</span> * <span class="hljs-number">0.8</span>) + <span class="hljs-string">"元"</span>)<br>    <span class="hljs-keyword">elif</span> y <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> wj <span class="hljs-keyword">and</span>(y &gt; <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> y &lt; <span class="hljs-number">11</span>):<br>        <span class="hljs-keyword">if</span> c == <span class="hljs-string">"头等舱"</span>:<br>            print(<span class="hljs-string">"请您支付:"</span> + str(<span class="hljs-number">5000</span> * <span class="hljs-number">0.5</span>) + <span class="hljs-string">"元"</span>)<br>        <span class="hljs-keyword">if</span> c == <span class="hljs-string">"经济舱"</span>:<br>            print(<span class="hljs-string">"请您支付:"</span> + str(<span class="hljs-number">5000</span> * <span class="hljs-number">0.4</span>) + <span class="hljs-string">"元"</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">"请输入正确的月份"</span>)<br>hxq()<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-7">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">你打算购买几月份的机票呢?6<br>你打算坐头等舱还是经济舱呢?经济舱<br>请您支付:<span class="hljs-number">4000.0</span>元<br></code></pre></td></tr></table></figure></blockquote><h3 id="8、学生管理系统">8、学生管理系统</h3><ul><li><strong>必须使用自定义函数，完成对程序的模块化</strong></li><li><strong>学生信息至少包含：姓名、年龄、地址，除此以外可以适当添加</strong></li><li><strong>必须完成的功能：添加、删除、修改、查询、退出</strong></li></ul><h4 id="（1）设置函数">（1）设置函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 新建一个列表，用来保存学生所有信息。</span><br>card_info = []<br><br><span class="hljs-comment"># 添加</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-string">"""添加名片的方法"""</span><br>    <span class="hljs-comment"># 插入一张新名片的功能</span><br>    <span class="hljs-comment"># 定义全局变量</span><br>    <span class="hljs-keyword">global</span> card_info<br>    newName = input(<span class="hljs-string">"请输入新的学生名字："</span>)<br>    newSex = input(<span class="hljs-string">"请输入新的学生性别(男/女)："</span>)<br>    newPhone = input(<span class="hljs-string">"请输入新的学生电话："</span>)<br>    <span class="hljs-comment"># 定义新的字典，存储新名片信息</span><br>    newInfo = &#123;&#125;<br>    newInfo[<span class="hljs-string">"name"</span>] = newName<br>    newInfo[<span class="hljs-string">"sex"</span>] = newSex<br>    newInfo[<span class="hljs-string">"phone"</span>] = newPhone<br><br>    <span class="hljs-comment"># 把输入的新名片添加到列表中</span><br>    card_info.append(newInfo)<br><br><span class="hljs-comment"># 删除</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span><span class="hljs-params">(info)</span>:</span><br>    delNum = int(input(<span class="hljs-string">"请输入要删除的序号："</span>)) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">del</span> info[delNum]<br><span class="hljs-comment"># 修改</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modify</span><span class="hljs-params">()</span>:</span><br>    studentId = int(input(<span class="hljs-string">"请输入要修改的序号："</span>)) - <span class="hljs-number">1</span><br>    newName = input(<span class="hljs-string">"请输入新的学生名字："</span>)<br>    newSex = input(<span class="hljs-string">"请输入新的学生性别(男/女)："</span>)<br>    newPhone = input(<span class="hljs-string">"请输入新的学生电话："</span>)<br>    newInfo = &#123;&#125;<br>    newInfo[<span class="hljs-string">"name"</span>] = newName<br>    newInfo[<span class="hljs-string">"sex"</span>] = newSex<br>    newInfo[<span class="hljs-string">"phone"</span>] = newPhone<br>    card_info[studentId] = newInfo<br><br><span class="hljs-comment"># 查询</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">query</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-string">"""查找名片是否存在"""</span><br>    flag = <span class="hljs-number">0</span> <span class="hljs-comment"># 默认为0表示没有此人，1表示有此人</span><br>    <span class="hljs-comment"># 请输入要查询的姓名</span><br>    find_name = input(<span class="hljs-string">"请您输入要查询的姓名:"</span>)<br>    <span class="hljs-keyword">for</span> card <span class="hljs-keyword">in</span> card_info :<br>        <span class="hljs-keyword">if</span> find_name == card[<span class="hljs-string">"name"</span>]:<br>            print(<span class="hljs-string">"%s\t%s\t%s"</span>%(card[<span class="hljs-string">"name"</span>],card[<span class="hljs-string">"sex"</span>],card[<span class="hljs-string">"phone"</span>]))<br>            flag = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">break</span> <span class="hljs-comment">#查到了的话就不查了</span><br>    <span class="hljs-keyword">if</span> flag == <span class="hljs-number">0</span> :<br>        print(<span class="hljs-string">"查无此人"</span>)<br><br><span class="hljs-comment"># 遍历</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ergodic</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">"="</span> * <span class="hljs-number">30</span>)<br>    print(<span class="hljs-string">"学生信息如下"</span>)<br>    print(<span class="hljs-string">"="</span> * <span class="hljs-number">30</span>)<br>    print(<span class="hljs-string">"序号    姓名    性别    手机号"</span>)<br>    num = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> tempInfo <span class="hljs-keyword">in</span> card_info:<br>        print(<span class="hljs-string">" %d   %s  %s   %s"</span> % (num, tempInfo[<span class="hljs-string">"name"</span>], tempInfo[<span class="hljs-string">"sex"</span>], tempInfo[<span class="hljs-string">"phone"</span>]))<br>        num += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 操作菜单</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_menua</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">'-------------------------学生信息管理系统----------------------'</span>)<br>    print(<span class="hljs-string">'1、添加 2、删除 3、修改 4、查询 5、遍历 0、退出'</span>)<br>    print(<span class="hljs-string">'--------------------------------------------------------------'</span>)<br></code></pre></td></tr></table></figure><h4 id="（2）调用函数">（2）调用函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 测试学生管理系统的功能</span><br><span class="hljs-comment"># from student_ sys. CMS import *</span><br><span class="hljs-keyword">import</span> python函数.mokuai.学生管理系统.xs <span class="hljs-keyword">as</span> stu<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span> == <span class="hljs-number">1</span>:<br>        <span class="hljs-comment"># 显示操作菜单</span><br>        stu.show_menua()<br>            <span class="hljs-comment"># 用户操作</span><br>        key = int(input(<span class="hljs-string">'请选择:[0、1、2、3、4、5]：'</span>))<br>        <span class="hljs-keyword">if</span> key == <span class="hljs-number">1</span>:<br>            stu.add()<br>        <span class="hljs-keyword">elif</span> key == <span class="hljs-number">2</span>:<br>            stu.delete(card_info)<br>        <span class="hljs-keyword">elif</span> key == <span class="hljs-number">3</span>:<br>            stu.modify()<br>        <span class="hljs-keyword">elif</span> key == <span class="hljs-number">4</span>:<br>            stu.query()<br>        <span class="hljs-keyword">elif</span> key == <span class="hljs-number">5</span>:<br>            stu.ergodic()<br>        <span class="hljs-keyword">elif</span> key == <span class="hljs-number">0</span>:<br>            exit = input(<span class="hljs-string">"真的要退出系统吗？(Yes or No)："</span>)<br>            <span class="hljs-keyword">if</span> exit == <span class="hljs-string">"Yes"</span>:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">elif</span> exit == <span class="hljs-string">"No"</span>:<br>                <span class="hljs-keyword">pass</span><br>            <span class="hljs-keyword">else</span>:<br>                print(<span class="hljs-string">"输入有误，请重新输入"</span>)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">"输入有误，请重新输入"</span>)<br><br><span class="hljs-comment"># 调用主函数，运行程序</span><br>main()<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-8">输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加</span><br>-------------------------学生信息管理系统----------------------<br><span class="hljs-number">1</span>、添加 <span class="hljs-number">2</span>、删除 <span class="hljs-number">3</span>、修改 <span class="hljs-number">4</span>、查询 <span class="hljs-number">5</span>、遍历 <span class="hljs-number">0</span>、退出<br>--------------------------------------------------------------<br>请选择:[<span class="hljs-number">0</span>、<span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">4</span>、<span class="hljs-number">5</span>]：<span class="hljs-number">1</span><br>请输入新的学生名字：xgp<br>请输入新的学生性别(男/女)：男<br>请输入新的学生电话：<span class="hljs-number">17634984710</span><br><br><span class="hljs-comment"># 遍历</span><br>-------------------------学生信息管理系统----------------------<br><span class="hljs-number">1</span>、添加 <span class="hljs-number">2</span>、删除 <span class="hljs-number">3</span>、修改 <span class="hljs-number">4</span>、查询 <span class="hljs-number">5</span>、遍历 <span class="hljs-number">0</span>、退出<br>--------------------------------------------------------------<br>请选择:[<span class="hljs-number">0</span>、<span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">4</span>、<span class="hljs-number">5</span>]：<span class="hljs-number">5</span><br>==============================<br>学生信息如下<br>==============================<br>序号    姓名    性别    手机号<br> <span class="hljs-number">1</span>   xgp  男   <span class="hljs-number">17634984710</span><br>    <br><span class="hljs-comment"># 查询</span><br>-------------------------学生信息管理系统----------------------<br><span class="hljs-number">1</span>、添加 <span class="hljs-number">2</span>、删除 <span class="hljs-number">3</span>、修改 <span class="hljs-number">4</span>、查询 <span class="hljs-number">5</span>、遍历 <span class="hljs-number">0</span>、退出<br>--------------------------------------------------------------<br>请选择:[<span class="hljs-number">0</span>、<span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">4</span>、<span class="hljs-number">5</span>]：<span class="hljs-number">4</span><br>请您输入要查询的姓名:xgp<br>xgp男<span class="hljs-number">17634984710</span><br><br><span class="hljs-comment"># 修改</span><br>-------------------------学生信息管理系统----------------------<br><span class="hljs-number">1</span>、添加 <span class="hljs-number">2</span>、删除 <span class="hljs-number">3</span>、修改 <span class="hljs-number">4</span>、查询 <span class="hljs-number">5</span>、遍历 <span class="hljs-number">0</span>、退出<br>--------------------------------------------------------------<br>请选择:[<span class="hljs-number">0</span>、<span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">4</span>、<span class="hljs-number">5</span>]：<span class="hljs-number">3</span><br>请输入要修改的序号：<span class="hljs-number">1</span><br>请输入新的学生名字：wsd<br>请输入新的学生性别(男/女)：男<br>请输入新的学生电话：<span class="hljs-number">17634984720</span><br><br><span class="hljs-comment"># 删除</span><br>-------------------------学生信息管理系统----------------------<br><span class="hljs-number">1</span>、添加 <span class="hljs-number">2</span>、删除 <span class="hljs-number">3</span>、修改 <span class="hljs-number">4</span>、查询 <span class="hljs-number">5</span>、遍历 <span class="hljs-number">0</span>、退出<br>--------------------------------------------------------------<br>请选择:[<span class="hljs-number">0</span>、<span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">4</span>、<span class="hljs-number">5</span>]：<span class="hljs-number">2</span><br>请输入要删除的序号：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义函数</title>
      <link href="/posts/a148.html"/>
      <url>/posts/a148.html</url>
      
        <content type="html"><![CDATA[<h1>一、PyCharm基本设置</h1><h2 id="1、用Ctrl-鼠标滚轮–放大或缩小字体">1、用Ctrl+鼠标滚轮–放大或缩小字体</h2><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200320212958194.png" alt="image-20200320212958194"></p><p>搜索zoom</p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200320212921571.png" alt="image-20200320212921571"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200320213202647.png" alt="image-20200320213202647"></p><h2 id="2、在Windows资源管理器打开文件或目录">2、在Windows资源管理器打开文件或目录</h2><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200320213244257.png" alt="image-20200320213244257"></p><p><strong>搜索keymap</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200320213425124.png" alt="image-20200320213425124"></p><p><strong>设置成不常用的键即可，如F3。</strong></p><h2 id="3、代码提示">3、代码提示</h2><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200320213244257.png" alt="image-20200320213244257"></p><p><strong>搜索letter</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200320214013618.png" alt="image-20200320214013618"></p><h1>二、自定义函数</h1><p>![image-20200319144955045](G:\四期\python\python文档\7 .assets\image-20200319144955045.png)</p><h2 id="1-为什么要使用函数">1.为什么要使用函数</h2><blockquote><p><strong>函数中的代码一次编写,多处运行;</strong><br><strong>函数可以让代码复用，减少代码冗余。</strong></p></blockquote><p><strong>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。</strong></p><p><strong>函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。</strong></p><p><strong>假设我有这样的需求：</strong></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPwAAAGoCAIAAADtoR9lAAAeEElEQVR4nO2dPY7qyBqGZ00mGIJuqTtiAZbuAq500wmogNGRSNCIBVR01jCRRcIEJGgkEhJvYJKRegMEREi+Qfmnyi5/2PVHtf2+yZyGz+WH4vFH2TDwS6HmdrsVgzOq+Ovry9PIYJYD5qfFvzgfsS94MsIUg/lpMaSnAuYwxZDeLwaYw2DEzAzpqYA5TDGk94sB5jAYMTNDeipgDlMcWvovNbfb7WtwRhWPij8MMIfBiJkZnZ4KmMMUB2aG9FTAHKYY0vvFAHMYjJiZIT0VMIcphvR+McAcBiNmZkhPBcxhiiG9Xwwwh8GImRnSUwFzmGJI7xcDzGEwYmaG9FTAHKYY0vvFAHMYjJiZIT0VMIcphvR+McAcBiNmZkhPBcxhikNLfwsV8TnP7xUwh0lg5qCd/sePHwky3fz48cPYDU/WaYuDSv/qJwXxHmM3PFkXi/TDN0G+USC9JpB+2oH0mkD6aQfSawLppx1Irwmkn3YgvSaQftqB9JpA+mkH0msC6acdSK8JpJ92IL0mkH7agfSaQHr7ZCxhWZHzNEl5/mqYViC9Jq+RPmNJkiSlKqUwCcvUe6nUtWJ7aVzpL31ynva6Wd0nj0rVy3vN81zZ/xOWLHsG6iTfSXqbj2iOSlDpa5sbiySlMpZ0NGnsy5hWPUnP7rFSbqFqq/zVc5csfVvenKdDjsiW/9SB6zNiV8ZuOHXtSSbd6VXRdDI/8yrleZHztHmlqP5Sh1D2UkvW7L69IFHuqUbrNPpu51dfbZod1rR8wAuQp3ynTu98xL4ElP55i5SE7thXHxzNnRlLUsZSxsUtGSsVzpiuj1atV7eEqQoSxlXIlDHpb2V75YE1B1SiHoMZS3k+ZNXlKZBekwg6fVeIgdKrBYV8qjB4903kQ0Xeba26JLa6SJFXRdXahmUZSzkXx6FueRPonBfSa/Jy6dVFufjnkOWNvHlVr7N9wFlxkrAsYwljrC19ztNybxnrLo9qycs7e9dtGUuql6PWI/UeSK/Ja6SX+2Qph+40tmiWLD3Rb9V72lvkPBVpbZRzVq1C1KOE8erykrTIl/5Z2S42lEdtSZ/ph/AdSK/Ja9b07dPHNG1uG770LzImnOzv5qr6lXwpz3VHRS19tRxvjG4b3KA3ZxGdnUmbKGcqfUekj0B6TV6+vFGu0ct3PbsgI9ypm6Za3vWq3lo6kW29SOill9Y4bcT6dUhGqzYTCBlLeSYdGylj7d16DaTX5KXSi6aeMiZdj6kX+Ly5cJLyTBGv3LZZWZRpNlelVy7ntNbkSXvzjvTqxSBpZPlaTd3ou92/vcOgb9tCek1eJr2iUrk0111YaS2xNRd6NH2z9ZZX+2hR/m5OC7prepaVzVzyu/qz4mnY5ZPa+lVAuqKT1IXhxIf0mgSVvnJF95RLy2LF8+619O7Vm06B7vCQtuhRrtXpC/UFo722r3cnf2Chs+fmQOocaUHEh/Sa4ANn0w6k1wTSTzuQXhNIP+1Aek0g/bTznaS3+YjmqED6aUc8ucZuOHXtSdDpETf5Tp3e+Yh9gfTTDqTXBNJPO5BeE0g/7UB6TfCjDHOIsRuerHu99Pj5nWkHP7/Tzgx/9U6oYI+BeXaLAempQPowxZDeLwakD4MRMzOkpwLpwxRDer8YkD4MRszMkJ4KpA9TDOn9YkD6MBgxM0N6KpA+THFo6b/U3G63r8EZVTwq/jBCMgvp7TEwz24x0OmpWDKj0w9MYGZITwXShymG9H4xIH0YjJiZIT0VSB+mGNL7xYD0YTBiZob0VCB9mGJI7xcD0ofBiJkZ0lOB9GGKIb1fDEgfBiNmZkhPZSzz9Xr9Q4qQXr7ler3GxhxDMaT3i+GbebVa9f0vpKvVKk7mlxdDer8Yvpn3+32f9Pv9Pk7mlxdDer8Yvpkvl0uf9JfLJU7mlxdDer8YAZg/Pz+7xn98fBhjYJ7dYgT91uJg+3IVM+btdtuVfrvdOsfTZj7zbBx0eipmzOfzuSv9+Xw2xsA8u8WA9FSMmd/e3mTj39/fbTAwz24xID0VY+bWCme73dpgYJ7dYkB6KsbMp9NJlv50OtlgYJ7dYkB6KsbMj8djuVwK45fL5ePxsMHAPLvFgPRUbJg3m42QfrPZWGJgnt1iQHoqNszH41FIfzweLTEwz24xID0VG+b7/b5YLBaLxf1+t8TAPLvFgPRULJnX6/V6vbbHwDy7xYD0VCyZD4fD4XCwx8A8u8X4TtLj13t85++//3b1dEP6onDxwF6txPTz8+dPV083pC8Kd9IPHwQZnp8/f0J697uH9DFnXtLfQsX+46OQ3l+E9JxzF0/16OCjxb0jQ3p/mVendz5iXyB9zIH0XnYP6WMOpPeye0gfcyC9l91D+pgD6b3sPrz0GUtY1vyZ81T+U5OcpynPyftZJtW1dtDZvW6wjHXeEnpCRY02+iH0BdJ72X2U0quOKH+19clYo2d9X87TXnF7NW24MpawrB6jSrmZCqCMJj+yEQ+BCKT3svsopS8UmRtJcp4mijyl2Jo+3avVUOk7DndoOqO1HtmAh/AskN7L7l8uff9ipLqnMkY9PMSt7UMmYx2lNEeE9vBQ6lim7E8yfbj0Tx/C80B6L7t/ifSyl/L6RB9qOdC1KGOVx5qGXXQ6ffNnp9Nr7ys6y54hJwJY0w8onrD0pTRS42ytRZ51ZkWuRnpJZnVJP0L61vi1qtSrka7Tj3oIVCC9l90Hl16YUS1tc56mnBOXQHKeijx1pK+bmnf6asj+E9TWaPqDY/hD6ATSe9l9aOkbaTKWMF5ZRZ1cik3aNYO6aans05p6X61/lcekpPJo6YmH8DyQ3svuA0vfPg1s1gO665ZJdfZX/Zc45015xpm8wNGsx8WfVKeXV+zanY6SfsxD0GZe0j/7GKazhP1osWKFfEbbsiFjibJuV84AWg5K62OxkEiIC5bP3pxqvbuVsSRJ09Sk0w9+CFTw0eKhGVUcstPLlncu2tRdsbn80tyjeT9KaFovuYX95X+pVcSANYZwV7JWveJOLpaqc+chD4GmKIq5dXrnI/YloPSNbj2v8j0qPLneJzRsOyYp2EdBgCqLfYqts6G+BpcsBxRPUnpkdCC9l91D+pgD6b3sHtLHHEjvZfeQPuZAei+7h/QxB9J72T2kjzmQ3svu8bV+8QfSO949vsA1/uALXB3vfoZfIS1MssfAPLvFgPRUIH2YYkjvFwPSh8GImRnSU4H0YYpDS/+l5na7fQ3OqOJR8YcRkllIb4+BeXaLgU5PxZIZnX5gAjNDeiqQPkwxpPeLAenDYMTMDOmpQPowxZDeLwakD4MRMzOkpwLpwxRDer8YkD4MRszMkJ4KpA9TDOn9YkD6MBgxM0N6KpA+TDGk94sB6cNgxMwM6alA+jDFkN4vBqQPgxEzM6SnAunDFIeW/hYqX2G/mdZJLJmF9I5YhmaG8zw26PRUxjJfr9c/pAjp5Vuu12tszDEUY3njF8M382q16vuugdVqFSfzy4shvV8M38z7/b5P+v1+Hyfzy4shvV8M38yXy6VP+svlEifzy4shvV+MAMyfn59d4z8+PowxMM9uMSA9FTPm3W7XlX632xljYJ7dYkB6KmbM5/O5K/35fDbGwDy7xYD0VIyZ397eZOPf399tMDDPbjEgPRVj5u12K0u/3W5tMDDPbjEgPRVj5tPpJEt/Op1sMDDPbjEgPRVj5sfjsVwuhfHL5fLxeNhgYJ7dYkB6KjbMm81GSL/ZbCwxMM9uMSA9FRvm4/EopD8ej5YYmGe3GJCeig3z/X5fLBaLxeJ+v1tiYJ7dYuCjxVQsmX/77bfffvvNFczAzHCexwadnool8+FwOBwO9hiYZ7cYE5Eev8E2Kj9+/DCbZ0/FkN4E49UWfb+YzbOnYkhvgiE/kQgdSA/pZxdID+lnF0gP6WcXSD876XOesqz+K2OJ9FfvFinPB97XGTDnafcsstmmGUAeSrNRNap2PM3A/YH0c5Y+Yz3OqCorf3UsH3YQ5TxV76jGqcdr70WploYl9kcdnVIg/XykL70rpdFZKPfJjNXNVWnG3V6a51meN1tptavc7PZ16b9SU6elR6e3LJ6P9IVwkrGUcWFarWjGpPWDXK2Y2umx7QUI7/hYbd8MrpG9RJH3Ty9v0Okti2clfVG0pCnNpZf1/S6p9yiHTsaqezQCpzxXpc85S1PJ7hqylBrLG6cY85S+ElFne7eFayI2bJ17ppwz7VlBhyHP2x2/kI8TBabFiOUNpC+LB0svrdVbt+t9yXkqottIXYgXmtPT1kjds2Od9D2HXX2godNbFk/ko8UDpc8Y4zxlWX8311yAFC7pjgppFaJ0ePl8VtuZq0GlDSQCXpvcON0+tZUBnz5sNWI3/p4Lg+CjxSYYg6TPmFhM1y0zkVf3bafrSzXyBRbVsFo5aWvhr8bEUZ2+XMgnKWNpdQ7AsmLA4uv5MYBOPx/pm2uVyols3VNl6ZVzUsnLnKeSVvXW7Qrt0lq/+KCWN88PJItOL/4N6d2M2JdXS19Gv05Q3GtJ27a1PC2QGn9ZIYQv7+rIKK9ztG92ZSxN03J5ozsjgPSuMGYvfb1e6JVH36KFbpXJ9TJE3ipJWCatRzrv5Co3Sy8R7bPTuo6+cqPfTzeQfnbSI5Ae0s8ukH5S0iPDYzbPnoohvQkG/sfwUcH/GO54xL7M8KsphGH2GJhntxiQngqkD1MM6f1iQPowGDEzQ3oqkD5MMaT3iwHpw2DEzAzpqUD6MMWhpf9Sc7vdvgZnVPGo+MMIySykt8fAPLvFQKenYsmMTj8wgZkhPRVIH6YY0vvFgPRhMGJmhvRUIH2YYkjvFwPSh8GImRnSU4H0YYohvV8Mr8zX6/UPKUJ6+Zbr9RobcwzFkN4vhm/m1WrV94He1WoVJ/PLiyG9XwzfzPv9vk/6/X4fJ/PLiyG9XwzfzJfLpU/6y+USJ/PLiyG9X4wAzJ+fn13jPz4+jDEwz24xID0VM+bdbteVfrfbGWNgnt1iQHoqZszn87kr/fl8NsbAPLvFgPRUjJnf3t5k49/f320wMM9uMSbyrcWeYsz8+++/y9L//vvvbsGIzGqezYJOT8WY+XQ6ydKfTicbDMyzWwxIT8WY+fF4LJdLYfxyuXw8HjYYmGe3GJCeig3zZrMR0m82G0sMzLNbDEhPxYb5eDwK6Y/HoyUG5tktBqSnYsN8v98Xi8Visbjf75YYmGe3GJCeiiXzer1er9f2GJhntxiQnool8+FwOBwO9hiYZ7cYE5Ee31o8KvjWYscj9sXrA3u1Rd8vZvPsqRjSm2DITyRCB9JD+tkF0kP62QXSQ/rZBdJD+tkF0k/ko8WQfnjEXPl7LgyCjxabYED64UGnh/SzC6SH9J1kLEkSlnVubN/USs7TlOe6m5P69pynz4ahR3MRSA/ptantzHnKskIvvSqm8pd6V8aE9xnTvjkqKgePZhtID+nJ6DVt9M9Y/VdjptLc6/SYWx0QI0ezCKSH9O1I5hUZq3TrX95U91SaVq8N6mjSK4ZqcGtgejQngfSQXhehpuyj8Zq+kEVvv3CwrG9grOk9YkD6Yem42bM+71sHFc15Qme9L9QfOZp5ID2k7w0lYrsL5zwV6RUz56lWZNZzhkyPZhNID+l1kft63ZifLOtFXXMWoB+t0Hf6EaNZB9JDek0ULWsr9dLXF1ekU8/OskY5aqTC1onDkNHsA+khfTd65zX/Ut7GkrbKeaq7vbteUqQfNJqDQHpI34nUXDOWKFfRxc05T1POWWtl377eUl6sfNKqyys72cDRXATSQ/p2Kkt1Hvadx5Z3a27ucV5q+nqVccnSIwY+Wjy7iLny91wYBB8tNsGA9MODTg/pZxdID+lnF0gP6WcXSA/pZxdID+lnF0g/KemR4TGbZ0/FkN4EA99aPCr41mLHI/Zlht+bLgyzx8A8u8WA9FQgfZhiSO8XA9KHwYiZGdJTgfRhiiG9XwxIHwYjZmZITwXShykOLf2Xmtvt9jU4o4pHxR+GV+a//vrrh5T6+mCdv/76ywAD8+wWA52eigHzarXquzq+Wq3iZH55cWBmSE/FgHm/3/dJv9/v42R+eTGk94vhm/lyufRJf7lc4mR+eTGk94sRgPnz87Nr/MfHhzEG5tktBqSnYsa82+260u92O2MMzLNbDEhPxYz5fD53pT+fz8YYmGe3GJCeijHz29ubbPz7+7sNBubZLQakp2LMvN1uZem3260NBubZLQakp2LMfDqdZOlPp5MNBubZLQakp2LM/Hg8lsulMH65XD4eDxsMzLNbDEhPxYZ5s9kI6TebjSUG5tktBqSnYsN8PB6F9Mfj0RID8+wWA9JTsWG+3++LxWKxWNzvd0sMzLNbDEhPxZJ5vV6v12t7DMyzW4yJfGuxp1gy//nnn3/++acrmIGZ4TyPzUQ6Pb4CZFTwFSCOR+yL1wf2aou+X8zm2VMxpDfBkJ9IhA6kh/SzC6SH9LMLpIf0swukh/T+4vEXAm0C6SG920i/uynn+Q/Khgukh/T+Unf6jCXit2fzPILGD+khvcNIP4ncm9cveCA9pPcWcQhEsaJRAukhvfP0LOtjaPJFUUB6SO8yje0aveO5lAPpIb3zoNOPLsZHi00SmfTfoNP7ey4Mgo8Wm2BEJj06fURudG+E9E6TMaF23delt6QyFselHEgP6R1G1rrSX7k1Cu8hPaSfXSA9pJ9dID2kn10g/aSkR4bHbJ49FUN6Ewx8G8Ko4NsQHI/Ylxl+CZEwzB4D8+wWA9JTgfRhiiG9XwxIHwYjZmZITwXShymG9H4xIH0YjJiZIT0VSB+mGB8tjiiWzEJ6RyxDM8N5Hht0eiro9GGKsbzxi+GV+Xq9/iFFSC/fcr1eY2OOoRjS+8XwzbxarfreB12tVnEyv7wY0vvF8M283+/7pN/v93Eyv7wY0vvF8M18uVz6pL9cLnEyv7wY0vvFCMD8+fnZNf7j48MYA/PsFgPSUzFj3u12Xel3u50xBubZLQakp2LGfD6fu9Kfz2djDMyzWwxIT8WY+e3tTTb+/f3dBgPz7BYD0lMxZt5ut7L02+3WBgPz7BYD0lMxZj6dTrL0p9PJBgPz7BYD0lMxZn48HsvlUhi/XC4fj4cNBubZLQakp2LDvNlshPSbzcYSA/PsFgPSU7FhPh6PQvrj8WiJgXl2i/HLl5rb7fY1OKOKR8UfRjDmf/75Z7FYLBaLf/75xxID8+wWA52eiiXzer1er9f2GJhntxiQnool8+FwOBwO9hiYZ7cYr5ce39P0HfP3338HcMN+5Eilf/XTh5jk58+fAdywHzlq6YePg7w2P3/+hPRDA+mnEUgP6WcXSA/pZxdID+lnF0gP6WcXSA/pZxdID+lnF0gfn/TUz9E3P+Oq/VXvejvpF4/bGw7bUVEUeZZp78x5yrIi56n8A+IZ07z/0+yR/PnZjHUxtONpBjYJpI9D+p4fpi/lqp/jfk1znib9ddrt5Bv1+29+MpyKqr66n0r28r+Syilj+mHFg1AOBBXf+vebpyD9LVS+er6Z1oH0cuqnOGOlUnneuKl7vjPWavIth9rasqxVxzjR9DVHkF46GbysaEkvbqqPJW2Dr6SnjjMX0nPOA7jhKd+/09NPsL4x9ne+VgNnWaugabq1fCyjVjrqIZPyvOt0+e9miLbs8iZdFu2coNMTxd9fejXiENA+rVWPVXvtE+kZ063uc854xlPGxepJu4Rpzh6qAcqxc56maapSao5c6Xir/tvsR1ntMMZaO4X0ZPFUpO9dOssKV8sHYkXc7fSqNMq5sGIzl2ySNpH8a85ha6zOMl56RHmeddf05VHDsupsJWNJdWQ2RDiRJYu/vfSN7Rp7ZF+l1bD8rHc7vcaPjDWniL0tXNK7/qe4RxlUOuPoGqhdSzUvL6n6UiGGro83eRWETk8Uf3vpyzzt9FVPba+/n67p1bpGJ1V6WTq541JXNRUIHXhnTS/GE9KLV6U0bep6fH5ybXVsIH1M0j/p9PWBQfXWfunrclX6nKcsk9fcjKkrFvKSZQeZ6vSFJH3zapPyvFriDL1K2ruiGhRIH5P0A57gsqPSyxtKeunu5hBSrii2j6p6i3q0lsJK9M26T/rq1YsaEZ2+e+MUpO+sXKS3pFpCVtfddWemRVH0rek7u5L2Ie1dHGKq+KOl1+y7e/1dfVO3u66SA+nb+f7S6692q7KzrHuZRH8qqe30ehWlevUd3aJ6i5c/W2eUI0pHWmftpdzcHCbq45HrhrxvYXMFB9JHID0SNpAe0s8ukB7Szy6QHtLPLpAe0s8uU5De5iOaoxLoo8WI5+Cjxc46PfK98r07vfMR+4IvcJ1S8AWugzK3r5D+3//+lyTJ9Xq1x8A8u8WA9FQgfZhiSO8XA9KHwYiZGdJTgfRhiiG9XwxIHwYjZmZITwXShymG9H4xIH0YjJiZIT0VSB+mGNL7xYD0YTBiZob0VCB9mGJI7xcD0ofBiJkZ0lOB9GGKZ/fR4phjw/zf//43SZLz+eyQZ0jmNs8GQaengk4fphjLG78YkD4MRszMkJ6KDfN//vMfSD8wkN4vRjBm8T9bQPohgfR+Mfwxn8/nP6QI6eVb5AMgEubvOM+Q3m/xWObVatX3/9etVitjDMyzWwxIT2Us836/75N+v98bY2Ce3WJAeipjmS+XS5/0l8vFGAPz7BYD0lMxYP78/Owa//HxYYOBeXaLAempGDDvdruu9LvdzgYD8+wWA9JTMWA+n89d6c/nsw0G5tktBqSnYsb89vYmG//+/m6JgXl2iwHpqZgxb7dbWfrtdmuJgXl2iwHpqZgxn04nWfrT6WSJgXl2i/HLl5rb7fY1OKOKR8UfRgDmf//999dffxXG//rrr//++68lBubZLQY6PRVj5s1mI6TfbDb2GJhntxiQnoox8/F4FNIfj0d7DMyzWwxIT8WY+X6/LxaLxWJxv9/tMTDPbjEgPRUb5vV6vV6vnWBgnt1iQHoqNsyHw+FwODjBwDy7xQgqPX50ZPKpf6EE0hdFUXx9fb36GUG8p/4tKkhfFJL0wzdBvlFaP7UJ6YsC0k89kF4TSD/tQHpNIP20A+k1gfTTDqTXBNJPO5BeE0g/7Xwn6W+hAumnHSE959zMDde6UUGnR9zkO3V65yP2BdJPO5BeE0g/7UB6TfxKn/O07+MgLBu4oVKY8zTluW5YUabdYcpzZXPrx0SzE3vJGPm4s4we2CCQXhPv0mufZPXJzxh1TOR5LhWmPNdY1ZIp56nuWBkrvXwEMaaBrA8odVzlL/kPGVP3oJ+1AoNAek1i6PQZG2KiZHJ/py/HE381vplJX24pRtY16ZbQEl6zX+l1RvI85Zxu+q4C6TWJo9M/N7Hcol7e9HZ6pcu3ZR8tfc5ZTwcnHpW0N+lRNmAZS3n+ZKXjKpBeE1/SEz2+szjQv9JrurhkU1+N5i7pKBkrfU2W8rwZOmUslW7XPXbN7RljWcZSzsUaTfegrc83uoH0mnjt9FILpxrbsOWNvIAYlTw3lD7nqdhj1ZpL9VPGxDAC/Okx2xyTrQnhMo6f1g/pNfEsvfK8t84Fped/0PKmcqfvRUQZRH9q2X/xRzccZ2maltKnabl7SVbtIZTzVERncLsLSAug5xeFjALpNQnb6Zsb1FW4snrQqUwug1srek2XNV3elCZmLElTJpp9mtbDaUarVE55rjuUlQlRhhj4ajc6kF6TkJ0+kwXvvK7rhFRvqw6c/t6c92xpLb16rJZLnERdbtWXauRTD/UordZDKc8a28U5gqezWkivSfA1vejFqsq9QuqkF7dzyZFnVxOf3dqflvSVxfUw8gXN7vl2IZ0W1KSJcmZdlfhp8wWk18ab9D3vjfKqT1cmtI4Gqn1L0uflNZDW7frdm78j21ywKU9Ya1R11UWdT0hn4NLxXd+QlC8dnsT/TtLbfERzVEJ99iZj4kRWfUdSXMSrO97gTl/f29a6WfuoYyn2Dk9zdqkuVejhhl3P7xwrnRtcBB8t1gQfOJt2vlOndz5iXyD9tAPpNYH00w6k1wTSTzuQXhNIP+1Aek0g/bQD6TWB9NMOpNcE0k87kF4TSD/tQHpN8KMMcwikV4Kf35lD8PM7SvADYGGKwfy0GNJTAXOYYkjvFwPMYTBiZg760eJg+3IVMIfJlD9a7GlkMMsB89NiSE8FzGGKIb1fDDCHwYiZGdJTAXOYYkjvFwPMYTBiZob0VMAcphjS+8UAcxiMmJkhPRUwhymG9H4xwBwGI2ZmSE8FzGGKIb1fDDCHwYiZ+f8VzxNW8IAMFAAAAABJRU5ErkJggg==" alt="img"></p><p><strong>但是我还是觉得太麻烦了，每次想吃饭的时候都要重复这样的步骤。此时，我希望有这样的机器：</strong></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASIAAADqCAIAAACJEN+MAAATuUlEQVR4nO2d3YscRRvF/ZvqzUbFiAkBdYUYl0qyRtxIRBYv9CKUQdkbWRGRYKL0ioqKkggqrjiNHwSRvfCDgCSaZsmCropLYDUxidmMeiFG+73omZ6q7uremp7uqqd6zrnKzJzuPlPz/PqprpnO3hCrWl9fj43V7XYpmJHZjhmZK5tvyDwmEsvHoURmOzF8zAzM3JiR2Y6ZSGZg5saMzHbMRDIDMzdmZLZjJpIZmLkxI7MdM5HMwMyNGZntmIlkBmZuzMhsx0wkMzBzY0ZmO2YimYGZGzMy2zETyXxDV9X6+nrXNyGzHSFzZaGbuTEjsx0zkczAzI0Zme2YiWQGZm7MyGzHTCQzMHNjRmY7ZiKZgZkbMzLbMRPJDMzcmJHZjplIZmDmxozMdsxEMgMzN2ZktmMmkhmYuTEjsx0zkczAzI0Zme2YiWQGZm7MyGzHTCSzA8zm5ubYmGlubs7+ONduRubKZgeYua55N7I/zrWbkbmy2Rlm5hv6LmDm0Ewks4MbYcYTM/vjXLuQubLQzRoXuplDM5HMwKxxATOHZiKZgVnjAmYOzUQyA7PGBcwcmolkBmaNC5g5NBPJDMwaFzBzaCaSGZg1LmDm0EwkMzBrXMDMoZlIZmDWuICZQzORzOOEWSiYCO0fFpg5NBPJ3G7MVLCUR/aYA2YOzUQytxuzOI4CzngQxXEskxUKZq+xATOHZiKZ245ZHMdRwBPQ+piFog+eFQEzh2YimccAs1S4NhvNjMyVze29ESYKONtUNtpacqSbb75527Ztt912286dO++4447Jycndu3dzzqenp++7774DBw48+OCDjUfxTaMXG26EsatQcM4Z58LmfDGO42HuFrcczFMNVXVUulnmcTsxSy7PQsFEGAXc8swxeb9///33X3/9de3atStXrly8ePGbb75ZW1v78ccfv/vuu3PnzkVRdPr06TRs0fJogdKrT5PX8jtUn5EOn7NKO1MnC/IhQpF5QbX291g+2yiZZgAzI7NtzNJlxcESiJXJYl/a91syzmqd68tPhUd5lOPKAFv5SXPMNP9Ut+q9oN9jSayy0wYwMzRbxCwKuHRilD7KUNi5LovjYTALOBNhv/6i5NFA8ncTsfKlxKAsM57ehlEYRYOttO87FDyIihoMD6IM8SIsxQzdLKP2YhYFPPPlWObkrC3JBjRMNwsF40JwESSVm0IRCqb5pq//hvp1nmsQGYkgV9r5zlbWzSRIh+1mURTF6GZ9tQezvDxZ0Ffqr8dKee7islRfUWDtf3vYO0JqK8FMPjEVY6ZKmqmz7FkOmNV/JPeYOVIlzPpTKh1f+TalUbKhXLBRwHkQiMH0Un89V4xZetzenFbqS4NdmYTrt97NLHoBMyMzMIvLxrnoh2BFv12JAp5It5Fcy9n5ZW4NpYQQEcZxKLgQuhXboubTa2D52Xt/K3Sz+o8EzGQVjXMoRBBwERaXvGZ5vk9JvjbTWg7VLpZZCck1vWiwc9kSal+Tt5Zzazth9gX5fWhHJCdgZmQGZnHROPfX+9IZn3JLQZai9FJJalH5NYsMZv2Kz150SUuV6Uty7YciWQTVzDn7/+7ZzVYaN51cFlIHzIzMwCwuXNDPXPWodxXkVs017USdoaVb575XzvXEPg/6NcM4cyClGw4WFGXalBcK1y4LD1UsYGZkBmax+Uqj/Kw0X1MxyV7L9C7vpM40KHiWvqTcFSSMbg2SdqP+bkSmyfB7M1XArKYjATNZQ2CmLPAVbaFZMkgqt1/jXAjOshdkjIkw7ZJl0ziFVl2Tk1wG3czoZ92MB9p3C8yMzMAsHnKcIVleYrY+grrdbgXzeGJmMkSuk5LT6FU3lKrVs4nQzRrX6N2subPsiJ3h5ZdfTt7doUOHrl+/bieGl90s89gaZuMm++Ncu1mb+cyZM5OTk4yx2dnZa9euWYgBzIzM+NvTdsa5dnNR5p9//nnPnj2Msfvvv//ChQtNxwBmbszIbMdckvnixYszMzOMsampqZ9++qnRGD6OMzBzY25f5j///PPhhx9mjO3fv//ff//1IrO1GMDMjbmVmf/777+kp83Pz/uS2U4MYObG3NbMq6urW7duZYwdP368oRg+jjMwc2NuceYPP/wwWfg5e/ZsEzF8HGdg5sbc7sxHjhxhjO3Zs6eJGD6OMzBzY2595v379zPGFhcXa4/h4zgDMzfm1mfudDrJ+n7tMXwcZ2DmxjwOmZOG1ul06o3h4zgDMzfmccj80UcfMcb27t27sbERRVGn0zl27NjRo0dHjOHjOAMzN+YWZ/71119PnTr15ptvPvPMM7fcckvmd2fvv//+iDF8HGcHfxGmdiGzHRlmfu6550p+3vnFF180nVMWkXFGN3NjbnHmq1ev3nTTTUWYXb58ecQYPo4zMHNjbnfml156ScvYjh07Ro/h4zgDMzfmdmf+448/8ldljLGDBw+OHsPHcQZmbsytz7ywsJDHbH5+fvQYPo4zMHNjbn3mS5cubd++PYNZ0e+JiWQGZmVCZjvmYTO/8cYbGcw+//zz0WP4OM7AzI15HDL/888/O3fulDFbW1sbPYaP4wzM3JjHJPOJEydSxiYmJmqJ4eM4AzM35vHJnPy/V4yxXbt21RLDx3EGZm7M45P57bffTjB74IEHaonh4zgDMzfmscqc/Cjk0KFDtcTwcZyBmRvzWGV+7733GGOffPJJLTF8HGdg5sY8bpmnpqZWVlZqieHjOAMzN+bmMh8+fLjoZ7tQXvJ/CN0gZl1VRG4cGErILMt13fqnhj4IWehmbszNZU5Kx9w/zsqMVXMfNzBzYwZmFATMSJSsj5mBmbmAGYmS9TEzMDMXMCNRsj5mBmbmAmYkStbHzMDMXMCMRMn6mBmYmQuYkShZHzMDM3MBMxIl62NmYGYuYEaiZH3MDMzMBcxIlKyPmYGZuYAZiZL1MTMwMxcwI1GyPmYGZuYCZiRK1sfMwMxc9jDrqsJNJXbU9I0wQ9TaGAs3wpDoDD5mBmbmwqSRRMn6mBmYmQuYkShZHzMDM3MBMxIl62NmYGYuYEaiZH3MDMzMBcxIlKyPmYGZuYAZiZL1MTMwMxcwI1GyPmYGZuYCZiRK1sfMwMxcwIxEyfqYGZiZC5iRKFkfMwMzcwEzEiXrY2ZgZi5gRqJkfcwMzMwFzEiUrI+ZgZm57GG2PoK63S4F81BqfeYRMAsFE2HuOR5EJdtEAS80RAFXd6g7gPJsKJgkyRsFPPOCYi3PWKhk42rjPJQZ3cyNubnMI3WzKOAZDvKYqSjklfqzBBYRqWKm+ae6be+FQbAy0suFSSOJkvUxcy2TRrV5aLpL1pWt88wORJjfpwgzT/EgKsOssW6WPgRmZUJmWRUxk6uWB2HaINKm0S97PVvps73n5A6TtEgVG+mRPLUctptFUYRuZsmMzLJG7GahYDyIomLMzJTFTIjCq7RQsM0x0+89CnjlThbHwIxIyfqYeRTMooCzQf3qJo36FzJSOE0v+JSmk0KktkHpSlDGzOioQ5wECsYKmJUJmWVVxiyZNnLOq3azDFoaBAaNS5qCJp0u2bgAM/Ug/au4UfpYImBGomR9zFwRsyjgIkwuk6JACFGGWXatUX89lu1m6bbSOmEomAgHe5a3yly9ZY6Ve74Sc8CMRMn6mLlyN4ulMi9faVQazQANI8zi/i54EMVRIIJI2p28496/ezvCSqNzMzLLqguz8m42Imba6zT12+y07bHMhR2+N3NjRmZZtWA2kO5XIGaTRl0flPaQw0x5LksTuplzMzLLsoOZzM0AgYFV281kMrLfoeUP3XNn2yu6mSMzMssaBbNxEzAjUbI+ZgZm5gJmJErWx8zAzFz2MOuqWsdfV7Gi5jIDM3MlY9XQByEL3cyNGd2MgjBpJFGyPmYGZuYCZiRK1sfMwMxcwIxEyfqYGZiZC5iRKFkfMwMzcwEzEiXrY2ZgZi5gRqJkfcwMzMwFzEiUrI+ZgZm5gBmJkvUxMzAzFzAjUbI+ZgZm5gJmJErWx8zAzFzAjETJ+pgZmJkLmJEoWR8zAzNzATMSJetjZmBmLtwIM4SQWRYwMxduhCHRGXzMDMzMhUkjiZL1MTMwMxcwI1GyPmYGZuYCZiRK1sfMwMxcwIxEyfqYGZiZC5iRKFkfMwMzcwEzEiXrY2ZgZi5gRqJkfcwMzMwFzEiUrI+ZGTSkqo0zMHMTg0jmw4cPu65bnzQ3N1dtnIGZmxjIXLLnffv2McZWV1dHj+HjOAMzN+Zxy3z77bczxi5dujR6DB/HGZi5MY9b5omJCcbY9evXR4/h4zgDMzfmscq8sbHBGNu+fXstMXwcZ9wI40ZjlXllZYUxtnv37nrzmIjIOKObuTGPVeazZ88yxg4ePFhLDB/HGZi5MY9V5sXFRcbYE088UUsMH8cZmLkxj1Xmxx57jDHW6XRqieHjOAMzN+axynzrrbcyxn755ZdaYvg4zsDMjXl8Mp8+fZoxdu+999YVw8dxBmZuzOOT+cUXX2SMHTt2rK4YPo4zMHNjHp/M09PTjLFTp07VFcPHcQZmbsxjkvmDDz5gjO3bt6/GGD6OMzBzYx6TzPfccw9j7OOPP64xho/jDMzcmMch8zvvvMMYm5mZqTeGj+MMzNyYW5/56tWrd955J2Pss88+qzeGj+MMzNyYW5/58ccfZ4w99NBDtcfwcZyBmRtzuzO/+uqrjLFt27b98MMPtcfwcZwtYTY3N2f77nOqSu6KJ/LxN1GyJ0+eTN7p0tJSEzG8xGx9BHW7XUOn28qmpubGuVGziZaWlrZu3coYe+WVVxqKUXtmCzEsdbOkvMz33Fal49DQODdq3jTzp59+mtwl/dRTT/mS2U4MYGZVLcbs+PHjybt7+umnG40BzAoFzBK1FbMjR44kb+31119vOgYwKxQwS2QBMx8FzOo5EjBLBMy0Amb1HAmYJWoYsyjgRaubIjTcUDFGAedBpNttYtMekAeRsnmNb3BoMzAbRzWPmRanUMj0hKKMwiiKJCMPIg0t6v7iKOA6OoFZKmBmVSS6WShMal9ip7ib9faXPBpABcwyAmZWRaSbbV77vS3SSWNhN1M6WRYvYNYTMLOqCpitrKyYjHNxH8tdNekmjdpOJdFS5NG8JHEJzHpqNWZFJ3fFUVAHmcuP3Mth+Y4LZI7ZuXPnFhYWOOc33nij6ThLbaosvtmkMQ7FZgsnekURMMuqJZjJJ1Uh9Gfr5ANXP3nlkfxALlP92b9KBW6O2fLychAEU1NT6XEmJibMMVMCZsZBem9Gk8b+myy64FN2oh9WYNZTSzCLY6l36c7kGYSkOc/gql0qHKlgeRCUN7ZhVIRZFEUvvPBCckt/ov/973/JP7Zs2VK5mw2eUK+meBAV0dOfV/IgKuqImSszzQkImGXUHsyiQBR0KY2yi2Pq9HJwWV9abhWUwezbb789evTo3Xffnacr1ZYtW86fP3/hwoW1tbXvv/9+eXn5zJkzX3311dLS0smTJzudzrvvvnvixIneu1KqXUZKOYVILylSn+ujqu1lmXaGblYqS38RpnnM0mpQztRcCK4pilT6OgiFCEPBgyD53khXaEbVk1ey8Zdffjk/P3/XXXcVFXAFJbnzk95kKFR4ChHQYZY8H0jnmc1mC7lnm6goQzVUz8OqJd0sCnhy+u63n/45XIjk408qcNM1NsaY3MeSnYeCiUDTDyooOcLXX3/95JNP7tq1yxChHTt2TE5OTk1NTU9PHzhwYHZ29pFHHhFCzM3Nzc/PP/vss88//3zB7zGC/jvuB87wp9lEh1nUO+MUvn15b/gVSE7EMSv5vjVTTZzzHmac98pKwkP7eUcBT6RjJtsZpGnl5guYhUrHIRnn5eXlhYWFvXv3pm8lP2lkjG1sbAx7oFAkSyDqOk7SpKP+uzDuZumrWZAG5y11X4PphFHXB2b1HKkqZubq1X4oGOciaWicpxfjmprqw8ODSLf0pmCm7MJwPVyrDGapVldXX3vttZmZGe1ppAJmfgmY1XMki5ipa2u9iSNTF+DTZUX5C1i1Q/VnmTwIB3wl13ojrIcUYZbq/Pnzb7311uzsrIzZ77//XvmIXgiY1XMk65j1uUl7kLzcn/+dQyxd3iVKpkPqL42igFde/Ei0KWapfvvtt8XFxUcffZQxduXKFfNDtL5kfczcJswGVwODb8bUqV4oSr9Vlb5Sk9bj0idYrz2OgJo5Zqm63e7ly5fND9H6kvUxc5swk35mJ93XUXoxbvb9Wo7O3BOmqoBZjJIdwUwkc2sw80PAzLKZSGZgZlXAzLKZSGZgZlXAzLKZSGZgZlXAzLKZSGZgZlXAzLKZSGZgZlXAzLKZSGZgZlXAzLKZSObW3Ajjh5JxaG6cGxUyV5bVbgYlam6cGzUjc2Uz/oygbbX+zwg2HcPHzPijuG7MyGzHTCQzMHNjRmY7ZiKZgZkbMzLbMRPJDMzcmJHZjplIZmDmxozMdsxEMgMzN2ZktmMmkhmYuTEjsx0zkczAzI0Zme2YiWQGZm7MyGzHTCQzMHNjRmY7ZiKZgZkbMzLbMRPJDMzcmJHZjplIZks3wjQqZLYjZK4sdDM3ZmS2YyaSGZi5MSOzHTORzMDMjRmZ7ZiJZAZmbszIbMdMJDMwc2NGZjtmIpmBmRszMtsxE8kMzNyYkdmOmUhmYObGjMx2zEQyAzM3ZmS2YyaSGZi5MSOzHTORzMDMjRmZ7ZiJZAZmbszIbMdMJDMwc2NGZjtmIpn/D+UJbkyosuCFAAAAAElFTkSuQmCC" alt="img"></p><p><strong>将重复的工作封装到一起，我们只要向机器里放入东西，就能得到我们想要的。</strong></p><p><strong>这也就是所谓的代码重用。</strong></p><h3 id="例子">例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义方法</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_nums</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-string">"""此处是函数功能的描述"""</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>):<br>        print(i,end=<span class="hljs-string">" "</span>)<br><br><span class="hljs-comment"># 1.三角形 2.正方形 3.梯形</span><br>key = int(input(<span class="hljs-string">'请输入要打印的图形：'</span>))<br><span class="hljs-keyword">if</span> key == <span class="hljs-number">1</span>:<br>    <span class="hljs-comment"># 打印三角形的代码</span><br>    print_nums()<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">elif</span> key == <span class="hljs-number">2</span>:<br>    <span class="hljs-comment"># 打印梯形的代码</span><br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">elif</span> key == <span class="hljs-number">3</span>:<br>    <span class="hljs-comment"># 正方形的代码</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h5 id="输出结果如下：">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">请输入要打印的图形：<span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <br>进程已结束，退出代码 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="分析一下"><strong>分析一下</strong></h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200320220015580.png" alt="image-20200320220015580"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200320220730259.png" alt="image-20200320220730259"></p><h2 id="2、定义函数">2、定义函数</h2><h4 id="你可以定义一个由自己想要功能的函数，以下是简单的规则："><strong>你可以定义一个由自己想要功能的函数，以下是简单的规则：</strong></h4><blockquote><p><strong>关键字: def</strong></p><p><strong>函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()，结尾处有冒号。</strong></p><p><strong>函数内第一行通常书写注释,表名该函数的意义</strong></p><p><strong>注释后空一行,开始写代码块，代码库要缩进</strong></p><p><strong>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。</strong></p><p><strong>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</strong></p><p><strong>函数内容以冒号起始，并且缩进。</strong></p><p><strong>return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</strong></p><p><strong>函数结束后,空2行</strong></p><p><strong>函数调用后空1行,再执行别的代码</strong></p></blockquote><p><strong>语法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#代码如下</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">functionname</span><span class="hljs-params">( parameters )</span>:</span><br>  <span class="hljs-string">"函数_文档字符串"</span><br>  function_suite<br>  <span class="hljs-keyword">return</span> [expression]<br></code></pre></td></tr></table></figure><p><strong>默认情况下，参数值和参数名称是按函数声明中定义的的顺序匹配起来的。</strong></p><h1>三、函数类型</h1><blockquote><p><strong>Python函数可以使用的参数类型：</strong></p><p><strong>必备参数</strong><br><strong>命名参数</strong><br><strong>缺省参数</strong><br><strong>不定长参数</strong></p></blockquote><blockquote><h2 id="参数类型：">参数类型：</h2><p>​    1、位置参数:参数的位置(顺序)很重要，形参和实参个数要匹配<br>​    2、关键字参数:对参数的位置要求不是很严格<br>​    3、默认值参数:<br>​        (1)如果形参中指定了默认值,在实参中可以不传递该形参对应的实参<br>​        (2)如果形参中指定了默认值，在实参汇总传递该参数后，最终参数以传递的实参为准<br>​    4、不定长参数：<br>​    (1)*a：接收传递单个值,保存为元组<br>​    (2)**b：接收键值对形式的参数，保存为字典格式</p></blockquote><h2 id="1、无参函数">1、无参函数</h2><h4 id="无参函数实现和调用：">无参函数实现和调用：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义无参函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hi</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-string">"""介绍自己的函数"""</span><br><br>    print(<span class="hljs-string">'我是xgp，今年18岁，年收入xxxx元'</span>)<br><br><span class="hljs-comment"># 调用无参函数</span><br>say_hi()<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-2">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">我是xgp，今年<span class="hljs-number">18</span>岁，年收入xxxx元<br><br>进程已结束，退出代码 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="2、带参函数">2、带参函数</h2><p><strong>下面说说带参数的函数：</strong></p><ul><li><strong>形参：指的是形式参数，是虚拟的，不占用内存空间，形参单元只有被调用的时才分配内存单元</strong></li><li><strong>实参：指的是实际参数，是一个变量，占用内存空间，数据传递单向，实参传给形参，形参不能传给实参</strong></li></ul><h4 id="例子-2">例子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义带参函数：形参（形式参数，模板）</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hi</span><span class="hljs-params">(name,age,money)</span>:</span><br>    <span class="hljs-string">"""介绍自己的函数"""</span><br><br>    print(<span class="hljs-string">'我是'</span>+name+<span class="hljs-string">'，今年'</span>+str(age)+<span class="hljs-string">'岁，年收入'</span>+str(money)+<span class="hljs-string">'元。'</span>)<br><br><span class="hljs-comment"># 调用带参函数：实参（实际传递的参数）</span><br>say_hi(<span class="hljs-string">'xgp'</span>,<span class="hljs-number">20</span>,<span class="hljs-number">20000</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-3">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">我是xgp，今年<span class="hljs-number">20</span>岁，年收入<span class="hljs-number">20000</span>元。<br><br>进程已结束，退出代码 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>注意事项:调用函数时,实参传递的个数</strong><br><strong>要与形参保持一致|</strong></p></blockquote><h3 id="（1）位置参数"><strong>（1）位置参数</strong></h3><p><strong>从上面的例子可以看出，实际参数和形式参数是一一对应的，如果调换位置，x和y被调用的时，位置也会互换，代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">(x,y)</span>:</span><br>    print(x)<br>    print(y)<br>print(<span class="hljs-string">"--------互换前-----"</span>)<br>test(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>print(<span class="hljs-string">"--------互换后-----"</span>)<br>test(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br> <br><span class="hljs-comment">#输出</span><br>--------互换前-----<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br>--------互换后-----<br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>因为定义x,y两个形参，所以传递实参的时候，也只能传递两个实参，多一个或少一个都是有问题的：</strong></p><p>a：多传递一个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">(x,y)</span>:</span><br>    print(x)<br>    print(y)<br>print(<span class="hljs-string">"--------多一个参数----"</span>)<br>test(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br> <br><span class="hljs-comment">#输出</span><br>--------多一个参数----<br>Traceback (most recent call last):<br>  File <span class="hljs-string">"D:/PycharmProjects/pyhomework/day3/函数_带参数.py"</span>, line <span class="hljs-number">8</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    test(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>TypeError: test() takes <span class="hljs-number">2</span> positional arguments but <span class="hljs-number">3</span> were given  <span class="hljs-comment">#test()函数需要传两个实参，你传了三个实参</span><br></code></pre></td></tr></table></figure><p>b：少传递一个实参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">(x,y)</span>:</span><br>    print(x)<br>    print(y)<br>print(<span class="hljs-string">"--------少一个参数----"</span>)<br>test(<span class="hljs-number">1</span>)<br> <br><span class="hljs-comment">#输出</span><br>--------少一个参数----<br>Traceback (most recent call last):<br>  File <span class="hljs-string">"D:/PycharmProjects/pyhomework/day3/函数_带参数.py"</span>, line <span class="hljs-number">8</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    test(<span class="hljs-number">1</span>)<br>TypeError: test() missing <span class="hljs-number">1</span> required positional argument: <span class="hljs-string">'y'</span>  <br><span class="hljs-comment">#没有给y参数传实参</span><br></code></pre></td></tr></table></figure><h3 id="（2）关键字参数">（2）关键字参数</h3><p><strong>上面的位置参数，看起来有点死，必须形参和实参的位置一一对应，不然就会传错参数，为了避免这种问题，就有了关键字参数的玩法：关键字传参不需要一一对应，只需要你指定你的哪个形参调用哪一个实参即可；</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">(x,y)</span>:</span><br>    print(x)<br>    print(y)<br> <br>print(<span class="hljs-string">"--------互换前------"</span>)<br>test(x=<span class="hljs-number">1</span>,y=<span class="hljs-number">2</span>)<br>print(<span class="hljs-string">"--------互换后------"</span>)<br>test(y=<span class="hljs-number">2</span>,x=<span class="hljs-number">1</span>)<br> <br><span class="hljs-comment">#输出</span><br>--------互换前------<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br>--------互换后------<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="3、默认参数">3、默认参数</h2><p><strong>调用函数时，默认参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br> <br><span class="hljs-comment">#可写函数说明</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printinfo</span><span class="hljs-params">( name, age =<span class="hljs-number">35</span> )</span>:</span><br>   <span class="hljs-string">"打印任何传入的字符串"</span><br>   <span class="hljs-keyword">print</span> <span class="hljs-string">"Name: "</span>, name<br>   <span class="hljs-keyword">print</span> <span class="hljs-string">"Age "</span>, age<br>   <span class="hljs-keyword">return</span><br> <br><span class="hljs-comment">#调用printinfo函数</span><br>printinfo( age=<span class="hljs-number">50</span>, name=<span class="hljs-string">"miki"</span> )<br>printinfo( name=<span class="hljs-string">"miki"</span> )<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-4">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Name:  miki<br>Age  <span class="hljs-number">50</span><br>Name:  miki<br>Age  <span class="hljs-number">35</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="4、不定长参数">4、不定长参数</h2><p><strong>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">functionname</span><span class="hljs-params">([formal_args,] *var_args_tuple )</span>:</span><br>   <span class="hljs-string">"函数_文档字符串"</span><br>   function_suite<br>   <span class="hljs-keyword">return</span> [expression]<br></code></pre></td></tr></table></figure><p><strong>加了星号（*）的变量名会存放所有未命名的变量参数。不定长参数实例如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br> <br><span class="hljs-comment"># 可写函数说明</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printinfo</span><span class="hljs-params">( arg1, *vartuple )</span>:</span><br>   <span class="hljs-string">"打印任何传入的参数"</span><br>   <span class="hljs-keyword">print</span> <span class="hljs-string">"输出: "</span><br>   <span class="hljs-keyword">print</span> arg1<br>   <span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> vartuple:<br>      <span class="hljs-keyword">print</span> var<br>   <span class="hljs-keyword">return</span><br> <br><span class="hljs-comment"># 调用printinfo 函数</span><br>printinfo( <span class="hljs-number">10</span> )<br>printinfo( <span class="hljs-number">70</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span> )<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-5">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">输出:<br><span class="hljs-number">10</span><br>输出:<br><span class="hljs-number">70</span><br><span class="hljs-number">60</span><br><span class="hljs-number">50</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="（1）例子">（1）例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不定长参数的类型</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">no_test</span><span class="hljs-params">(*args,**b)</span>:</span><br>    print((args))<br>    print(b)<br>no_test(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>no_test(name=<span class="hljs-string">'test'</span>,ages=<span class="hljs-number">18</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-6">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>&#123;&#125;<br>()<br>&#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'test'</span>, <span class="hljs-string">'ages'</span>: <span class="hljs-number">18</span>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="5、匿名函数">5、匿名函数</h2><p><strong>python 使用 lambda 来创建匿名函数。</strong></p><ul><li><strong>lambda只是一个表达式，函数体比def简单很多。</strong></li><li><strong>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</strong></li><li><strong>lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。</strong></li><li><strong>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</strong></li></ul><h3 id="语法">语法</h3><p><strong>lambda函数的语法只包含一个语句，如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression<br></code></pre></td></tr></table></figure><p><strong>如下实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">相加后的值为 :  <span class="hljs-number">30</span><br>相加后的值为 :  <span class="hljs-number">40</span><br></code></pre></td></tr></table></figure><h1>四、rerun传递列表类型数据</h1><p><strong>return语句[表达式]退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，下例便告诉你怎么做：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br> <br><span class="hljs-comment"># 可写函数说明</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span><span class="hljs-params">( arg1, arg2 )</span>:</span><br>   <span class="hljs-comment"># 返回2个参数的和."</span><br>   total = arg1 + arg2<br>   <span class="hljs-keyword">print</span> <span class="hljs-string">"函数内 : "</span>, total<br>   <span class="hljs-keyword">return</span> total<br> <br><span class="hljs-comment"># 调用sum函数</span><br>total = sum( <span class="hljs-number">10</span>, <span class="hljs-number">20</span> )<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-7">输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">函数内 :  <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：在函数内没有写return语句的时候，默认return的是一个空对象。也就是就算没写，python内部也做了处理。</strong></p><p><strong>此时，有部分人分不清函数的输出和返回值的区别。</strong></p><p><strong>这样说吧，在函数里print之类的操作能够输出内容，是因为虽然函数的执行环境是独立的，但代码还是有效的。外部能进行的操作，函数内部也可以。但是并不是所有的函数在执行完毕后都有如此明显的输出效果，此时我们需要查看函数是否成功，或者说我放了米进去，你操作一番之后总要把饭给我拿出来吧。</strong></p><p><strong>这就是函数中return的意义。返回一个对象。这个对象可以是对执行状态的说明，也可以是处理后的结果等等。</strong></p></blockquote><h2 id="1、return语句返回简单类型">1、return语句返回简单类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'hello'</span><br>print(test())<br><br><span class="hljs-comment"># return 语句返回字典</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_info</span><span class="hljs-params">(name,age)</span>:</span><br>    person = &#123;<span class="hljs-string">'name'</span>:name,<span class="hljs-string">'age'</span>:age&#125;<br>    <span class="hljs-keyword">return</span> person<br><br>print(show_info(<span class="hljs-string">'test'</span>,<span class="hljs-number">18</span>))<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-8">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">hello<br>&#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'test'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">18</span>&#125;<br><br>进程已结束，退出代码 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="2、用户问候">2、用户问候</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hi</span><span class="hljs-params">(first_name,last_name)</span>:</span><br>    <span class="hljs-string">"""返回完整名字"""</span><br>    full_name = first_name + <span class="hljs-string">' '</span> + last_name<br>    <span class="hljs-keyword">return</span> full_name<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    print(<span class="hljs-string">'请输入您的姓名:'</span>)<br>    f_name = input(<span class="hljs-string">'姓：'</span>)<br>    <span class="hljs-keyword">if</span> f_name ==<span class="hljs-string">'q'</span>:<br>        <span class="hljs-keyword">break</span><br><br>    l_name = input(<span class="hljs-string">'名：'</span>)<br>    <span class="hljs-keyword">if</span> l_name == <span class="hljs-string">'q'</span>:<br>        <span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># 调用函数</span><br>    format_name = say_hi(f_name,l_name)<br>    print(<span class="hljs-string">'hello'</span>+format_name+<span class="hljs-string">'!'</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-9">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">请输入您的姓名:<br>姓：x<br>名：gp<br>hellox gp!<br></code></pre></td></tr></table></figure></blockquote><h2 id="3、传递列表类型数据">3、传递列表类型数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">(names)</span>:</span><br>    <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names:<br>        print(name)<br>user_name = [<span class="hljs-string">'sdf'</span>,<span class="hljs-string">'fsd'</span>,<span class="hljs-string">'fewfwef'</span>,<span class="hljs-string">'fwefe'</span>]<br>test(user_name)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-10">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">sdf<br>fsd<br>fewfwef<br>fwefe<br><br>进程已结束，退出代码 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="5、range函数的练习">5、range函数的练习</h2><ol><li><strong>当只用一个变量调用这个函数时，这个变量指的是输出的等差数列的终点，如<code>range(5)</code></strong></li><li><strong>当给定两个变量时，分别指输出的起始值和终点,，如<code>range(2, 5)</code></strong></li><li><strong>当给定三个变量时，在上一条的基础上第三个变量指输出时的步长，如<code>range(2, 5, -1)</code></strong></li></ol><p><em><strong>（假定我们调用这个函数时总是用整数或浮点数）</strong></em></p><p><strong>分析一下如何实现这个函数，下面给出我的思路作为参考</strong></p><ul><li><strong>一共需要三个参数是显而易见的；</strong></li><li><strong>最直观的感受是起始值是要有默认值的，如果不规定从哪里开始，那就从0开始；</strong></li><li><strong>步长也是要有默认值的，如果不规定，那么步长是1；</strong></li><li><strong>根据有默认值的参数要放在后面的原则，那么最理所当然的参数设计是<code>range_custom(stop, start=0, step=1)</code></strong></li><li><strong>这个方案看上去可行，但是不满足刚才的后面两个要求，如果我们这样用两个变量调用，起始值和终点是反的；</strong></li><li><strong>我们加个判断就可以了，如果start用了初始值，那么说明我们调用的时候只给了一个参数，这个时候stop就是终点，如果start被重新赋值了说明给了至少两个参数，那么这时候把stop和start的值调换一下就可以了；</strong></li><li><strong>现在这个函数似乎可以满足大多数情况了，但是有一个bug，如果给定参数的时候给的start值就是0怎么办呢？如<code>range_custom(-5, 0)</code>按目前的规则会被翻译成<code>range(0, -5)</code>，但是我们的目的却是<code>range(-5, 0)</code>；</strong></li><li><strong>所以start的初始值不应该是数字而是别的数据类型，为了方便起见，我们把它的初始值赋为<code>None</code>，我们的程序雏形就出来了。</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">range_custom</span><span class="hljs-params">(stop, start=None, step=<span class="hljs-number">1</span>)</span>:</span><br>    <span class="hljs-keyword">if</span> start <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> range(stop)<br>    <span class="hljs-keyword">return</span> range(stop, start, step)<br></code></pre></td></tr></table></figure><p><strong>现在这个程序已经满足我们的要求了，但是看上去不太舒服，可以改成</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">range_custom</span><span class="hljs-params">(start, stop=None, step=<span class="hljs-number">1</span>)</span>:</span><br>    <span class="hljs-keyword">if</span> stop <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> range(start)<br>    <span class="hljs-keyword">return</span> range(start, stop, step)<br></code></pre></td></tr></table></figure><p><strong>现在这个函数的参数顺序在逻辑上更好理解一些，可以说基本上满足我们的要求了。当然，本例只是为了说明参数的顺序问题，并不是为了实现range函数。事实上Python的range函数还包括参数实例化，生成器等知识，在后面我们应该还有机会再接触它。</strong></p><h3 id="可选参数">可选参数</h3><p><strong>说到可选参数，可能有的人见过，却也不明白到底是什么意思，它一般是这样出现的</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_option</span><span class="hljs-params">(*args)</span>:</span><br>    <span class="hljs-keyword">return</span> args<br></code></pre></td></tr></table></figure><p><strong>注意到我们声明函数的时候在参数名前加了个<code>*</code>星号，这是声明可选参数的方法。那么可选参数到底有什么用呢？</strong></p><p><strong>可选参数的作用是用元组把所有多余的变量收集起来，这个元组的名字就是这个可选参数名。在上例<code>func_option</code>中我们可以用任意多个变量调用它，比如<code>a = func_option(1, 2, 3)</code>那么<code>a</code>就会是元组<code>(1, 2, 3)</code>。关于为什么是元组而不是列表，我们在上一篇<a href="https://www.jianshu.com/p/e6c4683a511d" target="_blank" rel="noopener">Python进阶-简单数据结构</a>中说过，元组在Python中往往是比列表更优先考虑使用的数据结构，具体原因在本文靠后<em>深入自定义函数参数</em>部分会讨论。</strong></p><p><strong>我们刚才说可选参数会收集多余的变量。我这么说是有原因的。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_option</span><span class="hljs-params">(a, *args, c=<span class="hljs-number">2</span>)</span>:</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> args<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>func_option2(<span class="hljs-number">1</span>)<br>()<br><span class="hljs-meta">&gt;&gt;&gt; </span>func_option2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">2</span>,)<br><span class="hljs-meta">&gt;&gt;&gt; </span>func_option2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p><strong>注意到我们的<code>*args</code>把除了给普通参数的第一个变量以外的值都放进了元组中。这样做导致了一个，问题在于我们的有默认值的参数如果不给定参数名地调用的话，就永远只能用默认值了。而且如果我们在调用函数时不把有默认值的参数放在最后面程序还会报错。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>func_option2(c=<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span><br>SyntaxError: positional argument follows keyword argument<br></code></pre></td></tr></table></figure><p><strong>那么有没有好的办法能规避这个问题呢？我们可以试试把可选参数放在有默认值的参数后面。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_option3</span><span class="hljs-params">(a, c=<span class="hljs-number">2</span>, *args)</span>:</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> args<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>func_option3(<span class="hljs-number">1</span>)<br>()<br><span class="hljs-meta">&gt;&gt;&gt; </span>func_option3(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>()<br><span class="hljs-meta">&gt;&gt;&gt; </span>func_option3(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">3</span>,)<br><span class="hljs-meta">&gt;&gt;&gt; </span>func_option2(c=<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span><br>SyntaxError: positional argument follows keyword argument<br></code></pre></td></tr></table></figure><p><strong>那么这种形式的函数能不能解决之前的问题呢。看上去不行，不过我们知道了，调用函数的时候，要尽量把有默认值的参数放在靠后的位置赋予变量。那么这两种我们到底该用哪个方法呢？在实际操作中，我们倾向于将可选参数放在有默认值的参数之后，而且如果参数较多，我们倾向于调用函数时都会所有变量都加上参数名。而且实际操作中，其实可选参数用得不那么多，相对来说，另一种可选参数其实用得更多。这种可选参数的形式一般是这样</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_optionkw</span><span class="hljs-params">(**kwargs)</span>:</span><br>    <span class="hljs-keyword">return</span> args<br></code></pre></td></tr></table></figure><p><strong>在这种情况下，关键字可选参数都是作为键值对保存在参数名的的字典中。也就是说，在调用函数时，在满足一般参数以后，变量都应该以赋值语句的形式给出，等号左边作为键右边作为值。如果不这样做，就会报错了。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>func_optionkw(<span class="hljs-number">3</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: t2() takes <span class="hljs-number">0</span> positional arguments but <span class="hljs-number">1</span> was given<br></code></pre></td></tr></table></figure><p><strong>需要说明的是，一个自定义函数只能有一个可选参数，同时也可以有至多一个关键字参数。其中关键字参数应该放在普通可选参数之后。</strong></p><p><strong>现在我们来总结一下函数参数顺序一般规律：</strong></p><ul><li><strong>一般参数放在最前面</strong></li><li><strong>可选参数放在最后面</strong></li><li><strong>关键字可选参数放在一般可选参数后面</strong></li><li><strong>函数调用时尽量把有默认值的参数对应的变量放在靠后的位置</strong></li><li><strong>如果参数比较多，调用函数时，最好所有变量都指明参数名</strong></li></ul><p><strong>以上这些，有的是为了防止函数定义时出错，有的是为了防止函数调用时出错，总之，应该养成良好的编程习惯。</strong></p><h1>五、变量作用域</h1><p><strong>一个程序的所有的变量并不是在哪个位置都可以访问的。访问权限决定于这个变量是在哪里赋值的。</strong></p><p><strong>变量的作用域决定了在哪一部分程序你可以访问哪个特定的变量名称。两种最基本的变量作用域如下：</strong></p><ul><li><strong>全局变量</strong></li><li><strong>局部变量</strong></li></ul><h1>六、全局变量和局部变量</h1><p><strong>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</strong></p><p><strong>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：</strong></p><h2 id="实例-Python-2-0">实例(Python 2.0+)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br> <br>total = <span class="hljs-number">0</span> <span class="hljs-comment"># 这是一个全局变量</span><br><span class="hljs-comment"># 可写函数说明</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span><span class="hljs-params">( arg1, arg2 )</span>:</span><br>   <span class="hljs-comment">#返回2个参数的和."</span><br>   total = arg1 + arg2 <span class="hljs-comment"># total在这里是局部变量.</span><br>   <span class="hljs-keyword">print</span> <span class="hljs-string">"函数内是局部变量 : "</span>, total<br>   <span class="hljs-keyword">return</span> total<br> <br><span class="hljs-comment">#调用sum函数</span><br>sum( <span class="hljs-number">10</span>, <span class="hljs-number">20</span> )<br><span class="hljs-keyword">print</span> <span class="hljs-string">"函数外是全局变量 : "</span>, total<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-11">输出结果如下：</h5><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">函数内是局部变量 :  30<br>函数外是全局变量 :  0<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyCharm和JDK安装与配置</title>
      <link href="/posts/2b21.html"/>
      <url>/posts/2b21.html</url>
      
        <content type="html"><![CDATA[<h1>一、PyCharm安装与配置</h1><p><strong>PyCharm 是一款功能强大的 Python 编辑器，具有跨平台性，鉴于目前最新版 PyCharm 使用教程较少，为了节约时间，来介绍一下 PyCharm 在 Windows下是如何安装的。</strong></p><p><strong>这是 PyCharm 的下载地址：<a href="http://www.jetbrains.com/pycharm/download/#section=windows" target="_blank" rel="noopener">http://www.jetbrains.com/pycharm/download/#section=windows</a></strong></p><p><strong>进入该网站后，我们会看到如下界面:</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/1591502672(1).png" alt="img"></p><p><strong>professional 表示专业版，community 是社区版，推荐安装社区版，因为是免费使用的。</strong></p><h2 id="1、安装">1、安装</h2><p><strong>双击安装包，点击next。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image003.png" alt="img"></p><p><strong>修改安装路径，我这里放的是D盘，点击“Browse…”修改好以后点击Next。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image004.png" alt="img"></p><p><strong>我们可以根据自己的电脑选择32位还是64位，目前应该基本都是64位系统。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image005.png" alt="img"></p><p><strong>点击“Install”进行安装。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image006.png" alt="img"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image007.png" alt="img"></p><p><strong>点击“Finish”结束安装。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image008.png" alt="img"></p><h2 id="2、破解">2、破解</h2><p><strong>破解工具如下。</strong> <img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image010.jpg" alt="img"></p><p><strong>将其复制到PyCharm安装目录下的lib目录，选中该文件，按住shift键的同时单击鼠标右键，选择“复制为路径”。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image012.jpg" alt="img"></p><p><strong>切换到bin目录，用记事本打开如下文件。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image014.jpg" alt="img"></p><p><strong>在文件中添加如下内容，其中-javaagent:后面是破解文件的路径，但是必须去掉双引号。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image016.jpg" alt="img"></p><p><strong>-javaagent:E:\jetbrains-agent.jar</strong></p><p><strong>保存该文件后打开PyCharm主程序，如果以前安装过PyCharm，那么可以使用之前的配置信息；反之的话点击“Do not import settings”，不导入配置信息。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image017.png" alt="img"></p><p><strong>点击“OK”，将打开程序主页。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image019.jpg" alt="img"></p><h2 id="3、创建第一个Python项目">3、创建第一个Python项目</h2><p><strong>点击“Create New Project”开始创建项目。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image021.jpg" alt="img"></p><p><strong>选择项目保存的路径，配置开发环境（不同的项目可能用到的Python库不同，此处的配置就是为了满足不同功能的项目需求），并且选择Python代码解释器，点击“Create”完成项目创建。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200319105619777.png" alt="image-20200319105619777"></p><h2 id="4、编写python文件"><strong>4、编写python文件</strong></h2><p><strong>在项目根目录下创建一个目录（暂时不是必须的），如：demo。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image024.jpg" alt="img"></p><p><strong>输入demo。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image026.jpg" alt="img"></p><p><strong>在demo目录下再新建python文件。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image028.jpg" alt="img"></p><p><strong>输入文件名，如hello，生成一个hello.py文件。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image030.jpg" alt="img"></p><p><strong>输入如下语句。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image032.jpg" alt="img"></p><p><strong>右键点击“Run ‘hello’”，在控制台输出结果。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image034.jpg" alt="img"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image036.jpg" alt="img"></p><p>​     <strong>至此，第一个python文件就完成了。</strong></p><h1>二、JDK安装与配置</h1><h2 id="1、下载JDK">1、下载JDK</h2><p>​    搜索“jdk官方下载”或是直接进入Sun公司的官网（<a href="https://www.oracle.com/%EF%BC%89" target="_blank" rel="noopener">https://www.oracle.com/）</a></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image002-1584708644535.png" alt="https://img-blog.csdn.net/20180414152218464"></p><p>​    下拉到页尾，点击“Download Java for Developers”，进入Java开发的下载页面</p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image004-1584708644535.png" alt="https://img-blog.csdn.net/20180414152604789"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image006-1584708644535.png" alt="https://img-blog.csdn.net/20180414152818315"></p><p>​    可以自行选择需要下载的java SE、java EE和Java ME的相应版本进行下载，我的电脑是32位的，所以我下载的是java SE的 jdk-8u161(如下图)</p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image008-1584708644535.png" alt="https://img-blog.csdn.net/20180414152638291"></p><p><strong>该页面还有各种相关介绍和开发说明，大家有需要的话，可以自行按需下载。</strong></p><p><strong>注：进入下载列表，选择所需下载的文件前，记得勾选列表标题下的 Accept License Agreement（此处默认是 Decline License Agreement），否则会不允许下载的。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image010-1584708644535.png" alt="https://img-blog.csdnimg.cn/2019040709505292.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tvbmdndV95b3VsYW4=,size_16,color_FFFFFF,t_70"></p><h2 id="2、安装">2、安装</h2><p>​    <strong>下载完成后就可以进行安装了。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image012-1584708644535.jpg" alt="img"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image014-1584708644535.jpg" alt="img"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image016-1584708644536.jpg" alt="img"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image018-1584708644536.jpg" alt="img"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image020-1584708644536.jpg" alt="img"></p><p>![img](file:///C:/Users/huawei/AppData/Local/Temp/msohtmlclip1/01/clip_image022.jpg)<img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image024-1584708644536.jpg" alt="img"></p><p>​    <strong>至此，jdk安装完成。</strong></p><h2 id="3、配置环境变量">3、配置环境变量</h2><p><strong>安装好的jdk需要进行环境变量的配置。</strong></p><p><strong>我使用的是Win10的系统，“此电脑/计算机”右键 “属性”，进入“高级系统设置”</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image026-1584708644536.jpg" alt="img"></p><p><strong>然后进入“环境变量”的设置，新建所需的环境变量（记得要在“系统变量”里面创建）</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image028-1584708644536.png" alt="https://img-blog.csdn.net/20180414181731901"></p><h3 id="（1）新建-JAVA-HOME-变量">（1）新建 JAVA_HOME 变量**</h3><p>![img](file:///C:/Users/huawei/AppData/Local/Temp/msohtmlclip1/01/clip_image030.jpg)</p><h3 id="（2）找到Path变量进行编辑，将“-JAVA-HOME-bin”和“-JAVA-HOME-jre”加入Path的变量值中">（2）找到Path变量进行编辑，将“%JAVA_HOME%\bin”和“%JAVA_HOME%\jre”加入Path的变量值中**</h3><p>![<a href="https://img-blog.csdn.net/20180414194425415" target="_blank" rel="noopener">https://img-blog.csdn.net/20180414194425415</a>](file:///C:/Users/huawei/AppData/Local/Temp/msohtmlclip1/01/clip_image032.png)<img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image033-1584708644536.png" alt="img"></p><h3 id="（3）每次编辑完“环境变量”，都要点击“确定”加以保存，否则，你所“新建-编辑”的环境变量都是无效的">（3）每次编辑完“环境变量”，都要点击“确定”加以保存，否则，你所“新建/编辑”的环境变量都是无效的</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image035-1584708644536.png" alt="https://img-blog.csdn.net/20180414194641853">![<a href="https://img-blog.csdn.net/20180414194704411" target="_blank" rel="noopener">https://img-blog.csdn.net/20180414194704411</a>](file:///C:/Users/huawei/AppData/Local/Temp/msohtmlclip1/01/clip_image037.png)</p><p>​    <strong>这样，jdk的环境变量就配置好了。</strong></p><h2 id="4、测试">4、测试</h2><p>​    <strong>安装好jdk，并配置好环境变量后，可以通过cmd命令进行测试，是否安装并配置正确。</strong></p><h3 id="（1）-在“开始”菜单栏键入-cmd，回车后打开cmd窗口；">（1） 在“开始”菜单栏键入 cmd，回车后打开cmd窗口；</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image038-1584708644536.png" alt="img"></p><h3 id="（2）输入-Java，回车，显示出-java-的相关信息；键入-Javac-回车，显示出-Java-编译的相关信息，即表示安装并配置成功">（2）输入 Java，回车，显示出 java 的相关信息；键入 Javac + 回车，显示出　Java 编译的相关信息，即表示安装并配置成功</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/clip_image040-1584708644536.jpg" alt="img"></p><h3 id="（3）说明：若想查看所安装jdk的版本信息，可在cmd窗口键入-java-version-（大小写没影响的）。">（3）说明：若想查看所安装jdk的版本信息，可在cmd窗口键入&quot;java -version&quot;（大小写没影响的）。</h3><p>![img](file:///C:/Users/huawei/AppData/Local/Temp/msohtmlclip1/01/clip_image042.jpg)****</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的input和while循环</title>
      <link href="/posts/7b33.html"/>
      <url>/posts/7b33.html</url>
      
        <content type="html"><![CDATA[<h1>python的input和while使用</h1><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200317145357720.png" alt="image-20200317145357720"></p><h1>一、Python input()函数：获取用户输入的字符串</h1><p><strong>Python3.x 中 input() 函数接受一个标准输入数据，返回为 string 类型。</strong></p><p><strong>Python2.x 中 input() 相等于 <code>eval(raw_input(prompt))</code>，用来获取控制台的输入。</strong></p><p><strong>raw_input() 将所有输入作为字符串看待，返回字符串类型。而 input() 在对待纯数字输入时具有自己的特性，它返回所输入的数字的类型（ int, float ）。</strong></p><blockquote><p><strong>注意：input() 和 raw_input() 这两个函数均能接收 字符串 ，但 raw_input() 直接读取控制台的输入（任何类型的输入它都可以接收）。而对于 input() ，它希望能够读取一个合法的 python 表达式，即你输入字符串的时候必须使用引号将它括起来，否则它会引发一个 SyntaxError 。</strong></p><p><strong>除非对 input() 有特别需要，否则一般情况下我们都是推荐使用 raw_input() 来与用户交互。</strong></p><p><strong>注意：python3 里 input() 默认接收到的是 str 类型。</strong></p></blockquote><h4 id="函数语法">函数语法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">input([prompt])<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><strong>prompt: 提示信息</strong></li></ul><h4 id="解决问题：">解决问题：</h4><blockquote><ul><li><strong>input 得到的数据到底是什么类型</strong></li><li><strong>多个参数接收input的输入，是怎么解包的</strong></li><li><strong>如果输入的个数不确定，怎么处理</strong></li><li><strong>要判断输入的是不是float 类型</strong></li><li><strong>要对输入的参数格式输出，规定参数只能是str或者int 或者float类型</strong></li></ul></blockquote><h2 id="1、例子">1、例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用户输入</span><br><span class="hljs-comment"># 提示输入内容</span><br>pet = input (<span class="hljs-string">'请输入您最喜欢的宠物名称：'</span>)<br>print(pet)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">请输入您最喜欢的宠物名称：猫咪<br>猫咪<br></code></pre></td></tr></table></figure></blockquote><h2 id="2、吉祥号码">2、吉祥号码</h2><p><em><strong>在python 3 里，一切input的得到的东西，都是str类型（可用type()查看类型）</strong></em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">good_luck_num = input(<span class="hljs-string">'请输入你的吉祥号码：'</span>)<br>print(type(good_luck_num))<br>print(<span class="hljs-string">'您输入的是：'</span>+good_luck_num)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-2">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">请输入你的吉祥号码：<span class="hljs-number">9898998</span><br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">str</span>'&gt;</span><br><span class="hljs-class">您输入的是：9898998</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="在python2-里-有input-和raw-input"><strong>在python2 里 有input 和raw_input</strong></h4><ul><li><strong>raw_input 得到的都是str类型</strong></li><li><strong>input 会根据输入数据的类型自动生成类型</strong></li></ul><h4 id="我们可以使用-Python-内置函数将字符串转换成想要的类型，比如：">我们可以使用 Python 内置函数将字符串转换成想要的类型，比如：</h4><ul><li><strong>int(string) 将字符串转换成 int 类型；</strong></li><li><strong>float(string) 将字符串转换成 float 类型；</strong></li><li><strong>bool(string) 将字符串转换成 bool 类型。</strong></li></ul><h2 id="3、超市选物">3、超市选物</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">print(<span class="hljs-string">'---------超市购物系统---------'</span>)<br>print(<span class="hljs-string">'1.电子产品 2.化妆品 3.生活用品 4.书籍'</span>)<br><span class="hljs-comment"># print('请选择您要购买的产品类型：')</span><br>product_type = input(<span class="hljs-string">'请选择您要购买的产品类型:'</span>)<br><span class="hljs-comment"># 判断输入的序号</span><br><span class="hljs-keyword">if</span> product_type == <span class="hljs-string">'1'</span>:<br>    print(<span class="hljs-string">'电子产品'</span>)<br><span class="hljs-keyword">elif</span> product_type ==<span class="hljs-string">'2'</span>:<br>    print(<span class="hljs-string">'化妆品'</span>)<br><span class="hljs-keyword">elif</span> product_type ==<span class="hljs-string">'3'</span>:<br>    print(<span class="hljs-string">'生活用品'</span>)<br><span class="hljs-keyword">elif</span> product_type ==<span class="hljs-string">'4'</span>:<br>    print(<span class="hljs-string">'书籍'</span>)<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'只能输入1~4的数字'</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-3">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">---------超市购物系统---------<br><span class="hljs-number">1.</span>电子产品 <span class="hljs-number">2.</span>化妆品 <span class="hljs-number">3.</span>生活用品 <span class="hljs-number">4.</span>书籍<br>请选择您要购买的产品类型:<span class="hljs-number">4</span><br>书籍<br></code></pre></td></tr></table></figure></blockquote><h2 id="4、小练习">4、小练习</h2><h3 id="（1）编写一个程序，询问用户最喜欢的IT从业岗位，并输出一条信息，如：“我最喜欢的岗位是Python自动化运维。”">（1）编写一个程序，询问用户最喜欢的IT从业岗位，并输出一条信息，如：“我最喜欢的岗位是Python自动化运维。”</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">gz = input(<span class="hljs-string">'您最喜欢的IT从业岗位：'</span>)<br>print(<span class="hljs-string">'我最喜欢的岗位是'</span>+gz)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-4">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">您最喜欢的IT从业岗位：Python自动化运维<br>我最喜欢的岗位是Python自动化运维<br></code></pre></td></tr></table></figure></blockquote><h3 id="（2）编写一个程序，询问学生今天的作业完成了吗？如果输入“y”，则输出“今天的作业完成了”；如果输入“no”，则输出“今天的作业还需要一段时间才能完成。”">（2）编写一个程序，询问学生今天的作业完成了吗？如果输入“y”，则输出“今天的作业完成了”；如果输入“no”，则输出“今天的作业还需要一段时间才能完成。”</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">zy = input(<span class="hljs-string">'今天的作业完成了吗？：（y/n）'</span>)<br><span class="hljs-keyword">if</span> zy ==  <span class="hljs-string">'y'</span>:<br>    print(<span class="hljs-string">'今天的作业完成了'</span>)<br><span class="hljs-keyword">elif</span> zy == <span class="hljs-string">'n'</span>:<br>    print(<span class="hljs-string">'今天的作业还需要一段时间才能完成'</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-5">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">今天的作业完成了吗？：（y/n）y<br>今天的作业完成了<br></code></pre></td></tr></table></figure></blockquote><h3 id="（3）让用户输入一个三位数，输出这个数是不是回文数。">（3）让用户输入一个三位数，输出这个数是不是回文数。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">num = input(<span class="hljs-string">'输入一个三位数'</span>)<br>num2 = num[::<span class="hljs-number">-1</span>]<br>print(num2)<br><span class="hljs-keyword">if</span> num == num2:<br>    print(<span class="hljs-string">'这是个回文数'</span>)<br><span class="hljs-keyword">elif</span> num != num2:<br>    print(<span class="hljs-string">'这是个普通数字'</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-6">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">输入一个三位数<span class="hljs-number">121</span><br><span class="hljs-number">121</span><br>这是个回文数<br></code></pre></td></tr></table></figure></blockquote><h1>二、Python While 循环语句</h1><p><strong>Python 编程中 while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。其基本形式为：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> 判断条件(condition)：<br>    执行语句(statements)……<br></code></pre></td></tr></table></figure><p><strong>执行语句可以是单个语句或语句块。判断条件可以是任何表达式，任何非零、或非空（null）的值均为true。</strong></p><p><strong>当判断条件假 false 时，循环结束。</strong></p><p><strong>执行流程图如下：</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2013/11/886A6E10-58F1-4A9B-8640-02DBEFF0EF9A.jpg" alt="img"></p><h3 id="Gif-演示-Python-while-语句执行过程">Gif 演示 Python while 语句执行过程</h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/05/006faQNTgw1f5wnm06h3ug30ci08cake.gif" alt="img"></p><p><strong>复杂一点:</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2013/11/loop-over-python-list-animation.gif" alt="img"></p><h2 id="1、例子：-while循环：如果这件事情是重复性的去做的">1、例子：(while循环：如果这件事情是重复性的去做的)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">num = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> num&lt;<span class="hljs-number">10</span>:<br>    print(num,end=<span class="hljs-string">" "</span>)<br>    num = num+<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-7">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <br></code></pre></td></tr></table></figure></blockquote><h2 id="2、使用while循环，计算1-100之间偶数之和。">2、使用while循环，计算1-100之间偶数之和。</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建一个变量x初始化为2</span><br>x = <span class="hljs-number">2</span><br><span class="hljs-comment">#创建一个变量sum初始化为0</span><br>sum = <span class="hljs-number">0</span><br><span class="hljs-comment">#使用while循环求出0-100所有偶数的和</span><br><span class="hljs-keyword">while</span> x &lt;= <span class="hljs-number">100</span> :<br>    sum += x <br>    x += <span class="hljs-number">2</span><br><span class="hljs-comment">#打印输出求和结果</span><br>print(sum)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-8">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2550</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="3、编写一个程序，模拟用户登录，验证用户名和密码，最大输入次数为3次，否则锁定用户。">3、编写一个程序，模拟用户登录，验证用户名和密码，最大输入次数为3次，否则锁定用户。</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">count = <span class="hljs-number">3</span><br>users= <span class="hljs-string">'xgp'</span><br>password= <span class="hljs-string">'123.com'</span><br>i = <span class="hljs-number">3</span><br><span class="hljs-keyword">while</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> i &lt; <span class="hljs-number">4</span>:<br>    <span class="hljs-comment"># 输入提示</span><br>    user = input(<span class="hljs-string">'请输入您的用户名：'</span>)<br>    passwd = input(<span class="hljs-string">'请输入您的密码：'</span>)<br>    <span class="hljs-comment"># 判断用户名和密码</span><br>    <span class="hljs-keyword">if</span> user == users <span class="hljs-keyword">and</span> passwd == password:<br>        print(<span class="hljs-string">'登陆成功'</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># 登陆统计次数</span><br>        i = i - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<br>            print(<span class="hljs-string">'账号锁定'</span>)<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vim">相比较上面的简单一点<br><span class="hljs-built_in">count</span> = <span class="hljs-number">3</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">count</span>&gt;<span class="hljs-number">0</span>: <br>    name = <span class="hljs-built_in">input</span>(<span class="hljs-string">'请输入用户名：'</span>)<br>    password = <span class="hljs-built_in">input</span>(<span class="hljs-string">'请输入密码：'</span>)  <br>    <span class="hljs-keyword">if</span> name == <span class="hljs-string">'xgp'</span> <span class="hljs-built_in">and</span> password == <span class="hljs-string">'123.com'</span>:<br>        <span class="hljs-keyword">print</span>(<span class="hljs-string">'通过验证，即将登陆......'</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">count</span> = <span class="hljs-built_in">count</span> - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">print</span>(<span class="hljs-string">'还剩'</span>+str(<span class="hljs-built_in">count</span>)+<span class="hljs-string">"次机会"</span>)<br></code></pre></td></tr></table></figure></blockquote><h5 id="输出结果-1-：">输出结果(1)：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">请输入您的用户名：<span class="hljs-number">1</span><br>请输入您的密码：<span class="hljs-number">1</span><br>请输入您的用户名：<span class="hljs-number">1</span><br>请输入您的密码：<span class="hljs-number">1</span><br>请输入您的用户名：<span class="hljs-number">1</span><br>请输入您的密码：<span class="hljs-number">1</span><br>账号锁定<br></code></pre></td></tr></table></figure></blockquote><h5 id="输出结果-2-：">输出结果(2)：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">请输入您的用户名：xgp<br>请输入您的密码：<span class="hljs-number">123.</span>com<br>登陆成功<br></code></pre></td></tr></table></figure></blockquote><h1>三、while循环处理列表和字典</h1><p><strong>for循环是一种遍历列表的有效方式，但在for循环中不应修改列表，否则将导致Python难以跟踪其中的元素。要在遍历列表的同时对其进行修改，可使用while循环。</strong></p><p><strong>通过将while循环同列表和字典结合起来使用，可收集、存储并组织大量输出，供以后查看和显示。</strong></p><h2 id="1、类似列表复制">1、类似列表复制</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">users = [<span class="hljs-string">'alpha'</span>,<span class="hljs-string">'byta'</span>,<span class="hljs-string">'gima'</span>]<br>users_shadow = []<br><br><span class="hljs-keyword">while</span> users:<br>    current_user = users.pop()<br>    users_shadow.append(current_user)<br><br>print(users_shadow)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-9">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">'gima'</span>, <span class="hljs-string">'byta'</span>, <span class="hljs-string">'alpha'</span>]<br></code></pre></td></tr></table></figure></blockquote><h3 id="for循环复制">for循环复制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> users:<br>    users_shdow.append(i)<br>print(users_shadow)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-10">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">'gima'</span>, <span class="hljs-string">'byta'</span>, <span class="hljs-string">'alpha'</span>]<br></code></pre></td></tr></table></figure></blockquote><h2 id="2、删除列表当中的指定元素">2、删除列表当中的指定元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">users = [<span class="hljs-string">'alpha'</span>,<span class="hljs-string">'byta'</span>,<span class="hljs-string">'gima'</span>]<br>print(users)<br><span class="hljs-keyword">while</span> <span class="hljs-string">'byta'</span> <span class="hljs-keyword">in</span> users:<br>    users.remove(<span class="hljs-string">'byta'</span>)<br>print(users)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-11">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">'alpha'</span>, <span class="hljs-string">'byta'</span>, <span class="hljs-string">'gima'</span>]<br>[<span class="hljs-string">'alpha'</span>, <span class="hljs-string">'gima'</span>]<br></code></pre></td></tr></table></figure></blockquote><h2 id="3、创建一个调查程序，每次循环的时候，提示输入接受调查的名字和回答，将这个收集到的数据存储到一个字典中">3、创建一个调查程序，每次循环的时候，提示输入接受调查的名字和回答，将这个收集到的数据存储到一个字典中</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个空字典</span><br>responses = &#123;&#125;<br><br><span class="hljs-comment"># 设置标志：表示调查是否继续</span><br>flag = <span class="hljs-literal">True</span><br><br><span class="hljs-comment"># 循环操作</span><br><span class="hljs-keyword">while</span> flag:<br>    <span class="hljs-comment">#提示输入接受调查的名字和回答</span><br>    name = input(<span class="hljs-string">'请输入您的名字：'</span>)<br>    response = input(<span class="hljs-string">'清输入您的答案：'</span>)<br>    <br>    <span class="hljs-comment"># 将答案存储到字典中</span><br>    responses[name] = response<br>    <br>    <span class="hljs-comment"># 是否还有人需要参加调查</span><br>    repeat = input(<span class="hljs-string">'是否还有人需要参加调查：(yes/no)'</span>)<br>    <span class="hljs-keyword">if</span> repeat == <span class="hljs-string">'no'</span>:<br>        flag = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 显示调查结果</span><br>print(<span class="hljs-string">'\n-------------------调查结果-------------------'</span>)<br><span class="hljs-keyword">for</span> name,response <span class="hljs-keyword">in</span> responses.items():<br>    print(name + <span class="hljs-string">"&gt;&gt;&gt;"</span> + response)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-12">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">请输入您的名字：wsd<br>清输入您的答案：<span class="hljs-number">123</span><br>是否还有人需要参加调查：(yes/no)yes<br>请输入您的名字：wushaox<br>清输入您的答案：x<br>是否还有人需要参加调查：(yes/no)no<br><br>-------------------调查结果-------------------<br>wsd&gt;&gt;&gt;<span class="hljs-number">123</span><br>wushaox&gt;&gt;&gt;x<br></code></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 字典</title>
      <link href="/posts/8e0b.html"/>
      <url>/posts/8e0b.html</url>
      
        <content type="html"><![CDATA[<h1>一、Python 字典(Dictionary)</h1><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200316150648198.png" alt="image-20200316150648198"></p><p><strong>字典是另一种可变容器模型，且可存储任意类型对象。</strong></p><p><strong>字典的每个键值 <code>key=&gt;value</code> 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 <code>{}</code> 中 ,格式如下所示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">d = &#123;key1 : value1, key2 : value2 &#125;<br></code></pre></td></tr></table></figure><p><strong>键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;dict = &#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'b'</span>: <span class="hljs-string">'3'</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>dict[<span class="hljs-string">'b'</span>]<br><span class="hljs-string">'3'</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>dict<br>&#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-string">'3'</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。</strong></p><h2 id="1、例子">1、例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python的数据类型：字典</span><br><br><span class="hljs-comment"># 数据类型与变量关联</span><br>name = <span class="hljs-string">'bily'</span><br>num = <span class="hljs-number">89</span><br>key = <span class="hljs-number">88.8</span><br>list = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>tuple = (<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">68</span>)<br><br><span class="hljs-comment"># 字典的例子：键和值</span><br>dict = &#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'老周'</span>,<span class="hljs-string">'age'</span>:<span class="hljs-string">'29'</span>,<span class="hljs-string">'job'</span>:<span class="hljs-string">'程序员'</span>&#125;<br>print(dict)<br>dict1=&#123;<span class="hljs-number">1</span>:<span class="hljs-number">101</span>,<span class="hljs-number">2</span>:<span class="hljs-number">102</span>&#125;<br>print(dict1)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果："><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'老周'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-string">'29'</span>, <span class="hljs-string">'job'</span>: <span class="hljs-string">'程序员'</span>&#125;<br>&#123;<span class="hljs-number">1</span>: <span class="hljs-number">101</span>, <span class="hljs-number">2</span>: <span class="hljs-number">102</span>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><em><strong>表和元组直接写入值即可，而字典需要键和值皆有。</strong></em></p><h2 id="2、简单的字典的操作">2、简单的字典的操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个字典</span><br>dict2 = &#123;<br>    <span class="hljs-string">'河北'</span>:<span class="hljs-string">'石家庄'</span>,<br>    <span class="hljs-string">'甘肃'</span>:<span class="hljs-string">'兰州'</span>,<br>    <span class="hljs-string">'四川'</span>:<span class="hljs-string">'成都'</span><br>&#125;<br><span class="hljs-keyword">print</span>（dict2）<br><br><span class="hljs-comment"># 对字典进行访问（取值）==&gt;  值=字典的名称[键]</span><br>sjz = dict2[<span class="hljs-string">'河北'</span>]<br>print(sjz)<br><br><span class="hljs-comment"># 添加字典的数据（键值对）</span><br>dict2[<span class="hljs-string">'山西'</span>]=<span class="hljs-string">'太原'</span><br>print(dict2)<br><br><span class="hljs-comment"># 修改字典的值</span><br>dict2[<span class="hljs-string">'河北'</span>]=<span class="hljs-string">'邢台'</span><br>print(dict2)<br><br><span class="hljs-comment"># 删除字典的键-值对</span><br><span class="hljs-keyword">del</span> dict2[<span class="hljs-string">'四川'</span>]<br>print(dict2)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-2"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 原来的数据</span><br>&#123;<span class="hljs-string">'河北'</span>:<span class="hljs-string">'石家庄'</span>,<span class="hljs-string">'甘肃'</span>:<span class="hljs-string">'兰州'</span>,<span class="hljs-string">'四川'</span>:<span class="hljs-string">'成都'</span>&#125;<br><br><span class="hljs-comment"># 访问键（河北）</span><br>石家庄<br><br><span class="hljs-comment"># 添加键值对（'山西': '太原'）</span><br>&#123;<span class="hljs-string">'河北'</span>: <span class="hljs-string">'石家庄'</span>, <span class="hljs-string">'甘肃'</span>: <span class="hljs-string">'兰州'</span>, <span class="hljs-string">'四川'</span>: <span class="hljs-string">'成都'</span>, <span class="hljs-string">'山西'</span>: <span class="hljs-string">'太原'</span>&#125;<br><br><span class="hljs-comment"># 修改字典的值（石家庄改为邢台）</span><br>&#123;<span class="hljs-string">'河北'</span>: <span class="hljs-string">'邢台'</span>, <span class="hljs-string">'甘肃'</span>: <span class="hljs-string">'兰州'</span>, <span class="hljs-string">'四川'</span>: <span class="hljs-string">'成都'</span>, <span class="hljs-string">'山西'</span>: <span class="hljs-string">'太原'</span>&#125;<br><br><span class="hljs-comment"># 删除字典的键-值对（四川）</span><br>&#123;<span class="hljs-string">'河北'</span>: <span class="hljs-string">'邢台'</span>, <span class="hljs-string">'甘肃'</span>: <span class="hljs-string">'兰州'</span>, <span class="hljs-string">'山西'</span>: <span class="hljs-string">'太原'</span>&#125;<br></code></pre></td></tr></table></figure></blockquote><h1>二、遍历字典</h1><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200316115750052.png" alt="image-20200316115750052" style="zoom: 200%;"><h2 id="1、定义一个字典">1、定义一个字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">dict = &#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'老周'</span>,<span class="hljs-string">'age'</span>:<span class="hljs-string">'29'</span>,<span class="hljs-string">'job'</span>:<span class="hljs-string">'程序员'</span>&#125;<br><br><span class="hljs-comment"># 遍历字典：键值对的集合、健的集合、值的集合</span><br><br><span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> dict.items():<br>    print(key+<span class="hljs-string">":"</span>+value)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-3"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name:老周<br>age:<span class="hljs-number">29</span><br>job:程序员<br></code></pre></td></tr></table></figure></blockquote><h2 id="2、遍历字典常用的方法">2、遍历字典常用的方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">print(dict.items())<br>print(dict.keys())<br>print(dict.values())<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-4"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dict_items([(<span class="hljs-string">'name'</span>, <span class="hljs-string">'老周'</span>), (<span class="hljs-string">'age'</span>, <span class="hljs-string">'29'</span>), (<span class="hljs-string">'job'</span>, <span class="hljs-string">'程序员'</span>)])<br>dict_keys([<span class="hljs-string">'name'</span>, <span class="hljs-string">'age'</span>, <span class="hljs-string">'job'</span>])<br>dict_values([<span class="hljs-string">'老周'</span>, <span class="hljs-string">'29'</span>, <span class="hljs-string">'程序员'</span>])<br></code></pre></td></tr></table></figure></blockquote><h2 id="3、字典元素的个数">3、字典元素的个数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(len(dict))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-5"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="4、复制字典">4、复制字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1 = &#123;&#125;<br>dict1 = dict.copy()<br>print(dict1)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-6"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'老周'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-string">'29'</span>, <span class="hljs-string">'job'</span>: <span class="hljs-string">'程序员'</span>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="5、将字典的键排序">5、将字典的键排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">print(sorted(dict1.keys()))<br>print(sorted(dict1.values()))<br><br><span class="hljs-keyword">for</span> info <span class="hljs-keyword">in</span> sorted(dict1.keys()):<br>    print(info,end=<span class="hljs-string">" "</span>)<br><br>print(<span class="hljs-string">"\n"</span>)<br><span class="hljs-keyword">for</span> info <span class="hljs-keyword">in</span> sorted(dict1.keys()):<br>    print(value,end=<span class="hljs-string">" "</span>)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-7"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">'age'</span>, <span class="hljs-string">'job'</span>, <span class="hljs-string">'name'</span>]<br>[<span class="hljs-string">'29'</span>, <span class="hljs-string">'程序员'</span>, <span class="hljs-string">'老周'</span>]<br>age job name <br><br>程序员 程序员 程序员 <br></code></pre></td></tr></table></figure></blockquote><h2 id="6、使用函数获取字典值">6、使用函数获取字典值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(dict1.get(<span class="hljs-string">'age'</span>))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-8"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">29</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="7、删除字典的方法">7、删除字典的方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 删除字典</span><br><span class="hljs-comment"># dicr1.clear()</span><br>dict = &#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'老周'</span>,<span class="hljs-string">'age'</span>:<span class="hljs-string">'29'</span>,<span class="hljs-string">'job'</span>:<span class="hljs-string">'程序员'</span>&#125;<br>print(dict)<br><br><span class="hljs-comment"># 删除末尾</span><br><span class="hljs-comment">#print(dict.popitem())</span><br><span class="hljs-comment">#print(dict)</span><br><br><span class="hljs-comment"># 指定删除</span><br>print(dict.pop(<span class="hljs-string">'age'</span>))<br>print(dict)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-9"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'老周'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-string">'29'</span>, <span class="hljs-string">'job'</span>: <span class="hljs-string">'程序员'</span>&#125;<br><span class="hljs-number">29</span><br>&#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'老周'</span>, <span class="hljs-string">'job'</span>: <span class="hljs-string">'程序员'</span>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="8、小练习">8、小练习</h2><h3 id="（1）编写一个字典，检查给定键是否已经存在于字典中。">（1）编写一个字典，检查给定键是否已经存在于字典中。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">dict = &#123;<br>    <span class="hljs-string">'name'</span>:<span class="hljs-string">'xgp'</span>,<br>    <span class="hljs-string">'ah'</span>:<span class="hljs-string">'sleep'</span>,<br>    <span class="hljs-string">'yd'</span>:<span class="hljs-string">'pb'</span>,<br>&#125;<br>print(dict)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-10"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'xgp'</span>, <span class="hljs-string">'ah'</span>: <span class="hljs-string">'sleep'</span>, <span class="hljs-string">'yd'</span>: <span class="hljs-string">'pb'</span>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="（2）编写一个Python程序，把已存在的一个字典添加到一个空字典中。">（2）编写一个Python程序，把已存在的一个字典添加到一个空字典中。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1 = &#123;&#125;<br>dict1 = dict.copy()<br>print(dict1)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-11"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'xgp'</span>, <span class="hljs-string">'ah'</span>: <span class="hljs-string">'sleep'</span>, <span class="hljs-string">'yd'</span>: <span class="hljs-string">'pb'</span>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="（3）编写一个字典，遍历出该字典所有的键、值、键值对。">（3）编写一个字典，遍历出该字典所有的键、值、键值对。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">dict2 = &#123;<br>    <span class="hljs-string">'1'</span>:<span class="hljs-string">'1'</span>,<br>    <span class="hljs-string">'2'</span>:<span class="hljs-string">'2'</span>,<br>    <span class="hljs-string">'3'</span>:<span class="hljs-string">'3'</span>,<br>    <span class="hljs-string">'4'</span>:<span class="hljs-string">'4'</span>,<br>    <span class="hljs-string">'5'</span>:<span class="hljs-string">'5'</span><br>&#125;<br>print(dict2.keys())<br>print(dict2.values())<br>print(dict2.items())<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-12"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dict_keys([<span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>])<br>dict_values([<span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>])<br>dict_items([(<span class="hljs-string">'1'</span>, <span class="hljs-string">'1'</span>), (<span class="hljs-string">'2'</span>, <span class="hljs-string">'2'</span>), (<span class="hljs-string">'3'</span>, <span class="hljs-string">'3'</span>), (<span class="hljs-string">'4'</span>, <span class="hljs-string">'4'</span>), (<span class="hljs-string">'5'</span>, <span class="hljs-string">'5'</span>)])<br></code></pre></td></tr></table></figure></blockquote><h1>三、字典与列表的嵌套</h1><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200316150833369.png" alt="image-20200316150833369"></p><h2 id="1、定义一个字典-2">1、定义一个字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dict = &#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'老周'</span>,<span class="hljs-string">'age'</span>:<span class="hljs-string">'29'</span>,<span class="hljs-string">'job'</span>:<span class="hljs-string">'程序员'</span>&#125;<br>dict1 = &#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'老周'</span>,<span class="hljs-string">'age'</span>:<span class="hljs-string">'29'</span>&#125;<br>dict2 = &#123;<span class="hljs-string">'age'</span>:<span class="hljs-string">'29'</span>,<span class="hljs-string">'job'</span>:<span class="hljs-string">'程序员'</span>&#125;<br>print(dict,dict1,dict2)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-13"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'老周'</span>,<span class="hljs-string">'age'</span>:<span class="hljs-string">'29'</span>,<span class="hljs-string">'job'</span>:<span class="hljs-string">'程序员'</span>&#125;,&#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'老周'</span>,<span class="hljs-string">'age'</span>:<span class="hljs-string">'29'</span>&#125;,&#123;<span class="hljs-string">'age'</span>:<span class="hljs-string">'29'</span>,<span class="hljs-string">'job'</span>:<span class="hljs-string">'程序员'</span>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="2、列表里嵌套字典">2、列表里嵌套字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">list = [dict,dict1,dict2]<br>print(list)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-14"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">[&#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'老周'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-string">'29'</span>, <span class="hljs-string">'job'</span>: <span class="hljs-string">'程序员'</span>&#125;, &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'老周'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-string">'29'</span>&#125;, &#123;<span class="hljs-string">'age'</span>: <span class="hljs-string">'29'</span>, <span class="hljs-string">'job'</span>: <span class="hljs-string">'程序员'</span>&#125;]<br>&#123;<span class="hljs-string">'pet'</span>: [<span class="hljs-string">'cat'</span>, <span class="hljs-string">'dog'</span>, <span class="hljs-string">'duck'</span>]&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="3、字典里嵌套列表">3、字典里嵌套列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">dict3 =&#123;<span class="hljs-string">'pet'</span>:[<span class="hljs-string">'cat'</span>,<span class="hljs-string">'dog'</span>,<span class="hljs-string">'duck'</span>]&#125;<br>print(dict3)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-15"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">'pet'</span>: [<span class="hljs-string">'cat'</span>, <span class="hljs-string">'dog'</span>, <span class="hljs-string">'duck'</span>]&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="4、字典里嵌套字典">4、字典里嵌套字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">dict4 = &#123;<br>    <span class="hljs-string">'age'</span>:&#123;<span class="hljs-string">'gir1'</span>:<span class="hljs-string">'18'</span>,<span class="hljs-string">'boy'</span>:<span class="hljs-string">'20'</span>&#125;,<br>    <span class="hljs-string">'job'</span>:&#123;<span class="hljs-string">'man'</span>:<span class="hljs-string">'IT'</span>,<span class="hljs-string">'women'</span>:<span class="hljs-string">'db'</span>&#125;<br>&#125;<br>print(dict4)<br><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> dict4.items():<br>    print(<span class="hljs-string">'key:'</span>+key,end=<span class="hljs-string">" "</span>)<br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> value.items():<br>        print(v)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-16"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">'age'</span>: &#123;<span class="hljs-string">'gir1'</span>: <span class="hljs-string">'18'</span>, <span class="hljs-string">'boy'</span>: <span class="hljs-string">'20'</span>&#125;, <span class="hljs-string">'job'</span>: &#123;<span class="hljs-string">'man'</span>: <span class="hljs-string">'IT'</span>, <span class="hljs-string">'women'</span>: <span class="hljs-string">'db'</span>&#125;&#125;<br>key:age (<span class="hljs-string">'gir1'</span>, <span class="hljs-string">'18'</span>)<br>(<span class="hljs-string">'boy'</span>, <span class="hljs-string">'20'</span>)<br>key:job (<span class="hljs-string">'man'</span>, <span class="hljs-string">'IT'</span>)<br>(<span class="hljs-string">'women'</span>, <span class="hljs-string">'db'</span>)<br></code></pre></td></tr></table></figure></blockquote><h1>四、小测试</h1><h2 id="1、创建两个字典来表示老师，然后将这两个字典存储到一个名为person的列表中。遍历这个列表，将其中每个老师的信息都打印出来。">1、创建两个字典来表示老师，然后将这两个字典存储到一个名为person的列表中。遍历这个列表，将其中每个老师的信息都打印出来。</h2><h3 id="（1）创建两个字典来表示老师">（1）创建两个字典来表示老师</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">dict = &#123;<br>    <span class="hljs-string">'name'</span>:<span class="hljs-string">'xgp'</span>,<br>    <span class="hljs-string">'age'</span>:<span class="hljs-string">'18'</span>,<br>    <span class="hljs-string">'job'</span>:<span class="hljs-string">'编程老师'</span><br>&#125;<br>dict1 = &#123;<br>    <span class="hljs-string">'name'</span>:<span class="hljs-string">'wsd'</span>,<br>    <span class="hljs-string">'age'</span>:<span class="hljs-string">'20'</span>,<br>    <span class="hljs-string">'job'</span>:<span class="hljs-string">'运维老师'</span><br>&#125;<br>print(str(dict)+str(dict1))<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-17"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'xgp'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-string">'18'</span>, <span class="hljs-string">'job'</span>: <span class="hljs-string">'编程老师'</span>&#125;&#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'wsd'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-string">'20'</span>, <span class="hljs-string">'job'</span>: <span class="hljs-string">'运维老师'</span>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="（2）两个字典存储到一个名为person的列表中">（2）两个字典存储到一个名为person的列表中</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">person = [dict,dict1]<br>print(person)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-18"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[&#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'xgp'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-string">'18'</span>, <span class="hljs-string">'job'</span>: <span class="hljs-string">'编程老师'</span>&#125;, &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'wsd'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-string">'20'</span>, <span class="hljs-string">'job'</span>: <span class="hljs-string">'运维老师'</span>&#125;]<br></code></pre></td></tr></table></figure></blockquote><h3 id="（3）遍历这个列表，将其中每个老师的信息都打印出来">（3）遍历这个列表，将其中每个老师的信息都打印出来</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> person[<span class="hljs-number">0</span>].items():<br>    print(key+<span class="hljs-string">":"</span>+value)<br>    <br>print(<span class="hljs-string">'\n'</span>)<br><span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> person[<span class="hljs-number">1</span>].items():<br>    print(key+<span class="hljs-string">":"</span>+value)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-19"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">name:xgp<br>age:<span class="hljs-number">18</span><br>job:编程老师<br><br><br>name:wsd<br>age:<span class="hljs-number">20</span><br>job:运维老师<br></code></pre></td></tr></table></figure></blockquote><h2 id="2、创建多个字典，每个字典都使用一种宠物的名字命名；在每个字典中，包含宠物的类型和主人的名字。将这些字典存储在一个名为pets的列表中，再遍历该列表，将宠物的信息都打印出来。">2、创建多个字典，每个字典都使用一种宠物的名字命名；在每个字典中，包含宠物的类型和主人的名字。将这些字典存储在一个名为pets的列表中，再遍历该列表，将宠物的信息都打印出来。</h2><h3 id="（1）创建多个字典，每个字典都使用一种宠物的名字命名；在每个字典中，包含宠物的类型和主人的名字。">（1）创建多个字典，每个字典都使用一种宠物的名字命名；在每个字典中，包含宠物的类型和主人的名字。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">dog = &#123;<br>    <span class="hljs-string">'dog'</span>:<span class="hljs-string">'柯基'</span>,<br>    <span class="hljs-string">'type'</span>:<span class="hljs-string">'Optimistic'</span>,<br>    <span class="hljs-string">'master'</span>:<span class="hljs-string">'xgp'</span>,<br>&#125;<br>cat = &#123;<br>    <span class="hljs-string">'cat'</span>:<span class="hljs-string">'加菲猫'</span>,<br>    <span class="hljs-string">'type'</span>:<span class="hljs-string">'lively'</span>,<br>    <span class="hljs-string">'master'</span>:<span class="hljs-string">'wsd'</span><br>&#125;<br><br>bird = &#123;<br>    <span class="hljs-string">'bird'</span>:<span class="hljs-string">'鹦鹉'</span>,<br>    <span class="hljs-string">'type'</span>:<span class="hljs-string">'free'</span>,<br>    <span class="hljs-string">'master'</span>:<span class="hljs-string">'dsw'</span><br>&#125;<br>print(dog)<br>print(cat)<br>print(bird)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-20"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">'dog'</span>: <span class="hljs-string">'柯基'</span>, <span class="hljs-string">'type'</span>: <span class="hljs-string">'Optimistic'</span>, <span class="hljs-string">'master'</span>: <span class="hljs-string">'xgp'</span>&#125;<br>&#123;<span class="hljs-string">'cat'</span>: <span class="hljs-string">'加菲猫'</span>, <span class="hljs-string">'type'</span>: <span class="hljs-string">'lively'</span>, <span class="hljs-string">'master'</span>: <span class="hljs-string">'wsd'</span>&#125;<br>&#123;<span class="hljs-string">'bird'</span>: <span class="hljs-string">'鹦鹉'</span>, <span class="hljs-string">'type'</span>: <span class="hljs-string">'free'</span>, <span class="hljs-string">'master'</span>: <span class="hljs-string">'dsw'</span>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="（2）将这些字典存储在一个名为pets的列表中">（2）将这些字典存储在一个名为pets的列表中</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pets = [dog,cat,bird]<br>print(pets)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-21"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[&#123;<span class="hljs-string">'dog'</span>: <span class="hljs-string">'柯基'</span>, <span class="hljs-string">'type'</span>: <span class="hljs-string">'Optimistic'</span>, <span class="hljs-string">'master'</span>: <span class="hljs-string">'xgp'</span>&#125;, &#123;<span class="hljs-string">'cat'</span>: <span class="hljs-string">'加菲猫'</span>, <span class="hljs-string">'type'</span>: <span class="hljs-string">'lively'</span>, <span class="hljs-string">'master'</span>: <span class="hljs-string">'wsd'</span>&#125;, &#123;<span class="hljs-string">'bird'</span>: <span class="hljs-string">'鹦鹉'</span>, <span class="hljs-string">'type'</span>: <span class="hljs-string">'free'</span>, <span class="hljs-string">'master'</span>: <span class="hljs-string">'dsw'</span>&#125;]<br></code></pre></td></tr></table></figure></blockquote><h3 id="（3）遍历该列表，将宠物的信息都打印出来">（3）遍历该列表，将宠物的信息都打印出来</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> pets[<span class="hljs-number">0</span>].items():<br>    print(key+<span class="hljs-string">":"</span>+value)<br>print(<span class="hljs-string">'\n'</span>)<br><span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> pets[<span class="hljs-number">1</span>].items():<br>    print(key+<span class="hljs-string">":"</span>+value)<br>print(<span class="hljs-string">'\n'</span>)<br><span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> pets[<span class="hljs-number">2</span>].items():<br>    print(key+<span class="hljs-string">":"</span>+value)<br></code></pre></td></tr></table></figure><h5 id="以上实例输出结果：-22"><strong>以上实例输出结果：</strong></h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">dog:柯基<br>type:Optimistic<br>master:xgp<br><br><br>cat:加菲猫<br>type:lively<br>master:wsd<br><br><br>bird:鹦鹉<br>type:free<br>master:dsw<br></code></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布尔表达式</title>
      <link href="/posts/9b8f.html"/>
      <url>/posts/9b8f.html</url>
      
        <content type="html"><![CDATA[<img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313205641716.png" alt="image-20200313205641716"><h1>一、if语句判断的定义</h1><ul><li><p>如果 <strong>条件满足</strong>，才能做某件事情，</p></li><li><p>如果 <strong>条件不满足</strong>，就做另外一件事情，或者什么也不做</p><p>正是因为有了判断，才使得程序世界丰富多彩，充满变化！</p><p><strong>判断语句</strong> 又被称为 “分支语句”，正是因为有了判断，才让程序有了很多的分支</p></li></ul><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313210905218.png" alt="image-20200313210905218"></p><p><strong>Python程序语言指定任何非0和非空（null）值为true，0 或者 null为false。</strong></p><p><strong>Python 编程中 if 语句用于控制程序的执行，基本形式为：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">if</span> 判断条件：<br>    执行语句……<br><span class="hljs-keyword">else</span>：<br>    执行语句……<br></code></pre></td></tr></table></figure><h2 id="例子：如果天气晴朗，我们去室外散步；否则，继续宅在家里">例子：如果天气晴朗，我们去室外散步；否则，继续宅在家里</h2><p><em><strong>我们要判断出语句中的关键字然后基于此编写脚本</strong></em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">"""</span><br><span class="hljs-string">如果 天气晴朗</span><br><span class="hljs-string">    去室外散步</span><br><span class="hljs-string">否则</span><br><span class="hljs-string">    继续宅在家里</span><br><span class="hljs-string">"""</span><br><br>state = <span class="hljs-string">'阴天'</span><br><span class="hljs-keyword">if</span> state == <span class="hljs-string">'晴朗'</span>:<br>    print(<span class="hljs-string">'室外散步！'</span>)<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'继续宅在家里。'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313211031395.png" alt="image-20200313211031395"></p><h1>二、if语句的比较运算符</h1><p><strong>以下假设变量a为10，变量b为20：</strong></p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">==</td><td style="text-align:left">等于 - 比较对象是否相等</td><td style="text-align:left">(a == b) 返回 False。</td></tr><tr><td style="text-align:left">!=</td><td style="text-align:left">不等于 - 比较两个对象是否不相等</td><td style="text-align:left">(a != b) 返回 true.</td></tr><tr><td style="text-align:left">&lt;&gt;</td><td style="text-align:left">不等于 - 比较两个对象是否不相等。<strong>python3 已废弃。</strong></td><td style="text-align:left">(a &lt;&gt; b) 返回 true。这个运算符类似 != 。</td></tr><tr><td style="text-align:left">&gt;</td><td style="text-align:left">大于 - 返回x是否大于y</td><td style="text-align:left">(a &gt; b) 返回 False。</td></tr><tr><td style="text-align:left">&lt;</td><td style="text-align:left">小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。</td><td style="text-align:left">(a &lt; b) 返回 true。</td></tr><tr><td style="text-align:left">&gt;=</td><td style="text-align:left">大于等于 - 返回x是否大于等于y。</td><td style="text-align:left">(a &gt;= b) 返回 False。</td></tr><tr><td style="text-align:left">&lt;=</td><td style="text-align:left">小于等于 - 返回x是否小于等于y。</td><td style="text-align:left">(a &lt;= b) 返回 true。</td></tr></tbody></table><h2 id="例子">例子</h2><h3 id="1、算数运算符在条件表达式中的应用：ATM-客服">1、算数运算符在条件表达式中的应用：ATM/客服</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">key = 1<br><span class="hljs-keyword">if</span> key == 1:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'存款'</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'取款'</span>)<br><span class="hljs-comment">#当数值等于1时存款，否则取款</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313211736827.png" alt="image-20200313211736827"></p><h3 id="2、-的使用">2、!=的使用</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span> key != 1:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'不存款'</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'存款'</span>)<br><span class="hljs-comment">#当数值不等于1时不存款，否则取款</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313211805795.png" alt="image-20200313211805795"></p><h3 id="3、-的使用">3、&gt;=的使用</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">age = 18<br><span class="hljs-keyword">if</span> age &gt;= 18:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'允许进入网吧'</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'未成年人禁止进入！'</span>)<br><span class="hljs-comment">#当年龄大于18可以进网吧，否则不行</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313212013393.png" alt="image-20200313212013393"></p><h1>三、if语句的逻辑运算符</h1><p><strong>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</strong></p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">逻辑表达式</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">and</td><td style="text-align:left">x and y</td><td style="text-align:left">布尔&quot;与&quot; - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td><td style="text-align:left">(a and b) 返回 20。</td></tr><tr><td style="text-align:left">or</td><td style="text-align:left">x or y</td><td style="text-align:left">布尔&quot;或&quot; - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。</td><td style="text-align:left">(a or b) 返回 10。</td></tr><tr><td style="text-align:left">not</td><td style="text-align:left">not x</td><td style="text-align:left">布尔&quot;非&quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td style="text-align:left">not(a and b) 返回 False</td></tr></tbody></table><p><strong>注意：if 有多个条件时可使用括号来区分判断的先后顺序，括号中的判断优先执行，此外 and 和 or 的优先级低于 &gt;（大于）、&lt;（小于）等判断符号，即大于和小于在没有括号的情况下会比与或要优先判断。</strong></p><h2 id="例子-2">例子</h2><p><strong>当年龄大于等于18岁，或有100块钱并且有身份证就可进入，否则不得进入</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 逻辑运算符：and/or</span><br>age = 16<br>money = 100<br>id_card = <span class="hljs-literal">True</span><br><br><span class="hljs-keyword">if</span> (age &gt;= 18 <span class="hljs-keyword">or</span> money &gt;= 100) <span class="hljs-keyword">and</span>  id_card:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'欢迎光临！'</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'抱歉'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313212712395.png" alt="image-20200313212712395"></p><h1>四、if语句的成员运算符</h1><p><strong>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</strong></p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">in</td><td style="text-align:left">如果在指定的序列中找到值返回 True，否则返回 False。</td><td style="text-align:left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td style="text-align:left">not in</td><td style="text-align:left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td style="text-align:left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table><h2 id="例子-3">例子</h2><h3 id="1、成员运算符：in-not-in">1、成员运算符：in/not in</h3><p><strong>当names列表中包含小写的Kety，就输出存在，否则不存在</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">names = [<span class="hljs-string">'Job'</span>,<span class="hljs-string">'Bili'</span>,<span class="hljs-string">'Laoyew'</span>,<span class="hljs-string">'kety'</span>]<br>name = <span class="hljs-string">'Kety'</span><br><br><span class="hljs-keyword">if</span> name.lower() <span class="hljs-keyword">in</span> names:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'存在'</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'不存在'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313212943693.png" alt="image-20200313212943693"></p><p><strong>当names列表中不包含大写的Kety，就输出不存在，否则存在</strong></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">name.upper</span>() <span class="hljs-variable"><span class="hljs-keyword">not</span></span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-variable">names</span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">'不存在'</span>)</span><br><span class="hljs-variable"><span class="hljs-keyword">else</span></span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">'存在'</span>)</span><br></code></pre></td></tr></table></figure><h1>五、小练习</h1><h2 id="1、检查是否相等">1、检查是否相等</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">num</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">num</span> == <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'ok'</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'no'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313213736773.png" alt="image-20200313213736773"></p><h2 id="2、检查是否不相等">2、检查是否不相等</h2><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">num1</span> = <span class="hljs-number">2</span><br><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">num1</span> <span class="hljs-variable">!</span>= <span class="hljs-number">1</span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">'no'</span>)</span><br><span class="hljs-variable"><span class="hljs-keyword">else</span></span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">'yes'</span>)</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313213747419.png" alt="image-20200313213747419"></p><h2 id="3、比较数字">3、比较数字</h2><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">num2</span> = <span class="hljs-number">3</span><br><span class="hljs-variable">num3</span> = <span class="hljs-number">4</span><br><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">num2</span> &lt;= <span class="hljs-variable">num3</span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">'ok'</span>)</span><br><span class="hljs-variable"><span class="hljs-keyword">else</span></span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">'no'</span>)</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313213759043.png" alt="image-20200313213759043"></p><h2 id="4、检查多个条件">4、检查多个条件</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">num4 = <span class="hljs-number">5</span><br>num5 = <span class="hljs-number">6</span><br>num6 = <span class="hljs-number">7</span><br><span class="hljs-keyword">if</span> (num4 &gt;= <span class="hljs-number">5</span> <span class="hljs-keyword">or</span> num5 &gt;= <span class="hljs-number">6</span>) <span class="hljs-keyword">and</span> num6 ==<span class="hljs-number">7</span>:<br>    print (<span class="hljs-string">'ok'</span>)<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'no'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313213802650.png" alt="image-20200313213802650"></p><h2 id="5、检查特定的值是否包含在列表中">5、检查特定的值是否包含在列表中</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">num7 = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>]<br>num8 = [<span class="hljs-string">'D'</span>]<br><span class="hljs-keyword">if</span> num8 <span class="hljs-keyword">in</span> num7:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'yes'</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'no'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313213813548.png" alt="image-20200313213813548"></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-function"><span class="hljs-title">str</span>(<span class="hljs-variable">num8</span>).lower() <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-variable">num7</span>:</span><br><span class="hljs-function">    <span class="hljs-title">print</span>(<span class="hljs-string">'yes'</span>)</span><br><span class="hljs-variable"><span class="hljs-keyword">else</span></span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">'no'</span>)</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313213815549.png" alt="image-20200313213815549"></p><h2 id="6、检查特定的值是否不包含在列表中">6、检查特定的值是否不包含在列表中</h2><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><br><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-function"><span class="hljs-title">str</span>(<span class="hljs-variable">num8</span>).upper() <span class="hljs-variable"><span class="hljs-keyword">not</span></span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-variable">num7</span>:</span><br><span class="hljs-function">    <span class="hljs-title">print</span>(<span class="hljs-string">'no'</span>)</span><br><span class="hljs-variable"><span class="hljs-keyword">else</span></span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">'yes'</span>)</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313213822644.png" alt="image-20200313213822644"></p><h1>六、if语句结构</h1><h2 id="1、简单的if语句">1、简单的if语句</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 简单的if</span><br>age = 0<br><span class="hljs-keyword">if</span> age ==0:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'婴儿'</span>)<br><span class="hljs-builtin-name">print</span>()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313214046741.png" alt="image-20200313214046741"></p><blockquote><p><strong>注意：Python 区分语句块采用的是缩进规则。具有相同缩进的代码被视是同一结构的代码块，上面的2，3行 print 语句就构成一个代码块（ 但不包括第6行的 print 语句），他们都属于 if 下的语句块。</strong><br><strong>如果 age大于等于18，就会执行第 2 和 3 行的 if 语句块。</strong><br><strong>缩进要严格按照 Python 的习惯写法：<code>4个空格，或者使用 Tab，不要混合 Tab 和空格</code>，否则很容易造成因为缩进而引起的语法错误。</strong></p></blockquote><h2 id="（一）if…else…-语句">（一）if…else… 语句</h2><p><strong>if…else… 语句，当 if 的条件为 True 时执行 if 下的语句块，否则执行 else 下语句块。</strong></p><p><strong>if…else… 语句格式如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">if &lt;条件&gt;:<br>      【if 的语句块】<br>else:<br>      【else 的语句块】<br></code></pre></td></tr></table></figure><p><strong>释：条件为 True 时执行【if的语句块】，否则执行【else的语句块】</strong></p><p><em><strong>注意：if 和 else 语句以及各自的缩进部分共同是一个 完整的代码块</strong></em></p><h3 id="例子-4">例子</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># if-else</span><br><br>age = 3<br><span class="hljs-keyword">if</span> age &gt;= 2 <span class="hljs-keyword">and</span> age &lt;= 4:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'蹒跚学步'</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'婴儿'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313214429259.png" alt="image-20200313214429259"></p><h2 id="（二）if…elif…else…-语句">（二）if…elif…else… 语句</h2><ul><li><strong>在开发中，使用 if 可以 <code>判断条件</code>，使用 else 可以处理 <code>条件不成立</code> 的情况</strong></li><li><strong>如果希望 <code>再增加一些条件，条件不同，需要执行的代码也不同</code> 时，就可以使用 elif</strong></li><li><strong>语法格式如下：</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> 条件<span class="hljs-number">1</span>:<br>    条件<span class="hljs-number">1</span>满足执行的代码<br>    ……<br><span class="hljs-keyword">elif</span> 条件<span class="hljs-number">2</span>:<br>    条件<span class="hljs-number">2</span>满足时，执行的代码<br>    ……<br><span class="hljs-keyword">elif</span> 条件<span class="hljs-number">3</span>:<br>    条件<span class="hljs-number">3</span>满足时，执行的代码<br>    ……<br><span class="hljs-keyword">else</span>:<br>    以上条件都不满足时，执行的代码<br>    ……<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：elif 和 else 都必须和 if 联合使用，而不能单独使用</strong><br><strong>可以将 if、 elif 和 else 以及各自缩进的代码，看成一个 完整的代码块</strong></p></blockquote><h3 id="例子：">例子：</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># if-elif-else</span><br>age = 3<br><span class="hljs-keyword">if</span> age ==0:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'婴儿'</span>)<br>elif age &gt;= 2 <span class="hljs-keyword">and</span> age &lt;= 4:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'蹒跚学步'</span>)<br>elif age &gt; 4 <span class="hljs-keyword">and</span> age &lt;=5:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'上幼儿园'</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'其他'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313214721467.png" alt="image-20200313214721467"></p><h2 id="（三）if-的嵌套">（三）if 的嵌套</h2><p><code>**elif</code> 的应用场景是：<code>同时</code> 判断 <code>多个条件</code>，所有的条件是 <code>平级</code> 的**</p><ul><li><strong>在开发中，使用 if 进行条件判断，如果希望 <code>在条件成立的执行语句中</code> 再 <code>增加条件判断</code>，就可以使用 <code>if 的嵌套</code></strong></li><li><strong><code>if 的嵌套</code> 的应用场景就是：在<code>之前条件满足的前提下</code>，再增加额外的判断</strong></li><li><strong><code>if 的嵌套</code> 的语法格式，除了<code>缩进</code>之外 和之前的没有区别</strong></li></ul><p><strong>语法格式如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> 条件 <span class="hljs-number">1</span>:<br>    条件 <span class="hljs-number">1</span> 满足执行的代码<br>    ……<br><br>    <span class="hljs-keyword">if</span> 条件 <span class="hljs-number">1</span> 基础上的条件 <span class="hljs-number">2</span>:<br>        条件 <span class="hljs-number">2</span> 满足时，执行的代码<br>        ……    <br><br>    <span class="hljs-comment"># 条件 2 不满足的处理</span><br>    <span class="hljs-keyword">else</span>:<br>        条件 <span class="hljs-number">2</span> 不满足时，执行的代码<br><br><span class="hljs-comment"># 条件 1 不满足的处理</span><br><span class="hljs-keyword">else</span>:<br>    条件<span class="hljs-number">1</span> 不满足时，执行的代码<br>    ……<br></code></pre></td></tr></table></figure><h3 id="例子-5">例子</h3><h4 id="1、当百米赛跑时间小于等于10秒时，男女分组进入决赛"><strong>1、当百米赛跑时间小于等于10秒时，男女分组进入决赛</strong></h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">second = 6<br>gender = <span class="hljs-string">'男'</span><br><br><span class="hljs-keyword">if</span> second &lt;= 10:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'进入决赛'</span>)   <br>    <br>    <span class="hljs-keyword">if</span> gender == <span class="hljs-string">'男'</span>:<br>        <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'进入男子组'</span>)<br>    elif gender == <span class="hljs-string">'女'</span>:<br>        <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'进入女子组'</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'重在参与，杭氧体育精神'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313215230011.png" alt="image-20200313215230011"></p><h4 id="2、if-的嵌套-演练-——-火车站安检"><strong>2、if 的嵌套 演练 —— 火车站安检</strong></h4><p><strong>需求</strong></p><ul><li><strong>定义布尔型变量 has_ticket 表示是否有车票</strong></li><li><strong>定义整型变量 knife_length 表示刀的长度，单位：厘米</strong></li><li><strong>首先检查是否有车票，如果有，才允许进行 安检</strong></li><li><strong>安检时，需要检查刀的长度，判断是否超过 20 厘米</strong><br><strong>如果超过 20 厘米，提示刀的长度，不允许上车</strong><br><strong>如果不超过 20 厘米，安检通过</strong></li><li><strong>如果没有车票，不允许进门</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义布尔型变量 has_ticket 表示是否有车票</span><br>has_ticket = <span class="hljs-literal">True</span><br><br><span class="hljs-comment"># 定义整数型变量 knife_length 表示刀的长度，单位：厘米</span><br>knife_length = <span class="hljs-number">20</span><br><br><span class="hljs-comment"># 首先检查是否有车票，如果有，才允许进行 安检</span><br><span class="hljs-keyword">if</span> has_ticket:<br>    print(<span class="hljs-string">"有车票，可以开始安检..."</span>)<br><br>    <span class="hljs-comment"># 安检时，需要检查刀的长度，判断是否超过 20 厘米</span><br>    <span class="hljs-comment"># 如果超过 20 厘米，提示刀的长度，不允许上车</span><br>    <span class="hljs-keyword">if</span> knife_length &gt;= <span class="hljs-number">20</span>:<br>        print(<span class="hljs-string">"不允许携带 %d 厘米长的刀上车"</span> % knife_length)<br>    <span class="hljs-comment"># 如果不超过 20 厘米，安检通过</span><br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">"安检通过，祝您旅途愉快……"</span>)<br><br><span class="hljs-comment"># 如果没有车票，不允许进门</span><br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">"大哥，您要先买票啊"</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313215325981.png" alt="image-20200313215325981"></p><h1>六、小练习（2）</h1><h2 id="1、-求100以内数字的偶数之和与奇数之和">1、 求100以内数字的偶数之和与奇数之和</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lisp">j = list(<span class="hljs-name">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">101</span>,<span class="hljs-number">2</span>))<br>print(<span class="hljs-name">sum</span>(<span class="hljs-name">j</span>))<br>print(<span class="hljs-name">sum</span>(<span class="hljs-name">range</span>(<span class="hljs-number">2</span>,<span class="hljs-number">101</span>,<span class="hljs-number">2</span>)))<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313215602676.png" alt="image-20200313215602676"></p><h2 id="2、输出100以内7的倍数的数字">2、输出100以内7的倍数的数字</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> in range(<span class="hljs-number">1</span>,<span class="hljs-number">101</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">i</span><span class="hljs-comment">%7 == 0:</span><br>        print(<span class="hljs-built_in">i</span>,<span class="hljs-keyword">end</span>=<span class="hljs-string">' '</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313215618084.png" alt="image-20200313215618084"></p><h2 id="3、打印直角三角形，奇数用-号代替，偶数用-号代替">3、打印直角三角形，奇数用*号代替，偶数用#号代替</h2><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sas">xgp = <span class="hljs-meta">list</span><span class="hljs-meta">(range(</span>1,10,2))<br>wsd = <span class="hljs-meta">list</span><span class="hljs-meta">(range(</span>2,10,2))<br>for i <span class="hljs-meta">in</span><span class="hljs-meta"> range(</span>1,10):<br>    for j <span class="hljs-meta">in</span><span class="hljs-meta"> range(</span>i+1):<br>        <span class="hljs-meta">if</span> j <span class="hljs-meta">in</span> xgp:<br>            p<span class="hljs-meta">rint(</span><span class="hljs-string">"*"</span>,<span class="hljs-meta">end</span>=<span class="hljs-string">''</span>)<br>        elif j <span class="hljs-meta">in</span> wsd:<br>            p<span class="hljs-meta">rint(</span><span class="hljs-string">"#"</span>,<span class="hljs-meta">end</span>=<span class="hljs-string">''</span>)<br>    p<span class="hljs-meta">rint(</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313215646718.png" alt="image-20200313215646718"></p><h2 id="4、">4、</h2><h3 id="查看fruits列表中是否有apper"><strong>查看fruits列表中是否有apper</strong></h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 定义列表</span><br>fruits = [<span class="hljs-string">'apper'</span>,<span class="hljs-string">'banana'</span>,<span class="hljs-string">'pear'</span>,<span class="hljs-string">'orange'</span>]<br>fruit = <span class="hljs-string">'apper'</span><br><span class="hljs-keyword">if</span> fruit <span class="hljs-keyword">in</span> fruits:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'存在'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313215932702.png" alt="image-20200313215932702"></p><h3 id="if嵌套">if嵌套</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> fruits:<br>    <span class="hljs-keyword">if</span> f == <span class="hljs-string">'pear'</span>:<br>        <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'做梨罐头'</span>) <br>    elif f == <span class="hljs-string">'orange'</span>:<br>        <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'做橘子罐头'</span>)       <br>    elif f == <span class="hljs-string">'apple'</span>:<br>        <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'做苹果罐头'</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'做沙拉'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313220023846.png" alt="image-20200313220023846"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#fruits = []</span><br>fruits = [<span class="hljs-string">'apple'</span>,<span class="hljs-string">'banana'</span>,<span class="hljs-string">'pear'</span>,<span class="hljs-string">'orange'</span>]<br><span class="hljs-builtin-name">print</span>(fruits)<br><br><span class="hljs-keyword">if</span> len(fruits) == 0:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'没有水果'</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">'开始做水果罐头了'</span>)<br>    <span class="hljs-keyword">for</span> fruit <span class="hljs-keyword">in</span> fruits:<br>        <span class="hljs-builtin-name">print</span>(fruit,<span class="hljs-attribute">end</span>=<span class="hljs-string">" "</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200313220113550.png" alt="image-20200313220113550"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 列表</title>
      <link href="/posts/46cd.html"/>
      <url>/posts/46cd.html</url>
      
        <content type="html"><![CDATA[<h1>Python 列表(List)</h1><p><strong>Python的基本数据类型有整数，浮点数，布尔，字符串，它们是最基本的数据。在实际编程中，我们要经常组织由很多基本数据组成的集合，这些集合的不同组织方式就是：数据结构，今天讲的是数据结构中的Python list(列表)。数据结构就是一些数据组合得到的“复合”数据类型。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311130518472.png" alt="image-20200311130518472"></p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312123334557.png" alt="image-20200312123334557" style="zoom:96%;"><h2 id="Python内置的数据结构有：">Python内置的数据结构有：</h2><ul><li><strong>列表(list)</strong></li><li><strong>元组(tuple)</strong></li><li><strong>字典(dict)</strong></li><li><strong>集合(set)</strong></li></ul><p><strong>在Python语言中，以上4种数据结构和基础数据类型（整数、浮点数等）统称为“内置类型”（Built-in Types）。</strong></p><h1>一、什么是列表</h1><p><strong>序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。</strong></p><p><strong>Python有6个序列的内置类型，但最常见的是列表和元组。</strong></p><p><strong>序列都可以进行的操作包括索引，切片，加，乘，检查成员。</strong></p><p><strong>此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。</strong></p><p><strong>列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。</strong></p><p><strong>列表的数据项不需要具有相同的类型</strong></p><h2 id="（1）创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：">（1）创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 定义列表</span><br>name = [<span class="hljs-string">'Tom'</span>,<span class="hljs-string">'Jack'</span>,<span class="hljs-string">'John'</span>]<br>pet = [<span class="hljs-string">'cat'</span>,<span class="hljs-string">'dog'</span>,<span class="hljs-string">'bird'</span>]<br><br><span class="hljs-comment"># 打印列表</span><br><span class="hljs-builtin-name">print</span>(name)<br><span class="hljs-builtin-name">print</span>(pet)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311132322792.png" alt="image-20200311132322792"></p><h2 id="（2）用索引访问列表元素">（2）用索引访问列表元素</h2><p><strong>使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符，如下所示：</strong></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 通过索引读取列表中的元素，索引从0开始，-1代表最后一个元素</span><br><br><span class="hljs-keyword">print</span>(name[<span class="hljs-number">0</span>])     <span class="hljs-meta">#查看列表中第一个</span><br><span class="hljs-keyword">print</span>(pet[<span class="hljs-number">2</span>])      <span class="hljs-meta">#查看列表中第二个</span><br><span class="hljs-keyword">print</span>(name[<span class="hljs-number">-1</span>])    <span class="hljs-meta">#查看列表中最后一个</span><br><span class="hljs-keyword">print</span>(pet[<span class="hljs-number">-2</span>])    <span class="hljs-meta">#查看列表中倒数第二个</span><br><span class="hljs-keyword">print</span> (name[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>])  <span class="hljs-meta">#查看索引2之前的元素</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311132920781.png" alt="image-20200311132920781"></p><h1>二、基本操作</h1><h3 id="Python包含以下方法">Python包含以下方法:</h3><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-append.html" target="_blank" rel="noopener">list.append(obj)</a> 在列表末尾添加新的对象</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-count.html" target="_blank" rel="noopener">list.count(obj)</a> 统计某个元素在列表中出现的次数</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-extend.html" target="_blank" rel="noopener">list.extend(seq)</a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-index.html" target="_blank" rel="noopener">list.index(obj)</a> 从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-insert.html" target="_blank" rel="noopener">list.insert(index, obj)</a> 将对象插入列表</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">[list.pop(<a href="https://www.runoob.com/python/att-list-pop.html" target="_blank" rel="noopener">index=-1])</a> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-remove.html" target="_blank" rel="noopener">list.remove(obj)</a> 移除列表中某个值的第一个匹配项</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-reverse.html" target="_blank" rel="noopener">list.reverse()</a> 反向列表中元素</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-sort.html" target="_blank" rel="noopener">list.sort(cmp=None, key=None, reverse=False)</a> 对原列表进行排序</td></tr></tbody></table><h2 id="1、通过素引获取元素-进行修改">1、通过素引获取元素,进行修改</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment">#修改列表的元素</span><br><span class="hljs-built_in">name</span>[<span class="hljs-number">1</span>] = 'Sean'   <span class="hljs-comment">#修改name列表，索引1的内容为Sean</span><br>print(<span class="hljs-built_in">name</span>)   <span class="hljs-comment">#打印列表</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311134602310.png" alt="image-20200311134602310"></p><h2 id="2、-向列表里面加元素">2、 向列表里面加元素</h2><p><strong>向python列表里面添加元素主要有三种方法：</strong></p><h3 id="（1）append（）"><strong>（1）append（）</strong></h3><p><strong>append()对于列表的操作主要实现的是在特定的列表最后添加一个元素，并且只能一次添加一个元素，并且只能在列表最后；</strong></p><p><code>name.append(元素A)</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 在列表末尾添加新元素</span><br>name.append(<span class="hljs-string">'Bob'</span>)<br><span class="hljs-builtin-name">print</span>(name)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311144920500.png" alt="image-20200311144920500"></p><h3 id="（2）extend（）"><strong>（2）extend（）</strong></h3><p><strong>extend（）对于列表的操作主要实现的是对于特定列表的扩展和增长，可以一次添加多个元素，不过也只能添加在列表的最后；</strong></p><p>​    <code>name.extend([元素A，元素B，……])</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">name.extend([<span class="hljs-string">'Xgp'</span>,<span class="hljs-string">'Wsd'</span>])<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(name)</span></span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311144941106.png" alt="image-20200311144941106"></p><h3 id="（3）insert（）"><strong>（3）insert（）</strong></h3><p><strong>insert（）对于列表的操作主要是在列表的特定位置添加想要添加的特定元素，比较常用，这里的特定位置是指元素所在列表中的位置索引号，需要注意的是这里的索引号都是从0开始的，不是从1开始的，这个大家需要特别注意。</strong></p><p>​    <code>pet.insert(A,元素B)：表示在列表m里面的第A+1处加入元素B</code></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 在列表指定位置添加新元素</span><br><span class="hljs-keyword">print</span>(pet)<br>pet.insert(<span class="hljs-number">0</span>,'penguin')   <span class="hljs-meta">#在列表最前面添加数据</span><br><span class="hljs-keyword">print</span>(pet)<br>pet.insert(<span class="hljs-number">-2</span>,'pig')      <span class="hljs-meta">#在列表倒数第三个添加数据</span><br><span class="hljs-keyword">print</span>(pet)<br></code></pre></td></tr></table></figure><p><img src="https://s1.51cto.com/images/blog/202003/11/ea1415a888f8e57c43526808b7a17d81.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt></p><h2 id="3、删减列表中的一些元素；">3、删减列表中的一些元素；</h2><p><strong>与之前python列表的添加元素相对，删减列表里面的一些元素也有三种方法：</strong></p><h3 id="（1）del-pet-n">（1）del pet[n]</h3><p><strong>它的作用是删除掉列表里面的索引号位置为n 的元素，这里需要注意的是del是一种操作语句。</strong></p><p><code>del m[n]</code></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 根据索引从列表中删除元素</span><br><span class="hljs-keyword">print</span>(pet)<br>del pet[<span class="hljs-number">0</span>]      <span class="hljs-meta">#删除开头的元素</span><br><span class="hljs-keyword">print</span> (pet)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311140935181.png" alt="image-20200311140935181"></p><h3 id="（2）pet-pop（）">（2）pet.pop（）</h3><p><strong>它的作用是将列表m的最后一个元素返回，并且在此基础上进行删除掉</strong></p><p><code>Temp=pet.pop()  %这里temp就会直接等于吗列表里最后一个元素。</code></p><p><code>Print(pet)    %这里再次输出m的时候已经是删掉最后一个元素的m列表</code></p><h4 id="pop-弹出列表末尾的元素">pop():弹出列表末尾的元素</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">print</span>(pet)<br><span class="hljs-attribute">new_pet</span>=pet.pop()<br><span class="hljs-builtin-name">print</span>(new_pet)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311141017663.png" alt="image-20200311141017663"></p><h4 id="弹出指定位置的元素">弹出指定位置的元素</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 弹出指定位置的元素</span><br><span class="hljs-keyword">print</span>(pet)<br>pet.pop(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">print</span>(pet)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311141309977.png" alt="image-20200311141309977"></p><h3 id="（3）pet-remove">（3）pet.remove()</h3><p><strong>m.remove的作用是移除掉列表m里面的特定元素；</strong></p><p><code>m.remove(元素A)</code></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 根据元素的值进行删除：remove()</span><br><span class="hljs-keyword">print</span>(pet)            <span class="hljs-meta">#查看源列表</span><br>pet.remove('cat')     <span class="hljs-meta">#删除cat</span><br><span class="hljs-keyword">print</span>(pet)            <span class="hljs-meta">#打印列表</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311141519431.png" alt="image-20200311141519431"></p><h1>三、排序</h1><h3 id="（1）永久排序（正索引，从头到尾）">（1）永久排序（正索引，从头到尾）</h3><p><strong>sort()排序方法：此<a href="https://www.iplaypy.com/jichu/function.html" target="_blank" rel="noopener">函数</a>方法对列表内容进行正向排序，排序后的新列表会覆盖原列表（id不变），也就是sort排序方法是直接修改原列表list排序方法。</strong></p><h3 id="（2）临时排序（正索引，从头到尾）">（2）临时排序（正索引，从头到尾）</h3><p><strong>sorted()方法：即可以保留原列表，又能得到已经排序好的列表</strong></p><h3 id="（3）倒序（从头到尾从尾到头）">（3）倒序（从头到尾从尾到头）</h3><p><strong>reverse列表反转排序：是把原列表中的元素顺序从左至右的重新存放，而不会对列表中的参数进行排序整理。如果需要对列表中的参数进行整理，就需要用到列表的另一种排序方式sort正序排序。</strong></p><h3 id="（4）列表长度">（4）列表长度</h3><p><strong>len() 方法返回列表元素个数。</strong></p><h3 id="操作">操作</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 定义列表：汽车的品牌</span><br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">'原始排序：'</span>)<br>brand = [<span class="hljs-string">'audi'</span>,<span class="hljs-string">'bmw'</span>,<span class="hljs-string">'toyota'</span>,<span class="hljs-string">'luhu'</span>]<br><span class="hljs-builtin-name">print</span>(brand)<br><br><span class="hljs-comment">#临时排序</span><br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">'临时排序：'</span>)<br><span class="hljs-builtin-name">print</span>(sorted(brand))<br><br><span class="hljs-comment"># 永久排序: sort()</span><br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">'正序排序：'</span>)<br>brand.sort()<br><span class="hljs-builtin-name">print</span>(brand)<br><br><span class="hljs-comment"># 倒序排序</span><br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">'倒序排序:'</span>)<br>brand.sort(<span class="hljs-attribute">reverse</span>=<span class="hljs-literal">True</span>)<br><span class="hljs-builtin-name">print</span>(brand)<br><br><span class="hljs-comment"># 获取列表长度</span><br><span class="hljs-builtin-name">print</span>(<span class="hljs-string">'列表长度:'</span>)<br><span class="hljs-builtin-name">print</span>(len(brand))<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311142805057.png" alt="image-20200311142805057"></p><h1>四、小练习</h1><h2 id="列表练习（一）">列表练习（一）</h2><ul><li><strong>定义一个列表，存储5个科目名称</strong></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">kemu = [<span class="hljs-string">'语文'</span>,<span class="hljs-string">'数学'</span>,<span class="hljs-string">'英语'</span>,<span class="hljs-string">'地理'</span>,<span class="hljs-string">'生物'</span>]<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(kemu)</span></span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311143921006.png" alt="image-20200311143921006"></p><ul><li><strong>新增科目（末尾新增）</strong></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">kemu.append(<span class="hljs-string">'化学'</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(kemu)</span></span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311144040606.png" alt="image-20200311144040606"></p><ul><li><strong>修改科目</strong></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">kemu[<span class="hljs-number">2</span>] = <span class="hljs-string">'计算机'</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(kemu)</span></span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311144102895.png" alt="image-20200311144102895"></p><ul><li><strong>删除科目，并且在打印科目列表的时候，能够显示删除了哪个科目</strong></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">print</span>(kemu)<br><span class="hljs-attribute">new_kemu</span>=kemu.pop(3)<br><span class="hljs-builtin-name">print</span>(new_kemu)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311144123294.png" alt="image-20200311144123294"></p><ul><li><strong>删除第2个科目</strong></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">kemu.pop(<span class="hljs-number">1</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(kemu)</span></span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311144159383.png" alt="image-20200311144159383"></p><ul><li><strong>指定位置新增</strong></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">kemu.insert(<span class="hljs-number">0</span>,<span class="hljs-string">'科学'</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(kemu)</span></span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311144249258.png" alt="image-20200311144249258"></p><ul><li><strong>删除指定名称的科目</strong></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">kemu.<span class="hljs-builtin-name">remove</span>(<span class="hljs-string">'生物'</span>)<br><span class="hljs-builtin-name">print</span>(kemu)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311144325974.png" alt="image-20200311144325974"></p><h2 id="列表练习（二）">列表练习（二）</h2><ul><li><strong>将5个城市的名称存储到列表中，并且保证名称不是按照字母顺序排列的</strong></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">city = [<span class="hljs-string">'北京'</span>,<span class="hljs-string">'上海'</span>,<span class="hljs-string">'广州'</span>,<span class="hljs-string">'深圳'</span>,<span class="hljs-string">'山西'</span>]<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(city)</span></span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311143436152.png" alt="image-20200311143436152"></p><ul><li><strong>打印出原始的城市列表信息</strong></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(city)</span></span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311143508581.png" alt="image-20200311143508581"></p><ul><li><strong>使用sorted()方法按字母顺序打印城市列表，但是不要修改列表元素的顺序</strong></li></ul><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">print(<span class="hljs-name">sorted</span>(<span class="hljs-name">city</span>))<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311143521167.png" alt="image-20200311143521167"></p><ul><li><strong>打印该列表，确认城市名称排列顺序没有被修改</strong></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(city)</span></span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311143538974.png" alt="image-20200311143538974"></p><ul><li><strong>使用sort()方法排列城市名称，确保永久性修改排列顺序</strong></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">city.sort()<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(city)</span></span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200311143607884.png" alt="image-20200311143607884"></p><h1>五、进阶操作</h1><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312122916830.png" alt="image-20200312122916830"></p><h1>（一）遍历列表</h1><h2 id="1、for循环">1、for循环</h2><p><strong>Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。</strong></p><p><strong>语法：</strong></p><p><strong>for循环的语法格式如下：</strong></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">for</span> <span class="hljs-variable">iterating_var</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-variable">sequence</span>:<br>   <span class="hljs-function"><span class="hljs-title">statements</span>(<span class="hljs-variable">s</span>)</span><br></code></pre></td></tr></table></figure><p><strong>流程图：</strong></p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312142816044.png" alt="image-20200312142816044" style="zoom:60%;"><h3 id="（1）简单的for循环">（1）简单的for循环</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog"># 定义一个列表<br>names = [<span class="hljs-string">'张三'</span>,<span class="hljs-string">'李四'</span>,<span class="hljs-string">'王五'</span>,<span class="hljs-string">'赵六'</span>,<span class="hljs-string">'田七'</span>]<br>zhang_san = names[<span class="hljs-number">0</span>]<br>li_si = names[<span class="hljs-number">1</span>]<br>wang_wu = names[<span class="hljs-number">2</span>]<br>print(zhang_san+<span class="hljs-string">" "</span>+li_si+<span class="hljs-string">" "</span>+wang_wu)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312141711860.png" alt="image-20200312141711860"></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># for循环</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">name</span> <span class="hljs-keyword">in</span> names:<br>    print(<span class="hljs-built_in">name</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312141730296.png" alt="image-20200312141730296"></p><p><strong>注意:</strong> <code>name</code> 这个变量是在 <code>for 循环</code>中定义的，意思是，依次取出 <code>names</code>中的每一个元素，并把元素赋值给 <code>name</code>，然后执行for循环体。</p><h3 id="（2）多重for循环">（2）多重for循环</h3><h4 id="1-直角三角形">&lt;1&gt;直角三角形</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 打印直角三角形</span><br><br><span class="hljs-comment"># 外层循环控制行数</span><br><span class="hljs-comment"># 内层循环控制列数</span><br><span class="hljs-comment"># 外层循环执行1次，内层循环执行1轮</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(1,10):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i):<br>        <span class="hljs-builtin-name">print</span>(j+1,<span class="hljs-attribute">end</span>=<span class="hljs-string">''</span>)<br>    <span class="hljs-builtin-name">print</span>()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312142032018.png" alt="image-20200312142032018"></p><h4 id="2-九九乘法表">&lt;2&gt;九九乘法表</h4><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-meta"># 打印九九乘法表</span><br><span class="hljs-keyword">for</span> i in range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):<br>    <span class="hljs-keyword">for</span> j in range(i):<br>        <span class="hljs-keyword">print</span>(<span class="hljs-keyword">str</span>((j+<span class="hljs-number">1</span>))+<span class="hljs-string">"x"</span>+<span class="hljs-keyword">str</span>(i)+<span class="hljs-string">"="</span>+<span class="hljs-keyword">str</span>(i*(j+<span class="hljs-number">1</span>)),<span class="hljs-keyword">end</span>=<span class="hljs-string">' '</span>)<br>    <span class="hljs-keyword">print</span>()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312142516498.png" alt="image-20200312142516498"></p><h1>（二）创建数值类表</h1><h2 id="1、range-的使用">1、range() 的使用</h2><p><strong>range ( ) 为 Python 的自有类，range() 带有内置的迭代方法iter() 和 next() ，它是一个可迭代对象，我们可以通过 for 访问 range() 创建的迭代器。</strong></p><h3 id="range-类初始化参数说明：">range 类初始化参数说明：</h3><ul><li><strong>range(stop)</strong> 从0开始到stop结束（不包含 stop）返回一个产生整数序列的迭代对象</li><li><strong>range(start, stop[, step])</strong> 从 start 开始到 stop 结束（不包含 stop）返回一个整数序列的迭代对象, step 为他的步长</li></ul><h3 id="（1）-循环输出1-10之间的数字">（1） 循环输出1-10之间的数字</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-keyword">for</span> <span class="hljs-built_in">num</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">11</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">num</span>,end=<span class="hljs-string">" "</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312144200584.png" alt="image-20200312144200584"></p><h3 id="（2）输出1-10之间的偶数">（2）输出1-10之间的偶数</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-keyword">for</span> <span class="hljs-built_in">num</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-number">11</span>,<span class="hljs-number">2</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">num</span>,end=<span class="hljs-string">" "</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312144233071.png" alt="image-20200312144233071"></p><h3 id="（3）-输出1-10之间的奇数">（3） 输出1-10之间的奇数</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-keyword">for</span> <span class="hljs-built_in">num</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">2</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">num</span>,end=<span class="hljs-string">" "</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312144326183.png" alt="image-20200312144326183"></p><h3 id="（4）输出1-10之间的奇数的平方">（4）输出1-10之间的奇数的平方</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> range(1,11,2):<br>    <span class="hljs-builtin-name">print</span>(num*<span class="hljs-number">*2</span>,<span class="hljs-attribute">end</span>=<span class="hljs-string">" "</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312144351651.png" alt="image-20200312144351651"></p><h3 id="（5）创建一个数字列表">（5）创建一个数字列表</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lisp">numbers = list(<span class="hljs-name">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>))<br>print(<span class="hljs-name">numbers</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312144432935.png" alt="image-20200312144432935"></p><h2 id="2、数字列表的简单统计（计算）">2、数字列表的简单统计（计算）</h2><h4 id="Python包含以下函数">Python包含以下函数:</h4><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">函数</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-cmp.html" target="_blank" rel="noopener">cmp(list1, list2)</a> 比较两个列表的元素</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-len.html" target="_blank" rel="noopener">len(list)</a> 列表元素个数</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-max.html" target="_blank" rel="noopener">max(list)</a> 返回列表元素最大值</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-min.html" target="_blank" rel="noopener">min(list)</a> 返回列表元素最小值</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="https://www.runoob.com/python/att-list-list.html" target="_blank" rel="noopener">list(seq)</a> 将元组转换为列表</td></tr></tbody></table><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 数字列表的最大值、最小值、总和</span><br><span class="hljs-keyword">print</span>(<span class="hljs-built_in">max</span>(numbers))    <span class="hljs-meta">#最大值</span><br><span class="hljs-keyword">print</span>(<span class="hljs-built_in">min</span>(numbers))    <span class="hljs-meta">#最小值</span><br><span class="hljs-keyword">print</span>(<span class="hljs-built_in">sum</span>(numbers))    <span class="hljs-meta">#总值</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312144616537.png" alt="image-20200312144616537"></p><h1>（三）Python列表切片</h1><p><strong>切片是Python序列的重要操作之一，适用于列表、元组、字符串、range对象等类型。切片使用2个冒号分隔的3个数字来完成：第一个数字表示切片的开始位置，默认为0，第二个数字表是切片的截止（但不包含）位置（默认为列表长度），第三个数字表示切片的步长(默认为1)，当步长省略时，顺便可以省略最后一个冒号。</strong></p><p><strong>可以使用切片来截取列表中的任何部分，得到一个新列表，也可以通过切片来修改和删除列表中部分元素，甚至可以通过切片操作为列表对象增加元素。与使用下标访问列表元素不同，切片操作不会因为下标越界而抛出异常，而是简单地在列表尾部截断或者返回一个空列表，代码具有更强的健壮性。</strong># 切片</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 创建一个列表</span><br>pets = [<span class="hljs-string">'cat'</span>,<span class="hljs-string">'dog'</span>,<span class="hljs-string">'duck'</span>,<span class="hljs-string">'pig'</span>]<br><span class="hljs-builtin-name">print</span>(pets)<br></code></pre></td></tr></table></figure><h3 id="1、读取列表中2和3的元素">1、读取列表中2和3的元素</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">pets[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312145812903.png" alt="image-20200312145812903"></p><h3 id="2、读取列表中1到4的元素">2、读取列表中1到4的元素</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">pets[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312145831441.png" alt="image-20200312145831441"></p><h3 id="3、读取列表中的第一个元素">3、读取列表中的第一个元素</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">pets[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312145843383.png" alt="image-20200312145843383"></p><h3 id="4、读取列表中的最后一个元素">4、读取列表中的最后一个元素</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">pets[<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312145903360.png" alt="image-20200312145903360"></p><h3 id="5、读取列表中，从第二个元素开始的所有元素">5、读取列表中，从第二个元素开始的所有元素</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">pets[<span class="hljs-number">1</span>:]<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312145917256.png" alt="image-20200312145917256"></p><h3 id="6、读取列表中，从第一个元素开始的所有元素">6、读取列表中，从第一个元素开始的所有元素</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">pets[<span class="hljs-number">0</span>:]<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312145931559.png" alt="image-20200312145931559"></p><h3 id="7、读取列表中，从倒数第三个元素开始的所有元素">7、读取列表中，从倒数第三个元素开始的所有元素</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">pets[<span class="hljs-number">-3</span>:]<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312145944314.png" alt="image-20200312145944314"></p><h3 id="8、循环输出列表中，从倒数第三个元素开始的所有元素">8、循环输出列表中，从倒数第三个元素开始的所有元素</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> pet <span class="hljs-keyword">in</span> pets[-3:]:<br>    <span class="hljs-builtin-name">print</span>(pet,<span class="hljs-attribute">end</span>=<span class="hljs-string">" "</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312150015612.png" alt="image-20200312150015612"></p><h3 id="9-读取列表中，从第三个开始的所有数据，并组合一下数据">9.读取列表中，从第三个开始的所有数据，并组合一下数据</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs processing">games = [<span class="hljs-string">'王者'</span>,<span class="hljs-string">'吃鸡'</span>,<span class="hljs-string">'抢滩登陆'</span>]<br># friend_games = [<span class="hljs-string">'王者'</span>,<span class="hljs-string">'吃鸡'</span>]<br>friend_games = games[:<span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'我喜欢的游戏有:'</span>+<span class="hljs-built_in">str</span>(games))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'我朋友喜欢的游戏有:'</span>+<span class="hljs-built_in">str</span>(friend_games))<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312150858704.png" alt="image-20200312150858704"></p><h1>（四）元组</h1><ul><li><strong>Python 的元组与列表类似，不同之处在于元组的元素不能修改。</strong></li><li><strong>元组使用小括号，列表使用方括号。</strong></li><li><strong>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</strong></li></ul><h3 id="1、定义元组">1、定义元组</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">numbers = (<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)   #定义元组<br>print(numbers[<span class="hljs-number">0</span>])   #查看元组中第一个元素<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312151733608.png" alt="image-20200312151733608"></p><h3 id="2、循环输出numbers元组中的数据">2、循环输出numbers元组中的数据</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> numbers:<br>    <span class="hljs-builtin-name">print</span>(num,<span class="hljs-attribute">end</span>=<span class="hljs-string">" "</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312151849601.png" alt="image-20200312151849601"></p><h3 id="3、修改元组">3、修改元组</h3><p><strong>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例:</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(numbers)</span></span><br>numbers = (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(numbers)</span></span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312152053017.png" alt="image-20200312152053017"></p><h3 id="4、删除元组">4、删除元组</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">print</span>(numbers)     <span class="hljs-meta">#查看元组</span><br>del numbers        <span class="hljs-meta">#删除元组</span><br><span class="hljs-keyword">print</span> (<span class="hljs-string">"删除后的元组 numbers : "</span>)<br><span class="hljs-keyword">print</span>(numbers)     <span class="hljs-meta">#因为删除了元组，所以看不到了，就会报错</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200312152455192.png" alt="image-20200312152455192"></p><h2 id="元组运算符">元组运算符</h2><p><strong>与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。</strong></p><table><thead><tr><th style="text-align:left">Python 表达式</th><th style="text-align:left">结果</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">len((1, 2, 3))</td><td style="text-align:left">3</td><td style="text-align:left">计算元素个数</td></tr><tr><td style="text-align:left">(1, 2, 3) + (4, 5, 6)</td><td style="text-align:left">(1, 2, 3, 4, 5, 6)</td><td style="text-align:left">连接</td></tr><tr><td style="text-align:left">(‘Hi!’,) * 4</td><td style="text-align:left">(‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’)</td><td style="text-align:left">复制</td></tr><tr><td style="text-align:left">3 in (1, 2, 3)</td><td style="text-align:left">True</td><td style="text-align:left">元素是否存在</td></tr><tr><td style="text-align:left">for x in (1, 2, 3): print (x,)</td><td style="text-align:left">1 2 3</td><td style="text-align:left">迭代</td></tr></tbody></table><h2 id="元组索引，截取">元组索引，截取</h2><p><strong>因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示：</strong></p><p><strong>元组：</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">L</span> = (<span class="hljs-string">'Google'</span>, <span class="hljs-string">'Taobao'</span>, <span class="hljs-string">'Runoob'</span>)<br></code></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">Python 表达式</th><th style="text-align:left">结果</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">L[2]</td><td style="text-align:left">‘Runoob’</td><td style="text-align:left">读取第三个元素</td></tr><tr><td style="text-align:left">L[-2]</td><td style="text-align:left">‘Taobao’</td><td style="text-align:left">反向读取，读取倒数第二个元素</td></tr><tr><td style="text-align:left">L[1:]</td><td style="text-align:left">(‘Taobao’, ‘Runoob’)</td><td style="text-align:left">截取元素，从第二个开始后的所有元素。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python变量</title>
      <link href="/posts/9a1f.html"/>
      <url>/posts/9a1f.html</url>
      
        <content type="html"><![CDATA[<h1>变量和简单的数据类型</h1><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200310130901833.png" alt="image-20200310130901833" style="zoom:150%;"><h2 id="一、变量">一、变量</h2><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">C:</span>\WINDOWS\system32&gt;jupyter notebook<br><span class="hljs-comment">//启动编辑器jupyter，会自动跳到默认浏览器或让你选择一个浏览器。</span><br></code></pre></td></tr></table></figure><p><strong>创建一个python3的文件</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200310131354250.png" alt="image-20200310131354250"></p><h3 id="1、变量命名规则">1、变量命名规则</h3><p><em><strong>变量要先定义才能使用</strong></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">message = <span class="hljs-string">'北京欢迎你'</span>  <span class="hljs-comment">#定义变量</span><br><span class="hljs-built_in">print</span> (message)       <span class="hljs-comment">#输出变量</span><br>北京欢迎你              <span class="hljs-comment">#输出成功</span><br></code></pre></td></tr></table></figure><h4 id="（1）只能包含的字母、数字、下划线，但是不能以数字打头">（1）只能包含的字母、数字、下划线，但是不能以数字打头</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$xpg</span> = <span class="hljs-string">'hello'</span>   <span class="hljs-comment">#定义变量以特殊符号开头</span><br><span class="hljs-built_in">print</span> (<span class="hljs-variable">$xgp</span>)     <span class="hljs-comment">#输出变量</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200310132639197.png" alt="image-20200310132639197"></p><p><em><strong>语法错误，所以不能使用特殊符号和数字开头</strong></em></p><h4 id="（2）不能包含空格，但是可以用下划线分隔其中的单词">（2）不能包含空格，但是可以用下划线分隔其中的单词</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">a</span> b=<span class="hljs-number">666</span>     <span class="hljs-comment">#定义变量名称以空格间隔</span><br><span class="hljs-keyword">a</span> b         <span class="hljs-comment">#输出变量</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200310133253799.png" alt="image-20200310133253799"></p><p><em><strong>语法错误，所以定义变量名称不能以空格间隔</strong></em></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">a_b=666      <span class="hljs-comment">#定义变量名称以空格间隔</span><br>a_b          <span class="hljs-comment">#输出变量</span><br>666          <span class="hljs-comment">#输出成功</span><br></code></pre></td></tr></table></figure><h4 id="（3）不能使用Python关键字和函数的名称用做变量">（3）不能使用Python关键字和函数的名称用做变量</h4><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> = <span class="hljs-string">'ere'</span>    #以Python关键字定义变量名称<br><span class="hljs-keyword">import</span>            #输出变量<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200310134353916.png" alt="image-20200310134353916"></p><p><em><strong>可以看出输出失败了，并且只要是<code>Python关键字</code>他会变成<code>绿色</code>的</strong></em></p><h4 id="（3）变量名应该简短并且见名知意">（3）变量名应该简短并且见名知意</h4><p><strong>应该把自己要说明情况以简短明了的方式在变量名称体现出来</strong></p><p><strong>如 name：</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">name</span> = <span class="hljs-string">'xgp'</span>    <span class="hljs-comment">#定义变量</span><br>name            <span class="hljs-comment">#输出变量</span><br><span class="hljs-string">'xgp'</span>           <span class="hljs-comment">#输出成功（通过变量名称就可以知道xgp是个名字）</span><br></code></pre></td></tr></table></figure><h4 id="（4）慎用大写字母I（i），小写字母l（L）和小写字母o">（4）慎用大写字母I（i），小写字母l（L）和小写字母o</h4><p><strong>因为I、l和1非常像，还有0和0也非常像，到你要引用的时候非常麻烦（傻傻看不清）</strong></p><h4 id="（5）变量的表达形式">（5）变量的表达形式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">str1 = <span class="hljs-string">'hello'</span>       <span class="hljs-comment">#单引号示范</span><br>str2 = <span class="hljs-string">"world"</span> <span class="hljs-comment">#双引号示范</span><br>str3 = <span class="hljs-string">""" #三引号示范</span><br><span class="hljs-string">1+1=2</span><br><span class="hljs-string">2+2=4</span><br><span class="hljs-string">4+4=8</span><br><span class="hljs-string">"""</span><br>print(str1) <span class="hljs-comment">#输出变量</span><br>print(str2) <span class="hljs-comment">#输出变量</span><br>print(str3) <span class="hljs-comment">#输出变量</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200310142112153.png" alt="image-20200310142112153"></p><p><strong>变量str1使用单引号，变量str2使用双引号，变量str3使用三引号，他们都是合法的Python字符串类型，需要注意的是，单引号和双引号的作用是一样的，可以根据习惯使用，但是定义多行文字时，必须要使用三引号。</strong></p><h3 id="2、字符串">2、字符串</h3><h4 id="（1）修改字符串大小写">（1）修改字符串大小写</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss">name = 'xgp wsd'<br><span class="hljs-keyword">print</span>(name.<span class="hljs-built_in">title</span>())  <span class="hljs-meta">#以首写字母大写的方式显示每个单词</span><br><span class="hljs-keyword">print</span>(name.<span class="hljs-built_in">upper</span>())  <span class="hljs-meta">#将所有字母都以大写的方式显示</span><br><span class="hljs-keyword">print</span>(name.<span class="hljs-built_in">lower</span>())  <span class="hljs-meta">#将所有字母都以小写的方式显示</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200310143244097.png" alt="image-20200310143244097"></p><h4 id="（2）拼接字符">（2）拼接字符</h4><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hsp">age = <span class="hljs-number">18</span><span class="hljs-meta">#定义变量 </span><br><span class="hljs-keyword">print</span>(<span class="hljs-string">'我叫'</span>+name.title()+<span class="hljs-string">',今年'</span>+<span class="hljs-keyword">str</span>(age)+<span class="hljs-string">'岁。'</span>)   <span class="hljs-meta">#输出变量&lt;str()引用变量&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200310143822574.png" alt="image-20200310143822574"></p><p><strong>这种方式最常用、直观、易懂，是入门级的实现方式。但是，它也存在两处让人容易犯错的地方。</strong></p><p><strong>首先，新入门编程的同学容易犯错，他们不知道字符串是不可变类型，新的字符串会独占一块新的内存，而原来的字符串保持不变。上例中，拼接前有两段字符串，拼接后实际有三段字符串。</strong></p><p><strong>其次，一些有经验的老程序员也容易犯错，他们以为当拼接次数不超过3时，使用+号连接符就会比其它方式快（ps：不少Python教程都是如此建议），但这没有任何合理根据。</strong></p><p><strong>事实上，在拼接短的字面值时，由于CPython中的 <code>常数折叠</code> （constant folding）功能，这些字面值会被转换成更短的形式，例如’a’+‘b’+‘c’ 被转换成’abc’，‘hello’+‘world’也会被转换成’hello world’。这种转换是在编译期完成的，而到了运行期时就不会再发生任何拼接操作，因此会加快整体计算的速度。</strong></p><p><strong>常数折叠优化有一个限度，它要求拼接结果的长度不超过20。所以，<code>当拼接的最终字符串长度不超过20时，+号操作符的方式，会比后面提到的join等方式快得多，这与+号的使用次数无关。</code></strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200310145745247.png" alt="image-20200310145745247"></p><h4 id="（3）换行-n">（3）换行\n</h4><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">age</span> = <span class="hljs-number">18</span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">'我叫'</span>+<span class="hljs-variable">name.title</span>()+<span class="hljs-string">',\n今年'</span>+<span class="hljs-title">str</span>(<span class="hljs-variable">age</span>)+<span class="hljs-string">'岁。'</span>)</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200310150337412.png" alt="image-20200310150337412"></p><h4 id="（4）去空格">（4）去空格</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">conten = <span class="hljs-string">' wsd xgp '</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(conten.lstrip()</span></span>)     #去前面的空格<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(conten.rstrip()</span></span>)   #去后面的空格<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(conten.strip()</span></span>)   #去前面和后面的空格<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200310150955030.png" alt="image-20200310150955030"></p><h3 id="3、数字的加减乘除">3、数字的加减乘除</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">num1 = <span class="hljs-number">8</span><br>num2 = <span class="hljs-number">0.5</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(num1+num2)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(num1-num2)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(num1*num2)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(num1/num2)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(num1%num2)</span></span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200310151556775.png" alt="image-20200310151556775"></p><h1>小测试</h1><h2 id="1、将用户的姓名存到一个变量中，并向该用户显示一条信息，显示内容为：“你好，xgp，今天的Python课你学到东西了吗？”">1、将用户的姓名存到一个变量中，并向该用户显示一条信息，显示内容为：“你好，xgp，今天的Python课你学到东西了吗？”</h2><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">name</span> = <span class="hljs-string">'xgp'</span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">'你好，'</span>+<span class="hljs-title">str</span>(<span class="hljs-variable">name</span>)+<span class="hljs-string">'\n今天的Python课你学到东西了吗？'</span>)</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200310161356564.png" alt="image-20200310161356564"></p><h2 id="2、将一个人的名字存到变量中，再以小写、大写和首字母大写的方式显示这个人的名字。">2、将一个人的名字存到变量中，再以小写、大写和首字母大写的方式显示这个人的名字。</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">name = <span class="hljs-string">'wsd'</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(name.lower()</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(name.upper()</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(name.title()</span></span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200310161417423.png" alt="image-20200310161417423"></p><h2 id="3、按一下格式打印诗词：">3、按一下格式打印诗词：</h2><blockquote><p>《自由》</p><p>为人进出的门紧锁着;</p><p>想死的门敞开着。</p><p>有个病毒在外面高喊着:</p><p>“出来玩吧，给你自由！”</p><p>但我深深地知道……</p><p>出去了，不一定还能回来。</p><p>人的生命只有一次，</p><p>算球了，</p><p>再关十几天就自由了！</p></blockquote><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">biaoti</span> = <span class="hljs-string">'《自由》 '</span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-title">str</span>(<span class="hljs-variable">biaoti</span>)+<span class="hljs-string">'\n为人进出的门紧锁着;'</span>+</span><br><span class="hljs-function"><span class="hljs-string">'\n想死的门敞开着。'</span>+</span><br><span class="hljs-function"><span class="hljs-string">'\n有个病毒在外面高喊着:'</span>+</span><br><span class="hljs-function"><span class="hljs-string">'\n“出来玩吧，给你自由！”'</span>+</span><br><span class="hljs-function"><span class="hljs-string">'\n但我深深地知道……'</span>+</span><br><span class="hljs-function"><span class="hljs-string">'\n出去了，不一定还能回来。'</span>+</span><br><span class="hljs-function"><span class="hljs-string">'\n人的生命只有一次，'</span>+</span><br><span class="hljs-function"><span class="hljs-string">'\n算球了，'</span>+</span><br><span class="hljs-function"><span class="hljs-string">'\n再关十几天就自由了！'</span>)</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200310161704615.png" alt="image-20200310161704615"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识python</title>
      <link href="/posts/e939.html"/>
      <url>/posts/e939.html</url>
      
        <content type="html"><![CDATA[<h1>一、PyCharm基本设置</h1><h2 id="1、用Ctrl-鼠标滚轮–放大或缩小字体">1、用Ctrl+鼠标滚轮–放大或缩小字体</h2><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/1591502108.png" alt></p><p>搜索zoom</p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/1591502108(1).png" alt></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/1591502108(2).png" alt></p><h2 id="2、在Windows资源管理器打开文件或目录">2、在Windows资源管理器打开文件或目录</h2><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/1591502108(3).png" alt></p><p><strong>搜索keymap</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/1591502108(4).png" alt></p><p><strong>设置成不常用的键即可，如F3。</strong></p><h2 id="3、代码提示">3、代码提示</h2><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/1591502108(5).png" alt></p><p><strong>搜索letter</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/1591502108(6).png" alt></p><h1>二、自定义函数</h1><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/1591502108(7).png" alt></p><h2 id="1-为什么要使用函数">1.为什么要使用函数</h2><blockquote><p><strong>函数中的代码一次编写,多处运行;</strong><br><strong>函数可以让代码复用，减少代码冗余。</strong></p></blockquote><p><strong>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。</strong></p><p><strong>函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。</strong></p><p><strong>假设我有这样的需求：</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/1591502108(8).png" alt></p><p><strong>但是我还是觉得太麻烦了，每次想吃饭的时候都要重复这样的步骤。此时，我希望有这样的机器：</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/1591502108(9).png" alt></p><p><strong>将重复的工作封装到一起，我们只要向机器里放入东西，就能得到我们想要的。</strong></p><p><strong>这也就是所谓的代码重用。</strong></p><h3 id="例子">例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义方法</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_nums</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-string">"""此处是函数功能的描述"""</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>):<br>        print(i,end=<span class="hljs-string">" "</span>)<br><br><span class="hljs-comment"># 1.三角形 2.正方形 3.梯形</span><br>key = int(input(<span class="hljs-string">'请输入要打印的图形：'</span>))<br><span class="hljs-keyword">if</span> key == <span class="hljs-number">1</span>:<br>    <span class="hljs-comment"># 打印三角形的代码</span><br>    print_nums()<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">elif</span> key == <span class="hljs-number">2</span>:<br>    <span class="hljs-comment"># 打印梯形的代码</span><br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">elif</span> key == <span class="hljs-number">3</span>:<br>    <span class="hljs-comment"># 正方形的代码</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h5 id="输出结果如下：">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">请输入要打印的图形：<span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <br>进程已结束，退出代码 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="分析一下"><strong>分析一下</strong></h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/1591502348(1).png" alt></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/1591502386(1).png" alt></p><h2 id="2、定义函数">2、定义函数</h2><h4 id="你可以定义一个由自己想要功能的函数，以下是简单的规则："><strong>你可以定义一个由自己想要功能的函数，以下是简单的规则：</strong></h4><blockquote><p><strong>关键字: def</strong></p><p><strong>函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()，结尾处有冒号。</strong></p><p><strong>函数内第一行通常书写注释,表名该函数的意义</strong></p><p><strong>注释后空一行,开始写代码块，代码库要缩进</strong></p><p><strong>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。</strong></p><p><strong>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</strong></p><p><strong>函数内容以冒号起始，并且缩进。</strong></p><p><strong>return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</strong></p><p><strong>函数结束后,空2行</strong></p><p><strong>函数调用后空1行,再执行别的代码</strong></p></blockquote><p><strong>语法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#代码如下</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">functionname</span><span class="hljs-params">( parameters )</span>:</span><br>  <span class="hljs-string">"函数_文档字符串"</span><br>  function_suite<br>  <span class="hljs-keyword">return</span> [expression]<br></code></pre></td></tr></table></figure><p><strong>默认情况下，参数值和参数名称是按函数声明中定义的的顺序匹配起来的。</strong></p><h1>三、函数类型</h1><blockquote><p><strong>Python函数可以使用的参数类型：</strong></p><p><strong>必备参数</strong><br><strong>命名参数</strong><br><strong>缺省参数</strong><br><strong>不定长参数</strong></p></blockquote><ul><li><h2 id="参数类型：">参数类型：</h2></li><li></li><li>​    1、位置参数:参数的位置(顺序)很重要，形参和实参个数要匹配</li><li>​    2、关键字参数:对参数的位置要求不是很严格</li><li>​    3、默认值参数:</li><li>​        (1)如果形参中指定了默认值,在实参中可以不传递该形参对应的实参</li><li>​        (2)如果形参中指定了默认值，在实参汇总传递该参数后，最终参数以传递的实参为准</li><li>​    4、不定长参数：</li><li>​    (1)*a：接收传递单个值,保存为元组</li><li>​    (2)**b：接收键值对形式的参数，保存为字典格式</li></ul><h2 id="1、无参函数">1、无参函数</h2><h4 id="无参函数实现和调用：">无参函数实现和调用：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义无参函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hi</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-string">"""介绍自己的函数"""</span><br><br>    print(<span class="hljs-string">'我是xgp，今年18岁，年收入xxxx元'</span>)<br><br><span class="hljs-comment"># 调用无参函数</span><br>say_hi()<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-2">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">我是xgp，今年<span class="hljs-number">18</span>岁，年收入xxxx元<br><br>进程已结束，退出代码 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="2、带参函数">2、带参函数</h2><p><strong>下面说说带参数的函数：</strong></p><ul><li><strong>形参：指的是形式参数，是虚拟的，不占用内存空间，形参单元只有被调用的时才分配内存单元</strong></li><li><strong>实参：指的是实际参数，是一个变量，占用内存空间，数据传递单向，实参传给形参，形参不能传给实参</strong></li></ul><h4 id="例子-2">例子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义带参函数：形参（形式参数，模板）</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hi</span><span class="hljs-params">(name,age,money)</span>:</span><br>    <span class="hljs-string">"""介绍自己的函数"""</span><br><br>    print(<span class="hljs-string">'我是'</span>+name+<span class="hljs-string">'，今年'</span>+str(age)+<span class="hljs-string">'岁，年收入'</span>+str(money)+<span class="hljs-string">'元。'</span>)<br><br><span class="hljs-comment"># 调用带参函数：实参（实际传递的参数）</span><br>say_hi(<span class="hljs-string">'xgp'</span>,<span class="hljs-number">20</span>,<span class="hljs-number">20000</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-3">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">我是xgp，今年<span class="hljs-number">20</span>岁，年收入<span class="hljs-number">20000</span>元。<br><br>进程已结束，退出代码 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>注意事项:调用函数时,实参传递的个数</strong><br><strong>要与形参保持一致|</strong></p></blockquote><h3 id="（1）位置参数"><strong>（1）位置参数</strong></h3><p><strong>从上面的例子可以看出，实际参数和形式参数是一一对应的，如果调换位置，x和y被调用的时，位置也会互换，代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">(x,y)</span>:</span><br>    print(x)<br>    print(y)<br>print(<span class="hljs-string">"--------互换前-----"</span>)<br>test(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>print(<span class="hljs-string">"--------互换后-----"</span>)<br>test(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br> <br><span class="hljs-comment">#输出</span><br>--------互换前-----<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br>--------互换后-----<br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>因为定义x,y两个形参，所以传递实参的时候，也只能传递两个实参，多一个或少一个都是有问题的：</strong></p><p>a：多传递一个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">(x,y)</span>:</span><br>    print(x)<br>    print(y)<br>print(<span class="hljs-string">"--------多一个参数----"</span>)<br>test(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br> <br><span class="hljs-comment">#输出</span><br>--------多一个参数----<br>Traceback (most recent call last):<br>  File <span class="hljs-string">"D:/PycharmProjects/pyhomework/day3/函数_带参数.py"</span>, line <span class="hljs-number">8</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    test(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>TypeError: test() takes <span class="hljs-number">2</span> positional arguments but <span class="hljs-number">3</span> were given  <span class="hljs-comment">#test()函数需要传两个实参，你传了三个实参</span><br></code></pre></td></tr></table></figure><p>b：少传递一个实参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">(x,y)</span>:</span><br>    print(x)<br>    print(y)<br>print(<span class="hljs-string">"--------少一个参数----"</span>)<br>test(<span class="hljs-number">1</span>)<br> <br><span class="hljs-comment">#输出</span><br>--------少一个参数----<br>Traceback (most recent call last):<br>  File <span class="hljs-string">"D:/PycharmProjects/pyhomework/day3/函数_带参数.py"</span>, line <span class="hljs-number">8</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    test(<span class="hljs-number">1</span>)<br>TypeError: test() missing <span class="hljs-number">1</span> required positional argument: <span class="hljs-string">'y'</span>  <br><span class="hljs-comment">#没有给y参数传实参</span><br></code></pre></td></tr></table></figure><h3 id="（2）关键字参数"><strong>（2）关键字参数</strong></h3><p><strong>上面的位置参数，看起来有点死，必须形参和实参的位置一一对应，不然就会传错参数，为了避免这种问题，就有了关键字参数的玩法：关键字传参不需要一一对应，只需要你指定你的哪个形参调用哪一个实参即可；</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">(x,y)</span>:</span><br>    print(x)<br>    print(y)<br> <br>print(<span class="hljs-string">"--------互换前------"</span>)<br>test(x=<span class="hljs-number">1</span>,y=<span class="hljs-number">2</span>)<br>print(<span class="hljs-string">"--------互换后------"</span>)<br>test(y=<span class="hljs-number">2</span>,x=<span class="hljs-number">1</span>)<br> <br><span class="hljs-comment">#输出</span><br>--------互换前------<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br>--------互换后------<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="3、默认参数">3、默认参数</h2><p><strong>调用函数时，默认参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br> <br><span class="hljs-comment">#可写函数说明</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printinfo</span><span class="hljs-params">( name, age = <span class="hljs-number">35</span> )</span>:</span><br>   <span class="hljs-string">"打印任何传入的字符串"</span><br>   <span class="hljs-keyword">print</span> <span class="hljs-string">"Name: "</span>, name<br>   <span class="hljs-keyword">print</span> <span class="hljs-string">"Age "</span>, age<br>   <span class="hljs-keyword">return</span><br> <br><span class="hljs-comment">#调用printinfo函数</span><br>printinfo( age=<span class="hljs-number">50</span>, name=<span class="hljs-string">"miki"</span> )<br>printinfo( name=<span class="hljs-string">"miki"</span> )<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-4">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Name:  miki<br>Age  <span class="hljs-number">50</span><br>Name:  miki<br>Age  <span class="hljs-number">35</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="4、不定长参数">4、不定长参数</h2><p><strong>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">functionname</span><span class="hljs-params">([formal_args,] *var_args_tuple )</span>:</span><br>   <span class="hljs-string">"函数_文档字符串"</span><br>   function_suite<br>   <span class="hljs-keyword">return</span> [expression]<br></code></pre></td></tr></table></figure><p><strong>加了星号（*）的变量名会存放所有未命名的变量参数。不定长参数实例如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br> <br><span class="hljs-comment"># 可写函数说明</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printinfo</span><span class="hljs-params">( arg1, *vartuple )</span>:</span><br>   <span class="hljs-string">"打印任何传入的参数"</span><br>   <span class="hljs-keyword">print</span> <span class="hljs-string">"输出: "</span><br>   <span class="hljs-keyword">print</span> arg1<br>   <span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> vartuple:<br>      <span class="hljs-keyword">print</span> var<br>   <span class="hljs-keyword">return</span><br> <br><span class="hljs-comment"># 调用printinfo 函数</span><br>printinfo( <span class="hljs-number">10</span> )<br>printinfo( <span class="hljs-number">70</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span> )<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-5">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">输出:<br><span class="hljs-number">10</span><br>输出:<br><span class="hljs-number">70</span><br><span class="hljs-number">60</span><br><span class="hljs-number">50</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="（1）例子">（1）例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不定长参数的类型</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">no_test</span><span class="hljs-params">(*args,**b)</span>:</span><br>    print((args))<br>    print(b)<br>no_test(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>no_test(name=<span class="hljs-string">'test'</span>,ages=<span class="hljs-number">18</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-6">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>&#123;&#125;<br>()<br>&#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'test'</span>, <span class="hljs-string">'ages'</span>: <span class="hljs-number">18</span>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="5、匿名函数">5、匿名函数</h2><p><strong>python 使用 lambda 来创建匿名函数。</strong></p><ul><li><strong>lambda只是一个表达式，函数体比def简单很多。</strong></li><li><strong>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</strong></li><li><strong>lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。</strong></li><li><strong>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</strong></li></ul><h3 id="语法">语法</h3><p><strong>lambda函数的语法只包含一个语句，如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression<br></code></pre></td></tr></table></figure><p><strong>如下实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">相加后的值为 :  <span class="hljs-number">30</span><br>相加后的值为 :  <span class="hljs-number">40</span><br></code></pre></td></tr></table></figure><h1>四、rerun传递列表类型数据</h1><p><strong>return语句[表达式]退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，下例便告诉你怎么做：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br> <br><span class="hljs-comment"># 可写函数说明</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span><span class="hljs-params">( arg1, arg2 )</span>:</span><br>   <span class="hljs-comment"># 返回2个参数的和."</span><br>   total = arg1 + arg2<br>   <span class="hljs-keyword">print</span> <span class="hljs-string">"函数内 : "</span>, total<br>   <span class="hljs-keyword">return</span> total<br> <br><span class="hljs-comment"># 调用sum函数</span><br>total = sum( <span class="hljs-number">10</span>, <span class="hljs-number">20</span> )<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-7">输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">函数内 :  <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：在函数内没有写return语句的时候，默认return的是一个空对象。也就是就算没写，python内部也做了处理。</strong></p><p><strong>此时，有部分人分不清函数的输出和返回值的区别。</strong></p><p><strong>这样说吧，在函数里print之类的操作能够输出内容，是因为虽然函数的执行环境是独立的，但代码还是有效的。外部能进行的操作，函数内部也可以。但是并不是所有的函数在执行完毕后都有如此明显的输出效果，此时我们需要查看函数是否成功，或者说我放了米进去，你操作一番之后总要把饭给我拿出来吧。</strong></p><p><strong>这就是函数中return的意义。返回一个对象。这个对象可以是对执行状态的说明，也可以是处理后的结果等等。</strong></p></blockquote><h2 id="1、return语句返回简单类型">1、return语句返回简单类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">'hello'</span><br>print(test())<br><br><span class="hljs-comment"># return 语句返回字典</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_info</span><span class="hljs-params">(name,age)</span>:</span><br>    person = &#123;<span class="hljs-string">'name'</span>:name,<span class="hljs-string">'age'</span>:age&#125;<br>    <span class="hljs-keyword">return</span> person<br><br>print(show_info(<span class="hljs-string">'test'</span>,<span class="hljs-number">18</span>))<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-8">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'test'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">18</span>&#125;<br><br>进程已结束，退出代码 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="2、用户问候">2、用户问候</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hi</span><span class="hljs-params">(first_name,last_name)</span>:</span><br>    <span class="hljs-string">"""返回完整名字"""</span><br>    full_name = first_name + <span class="hljs-string">' '</span> + last_name<br>    <span class="hljs-keyword">return</span> full_name<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    print(<span class="hljs-string">'请输入您的姓名:'</span>)<br>    f_name = input(<span class="hljs-string">'姓：'</span>)<br>    <span class="hljs-keyword">if</span> f_name ==<span class="hljs-string">'q'</span>:<br>        <span class="hljs-keyword">break</span><br><br>    l_name = input(<span class="hljs-string">'名：'</span>)<br>    <span class="hljs-keyword">if</span> l_name == <span class="hljs-string">'q'</span>:<br>        <span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># 调用函数</span><br>    format_name = say_hi(f_name,l_name)<br>    print(<span class="hljs-string">'hello'</span>+format_name+<span class="hljs-string">'!'</span>)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-9">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">请输入您的姓名:<br>姓：x<br>名：gp<br>hellox gp!<br></code></pre></td></tr></table></figure></blockquote><h2 id="3、传递列表类型数据">3、传递列表类型数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span><span class="hljs-params">(names)</span>:</span><br>    <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names:<br>        print(name)<br>user_name = [<span class="hljs-string">'sdf'</span>,<span class="hljs-string">'fsd'</span>,<span class="hljs-string">'fewfwef'</span>,<span class="hljs-string">'fwefe'</span>]<br>test(user_name)<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-10">输出结果如下：</h5><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">sdf<br>fsd<br>fewfwef<br>fwefe<br><br>进程已结束，退出代码 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="5、range函数的练习">5、range函数的练习</h2><ol><li><strong>当只用一个变量调用这个函数时，这个变量指的是输出的等差数列的终点，如<code>range(5)</code></strong></li><li><strong>当给定两个变量时，分别指输出的起始值和终点,，如<code>range(2, 5)</code></strong></li><li><strong>当给定三个变量时，在上一条的基础上第三个变量指输出时的步长，如<code>range(2, 5, -1)</code></strong></li></ol><p><em><strong>（假定我们调用这个函数时总是用整数或浮点数）</strong></em></p><p><strong>分析一下如何实现这个函数，下面给出我的思路作为参考</strong></p><ul><li><strong>一共需要三个参数是显而易见的；</strong></li><li><strong>最直观的感受是起始值是要有默认值的，如果不规定从哪里开始，那就从0开始；</strong></li><li><strong>步长也是要有默认值的，如果不规定，那么步长是1；</strong></li><li><strong>根据有默认值的参数要放在后面的原则，那么最理所当然的参数设计是<code>range_custom(stop, start=0, step=1)</code></strong></li><li><strong>这个方案看上去可行，但是不满足刚才的后面两个要求，如果我们这样用两个变量调用，起始值和终点是反的；</strong></li><li><strong>我们加个判断就可以了，如果start用了初始值，那么说明我们调用的时候只给了一个参数，这个时候stop就是终点，如果start被重新赋值了说明给了至少两个参数，那么这时候把stop和start的值调换一下就可以了；</strong></li><li><strong>现在这个函数似乎可以满足大多数情况了，但是有一个bug，如果给定参数的时候给的start值就是0怎么办呢？如<code>range_custom(-5, 0)</code>按目前的规则会被翻译成<code>range(0, -5)</code>，但是我们的目的却是<code>range(-5, 0)</code>；</strong></li><li><strong>所以start的初始值不应该是数字而是别的数据类型，为了方便起见，我们把它的初始值赋为<code>None</code>，我们的程序雏形就出来了。</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">range_custom</span><span class="hljs-params">(stop, start=None, step=<span class="hljs-number">1</span>)</span>:</span><br>    <span class="hljs-keyword">if</span> start <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> range(stop)<br>    <span class="hljs-keyword">return</span> range(stop, start, step)<br></code></pre></td></tr></table></figure><p><strong>现在这个程序已经满足我们的要求了，但是看上去不太舒服，可以改成</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">range_custom</span><span class="hljs-params">(start, stop=None, step=<span class="hljs-number">1</span>)</span>:</span><br>    <span class="hljs-keyword">if</span> stop <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> range(start)<br>    <span class="hljs-keyword">return</span> range(start, stop, step)<br></code></pre></td></tr></table></figure><p><strong>现在这个函数的参数顺序在逻辑上更好理解一些，可以说基本上满足我们的要求了。当然，本例只是为了说明参数的顺序问题，并不是为了实现range函数。事实上Python的range函数还包括参数实例化，生成器等知识，在后面我们应该还有机会再接触它。</strong></p><h3 id="可选参数">可选参数</h3><p><strong>说到可选参数，可能有的人见过，却也不明白到底是什么意思，它一般是这样出现的</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_option</span><span class="hljs-params">(*args)</span>:</span><br>    <span class="hljs-keyword">return</span> args<br></code></pre></td></tr></table></figure><p><strong>注意到我们声明函数的时候在参数名前加了个<code>*</code>星号，这是声明可选参数的方法。那么可选参数到底有什么用呢？</strong></p><p><strong>可选参数的作用是用元组把所有多余的变量收集起来，这个元组的名字就是这个可选参数名。在上例<code>func_option</code>中我们可以用任意多个变量调用它，比如<code>a = func_option(1, 2, 3)</code>那么<code>a</code>就会是元组<code>(1, 2, 3)</code>。关于为什么是元组而不是列表，我们在上一篇<a href="https://www.jianshu.com/p/e6c4683a511d" target="_blank" rel="noopener">Python进阶-简单数据结构</a>中说过，元组在Python中往往是比列表更优先考虑使用的数据结构，具体原因在本文靠后<em>深入自定义函数参数</em>部分会讨论。</strong></p><p><strong>我们刚才说可选参数会收集多余的变量。我这么说是有原因的。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_option</span><span class="hljs-params">(a, *args, c=<span class="hljs-number">2</span>)</span>:</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> args<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>func_option2(<span class="hljs-number">1</span>)<br>()<br><span class="hljs-meta">&gt;&gt;&gt; </span>func_option2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">2</span>,)<br><span class="hljs-meta">&gt;&gt;&gt; </span>func_option2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p><strong>注意到我们的<code>*args</code>把除了给普通参数的第一个变量以外的值都放进了元组中。这样做导致了一个，问题在于我们的有默认值的参数如果不给定参数名地调用的话，就永远只能用默认值了。而且如果我们在调用函数时不把有默认值的参数放在最后面程序还会报错。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>func_option2(c=<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span><br>SyntaxError: positional argument follows keyword argument<br></code></pre></td></tr></table></figure><p><strong>那么有没有好的办法能规避这个问题呢？我们可以试试把可选参数放在有默认值的参数后面。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_option3</span><span class="hljs-params">(a, c=<span class="hljs-number">2</span>, *args)</span>:</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> args<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>func_option3(<span class="hljs-number">1</span>)<br>()<br><span class="hljs-meta">&gt;&gt;&gt; </span>func_option3(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>()<br><span class="hljs-meta">&gt;&gt;&gt; </span>func_option3(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">3</span>,)<br><span class="hljs-meta">&gt;&gt;&gt; </span>func_option2(c=<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span><br>SyntaxError: positional argument follows keyword argument<br></code></pre></td></tr></table></figure><p><strong>那么这种形式的函数能不能解决之前的问题呢。看上去不行，不过我们知道了，调用函数的时候，要尽量把有默认值的参数放在靠后的位置赋予变量。那么这两种我们到底该用哪个方法呢？在实际操作中，我们倾向于将可选参数放在有默认值的参数之后，而且如果参数较多，我们倾向于调用函数时都会所有变量都加上参数名。而且实际操作中，其实可选参数用得不那么多，相对来说，另一种可选参数其实用得更多。这种可选参数的形式一般是这样</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func_optionkw</span><span class="hljs-params">(**kwargs)</span>:</span><br>    <span class="hljs-keyword">return</span> args<br></code></pre></td></tr></table></figure><p><strong>在这种情况下，关键字可选参数都是作为键值对保存在参数名的的字典中。也就是说，在调用函数时，在满足一般参数以后，变量都应该以赋值语句的形式给出，等号左边作为键右边作为值。如果不这样做，就会报错了。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>func_optionkw(<span class="hljs-number">3</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: t2() takes <span class="hljs-number">0</span> positional arguments but <span class="hljs-number">1</span> was given<br></code></pre></td></tr></table></figure><p><strong>需要说明的是，一个自定义函数只能有一个可选参数，同时也可以有至多一个关键字参数。其中关键字参数应该放在普通可选参数之后。</strong></p><p><strong>现在我们来总结一下函数参数顺序一般规律：</strong></p><ul><li><strong>一般参数放在最前面</strong></li><li><strong>可选参数放在最后面</strong></li><li><strong>关键字可选参数放在一般可选参数后面</strong></li><li><strong>函数调用时尽量把有默认值的参数对应的变量放在靠后的位置</strong></li><li><strong>如果参数比较多，调用函数时，最好所有变量都指明参数名</strong></li></ul><p><strong>以上这些，有的是为了防止函数定义时出错，有的是为了防止函数调用时出错，总之，应该养成良好的编程习惯。</strong></p><h1>五、变量作用域</h1><p><strong>一个程序的所有的变量并不是在哪个位置都可以访问的。访问权限决定于这个变量是在哪里赋值的。</strong></p><p><strong>变量的作用域决定了在哪一部分程序你可以访问哪个特定的变量名称。两种最基本的变量作用域如下：</strong></p><ul><li><strong>全局变量</strong></li><li><strong>局部变量</strong></li></ul><h1>六、全局变量和局部变量</h1><p><strong>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</strong></p><p><strong>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：</strong></p><h2 id="实例-Python-2-0">实例(Python 2.0+)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br> <br>total = <span class="hljs-number">0</span> <span class="hljs-comment"># 这是一个全局变量</span><br><span class="hljs-comment"># 可写函数说明</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span><span class="hljs-params">( arg1, arg2 )</span>:</span><br>   <span class="hljs-comment">#返回2个参数的和."</span><br>   total = arg1 + arg2 <span class="hljs-comment"># total在这里是局部变量.</span><br>   <span class="hljs-keyword">print</span> <span class="hljs-string">"函数内是局部变量 : "</span>, total<br>   <span class="hljs-keyword">return</span> total<br> <br><span class="hljs-comment">#调用sum函数</span><br>sum( <span class="hljs-number">10</span>, <span class="hljs-number">20</span> )<br><span class="hljs-keyword">print</span> <span class="hljs-string">"函数外是全局变量 : "</span>, total<br></code></pre></td></tr></table></figure><h5 id="输出结果如下：-11">输出结果如下：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">函数内是局部变量 :  <span class="hljs-number">30</span><br>函数外是全局变量 :  <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s复习</title>
      <link href="/posts/h8er.html"/>
      <url>/posts/h8er.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建镜像的方法">创建镜像的方法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# vim Dockerfile<br>FROM nginx<br>ADD index.htm /usr/share/nginx/html/<br>//创建Dockerfile<br><br>[root@master test]# echo "&lt;h1&gt;version 01 wsd&lt;/h1&gt;" &gt; index.html<br>[root@master test]# docker build -t 192.168.1.1:5000/nginx .<br>[root@master test]# echo "&lt;h1&gt;version 02 wsd&lt;/h1&gt;" &gt; index.html <br>[root@master test]# docker build -t 192.168.1.1:5000/nginx:v1.14 <br>[root@master test]# echo "&lt;h1&gt;version 03 wsd&lt;/h1&gt;" &gt; index.html .<br>[root@master test]# docker build -t 192.168.1.1:5000/nginx:v1.15 .<br>//创建不同index.html文件，生成测试镜像<br><br>[root@master test]# docker push 192.168.1.1:5000/nginx<br>[root@master test]# docker push 192.168.1.1:5000/nginx:v1.14<br>[root@master test]# docker push 192.168.1.1:5000/nginx:v1.15<br>//上传镜像<br></code></pre></td></tr></table></figure><h1>2) deployment名字为:nginx,保证运行3个Pod.service名字为：nginx-svc。映射到主机端口：31234.（10分）</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# docker pull nginx<br>//下载nginx镜像<br>[root@master yaml]# vim deployment.yaml <br>//编写deployment和service的yaml文件<br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: nginx<br>spec:<br>  replicas: 3<br>  template:<br>    metadata:<br>      labels:<br>        app: nginx<br>    spec:<br>      containers:<br>      - name: nginx<br>        image: nginx<br>---<br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: nginx-svc<br>spec:<br>  type: NodePort<br>  selector:<br>    app: nginx<br>  ports:<br>    - port: 80<br>      targetPort: 80<br>      nodePort: 31234<br></code></pre></td></tr></table></figure><h2 id="执行一下">执行一下</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f deployment.yaml<br></code></pre></td></tr></table></figure><h2 id="查看一下">查看一下</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod<br></code></pre></td></tr></table></figure><p><img src="http://q9npprkue.bkt.clouddn.com/image-20200315100201329.png" alt="image-20200315100201329"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get svc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315100228967.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315100228967.png" alt="image-20200315100228967"></a></p><h2 id="访问一下http-192-168-1-21-31234">访问一下http://192.168.1.21:31234/</h2><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315100419217.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315100419217.png" alt="image-20200315100419217"></a></p><h1>3) 共有3个版本，版本1对应image镜像为：nginx，版本2对应的image为：nginx:1.14.版本3对应的版本为:nginx:1.15.分别运行各版本，每个版本要有在浏览器的访问验证。（10分）</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# docker pull nginx<br>[root@master yaml]# docker pull nginx:1.14<br>[root@master yaml]# docker pull nginx:1.15<br>//下载所需镜像<br></code></pre></td></tr></table></figure><h2 id="编写deployment的yaml文件">编写deployment的yaml文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim banben1.yaml<br>//编写deployment和service的yaml文件<br><br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: nginx<br>spec:<br>  replicas: 3<br>  template:<br>    metadata:<br>      labels:<br>        app: nginx-svc        <br>    spec:<br>      containers:<br>      - name: nginx         <br>        image: nginx         #更改一下镜像（1.14和1.15的）<br>[root@master yaml]# vim banben2.yaml<br>//编写deployment和service的yaml文件<br><br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: nginx2<br>spec:<br>  replicas: 3<br>  template:<br>    metadata:<br>      labels:<br>        app: nginx-svc        <br>    spec:<br>      containers:<br>      - name: nginx         <br>        image: nginx:1.14        #更改一下镜像（1.14和1.15的）<br>[root@master yaml]# vim banben3.yaml<br>//编写deployment和service的yaml文件<br><br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: nginx3<br>spec:<br>  replicas: 3<br>  template:<br>    metadata:<br>      labels:<br>        app: nginx-svc        <br>    spec:<br>      containers:<br>      - name: nginx         <br>        image: nginx:1.15         #更改一下镜像（1.14和1.15的）<br></code></pre></td></tr></table></figure><h2 id="编写service的yaml文件">编写service的yaml文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim ngnix-svc.yaml <br><br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: nginx-svc<br>spec:<br>  type: NodePort<br>  selector:<br>    app: nginx-svc<br>  ports:<br>    - port: 80<br>      targetPort: 80<br>      nodePort: 31235<br></code></pre></td></tr></table></figure><h3 id="执行一下（记录版本信息）">执行一下（记录版本信息）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f banben1.yaml --record <br>[root@master yaml]# kubectl apply -f banben2.yaml --record <br>[root@master yaml]# kubectl apply -f banben3.yaml --record <br>[root@master yaml]# kubectl apply -f ngnix-svc.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下-2">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315145551904.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315145551904.png" alt="image-20200315145551904"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get svc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315142530998.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315142530998.png" alt="image-20200315142530998"></a></p><h3 id="访问一下-http-192-168-1-21-31235">访问一下 <a href="http://192.168.1.21:31235/" target="_blank" rel="noopener">http://192.168.1.21:31235/</a></h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315143242088.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315143242088.png" alt="image-20200315143242088"></a></p><h1>4)运行到版本3之后，进行回滚操作回滚到版本4.（5分）</h1><h2 id="查看记录的版本信息">查看记录的版本信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]#  kubectl rollout history deployment nginx<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315142738558.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315142738558.png" alt="image-20200315142738558"></a></p><h3 id="回滚到指定版本">回滚到指定版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl rollout undo deployment nginx --to-revision=4<br>//这里指定的是版本信息的编号<br></code></pre></td></tr></table></figure><h3 id="访问一下">访问一下</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315143715792.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315143715792.png" alt="image-20200315143715792"></a></p><h1>5) 此时更改默认的3个Pod的访问界面,.版本1的访问界面内容为：考生名称+version:No1.版本2的访问界面:考生名称+version:No2,以此类推。（5分）</h1><h3 id="修改POD页面内容（三台不一样）">修改POD页面内容（三台不一样）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl exec -it xgp-web-8d5f9656f-8z7d9 /bin/bash<br>//根据pod名称进入pod之中<br></code></pre></td></tr></table></figure><h3 id="进入容器后修改页面内容">进入容器后修改页面内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">1<br>[root@master yaml]# kubectl exec -it nginx-d6c5c85cb-8vcvt /bin/bash<br>root@nginx-d6c5c85cb-8vcvt:/# echo "&lt;h1&gt;version 01 wushaodong&lt;/h1&gt;"   &gt; /usr/share/nginx/html/index.html <br>root@nginx-d6c5c85cb-8vcvt:/# exit<br><br>2<br>[root@master yaml]# kubectl exec -it nginx-d6c5c85cb-bxvvt /bin/bash<br>root@nginx-d6c5c85cb-bxvvt:/# echo "&lt;h1&gt;version 02 wushaodong&lt;/h1&gt;"   &gt; /usr/share/nginx/html/index.html<br>root@nginx-d6c5c85cb-bxvvt:/# exit<br><br>3<br>[root@master yaml]# kubectl exec -it nginx-d6c5c85cb-lhlz9 /bin/bash<br>root@nginx-d6c5c85cb-lhlz9:/# echo "&lt;h1&gt;version 03 wushaodong&lt;/h1&gt;"   &gt; /usr/share/nginx/html/index.html<br>root@nginx-d6c5c85cb-lhlz9:/# exit<br></code></pre></td></tr></table></figure><h1>6) 验证界面是否会会有轮训效果，并加以分析论述。（5分）</h1><p><em><strong>不要在浏览器里测试轮询，有缓存</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# curl 127.0.0.1:31235<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315150130146.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315150130146.png" alt="image-20200315150130146"></a></p><p><strong>答：会有轮询的效果，kubernetes 内部的负载均衡是通过 iptables 的 probability 特性来做到的，kube-proxy通过iptables 将访问 Service 的流量转发到后端 Pod，而且使用类似轮询的负载均衡策略。</strong></p><h1>7) 创建一个NFS PV，NFS共享目录为：考生名称。PV名称为：new-pv。创建一个PVC，名称为new-pvc。单独创建一个pod，使用new-pv，运行之后，验证nfs是否使用成功。（10分）</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# yum -y install nfs-utils rpcbind<br><br>[root@master yaml]# mkdir /wushaodong<br>//创建指定名称的共享目录<br>[root@master yaml]# echo "/wushaodong *(rw,sync,no_root_squash)" &gt; /etc/exports<br>//编写共享目录的权限<br><br>[root@master ~]#  systemctl start nfs-server<br>[root@master ~]#  systemctl start rpcbind<br>//启动服务<br><br>[root@master yaml]# showmount -e<br>//测试一下<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315152012176.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315152012176.png" alt="image-20200315152012176"></a></p><h2 id="1、创建一个NFS-PV的yaml文件">1、创建一个NFS PV的yaml文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim new-pv.yaml<br><br>apiVersion: v1<br>kind: PersistentVolume<br>metadata:<br>  name: new-xgp<br>spec:<br>  capacity:<br>    storage: 1Gi<br>  accessModes:<br>    - ReadWriteOnce<br>  persistentVolumeReclaimPolicy: Recycle<br>  storageClassName: nfs<br>  nfs:<br>    path: /wushaodong/new-pv<br>    server: 192.168.1.21<br><br>[root@master yaml]# mkdir /wushaodong/new-pv<br>//创建指定目录<br></code></pre></td></tr></table></figure><h3 id="执行一下-2">执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply  -f  new-pv.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下-3">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pv<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315152639218.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315152639218.png" alt="image-20200315152639218"></a></p><h2 id="2、创建一个PVC的yaml文件">2、创建一个PVC的yaml文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim new-pvc.yaml<br>apiVersion: v1<br>kind: PersistentVolumeClaim<br>metadata:<br>  name: new-pvc<br>spec:<br>  accessModes:            #要和pv的一直否则关联不成功<br>  - ReadWriteOnce<br>  resources:<br>    requests:<br>      storage: 1Gi<br>  storageClassName: nfs   #要和pv的一直否则关联不成功<br></code></pre></td></tr></table></figure><h3 id="执行一下-3">执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply  -f  new-pvc.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下-4">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pvc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315153049267.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315153049267.png" alt="image-20200315153049267"></a></p><h2 id="3、单独创建一个pod，使用new-pv">3、单独创建一个pod，使用new-pv</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim pod.yaml<br>apiVersion: v1<br>kind: Pod<br>metadata:<br>  name: xgp-pod<br>spec:<br>  containers:<br>  - name: xgp-pod<br>    image: busybox<br>    args:<br>    - /bin/sh<br>    - -c<br>    - sleep 300000<br>    volumeMounts:<br>    - mountPath: /wushaodong  #容器的被挂载目录<br>      name: volumedata<br>  volumes:<br>    - name: volumedata<br>      persistentVolumeClaim:<br>        claimName: new-pvc<br></code></pre></td></tr></table></figure><h3 id="执行一下-4">执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f pod.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下-5">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315153837882.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315153837882.png" alt="image-20200315153837882"></a></p><h2 id="4、测试一下">4、测试一下</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl exec -it xgp-pod /bin/sh<br>//进入pod<br><span class="hljs-meta">#</span><span class="bash">  <span class="hljs-built_in">echo</span> <span class="hljs-string">"xgpIwsd"</span> &gt; /wushaodong/xgp.txt</span><br>//添加内容到挂载目录<br><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">exit</span></span><br></code></pre></td></tr></table></figure><h3 id="查看一下，挂载目录是否有添加内容">查看一下，挂载目录是否有添加内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# cat /wushaodong/new-pv/xgp.txt<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315154239587.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315154239587.png" alt="image-20200315154239587"></a></p><h1>8）请简述k8s集群中，master节点有哪些组件，node节点有哪些组件，作用分别有什么作用，各组件又是怎么交互的。（5分）</h1><h2 id="master节点">master节点</h2><p><strong>1. API server[资源操作入口]</strong>：是k8s集群的前端接口，各种各样客户端工具以及k8s的其他组件可以通过它管理k8s集群的各种资源。它提供了HTTP/HTTPS RESTful API,即K8S API。</p><blockquote><ul><li>提供了资源对象的唯一操作入口，其他所有组件都必须通过它提供的API来操作资源数据，只有API Server与存储通信，其他模块通过API Server访问集群状态。</li></ul><p>第一，是为了保证集群状态访问的安全。</p><p>第二，是为了隔离集群状态访问的方式和后端存储实现的方式：API Server是状态访问的方式，不会因为后端存储技术etcd的改变而改变。</p><ul><li>作为kubernetes系统的入口，封装了核心对象的增删改查操作，以<a href="https://www.centos.bz/tag/restful/" target="_blank" rel="noopener">RESTFul</a>接口方式提供给外部客户和内部组件调用。对相关的资源数据“全量查询”+“变化监听”，实时完成相关的业务功能。</li></ul></blockquote><p><strong>2. Scheduler[集群分发调度器]</strong>：负责决定将Pod放在哪个Node上运行。在调度时，会充分考虑集群的拓扑结构，当前各个节点的负载情况，以及应对高可用、性能、数据亲和性和需求。</p><blockquote><p>1.Scheduler收集和分析当前Kubernetes集群中所有Minion节点的资源(内存、CPU)负载情况，然后依此分发新建的Pod到Kubernetes集群中可用的节点。</p><p>2.实时监测Kubernetes集群中未分发和已分发的所有运行的Pod。</p><p>3.Scheduler也监测Minion节点信息，由于会频繁查找Minion节点，Scheduler会缓存一份最新的信息在本地。</p><p>4.最后，Scheduler在分发Pod到指定的Minion节点后，会把Pod相关的信息Binding写回API Server。</p></blockquote><p><strong>4. Controller Manager[内部管理控制中心]</strong>：负责管理集群的各种资源，保证资源处于预期的状态。它由多种Controller组成，包括Replication Controller、Endpoints Controller、Namespace Controller、Serviceaccounts Controller等。</p><blockquote><p>实现集群故障检测和恢复的自动化工作，负责执行各种控制器，主要有：</p><p>1.endpoint-controller：定期关联<a href="https://www.centos.bz/tag/service/" target="_blank" rel="noopener">service</a>和pod(关联信息由endpoint对象维护)，保证service到pod的映射总是最新的。</p><p>2.replication-controller：定期关联replicationController和pod，保证replicationController定义的复制数量与实际运行pod的数量总是一致的。</p></blockquote><p>**5. Etcd：**负责保存k8s集群的配置信息和各种资源的状态信息。当数据发生变化时，etcd会快速的通知k8s相关组件。<a href="https://wsdlxgp.top/posts/gssl.html">（第三方组件）它有可替换方案。Consul、zookeeper</a></p><p><strong>6. Pod:</strong> k8s集群的最小组成单位。一个Pod内，可以运行一个或多个容器。大多数情况下，一个Pod内只有一个Container容器。</p><p>**7. Flanner：**是k8s集群网络，可以保证Pod的跨主机通信。也有替换方案。</p><h2 id="Node节点">Node节点</h2><p><strong>Kubelet[节点上的Pod管家]</strong>：它是Node的agent(代理)，当Scheduler确定某 个Node上运行Pod之后，会将Pod的具体配置信息发送给该节点的kubelet,kubelet会根据这些信息创建和运行容器，并向Master报告运行状态。</p><blockquote><ul><li>负责Node节点上pod的创建、修改、监控、删除等全生命周期的管理</li><li>定时上报本Node的状态信息给API Server。</li><li>kubelet是Master API Server和Minion之间的桥梁，接收Master API Server分配给它的commands和work，与持久性键值存储etcd、file、server和http进行交互，读取配置信息。</li><li>具体的工作如下：</li></ul><p>设置容器的环境变量、给容器绑定<a href="https://www.centos.bz/tag/volume/" target="_blank" rel="noopener">Volume</a>、给容器绑定Port、根据指定的Pod运行一个单一容器、给指定的Pod创建network 容器。</p><p>同步Pod的状态、同步Pod的状态、从<a href="https://www.centos.bz/tag/cadvisor/" target="_blank" rel="noopener">cAdvisor</a>获取<a href="https://www.centos.bz/tag/container/" target="_blank" rel="noopener">Container</a> info、 pod info、 root info、 <a href="https://www.centos.bz/tag/machine/" target="_blank" rel="noopener">machine</a> info。</p><p>在容器中运行命令、杀死容器、删除Pod的所有容器。</p></blockquote><p>**kube-proxy[负载均衡、路由转发]:**负责将访问service的TCP/UDP数据流转发到后端的容器。如果有多个<br>副本，kube-proxy会实现负载均衡。</p><blockquote><ul><li>Proxy是为了解决外部网络能够访问跨机器集群中容器提供的应用服务而设计的，运行在每个Node上。Proxy提供TCP/UDP sockets的proxy，每创建一种Service，Proxy主要从etcd获取Services和Endpoints的配置信息（也可以从file获取），然后根据配置信息在Minion上启动一个Proxy的进程并监听相应的服务端口，当外部请求发生时，Proxy会根据Load Balancer将请求分发到后端正确的容器处理。</li><li>Proxy不但解决了同一主宿机相同服务端口冲突的问题，还提供了Service转发服务端口对外提供服务的能力，Proxy后端使用了随机、轮循负载均衡算法。</li></ul></blockquote><h2 id="各个组件的作用以及架构工作流程">各个组件的作用以及架构工作流程:</h2><p><strong>1) kubectl发送部署 请求到API server</strong><br><strong>2) APIserver通知Controller Manager创建一个Deployment资源。</strong><br><strong>3) Scheduler执行调度任务,将两个副本Pod分发到node01和node02. 上。</strong><br><strong>4) node01和node02, 上的kubelet在各自节点上创建并运行Pod。</strong></p><h3 id="补充">补充</h3><p><strong>1.应用的配置和当前的状态信息保存在etcd中，执行kubectl get pod时API server会从etcd中读取这些数据。</strong></p><p><strong>2.flannel会为每个Pod分配一个IP。 但此时没有创建Service资源，目前kube-proxy还没有参与进来。</strong></p><h1>9）部署一个dashboard。（5分）</h1><h2 id="1、下载所需yaml文件和镜像">1、下载所需yaml文件和镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-rc5/aio/deploy/recommended.yaml<br>[root@master https]# docker pull kubernetesui/dashboard:v2.0.0-rc5<br></code></pre></td></tr></table></figure><h2 id="2、修改-recommended-yaml">2、修改 recommended.yaml</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]#vim recommended.yaml <br>---<br>kind: Service<br>apiVersion: v1<br>metadata:<br>  labels:<br>    k8s-app: kubernetes-dashboard<br>  name: kubernetes-dashboard<br>  namespace: kubernetes-dashboard<br>spec:<br>  type: NodePort            #添加40<br>  ports:<br>    - port: 443<br>      targetPort: 8443<br>  selector:<br>    k8s-app: kubernetes-dashboard<br></code></pre></td></tr></table></figure><h3 id="执行一下-5">执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl apply -f recommended.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下-6">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl get svc -n kubernetes-dashboard<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315154708443.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315154708443.png" alt="image-20200315154708443"></a></p><h2 id="3、浏览器访问https-192-168-1-21-30949">3、浏览器访问https://192.168.1.21:30949/</h2><p><strong>PS:如果是使用的旧版本的dashboard, 使用Google浏览器登录，可能是不成功的，需要换成其他的浏览器，比如:火狐。</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315154859800.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315154859800.png" alt="image-20200315154859800"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315154929279.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315154929279.png" alt="image-20200315154929279"></a></p><h2 id="4、基于token的方法登录dashboard">4、基于token的方法登录dashboard</h2><h3 id="1-创建一个dashboard的管理用户">&lt;1&gt;创建一个dashboard的管理用户</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl create serviceaccount dashboard-admin -n kube-system<br></code></pre></td></tr></table></figure><h3 id="2-绑定用户为集群管理用户">&lt;2&gt;绑定用户为集群管理用户</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl create clusterrolebinding dashboard-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin<br></code></pre></td></tr></table></figure><h3 id="3-获取Token">&lt;3&gt;获取Token</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl get secrets -n kube-system | grep dashboard-admin<br>//先得到Token的名称<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315155029875.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315155029875.png" alt="image-20200315155029875"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl describe secrets -n kube-system  dashboard-admin-token-j874n<br>//查看上述得到的secret资源的详细信息，会得到token<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315155147297.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315155147297.png" alt="image-20200315155147297"></a></p><h3 id="4-在浏览器上使用token登录。">&lt;4&gt;在浏览器上使用token登录。</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315155307433.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315155307433.png" alt="image-20200315155307433"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315155326746.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315155326746.png" alt="image-20200315155326746"></a></p><p><strong>成功界面</strong></p><h1>10）使用helm的方式，部署mysql服务，要求使用storageclass作为持久化存储，服务运行之后，进入数据库，创建一个test库，库中一张test表，内容为： 9527.</h1><h1>然后模拟数据库Pod失败，待Pod重启后，查看对应数据是否还存在？（10分）</h1><h2 id="1、安装部署helm工具">1、安装部署helm工具</h2><h3 id="（1）下载helm的包">（1）下载helm的包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]#docker pull gcr.io/kubernetes-helm/tiller:v2.14.3<br>[root@master ~]# wget https://get.helm.sh/helm-v2.14.3-linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><h3 id="（2）把helm包的命令，复制到本地">（2）把helm包的命令，复制到本地</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master helm]# mv linux-amd64/helm /usr/local/bin/<br>//移动命令目录到/usr/local/bin/<br>[root@master helm]# chmod +x /usr/local/bin/helm <br>//给予执行权限<br>[root@master helm]# helm help<br>//验证是否安装成功<br></code></pre></td></tr></table></figure><h3 id="（3）设置命令自动补全">（3）设置命令自动补全</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master helm]#  echo 'source &lt;(helm completion bash)' &gt;&gt; /etc/profile<br>[root@master helm]# . /etc/profile<br>//刷新一下<br></code></pre></td></tr></table></figure><h2 id="2、安装Tiller-server（服务端，需要创建授权用户）">2、安装Tiller server（服务端，需要创建授权用户）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim tiller-rbac.yaml   #创建授权用户<br>apiVersion: v1<br>kind: ServiceAccount<br>metadata:<br>  name: tiller<br>  namespace: kube-system<br>---<br>apiVersion: rbac.authorization.k8s.io/v1beta1<br>kind: ClusterRoleBinding<br>metadata:<br>  name: tiller<br>roleRef:<br>  apiGroup: rbac.authorization.k8s.io<br>  kind: ClusterRole<br>  name: cluster-admin<br>subjects:<br>  - kind: ServiceAccount<br>    name: tiller<br>    namespace: kube-system<br></code></pre></td></tr></table></figure><h4 id="执行一下-6">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f tiller-rbac.yaml<br></code></pre></td></tr></table></figure><h3 id="（1）Tiller-server的环境初始化">（1）Tiller server的环境初始化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master helm]# helm init  --service-account=tiller<br>//helm的服务端就是Tiller（因为是访问外国的网站，可能需要多次执行）<br></code></pre></td></tr></table></figure><h4 id="查看一下-7">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master helm]# kubectl get deployment. -n kube-system<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315163043816.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315163043816.png" alt="image-20200315163043816"></a></p><p><strong>现在发现没有开启，那是因为默认下载的Google的镜像，下载不下来</strong></p><h3 id="（2）设置镜像源改为阿里云的">（2）设置镜像源改为阿里云的</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master helm]# helm repo add stable https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts<br></code></pre></td></tr></table></figure><h4 id="查看一下-8">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master helm]# helm version<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315163313031.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315163313031.png" alt="image-20200315163313031"></a></p><h2 id="3、基于NFS服务，创建共享。">3、基于NFS服务，创建共享。</h2><p><strong>因为上面已经做过了，所以现在只需创建目录和设置权限即可</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master heml]# mkdir /xgpwsd<br>//创建目录<br>[root@master heml]# echo '/xgpwsd *(rw,sync,no_root_squash)' &gt;&gt; /etc/exports<br>//设置共享目录权限<br>[root@master heml]# systemctl restart nfs-server<br>[root@master heml]# systemctl restart rpcbind<br>//重启nfs服务<br>[root@master heml]# showmount -e<br>//测试一下<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315164157425.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315164157425.png" alt="image-20200315164157425"></a></p><h2 id="4、创建pv">4、创建pv</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# vim nfs-pv1.yml <br>apiVersion: v1<br>kind: PersistentVolume<br>metadata:<br>  name: mysqlpv<br>spec:<br>  capacity:<br>    storage: 8Gi<br>  accessModes:<br>    - ReadWriteOnce<br>  persistentVolumeReclaimPolicy: Recycle<br>  nfs:<br>    path: /xgpwsd/xgp<br>    server: 192.168.1.21<br>[root@master xgp]# mkdir /xgpwsd/xgp<br>//创建所需目录<br></code></pre></td></tr></table></figure><h4 id="执行一下-7">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# kubectl apply -f nfs-pv1.yml<br></code></pre></td></tr></table></figure><h4 id="查看一下-9">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# kubectl get pv<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315182950429.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315182950429.png" alt="image-20200315182950429"></a></p><h2 id="5、创建StorageClass资源对象。">5、创建StorageClass资源对象。</h2><h3 id="（1）创建rbac权限。">（1）创建rbac权限。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim rbac.yaml <br>apiVersion: v1<br>kind: ServiceAccount<br>metadata:<br>  name: nfs-provisioner<br>  namespace: default<br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRole<br>metadata:<br>  name: nfs-provisioner-runner<br>  namespace: default<br>rules:<br>   -  apiGroups: [""]<br>      resources: ["persistentvolumes"]<br>      verbs: ["get", "list", "watch", "create", "delete"]<br>   -  apiGroups: [""]<br>      resources: ["persistentvolumeclaims"]<br>      verbs: ["get", "list", "watch", "update"]<br>   -  apiGroups: ["storage.k8s.io"]<br>      resources: ["storageclasses"]<br>      verbs: ["get", "list", "watch"]<br>   -  apiGroups: [""]<br>      resources: ["events"]<br>      verbs: ["watch", "create", "update", "patch"]<br>   -  apiGroups: [""]<br>      resources: ["services", "endpoints"]<br>      verbs: ["get","create","list", "watch","update"]<br>   -  apiGroups: ["extensions"]<br>      resources: ["podsecuritypolicies"]<br>      resourceNames: ["nfs-provisioner"]<br>      verbs: ["use"]<br>---<br>kind: ClusterRoleBinding<br>apiVersion: rbac.authorization.k8s.io/v1<br>metadata:<br>  name: run-nfs-provisioner<br>subjects:<br>  - kind: ServiceAccount<br>    name: nfs-provisioner<br>    namespace: default        #必写字段<br>roleRef:<br>  kind: ClusterRole<br>  name: nfs-provisioner-runner<br>  apiGroup: rbac.authorization.k8s.io<br></code></pre></td></tr></table></figure><h4 id="执行一下-8">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f rbac.yaml<br></code></pre></td></tr></table></figure><h3 id="（2）创建Deployment资源对象，用Pod代替-真正的NFS服务。">（2）创建Deployment资源对象，用Pod代替 真正的NFS服务。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim nfs-deployment.yaml <br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: nfs-client-provisioner<br>spec:<br>  replicas: 1<br>  strategy:<br>    type: Recreate<br>  template:<br>    metadata:<br>      labels:<br>        app: nfs-client-provisioner<br>    spec:<br>      serviceAccount: nfs-provisioner<br>      containers:<br>        - name: nfs-client-provisioner<br>          image: registry.cn-hangzhou.aliyuncs.com/open-ali/nfs-client-provisioner<br>          volumeMounts:<br>            - name: nfs-client-root<br>              mountPath:  /persistentvolumes<br>          env:<br>            - name: PROVISIONER_NAME<br>              value: xgp<br>            - name: NFS_SERVER<br>              value: 192.168.1.21<br>            - name: NFS_PATH<br>              value: /xgpwsd/wsd<br>      volumes:<br>        - name: nfs-client-root<br>          nfs:<br>            server: 192.168.1.21<br>            path: /xgpwsd/wsd<br>            <br>[root@master heml]# mkdir /xgpwsd/wsd<br>//创建指定目录<br></code></pre></td></tr></table></figure><h4 id="执行一下-9">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f nfs-deployment.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-10">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315164706266.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315164706266.png" alt="image-20200315164706266"></a></p><h3 id="（3）创建storageclass的yaml文件">（3）创建storageclass的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim xgp-storageclass.yaml <br>apiVersion: storage.k8s.io/v1<br>kind: StorageClass<br>metadata:<br>  name: xgp-nfs<br>provisioner: xgp  #通过provisioner字段关联到上述Deploy<br>reclaimPolicy: Retain<br></code></pre></td></tr></table></figure><h4 id="执行一下-10">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f xgp-storageclass.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-11">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get sc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315164758857.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315164758857.png" alt="image-20200315164758857"></a></p><h2 id="6、创建一个mysql服务">6、创建一个mysql服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# docker pull mysql:5.7.14<br>//下载所需镜像<br>[root@master yaml]# helm fetch stable/mysql<br>//直接下载stable/mysql的chart包<br>[root@master yaml]# tar -zxf mysql-0.3.5.tgz <br>//解压mysql包<br>[root@master yaml]# cd mysql/<br>[root@master mysql]# vim values.yaml <br>//修改values.yaml文件，添加storageClass存储卷<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315173613775.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315173613775.png" alt="image-20200315173613775"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]# helm install stable/mysql -n xgp-mysql --set mysqlRootPassword=123.com -f values.yaml <br>//基于values.yaml和stable/mysql开启一个密码为123.com的mysqlpod<br></code></pre></td></tr></table></figure><h3 id="查看一下-12">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]# kubectl get svc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315173526818.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315173526818.png" alt="image-20200315173526818"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]# kubectl get pod -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315173702896.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315173702896.png" alt="image-20200315173702896"></a></p><h2 id="7、进入mysql数据库，创建一个test库，库中一张test表，内容为：-9527。">7、进入mysql数据库，创建一个test库，库中一张test表，内容为： 9527。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# kubectl exec -it bdqn-mysql-mysql-7b89c7b99-8ff2r -- mysql -u root -p123.com<br></code></pre></td></tr></table></figure><h3 id="创建数据库">创建数据库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">mysql&gt;</span><span class="bash"> create database <span class="hljs-built_in">test</span>;</span><br></code></pre></td></tr></table></figure><h3 id="切换数据库">切换数据库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">mysql&gt;</span><span class="bash"> use <span class="hljs-built_in">test</span>;</span><br></code></pre></td></tr></table></figure><h3 id="创建表">创建表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">mysql&gt;</span><span class="bash"> create table <span class="hljs-built_in">test</span>( id int(4))；</span><br></code></pre></td></tr></table></figure><h3 id="在表中插入数据">在表中插入数据</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">mysql&gt;</span><span class="bash"> insert <span class="hljs-built_in">test</span> values(9527);</span><br></code></pre></td></tr></table></figure><h3 id="查看表">查看表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">mysql&gt;</span><span class="bash"> select * from <span class="hljs-built_in">test</span>;</span><br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315181155502.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315181155502.png" alt="image-20200315181155502"></a></p><h2 id="8、模拟数据库Pod失败，待Pod重启后，查看对应数据是否还存在？">8、模拟数据库Pod失败，待Pod重启后，查看对应数据是否还存在？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]# kubectl delete pod xgp-mysql-mysql-67c6fb5f9-4h4kz<br>//删除这个pod让他重新生成<br>[root@master mysql]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315181626553.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315181626553.png" alt="image-20200315181626553"></a></p><h3 id="进入新的pod查看">进入新的pod查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]# kubectl exec -it xgp-mysql-mysql-67c6fb5f9-k4c29 -- mysql -u root -p123.com<br><span class="hljs-meta">mysql&gt;</span><span class="bash"> use <span class="hljs-built_in">test</span>;</span><br>Reading table information for completion of table and column names<br>You can turn off this feature to get a quicker startup with -A<br><br>Database changed<br><span class="hljs-meta">mysql&gt;</span><span class="bash"> select * from <span class="hljs-built_in">test</span>;</span><br>+------+<br>| id   |<br>+------+<br>| 9527 |<br>+------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315181720939.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200315181720939.png" alt="image-20200315181720939"></a></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nfs </tag>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> dashboard </tag>
            
            <tag> helm </tag>
            
            <tag> deployment </tag>
            
            <tag> StorageClass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s的持续集成（jenkins+gitlab+k8s）</title>
      <link href="/posts/b04b.html"/>
      <url>/posts/b04b.html</url>
      
        <content type="html"><![CDATA[<h2 id="应用场景：">应用场景：</h2><p><strong><code>问题</code>项目分为app和后台两种，为了保证再同一个环境下面测试，所以不可能链接开发本地服务进行测试，所以需要搭建一个测试环境，供app进行开发测试。这个时候就有一个问题，如果开发新增加功能或者app调试的时候发现问题，这个时候就需要提交新的代码或者修复bug，然后重新发布到测试环境中去。但是后台人员又不能进入Linux服务器中，只能通过Linux运维人员来重新部署，这样的效率就会极低。</strong></p><p><strong><code>方案：</code>基于这种模式下面的，我们引入了Jenkins工具，通过Jenkins来拉取svn/git代码到服务器中，再Jenkins中编写Linux运行脚本，通过脚本我们就可以对代码进行编译运行，然后重新发布到服务器中运行。后端人员也不需要通知Linux运维人员来执行这个操作，直接再Jenkins的控制台就可以执行了。</strong></p><h2 id="实验环境">实验环境</h2><table><thead><tr><th>IP</th><th>主机名称</th><th>服务</th></tr></thead><tbody><tr><td><strong>192.168.1.21</strong></td><td><strong>master</strong></td><td><strong>k8s</strong></td></tr><tr><td><strong>192.168.1.22</strong></td><td><strong>node01</strong></td><td><strong>k8s</strong></td></tr><tr><td><strong>192.168.1.10</strong></td><td><strong>git</strong></td><td><strong>gitlab</strong></td></tr><tr><td><strong>192.168.1.13</strong></td><td><strong>jenkins</strong></td><td><strong>jenkins</strong></td></tr></tbody></table><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200309134708695.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200309134708695.png" alt="image-20200309134708695"></a></p><p><strong>总体流程：</strong></p><ul><li><strong>在开发机开发代码后提交到gitlab</strong></li><li><strong>之后通过webhook插件触发jenkins进行构建，jenkins将代码打成docker镜像，push到docker-registry</strong></li><li><strong>之后将在k8s-master上执行rc、service的创建，进而创建Pod，从私服拉取镜像，根据该镜像启动容器</strong></li></ul><p><strong>应用构建和发布流程说明。</strong></p><ol><li><strong>用户向Gitlab提交代码，代码中必须包含<code>Dockerfile</code></strong></li><li><strong>将代码提交到远程仓库</strong></li><li><strong>用户在发布应用时需要填写git仓库地址和分支、服务类型、服务名称、资源数量、实例个数，确定后触发Jenkins自动构建</strong></li><li><strong>Jenkins的CI流水线自动编译代码并打包成docker镜像推送到Harbor镜像仓库</strong></li><li><strong>Jenkins的CI流水线中包括了自定义脚本，根据我们已准备好的kubernetes的YAML模板，将其中的变量替换成用户输入的选项</strong></li><li><strong>生成应用的kubernetes YAML配置文件</strong></li><li><strong>更新Ingress的配置，根据新部署的应用的名称，在ingress的配置文件中增加一条路由信息</strong></li><li><strong>更新PowerDNS，向其中插入一条DNS记录，IP地址是边缘节点的IP地址。关于边缘节点，请查看<a href="https://jimmysong.io/kubernetes-handbook/practice/edge-node-configuration.html" target="_blank" rel="noopener">边缘节点配置</a></strong></li><li><strong>Jenkins调用kubernetes的API，部署应用</strong></li></ol><h1>一、前期工作</h1><h2 id="1、先验证k8s集群（1-21和1-22）">1、先验证k8s集群（1.21和1.22）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get nodes<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306083959440.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306083959440.png" alt="image-20200306083959440"></a></p><h2 id="2、master部署私有仓库">2、master部署私有仓库</h2><h3 id="Docker01部署"><strong>Docker01部署</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">72 docker pull registry<br>//下载registry镜像<br><br>73 docker run -itd --name registry -p 5000:5000 --restart=always registry:latest<br>//基于registry镜像，启动一台容器<br><br>78 vim /usr/lib/systemd/system/docker.service #13行修改<br>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.1.21:5000 <br><br>80 systemctl daemon-reload<br>81 systemctl restart docker.service<br>//重启docker<br><br>76 docker tag httpd:latest 192.168.1.11:5000/web:v1 <br>76 docker tag httpd:latest 192.168.1.11:5000/web:v2<br>//把容器重命名一个标签<br><br>77 docker ps<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200309101144205.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200309101144205.png" alt="image-20200309101144205"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">78 vim /usr/lib/systemd/system/docker.service #13行修改<br>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.1.11:5000 <br><br><br>80 systemctl daemon-reload<br>81 systemctl restart docker.service<br>//重启docker<br><br>100 docker push 192.168.1.11:5000/web:v1<br>100 docker push 192.168.1.11:5000/web:v2<br>//上传容器到私有仓库<br></code></pre></td></tr></table></figure><h3 id="Docker02和docker03加入私有仓库"><strong>Docker02和docker03加入私有仓库</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">78 vim /usr/lib/systemd/system/docker.service #13行修改<br>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.1.11:5000  <br><br>80 systemctl daemon-reload<br>81 systemctl restart docker.service<br>//重启docker<br><br>99 docker pull 192.168.1.21:5000/web:v1<br>//测试下载<br></code></pre></td></tr></table></figure><h2 id="3、然后重要的地方到了，建立-yaml配置文件让kubernetes自己控制容器集群。"><strong>3、然后重要的地方到了，建立 yaml配置文件让kubernetes自己控制容器集群。</strong></h2><p><em><strong>用来模拟我们部署的服务</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master app]# vim deploy.yaml<br><br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: web<br>spec:<br>  replicas: 2<br>  template:<br>    metadata:<br>      labels:<br>        name: web<br>    spec:<br>      containers:<br>      - name: web<br>        image: 192.168.1.21:5000/web:v1<br>        imagePullPolicy: Always     #改为本地仓库下载<br>        ports:<br>        - containerPort: 80<br></code></pre></td></tr></table></figure><h4 id="执行一下">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master app]# kubectl apply -f deploy.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master app]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306085507559.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306085507559.png" alt="image-20200306085507559"></a></p><h3 id="可是容器的ip只能在容器本机上访问，集群内的其他主机和集群外的主机都没办法访问，这个时候就需要将容器的端口映射到服务器上的端口了，所以需要做一个service的模板。service-模板可以将容器的端口映射到服务器的端口上，并且可以固定映射在服务器上的端口。"><strong>可是容器的ip只能在容器本机上访问，集群内的其他主机和集群外的主机都没办法访问，这个时候就需要将容器的端口映射到服务器上的端口了，所以需要做一个service的模板。service 模板可以将容器的端口映射到服务器的端口上，并且可以固定映射在服务器上的端口。</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master app]# vim deploy-svc.yaml<br><br>apiVersion: v1<br>kind: Service<br>metadata:<br>  labels:<br>    name: web<br>  name: web<br>spec:<br>  type: NodePort<br>  ports:<br>  - port: 80<br>    targetPort: 80<br>    nodePort: 31234<br>  selector:<br>    name: web<br></code></pre></td></tr></table></figure><p><strong>执行一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master app]# kubectl apply -f deploy-svc.yaml<br></code></pre></td></tr></table></figure><p><strong>查看一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master app]# kubectl get svc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306085725863.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306085725863.png" alt="image-20200306085725863"></a></p><p><strong>访问一下http://192.168.1.21:31234/</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306085846077.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306085846077.png" alt="image-20200306085846077"></a></p><h3 id="《ok-kubernetes-完毕，-开始配置-jenkins-gitlab联动》"><strong>《ok kubernetes</strong> <strong>完毕， 开始配置 jenkins+gitlab联动》</strong></h3><h3 id="4、git和jenkins加入私有仓库">4、git和jenkins加入私有仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">78 vim /usr/lib/systemd/system/docker.service #13行修改<br>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.1.11:5000  <br><br>80 systemctl daemon-reload<br>81 systemctl restart docker.service<br>//重启docker<br><br>99 docker pull 192.168.1.11/busybox:v1<br>//测试下载<br></code></pre></td></tr></table></figure><h3 id="5、jenkins服务器向k8smaster做免密登录">5、jenkins服务器向k8smaster做免密登录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">100 ssh-copy-id 192.168.1.21<br></code></pre></td></tr></table></figure><h1>二、安装jenkins（1.13）</h1><h3 id="安装java环境">安装java环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@jenkins ~]# tar -zxf jdk-8u231-linux-x64.tar.gz<br><br>[root@jenkins ~]# mv jdk1.8.0_131 /usr/java<br><span class="hljs-meta">#</span><span class="bash">注意 这里有位置敏感，不要多一个“/”</span><br>[root@jenkins ~]# vim /etc/profile #在最下面写<br><br>export JAVA_HOME=/usr/java<br>export JRE_HOME=/usr/java/jre<br>export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH<br>export CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar<br><br>[root@jenkins ~]#  source /etc/profile<br>//环境变量生效<br>[root@jenkins ~]#  java -version<br>//验证环境变量<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306091443071.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306091443071.png" alt="image-20200306091443071"></a></p><h3 id="安装tomcat">安装tomcat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@jenkins ~]# tar -zxf apache-tomcat-7.0.54.tar.gz <br>[root@jenkins ~]# mv apache-tomcat-7.0.54 /usr/tomcat7<br>[root@jenkins ~]# cd /usr/tomcat7/webapps/<br>[root@jenkins webapps]# rm -rf *<br>[root@jenkins webapps]# cp /root/jenkins.war . #这几步是jenkins的包放进了tomcat里<br>[root@jenkins webapps]# vim /usr/tomcat7/conf/server.xml <br>//修改tomcat的字符集<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306092022390.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306092022390.png" alt="image-20200306092022390"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@jenkins webapps]# cd /usr/tomcat7/bin/<br><br>[root@jenkins bin]# vim catalina.sh <br><span class="hljs-meta">#</span><span class="bash">!/bin/sh</span><br>export CATALINA_OPTS="-DJENKINS_HOME=/data/jenkins"<br>export JENKINS_JAVA_OPTIONS="-Djava.awt.headless=true -Dhudson.ClassicPluginStrategy.noBytecodeTransformer=true"<br>//这两行添加的是jenkins的家目录位置，这个很重要<br><br>[root@jenkins bin]# ./catalina.sh start <br>//启动tomcat<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306092523262.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306092523262.png" alt="image-20200306092523262"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@jenkins bin]# netstat -anput | grep 8080<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306110511541.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306110511541.png" alt="image-20200306110511541"></a></p><h3 id="浏览器安装jenkins">浏览器安装jenkins</h3><p><a href="http://192.168.1.11:8080/jenkins" target="_blank" rel="noopener">http://192.168.1.11:8080/jenkins</a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306110627790.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306110627790.png" alt="image-20200306110627790"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@jenkins bin]# cat /data/jenkins/secrets/initialAdminPassword<br>c577cbf75d934878a94b0f9e00ada328   //复制密码<br></code></pre></td></tr></table></figure><h3 id="（1）推荐安装">（1）推荐安装</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200308124155279.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200308124155279.png" alt="image-20200308124155279"></a></p><p><strong>#左边是自动安装， 右边是自定义安装，我们选左边的，如果不是这个画面则说明网络很卡或者没有网(推荐使用右边的，然后选择不安装插件，之后可以自定义安装）</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306151852889.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306151852889.png" alt="image-20200306151852889"></a></p><h3 id="（2）这个是自定义安装（自己上传的包）">（2）这个是自定义安装（自己上传的包）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@autoweb bin]# ./catalina.sh stop<br>[root@autoweb ~]# cd /data/jenkins/plugins/<br>[root@autoweb jenkins]# mv plugins plugins/.bk<br>然后上传plugins.tar.gz包：<br>[root@autoweb jenkins]# tar -zxf plugins.tar.gz <br>[root@autoweb ~]# cd /usr/tomcat7/bin/<br>[root@autoweb bin]# ./catalina.sh stop<br>[root@autoweb bin]# ./catalina.sh start<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306110627790.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306110627790.png" alt="image-20200306110627790"></a></p><p><strong>输入密码后断网</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200308124449039.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200308124449039.png" alt="image-20200308124449039"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200308123936170.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200308123936170.png" alt="image-20200308123936170"></a></p><h3 id="（3）两个剩下的方法一样">（3）两个剩下的方法一样</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306151900827.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306151900827.png" alt="image-20200306151900827"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306151905668.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306151905668.png" alt="image-20200306151905668"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306151911675.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306151911675.png" alt="image-20200306151911675"></a></p><h4 id="下载中文插件"><strong>下载中文插件</strong></h4><p><strong>系统管理-----&gt;插件管理-----&gt;avalilable(可选)然后搜索localization-zh-cn</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306152834083.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306152834083.png" alt="image-20200306152834083"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306152957419.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306152957419.png" alt="image-20200306152957419"></a></p><p><strong>然后还需要3个插件</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306153713286.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306153713286.png" alt="image-20200306153713286"></a></p><h1>三、安装gitlab（1.10）</h1><p><strong>GitLab CI 是 GitLab 默认集成的 CI 功能，GitLab CI 通过在项目内 .gitlab-ci.yaml 配置文件读取 CI 任务并进行相应处理；GitLab CI 通过其称为 GitLab Runner 的 Agent 端进行 build 操作；Runner 本身可以使用多种方式安装，比如使用 Docker 镜像启动等；Runner 在进行 build 操作时也可以选择多种 build 环境提供者；比如直接在 Runner 所在宿主机 build、通过新创建虚拟机(vmware、virtualbox)进行 build等；同时 Runner 支持 Docker 作为 build 提供者，即每次 build 新启动容器进行 build；GitLab CI 其大致架构如下</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200309140112958.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200309140112958.png" alt="image-20200309140112958"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> yum -y install curl policycoreutils openssh-server openssh-clients postfix git</span><br><span class="hljs-meta">#</span><span class="bash"> systemctl <span class="hljs-built_in">enable</span> sshd</span><br><span class="hljs-meta">#</span><span class="bash"> systemctl start sshd</span><br><span class="hljs-meta">#</span><span class="bash"> systemctl <span class="hljs-built_in">enable</span> postfix</span><br><span class="hljs-meta">#</span><span class="bash"> systemctl start postfix</span><br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306112315163.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306112315163.png" alt="image-20200306112315163"></a></p><h3 id="安装gitlab-ce"><strong>安装gitlab-ce</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@git ~]# curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash<br></code></pre></td></tr></table></figure><p><strong>注：由于网络问题，国内用户，使用清华大学的镜像源进行安装：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@git ~]# vim /etc/yum.repos.d/gitlab-ce.repo<br>[gitlab-ce]<br>name=gitlab-ce<br>baseurl=http://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7<br>repo_gpgcheck=0<br>gpgcheck=0<br>enabled=1<br>gpgkey=https://packages.gitlab.com/gpg.key<br><br>[root@git ~]# yum makecache<br>//保存到本地<br><br>[root@git ~]# yum -y install gitlab-ce <br><span class="hljs-meta">#</span><span class="bash">这两条命令是把gitlab源先加入了yum，然后yum下载gitlab</span><br><br>[root@git ~]# vim /etc/gitlab/gitlab.rb <br>//修改端口是为了防止端口冲突，因为80默认是http服务的 <br><br>external_url 'http://192.168.1.21:90'  #端口， unicorn默认是8080 也是tomcat的端口 <br>unicorn['listen'] = '127.0.0.1'<br>unicorn['port'] = 3000 <br><br><br>[root@git ~]# gitlab-ctl reconfigure <br>//启动gitlab，这个过程可能会有点慢<br><br><br>[root@git ~]# ls /etc/yum.repos.d/<br>//查看一下<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306141100803.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306141100803.png" alt="image-20200306141100803"></a></p><h3 id="访问192-168-1-10-90">访问192.168.1.10:90</h3><p><strong>在网页配置用户密码后则安装完毕。用户默认root，这里让设置一个密码再登录，<a href="http://xn--12345-of3np30ehqhlqe.com/" target="_blank" rel="noopener">这里设置12345.com</a>（相对较短的密码不让设置）</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306141728312.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306141728312.png" alt="image-20200306141728312"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306142041682.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306142041682.png" alt="image-20200306142041682"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306142219600.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306142219600.png" alt="image-20200306142219600"></a></p><h1>四、jenkins和gitlab相互关联</h1><p><strong>jenkins：工具集成平台</strong></p><p><strong>gitlab: 软件托管平台</strong></p><p><strong>部署这两个服务的联动，需要经过ssh验证。</strong></p><h2 id="1、首先我们需要在gitlab上绑定jenkins服务器的ssh公钥，这里我们使用的是root用户的公私钥，切记生产环境是不允许随便用root的">1、<strong>首先我们需要在gitlab上绑定jenkins服务器的ssh公钥，这里我们使用的是root用户的公私钥，切记生产环境是不允许随便用root的</strong></h2><h3 id="（1）jenkins"><strong>（1）jenkins</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@jenkins ~]# ssh-keygen -t rsa <br>//然后不输入只回车会生成一对公私钥<br></code></pre></td></tr></table></figure><h4 id="默认在-root-ssh-目录里"><strong>默认在/root/.ssh/目录里</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@jenkins ~]# cat /root/.ssh/id_rsa.pub <br>//查看公钥并复制<br>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDMA4+je3NsxZrF2v8TPLXJp1ejwy1YokXipEFyGVNo5IbtkiBDwBLOAl5i7yromY8YGgoNNriE2g89IM/44BGC5UDCokQ69Ze9Ta9Kynv3/1PDFXIABJJG0f6LsUqt0nKFaFoGz3ZuYAnl6AzLpXEic8DBDrsFk+UGrxvMfSEqHlYO2b7jRXE1HGRnqI/IcVB190cLT1kmBKi7hSqUNBc1cY6t3a6gGiBpp9tc8PW4r/RcLblhAL1LKx8x37NOZkqox8IMh3eM/wtWwAVFlI8XU+sz9akzJOVmd1ArT5Q4w8WA/uVHCDUGVI/fli/ZRv+mNZyF3EH26runctb5LkCT root@jenkins<br></code></pre></td></tr></table></figure><h3 id="（2）gitlab">（2）gitlab</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306195836403.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306195836403.png" alt="image-20200306195836403"></a></p><h4 id="在这里放刚才拷贝的公钥保存就行了。"><strong>在这里放刚才拷贝的公钥保存就行了。</strong></h4><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306200026493.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306200026493.png" alt="image-20200306200026493"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306200103458.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306200103458.png" alt="image-20200306200103458"></a></p><h4 id="我们先在gitlab上创建一个代码仓库-点击-new-project"><strong>我们先在gitlab上创建一个代码仓库 点击 new project</strong></h4><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306200156932.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306200156932.png" alt="image-20200306200156932"></a></p><p><strong>输入一个仓库的名字，权限选择公共的（public）然后直接点击创建</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306200431858.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306200431858.png" alt="image-20200306200431858"></a></p><h4 id="点击新建一个new-file"><strong>点击新建一个new.file</strong></h4><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306201437862.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306201437862.png" alt="image-20200306201437862"></a></p><h4 id="写入代码，起一个名字然后保存"><strong>写入代码，起一个名字然后保存</strong></h4><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306201558158.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306201558158.png" alt="image-20200306201558158"></a></p><h4 id="创建好了，然后在本地测试一下是否可用"><strong>创建好了，然后在本地测试一下是否可用</strong></h4><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306201744679.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306201744679.png" alt="image-20200306201744679"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@git ~]# mkdir xgp<br>[root@git ~]# cd xgp/<br>[root@git xgp]# git clone git@192.168.1.10:root/xgp-demo.git<br>//克隆xgp-demo仓库到本地<br><br>[root@git xgp]# ls xgp-demo/<br>index.html<br>[root@git xgp]# cat xgp-demo/index.html <br>print: "hello word!!!"<br>//查看一下<br></code></pre></td></tr></table></figure><h3 id="（3）自动构建">（3）自动构建</h3><p><strong>安装插件</strong></p><p><strong>先进入到之前查看插件的地方</strong></p><p><strong>系统设置----插件管理----高级_—上传插件gitlab-oauth、gitlab-plugin、 windows-slaves、ruby-runt ime、gitlab-hook</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306212734302.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306212734302.png" alt="image-20200306212734302"></a></p><h3 id="（4）如果可以用，则打开jenkins-点击新建">（4）如果可以用，则打开jenkins 点击新建</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306202647670.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306202647670.png" alt="image-20200306202647670"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306202724313.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306202724313.png" alt="image-20200306202724313"></a></p><h4 id="地址粘贴进去以后没有报错则没错"><strong>地址粘贴进去以后没有报错则没错</strong></h4><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306203441474.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306203441474.png" alt="image-20200306203441474"></a></p><p><strong>但是很伤心它报错了，那是因为jenkins和git没有关联上</strong></p><h3 id="解决">解决</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306203407502.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306203407502.png" alt="image-20200306203407502"></a></p><h4 id="git主机生成ssh密钥">git主机生成ssh密钥</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@jenkins ~]# ssh-keygen -t rsa <br>//然后不输入只回车会生成一对公私钥<br>[root@jenkins ~]# cat /root/.ssh/id_rsa   <br>//查看密钥并复制<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306203947496.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306203947496.png" alt="image-20200306203947496"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306204232588.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306204232588.png" alt="image-20200306204232588"></a></p><p><strong>下面的这个插件很重要，就是他实现自动化更新的webhook插件，安装过了就会有这条，然后点击这条下面出来的这些东西保持默认就行。同时注意复制</strong></p><p><strong>这个里面写的是jenkins构建时候会执行的shell脚本，这个是最重要的，就是他实现了下端kubernetes自动更新容器的操作。</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306204512237.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306204512237.png" alt="image-20200306204512237"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306204948462.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306204948462.png" alt="image-20200306204948462"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>backupcode="/data/backcode/$JOB_NAME/$BUILD_NUMBER"  <br>mkdir -p $backupcode     #jenkins创建上述目录<br>chmod 644 "$JENKINS_HOME"/workspace/"$JOB_NAME"/*<br>rsync -acP   "$JENKINS_HOME"/workspace/"$JOB_NAME"/*  $backupcode #$JENKINS_HOME和$JOB_NAME同步最新消息<br><span class="hljs-meta">#</span><span class="bash">ssh root@192.168.1.21 sed -i <span class="hljs-string">'s/v1/v2/g'</span> /root/app/deploy.yaml <span class="hljs-comment">#更改镜像版本</span></span><br>echo From  192.168.1.21:5000/web:v1 &gt; "$JENKINS_HOME"/workspace/Dockerfile<br>echo COPY ./"$JOB_NAME"/* /usr/local/apache2/htdocs/ &gt;&gt; "$JENKINS_HOME"/workspace/Dockerfile<br>docker rmi 192.168.1.21:5000/web:v1<br>docker build -t 192.168.1.21:5000/web:v1 /"$JENKINS_HOME"/workspace/.<br>docker push 192.168.1.21:5000/web:v1<br>ssh root@192.168.1.21 kubectl delete deployment web<br>ssh root@192.168.1.21 kubectl apply -f /root/app/deploy.yaml<br></code></pre></td></tr></table></figure><blockquote><p><strong>$JOB_NAME：项目名称</strong></p><p><strong>$BUILD_NUMBER：第几次构建</strong></p><p><strong>$JENKINS_HOME：jenkins的家目录</strong></p></blockquote><p><strong>完事以后先别保存，首先复制一下上面的jenkins地址，然后去gitlab上绑定webhook</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306213050759.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306213050759.png" alt="image-20200306213050759"></a></p><p><strong>保存，登陆gitlab，点击下图这个设置</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306213514819.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306213514819.png" alt="image-20200306213514819"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306213829519.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306213829519.png" alt="image-20200306213829519"></a></p><p><strong>测试显示下图 的蓝条说明jenkins 已经连通了gitlab</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306214117715.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306214117715.png" alt="image-20200306214117715"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306215322180.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306215322180.png" alt="image-20200306215322180"></a></p><h4 id="回到Jenkins开启匿名访问权限"><strong>回到Jenkins开启匿名访问权限</strong></h4><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306215429619.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306215429619.png" alt="image-20200306215429619"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306215504413.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306215504413.png" alt="image-20200306215504413"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306215539717.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306215539717.png" alt=""></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306215611348.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306215611348.png" alt="image-20200306215611348"></a></p><p><strong>测试显示下图 的蓝条说明jenkins 已经连通了gitlab</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306214126410.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200306214126410.png" alt="image-20200306214126410"></a></p><p><strong>好了，jenkins和gitlab 都已经互相的ssh通过了，然后我们最后需要做的一个ssh是关于jenkins</strong></p><p><strong>///注意，这里是从git和jenkins向master节点做免密登录。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@git ~]# ssh-copy-id root@192.168.1.21<br>[root@jenkins ~]# ssh-copy-id root@192.168.1.21<br></code></pre></td></tr></table></figure><p><strong>好了，环境全部部署完毕！！！。开始测试</strong></p><h1>五、测试</h1><p><strong>测试的方法很简单，就是在gitlab上新建代码，删除代码，修改代码，都会触发webhook进行自动部署。最终会作用在所有的nginx容器中，也就是我们的web服务器。</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200309100434912.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200309100434912.png" alt="image-20200309100434912"></a></p><p><strong>这里我修改了之前建立的 index.html文件 保存以后，就打开浏览器 一直访问kubernetes-node 里面的容器了</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200309100445830.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200309100445830.png" alt="image-20200309100445830"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200309100530210.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200309100530210.png" alt="image-20200309100530210"></a></p><h2 id="访问一下http-192-168-1-21-31234">访问一下http://192.168.1.21:31234/</h2><p><em><strong>如果没有变，应该注意查看是否在jenkins上构建完成，等以小会就可以了。</strong></em></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200309100557309.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200309100557309.png" alt="image-20200309100557309"></a></p><p><strong>构建成功</strong></p><h1>六、GitLab CI 总结</h1><p><strong>CS 架构</strong><br>GitLab 作为 Server 端，控制 Runner 端执行一系列的 CI 任务；代码 clone 等无需关心，GitLab 会自动处理好一切；Runner 每次都会启动新的容器执行 CI 任务</p><p><strong>容器即环境</strong><br>在 Runner 使用 Docker build 的前提下；所有依赖切换、环境切换应当由切换不同镜像实现，即 build 那就使用 build 的镜像，deploy 就用带有 deploy 功能的镜像；通过不同镜像容器实现完整的环境隔离</p><p><strong>CI即脚本</strong><br>不同的 CI 任务实际上就是在使用不同镜像的容器中执行 <a href="https://www.centos.bz/tag/shell/" target="_blank" rel="noopener">SHELL</a> 命令，自动化 CI 就是执行预先写好的一些小脚本</p><p><strong>敏感信息走环境变量</strong><br>一切重要的敏感信息，如账户密码等，不要写到 CI 配置中，直接放到 GitLab 的环境变量中；GitLab 会保证将其推送到远端 Runner 的 SHELL 变量中</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s的charts的四种安装方式及helm私有仓库</title>
      <link href="/posts/e7d.html"/>
      <url>/posts/e7d.html</url>
      
        <content type="html"><![CDATA[<h1>自定义helm模板</h1><p><a href="https://hub.helm.sh/" target="_blank" rel="noopener">https://hub.helm.sh/</a></p><h2 id="1、开发自己的chare包">1、开发自己的chare包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# helm create mychare<br>//创建一个名为mychare的chare包<br>[root@master ~]# tree -C mychare/<br>//以树状图查看一下chare包<br>mychare/<br>├── charts<br>├── Chart.yaml<br>├── templates<br>│   ├── deployment.yaml<br>│   ├── _helpers.tpl<br>│   ├── ingress.yaml<br>│   ├── NOTES.txt<br>│   ├── service.yaml<br>│   └── tests<br>│       └── test-connection.yaml<br>└── values.yaml<br></code></pre></td></tr></table></figure><h2 id="2、调试chart">2、调试chart</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mychare]# cd<br>[root@master ~]# helm install --dry-run --debug mychare<br>//检查这个mychare是否有问题<br></code></pre></td></tr></table></figure><h2 id="3、安装chart">3、安装chart</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node02 ~]# docker pull nginx:stable<br></code></pre></td></tr></table></figure><h3 id="（1）通过仓库安装">（1）通过仓库安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mychare]# helm search redis<br>//搜索chare包<br>[root@master mychare]# helm repo list<br>//查看是否有能访问仓库<br>[root@master mychare]# helm install stable/redis<br>//安装<br></code></pre></td></tr></table></figure><h3 id="（2）通过tar包安装">（2）通过tar包安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# helm fetch stable/redis<br>//直接下载chare包<br>[root@master ~]# tar -zxf redis-1.1.15.tgz<br>//解压下载的chare包<br>[root@master ~]# tree -C redis<br>redis<br>├── Chart.yaml<br>├── README.md<br>├── templates<br>│   ├── deployment.yaml<br>│   ├── _helpers.tpl<br>│   ├── networkpolicy.yaml<br>│   ├── NOTES.txt<br>│   ├── pvc.yaml<br>│   ├── secrets.yaml<br>│   └── svc.yaml<br>└── values.yaml<br></code></pre></td></tr></table></figure><h3 id="（3）通过chare本地目录安装">（3）通过chare本地目录安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# helm fetch stable/redis<br>//直接下载chare包<br>[root@master ~]# tar -zxf redis-1.1.15.tgz<br>//解压下载的chare包<br>[root@master ~]# helm install redis<br></code></pre></td></tr></table></figure><h3 id="（4）通过URL安装">（4）通过URL安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# helm install https://example.com/charts/foo-1.2.3.tgz<br></code></pre></td></tr></table></figure><h3 id="（5）使用本地目录安装：">（5）使用本地目录安装：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# cd mychare/<br>[root@master mychare]# vim values.yaml<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304094840738.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304094840738.png" alt="image-20200304094840738"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mychare]# cd templates/<br>[root@master templates]# vim service.yaml<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304095647172.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304095647172.png" alt="image-20200304095647172"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master templates]# cd ..<br>[root@master mychare]# helm install -n test ../mychare/<br>[root@master ~]# helm upgrade test mychare/ -f  mychare/values.yaml<br></code></pre></td></tr></table></figure><h2 id="4、例子">4、例子</h2><p><strong>使用mychart部署一个实例: xgp。使用镜像为私有镜像v1 版本。</strong></p><p><strong>完成之后，镜像版本。</strong></p><p><strong>全部成功之后，将实例做一个升级，将镜像改为v2版本。</strong></p><h3 id="更改镜像为私有镜像">更改镜像为私有镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim mychare/values.yaml<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304104416415.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304104416415.png" alt="image-20200304104416415"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]#  helm install -n xgp mychare/ -f mychare/values.yaml<br>[root@master ~]# kubectl get deployments. -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304104645260.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304104645260.png" alt="image-20200304104645260"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim mychare/values.yaml<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304105120894.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304105120894.png" alt="image-20200304105120894"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# helm upgrade  xgp mychare/  -f mychare/values.yaml <br>[root@master ~]# kubectl get deployments. -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304105211506.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304105211506.png" alt="image-20200304105211506"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl edit deployments. xgp-mychare<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304105334541.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304105334541.png" alt="image-20200304105334541"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get deployments. -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304105359184.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304105359184.png" alt="image-20200304105359184"></a></p><h1>创建自己的Repo仓库</h1><h2 id="1、node01启动一个httpd的容器">1、node01启动一个httpd的容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node01 ~]# mkdir /var/xgp<br>//创建一个目录<br>[root@node01 ~]# docker pull httpd<br>//下载httpd镜像<br>[root@node02 ~]# docker run -d -p 8080:80 -v /var/xgp:/usr/local/apache2/htdocs httpd<br>//启动一个httpd的容器<br></code></pre></td></tr></table></figure><h2 id="2、master节点上，将mychart目录打包。">2、master节点上，将mychart目录打包。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# helm package mychare/<br>Successfully packaged chart and saved it to: /root/mychare-0.1.0.tgz<br></code></pre></td></tr></table></figure><h2 id="3、生成仓库的index文件。">3、生成仓库的index文件。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# mkdir myrepo<br>//创建一个目录存放打包的chare<br>[root@master ~]# mv mychare-0.1.0.tgz myrepo/<br>//移动打包好的文件<br>[root@master ~]# helm repo index myrepo/ --url http://192.168.1.22:8080/charts<br>//生成仓库的index文件<br>[root@master ~]# ls myrepo/<br>index.yaml  mychare-0.1.0.tgz<br></code></pre></td></tr></table></figure><h2 id="4、将生成的tar包和index-yaml上传到node01的-var-www-charts目录下">4、将生成的tar包和index.yaml上传到node01的/var/www/charts目录下.</h2><h3 id="node01创建目录">node01创建目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node01 ~]# mkdir /var/xgp/charts<br></code></pre></td></tr></table></figure><h3 id="master移动动到">master移动动到</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# scp myrepo/* node01:/var/xgp/charts/<br></code></pre></td></tr></table></figure><h3 id="node01查看一下">node01查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node01 ~]# ls /var/xgp/charts/<br>index.yaml  mychare-0.1.0.tgz<br></code></pre></td></tr></table></figure><h2 id="5、添加新的repo仓库。">5、添加新的repo仓库。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# helm repo add newrepo http://192.168.1.22:8080/charts<br>[root@master ~]# helm repo list<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304112410286.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304112410286.png" alt="image-20200304112410286"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# helm search mychare<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304112443931.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304112443931.png" alt="image-20200304112443931"></a></p><h2 id="6、我们就可以直接使用新的repo仓库部署实例了。">6、我们就可以直接使用新的repo仓库部署实例了。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# helm install newrepo/mychare -n wsd<br>[root@master ~]# helm list<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304112515084.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304112515084.png" alt="image-20200304112515084"></a></p><h2 id="7-如果以后仓库中新添加了chart包-需要用helm-repo-update命玲更新本地的index文件。">7.如果以后仓库中新添加了chart包,需要用helm repo update命玲更新本地的index文件。</h2><h3 id="练习：">练习：</h3><h4 id="新创建一个bdqn-的chart包。然后将chart包上传到上述repo源中。">新创建一个bdqn.的chart包。然后将chart包上传到上述repo源中。</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# helm create bdqn<br>[root@master ~]# helm package bdqn/<br>[root@master ~]# mv bdqn-0.1.0.tgz myrepo/<br>[root@master ~]#  helm repo index myrepo/ --url http://192.168.1.22:8080/charts<br>[root@master myrepo]# scp bdqn-0.1.0.tgz index.yaml  node01:/var/xgp/charts<br>[root@master myrepo]# helm repo update<br>[root@master myrepo]# helm search bdqn<br>[root@master myrepo]# helm install http://192.168.1.22:8080/charts/bdqn-0.1.0.tgz<br></code></pre></td></tr></table></figure><h2 id="1）创建helm的私有仓库，以自己的名字命名。">1）创建helm的私有仓库，以自己的名字命名。</h2><h3 id="1、node01启动一个httpd的容器-2">1、node01启动一个httpd的容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node01 ~]# mkdir /var/xgp<br>//创建一个目录<br>[root@node01 ~]# docker pull httpd<br>//下载httpd镜像<br>[root@node02 ~]# docker run -d -p 8080:80 -v /var/xgp:/usr/local/apache2/htdocs httpd<br>//启动一个httpd的容器<br></code></pre></td></tr></table></figure><h3 id="3、生成仓库的index文件。-2">3、生成仓库的index文件。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# mkdir xgprepo<br>//创建一个目录存放打包的chare<br>[root@master ~]# helm repo index xgprepo/ --url http://192.168.1.22:8080/charts<br>//生成仓库的index文件<br></code></pre></td></tr></table></figure><h3 id="4、将生成的index-yaml上传到node01的-var-www-charts目录下">4、将生成的index.yaml上传到node01的/var/www/charts目录下.</h3><h4 id="node01创建目录-2">node01创建目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node01 ~]# mkdir /var/xgp/charts<br></code></pre></td></tr></table></figure><h4 id="master移动动到-2">master移动动到</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# scp xgprepo/* node01:/var/xgp/charts/<br></code></pre></td></tr></table></figure><h4 id="node01查看一下-2">node01查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node01 ~]# ls /var/xgp/charts/<br>index.yaml<br></code></pre></td></tr></table></figure><h3 id="5、添加新的repo仓库">5、添加新的repo仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# helm repo add xgp http://192.168.1.22:8080/charts<br>[root@master ~]# helm repo list<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304132528938.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304132528938.png" alt="image-20200304132528938"></a></p><h2 id="2）-自定义一个chart包，要求这个包运行一个httpd的服务，使用私有镜像v1版本。3个副本Pod，service类型更改为NodePort，端口指定为-30000">2） 自定义一个chart包，要求这个包运行一个httpd的服务，使用私有镜像v1版本。3个副本Pod，service类型更改为NodePort，端口指定为:30000</h2><h4 id="自定义一个chart包">自定义一个chart包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# helm create wsd<br>//创建一个名为wsd的chares包<br></code></pre></td></tr></table></figure><h4 id="按照要求修改配置文件">按照要求修改配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# cd wsd/<br>//进入这个chart包<br>[root@master wsd]# vim values.yaml<br>//修改wsd的配置文件<br>replicaCount: 3                         #三个副本<br><br>image:<br>  repository: 192.168.1.21:5000/web      #更改镜像为私有镜像<br>  tag: v1                                #镜像标签v1<br>  pullPolicy: IfNotPresent              <br><br>imagePullSecrets: []<br>nameOverride: ""<br>fullnameOverride: ""<br><br>service:<br>  type: NodePort              #修改模式为映射端口<br>  port: 80<br>  nodePort: 30000             #添加端口<br><br>[root@master wsd]# vim templates/service.yaml <br><br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: &#123;&#123; include "wsd.fullname" . &#125;&#125;<br>  labels:<br>&#123;&#123; include "wsd.labels" . | indent 4 &#125;&#125;<br>spec:<br>  type: &#123;&#123; .Values.service.type &#125;&#125;<br>  ports:<br>    - port: &#123;&#123; .Values.service.port &#125;&#125;<br>      targetPort: http<br>      protocol: TCP<br>      name: http<br>      nodePort: &#123;&#123; .Values.service.nodePort &#125;&#125;    #“添加”能让服务识别到nodePort的端口<br>  selector:<br>    app.kubernetes.io/name: &#123;&#123; include "wsd.name" . &#125;&#125;<br>    app.kubernetes.io/instance: &#123;&#123; .Release.Name &#125;&#125;<br></code></pre></td></tr></table></figure><h4 id="测试一下">测试一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# helm install -n wsd  wsd/ -f wsd/values.yaml<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304134959273.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304134959273.png" alt="image-20200304134959273"></a></p><h4 id="查看一下镜像版本">查看一下镜像版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get deployments. -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304135106081.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304135106081.png" alt="image-20200304135106081"></a></p><h4 id="访问一下">访问一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# curl 127.0.0.1:30000<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304150609552.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304150609552.png" alt="image-20200304150609552"></a></p><h2 id="3-将实例进行更新，要求镜像生产v2版本。">3) 将实例进行更新，要求镜像生产v2版本。</h2><p><strong>私有镜像和官方镜像升级有所不同，官方的只需通过 （helm upgrade --set imageTag=“标签” 服务名称 charts包名 ）进行更改标签即可，而私有镜像需通过更改values.yaml中的标签才行比较麻烦一点。</strong></p><h3 id="1、修改values-yaml">1、修改values.yaml</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim wsd/values.yaml <br><br><span class="hljs-meta">#</span><span class="bash"> Default values <span class="hljs-keyword">for</span> wsd.</span><br><span class="hljs-meta">#</span><span class="bash"> This is a YAML-formatted file.</span><br><span class="hljs-meta">#</span><span class="bash"> Declare variables to be passed into your templates.</span><br><br>replicaCount: 3<br><br>image:<br>  repository: 192.168.1.21:5000/web<br>  tag: v2                            #修改标签为v2<br>  pullPolicy: IfNotPresent<br>[root@master ~]# helm upgrade wsd wsd/ -f wsd/values.yaml<br>//基于配置文件刷新一下wsd服务<br></code></pre></td></tr></table></figure><h4 id="查看一下">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get deployments. -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304140054269.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304140054269.png" alt="image-20200304140054269"></a></p><h4 id="访问一下-2">访问一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# curl 127.0.0.1:30000<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304150742815.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304150742815.png" alt="image-20200304150742815"></a></p><h3 id="2、使用edit进行版本更新">2、使用edit进行版本更新</h3><p><em><strong>确定wsd这个服务开启</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl edit deployments. wsd<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304140425336.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304140425336.png" alt="img"></a></p><h4 id="查看一下-2">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get deployments. -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304140520342.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304140520342.png" alt="image-20200304140520342"></a></p><h4 id="访问一下-3">访问一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# curl 127.0.0.1:30000<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304150839440.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304150839440.png" alt="image-20200304150839440"></a></p><h2 id="4）重新定义一个chart包，名称为-new-test-将这个包上传到上述私有仓库中。">4）重新定义一个chart包，名称为: new-test,将这个包上传到上述私有仓库中。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# helm repo list<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304142059023.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304142059023.png" alt="image-20200304142059023"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# helm create xgp-wsd<br>//创建一个名为xgp-wsd的charts包<br><br>[root@master ~]# helm package xgp-wsd/<br>//将xgp-wsd打包在当前目录<br><br>[root@master ~]# mv xgp-wsd-0.1.0.tgz xgprepo/<br>//把打包文件放到仓库目录<br><br>[root@master ~]# helm repo index xgprepo/ --url http://192.168.1.22:8080/charts<br>//把仓库目录新加入的charts包信息记录在index.yaml中，使得其他加入的主机可以识别到，仓库的charts包<br><br>[root@master ~]# scp xgprepo/* node01:/var/xgp/charts<br>//将仓库目录的文件移动到httpd服务上，使各个主机可以访问，下载仓库的charts包<br><br>[root@master ~]# helm repo update <br>//更新一下chart存储库<br></code></pre></td></tr></table></figure><h3 id="查看一下-3">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# helm search xgp-wsd<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304142009776.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200304142009776.png" alt="image-20200304142009776"></a></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> helm </tag>
            
            <tag> chares </tag>
            
            <tag> url </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s中helm安装部署，升级和回滚（chart，helm，tiller，StorageClass）</title>
      <link href="/posts/5bc1.html"/>
      <url>/posts/5bc1.html</url>
      
        <content type="html"><![CDATA[<h1>一、Helm介绍</h1><p><strong><code>helm</code>是基于<code>kubernetes</code> 的包管理器。它之于 <code>kubernetes</code> 就如 <code>yum</code> 之于 <code>centos</code>，<code>pip</code> 之于 <code>python，npm</code> 之于 <code>javascript</code></strong></p><p><strong>那 <code>helm</code> 的引入对于管理集群有哪些帮助呢？</strong></p><ul><li><strong>更方便地部署基础设施，如 <code>gitlab</code>，<code>postgres</code>，<code>prometheus</code>，<code>grafana</code> 等</strong></li><li><strong>更方便地部署自己的应用，为公司内部的项目配置 Chart，使用 <code>helm</code> 结合 CI，在 k8s 中部署应用一行命令般简单</strong></li></ul><h2 id="1、Helm用途">1、Helm用途</h2><p><strong>Helm把Kubernetes资源(比如deployments、services或 ingress等) 打包到一个chart中，而chart被保存到chart仓库。通过chart仓库可用来存储和分享chart。Helm使发布可配置，支持发布应用配置的版本管理，简化了Kubernetes部署应用的版本控制、打包、发布、删除、更新等操作。</strong></p><p><strong>做为Kubernetes的一个包管理工具，用来管理charts——预先配置好的安装包资源，有点类似于Ubuntu的APT和CentOS中的yum。</strong></p><h4 id="Helm具有如下功能：">Helm具有如下功能：</h4><ul><li><strong>创建新的chart</strong></li><li><strong>chart打包成tgz格式</strong></li><li><strong>上传chart到chart仓库或从仓库中下载chart</strong></li><li><strong>在Kubernetes集群中安装或卸载chart</strong></li><li><strong>管理用Helm安装的chart的发布周期</strong></li></ul><h4 id="使用Helm可以完成以下事情：">使用Helm可以完成以下事情：</h4><ul><li><strong>管理Kubernetes manifest files</strong></li><li><strong>管理Helm安装包charts</strong></li><li><strong>基于chart的Kubernetes应用分发</strong></li></ul><h2 id="2、Helm组件及相关术语">2、Helm组件及相关术语</h2><p><strong>开始接触Helm时遇到的一个常见问题就是Helm中的一些概念和术语非常让人迷惑，我开始学习Helm就遇到这个问题。</strong></p><p><strong>因此我们先了解一下Helm的这些相关概念和术语。</strong></p><h3 id="包管理工具"><strong>包管理工具:</strong></h3><ul><li><p><strong>Helm: Kubernetes的应用打包工具，也是命令行工具的名称。</strong></p></li><li><p><strong>Helm CLI：是 Helm 客户端，可以在本地执行</strong></p></li><li><p><strong>Tiller: Helm的服务端，部署在Kubernetes集群中，用于处理Helm的相关命令。</strong></p><blockquote><p><strong>helm的作用：像centos7中的yum命令一样，管理软件包，只不过helm这儿管理的是在k8s上安装的各种容器。</strong></p><p><strong>tiller的作用：像centos7的软件仓库一样，简单说类似于/etc/yum.repos.d目录下的xxx.repo。</strong></p></blockquote></li><li><p><strong>Repoistory: Helm的软件仓库，repository本质上是一个web服务器，该服务器保存了chart软件包以供下载，并有提供一个该repository的chart包的清单文件以供查询。在使用时，Helm可以对接多个不同的Repository。</strong></p></li><li><p><strong>Charts：是一个Helm的程序包，它包含了运行一个kubernetes应用程序所需要的镜像、依赖关系和资源定义等。</strong></p></li><li><p><strong>Release：应用程序运行Charts之后，得到的一个实例。</strong></p><blockquote><p><strong>需要特别注意的是， Helm中提到的Release和我们通常概念中的版本有所不同，这里的Release可以理解为Helm使用Chart包部署的一个应用实例。</strong></p><p><strong>其实Helm中的Release叫做Deployment更合适。估计因为Deployment这个概念已经被Kubernetes使用了，因此Helm才采用了Release这个术语。</strong></p></blockquote></li></ul><h3 id="命令介绍">命令介绍</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# helm search<br>//查看可用的Charts包<br>[root@master ~]# helm inspect  stable/redis<br>//查看stable/redis包的详细信息<br>[root@master mysql]# helm fetch stable/mysql<br>//直接下载stable/mysql的chart包<br>[root@master ~]# helm install stable/redis -n redis --dry-run <br>//基于stable/redis包运行一个名为redis的服务（把--dry-run去掉之后相当于安装了一个服务）<br>[root@master ~]# helm list<br>//查看安装的服务<br>[root@master ~]# helm delete redis<br>//删除这个服务<br>[root@master mysql]# helm upgrade --set imageTag=5.7.15 xgp-mysql stable/mysql -f values.yaml <br>//mysql服务的升级<br>[root@master mysql]#  helm history xgp-mysql<br>//查看历史版本<br>[root@master mysql]# helm rollback xgp-mysql 1  <br>//回滚到版本一<br></code></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">http://<span class="hljs-title">hub.kubeapps.com</span>/</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">completion</span>  # 为指定的<span class="hljs-title">shell</span>生成自动完成脚本（<span class="hljs-title">bash</span>或<span class="hljs-title">zsh</span>）</span><br><span class="hljs-function"><span class="hljs-title">create</span>      # 创建一个具有给定名称的新 <span class="hljs-title">chart</span></span><br><span class="hljs-function"><span class="hljs-title">delete</span>      # 从 <span class="hljs-title">Kubernetes</span> 删除指定名称的 <span class="hljs-title">release</span></span><br><span class="hljs-function"><span class="hljs-title">dependency</span>  # 管理 <span class="hljs-title">chart</span> 的依赖关系</span><br><span class="hljs-function"><span class="hljs-title">fetch</span>       # 从存储库下载 <span class="hljs-title">chart</span> 并（可选）将其解压缩到本地目录中</span><br><span class="hljs-function"><span class="hljs-title">get</span>         # 下载一个命名 <span class="hljs-title">release</span></span><br><span class="hljs-function"><span class="hljs-title">help</span>        # 列出所有帮助信息</span><br><span class="hljs-function"><span class="hljs-title">history</span>     # 获取 <span class="hljs-title">release</span> 历史</span><br><span class="hljs-function"><span class="hljs-title">home</span>        # 显示 <span class="hljs-title">HELM_HOME</span> 的位置</span><br><span class="hljs-function"><span class="hljs-title">init</span>        # 在客户端和服务器上初始化<span class="hljs-title">Helm</span></span><br><span class="hljs-function"><span class="hljs-title">inspect</span>     # 检查 <span class="hljs-title">chart</span> 详细信息</span><br><span class="hljs-function"><span class="hljs-title">install</span>     # 安装 <span class="hljs-title">chart</span> 存档</span><br><span class="hljs-function"><span class="hljs-title">lint</span>        # 对 <span class="hljs-title">chart</span> 进行语法检查</span><br><span class="hljs-function"><span class="hljs-title">list</span>        # <span class="hljs-title">releases</span> 列表</span><br><span class="hljs-function"><span class="hljs-title">package</span>     # 将 <span class="hljs-title">chart</span> 目录打包成 <span class="hljs-title">chart</span> 档案</span><br><span class="hljs-function"><span class="hljs-title">plugin</span>      # 添加列表或删除 <span class="hljs-title">helm</span> 插件</span><br><span class="hljs-function"><span class="hljs-title">repo</span>        # 添加列表删除更新和索引 <span class="hljs-title">chart</span> 存储库</span><br><span class="hljs-function"><span class="hljs-title">reset</span>       # 从集群中卸载 <span class="hljs-title">Tiller</span></span><br><span class="hljs-function"><span class="hljs-title">rollback</span>    # 将版本回滚到以前的版本</span><br><span class="hljs-function"><span class="hljs-title">search</span>      # 在 <span class="hljs-title">chart</span> 存储库中搜索关键字</span><br><span class="hljs-function"><span class="hljs-title">serve</span>       # 启动本地<span class="hljs-title">http</span>网络服务器</span><br><span class="hljs-function"><span class="hljs-title">status</span>      # 显示指定 <span class="hljs-title">release</span> 的状态</span><br><span class="hljs-function"><span class="hljs-title">template</span>    # 本地渲染模板</span><br><span class="hljs-function"><span class="hljs-title">test</span>        # 测试一个 <span class="hljs-title">release</span></span><br><span class="hljs-function"><span class="hljs-title">upgrade</span>     # 升级一个 <span class="hljs-title">release</span></span><br><span class="hljs-function"><span class="hljs-title">verify</span>      # 验证给定路径上的 <span class="hljs-title">chart</span> 是否已签名且有效</span><br><span class="hljs-function"><span class="hljs-title">version</span>     # 打印客户端/服务器版本信息</span><br><span class="hljs-function"><span class="hljs-title">dep</span>         # 分析 <span class="hljs-title">Chart</span> 并下载依赖</span><br></code></pre></td></tr></table></figure><h2 id="3、组件架构">3、组件架构</h2><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200302214010170.png" alt></p><p><strong><code>Helm Client</code> 是用户命令行工具，其主要负责如下：</strong></p><ul><li><strong>本地 chart 开发</strong></li><li><strong>仓库管理</strong></li><li><strong>与 Tiller sever 交互</strong></li><li><strong>发送预安装的 chart</strong></li><li><strong>查询 release 信息</strong></li><li><strong>要求升级或卸载已存在的 release</strong></li></ul><p><strong><code>Tiller Server</code>是一个部署在<code>Kubernetes</code>集群内部的 server，其与 Helm client、Kubernetes API server 进行交互。Tiller server 主要负责如下：</strong></p><ul><li><strong>监听来自 Helm client 的请求</strong></li><li><strong>通过 chart 及其配置构建一次发布</strong></li><li><strong>安装 chart 到<code>Kubernetes</code>集群，并跟踪随后的发布</strong></li><li><strong>通过与<code>Kubernetes</code>交互升级或卸载 chart</strong></li><li><strong>简单的说，client 管理 charts，而 server 管理发布 release</strong></li></ul><h3 id="helm客户端">helm客户端</h3><p><strong>helm客户端是一个命令行工具，负责管理charts、reprepository和release。它通过gPRC API（使用kubectl port-forward将tiller的端口映射到本地，然后再通过映射后的端口跟tiller通信）向tiller发送请求，并由tiller来管理对应的Kubernetes资源。</strong></p><h3 id="tiller服务端">tiller服务端</h3><p><strong>tiller接收来自helm客户端的请求，并把相关资源的操作发送到Kubernetes，负责管理（安装、查询、升级或删除等）和跟踪Kubernetes资源。为了方便管理，tiller把release的相关信息保存在kubernetes的ConfigMap中。</strong><br><strong>tiller对外暴露gRPC API，供helm客户端调用。</strong></p><h2 id="4、工作原理">4、工作原理</h2><h4 id="Chart-Install-过程："><strong>Chart Install 过程：</strong></h4><ul><li><strong>Helm从指定的目录或者tgz文件中解析出Chart结构信息</strong></li><li><strong>Helm将指定的Chart结构和Values信息通过gRPC传递给Tiller</strong></li><li><strong>Tiller根据Chart和Values生成一个Release</strong></li><li><strong>Tiller将Release发送给Kubernetes运行。</strong></li></ul><h4 id="Chart-Update过程："><strong>Chart Update过程：</strong></h4><ul><li><strong>Helm从指定的目录或者tgz文件中解析出Chart结构信息</strong></li><li><strong>Helm将要更新的Release的名称和Chart结构，Values信息传递给Tiller</strong></li><li><strong>Tiller生成Release并更新指定名称的Release的History</strong></li><li><strong>Tiller将Release发送给Kubernetes运行</strong></li></ul><h4 id="Chart-Rollback">Chart Rollback</h4><ul><li><strong>helm将会滚的release名称传递给tiller</strong></li><li><strong>tiller根据release名称查找history</strong></li><li><strong>tiller从history中获取到上一个release</strong></li><li><strong>tiller将上一个release发送给kubernetes用于替换当前release</strong></li></ul><h4 id="Chart处理依赖">Chart处理依赖</h4><p><strong>Tiller 在处理 Chart 时，直接将 Chart 以及其依赖的所有 Charts 合并为一个 Release，同时传递给 Kubernetes。因此 Tiller 并不负责管理依赖之间的启动顺序。Chart 中的应用需要能够自行处理依赖关系。</strong></p><h1>二、安装部署helm工具（客户端）</h1><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302084446678.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302084446678.png" alt="image-20200302084446678"></a></p><h4 id="前提要求"><strong>前提要求</strong></h4><ul><li><strong>Kubernetes1.5以上版本</strong></li><li><strong>集群可访问到的镜像仓库</strong></li><li><strong>执行helm命令的主机可以访问到kubernetes集群</strong></li></ul><h3 id="（1）下载helm的包">（1）下载helm的包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]#docker pull gcr.io/kubernetes-helm/tiller:v2.14.3<br>[root@master ~]# wget https://get.helm.sh/helm-v2.14.3-linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><h3 id="（2）把helm包的命令，复制到本地">（2）把helm包的命令，复制到本地</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master helm]# mv linux-amd64/helm /usr/local/bin/<br>//移动命令目录到/usr/local/bin/<br>[root@master helm]# chmod +x /usr/local/bin/helm <br>//给予执行权限<br>[root@master helm]# helm help<br>//验证是否安装成功<br></code></pre></td></tr></table></figure><h3 id="（3）设置命令自动补全">（3）设置命令自动补全</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master helm]#  echo 'source &lt;(helm completion bash)' &gt;&gt; /etc/profile<br>[root@master helm]# . /etc/profile<br>//刷新一下<br></code></pre></td></tr></table></figure><h2 id="2、安装Tiller-server（服务端，需要创建授权用户）">2、安装Tiller server（服务端，需要创建授权用户）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim tiller-rbac.yaml   #创建授权用户<br>apiVersion: v1<br>kind: ServiceAccount<br>metadata:<br>  name: tiller<br>  namespace: kube-system<br>---<br>apiVersion: rbac.authorization.k8s.io/v1beta1<br>kind: ClusterRoleBinding<br>metadata:<br>  name: tiller<br>roleRef:<br>  apiGroup: rbac.authorization.k8s.io<br>  kind: ClusterRole<br>  name: cluster-admin<br>subjects:<br>  - kind: ServiceAccount<br>    name: tiller<br>    namespace: kube-system<br></code></pre></td></tr></table></figure><h4 id="执行一下">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f tiller-rbac.yaml<br></code></pre></td></tr></table></figure><h3 id="（1）Tiller-server的环境初始化">（1）Tiller server的环境初始化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master helm]# helm init  --service-account=tiller<br>//helm的服务端就是Tiller（因为是访问外国的网站，可能需要多次执行）<br></code></pre></td></tr></table></figure><h4 id="查看一下">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master helm]# kubectl get deployment. -n kube-system<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228120107088.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228120107088.png" alt="image-20200228120107088"></a></p><p><strong>现在发现没有开启，那是因为默认下载的Google的镜像，下载不下来</strong></p><h3 id="（2）设置镜像源改为阿里云的">（2）设置镜像源改为阿里云的</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master helm]# helm repo add stable https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts<br></code></pre></td></tr></table></figure><h4 id="查看一下-2">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master helm]# helm version<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228120548734.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228120548734.png" alt="image-20200228120548734"></a></p><h2 id="3、部署一个实例helm-install-charts-n-Release名称。">3、部署一个实例helm install + charts -n Release名称。</h2><blockquote><p><strong>1、关于这个Release的描述。</strong></p><p><strong>2、关于这个Release资源的描述。</strong></p><p><strong>3、怎么使用这个Release。</strong></p></blockquote><h3 id="（1）Helm部署安装一个Mysql服务。">（1）Helm部署安装一个Mysql服务。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# helm search mysql<br>//查看关于mysqk的Charts包<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302091903599.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302091903599.png" alt="image-20200302091903599"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# helm install stable/mysql -n mysql <br>//基于stable/mysql包安装一个名为MySQL的服务<br></code></pre></td></tr></table></figure><h3 id="查看一下-3">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# helm list<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302092055970.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302092055970.png" alt="image-20200302092055970"></a></p><h3 id="（2）Charts包解压过后的目录">（2）Charts包解压过后的目录:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# cd .helm/cache/archive<br>//查看helm缓存<br>[root@master archive]# ls<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302093625736.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302093625736.png" alt="image-20200302093625736"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]# helm fetch stable/mysql<br>//直接下载stable/mysql的chart包<br>[root@master archive]# tar -zxf mysql-0.3.5.tgz <br>//解压一下MySQL包<br>[root@master archive]# tree -C mysql <br>//树状图查看解压出来的mysql目录，-C:显示颜色<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302093816396.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302093816396.png" alt="image-20200302093816396"></a></p><blockquote><p><strong>Chart.yaml：这个chart包的概要信息。（name和version 这两是必填项，其他可选。）</strong></p><p><strong>README md：是这个chart包的一个使用帮助文档。</strong></p><p><strong>templates：chart包内各种资源对象的模板。</strong></p><blockquote><p><strong>deployment.yaml：deployment 控制器的 Go 模板文件</strong></p><p><strong>_helpers.tpl：以 _ 开头的文件不会部署到 k8s 上，可用于定制通用信息</strong></p><p><strong>NOTES.txt：Chart 部署到集群后的一些信息</strong></p><p><strong>service.yaml：service 的 Go 模板文件</strong></p></blockquote><p><strong>values.yaml：是这个chart包的默认的值，可以被templet内的yaml文件使用。</strong></p></blockquote><h3 id="（3）Helm部署安装-个Mysql服务。">（3）Helm部署安装-个Mysql服务。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# docker pull mysql:5.7.14<br>[root@master ~]# docker pull mysql:5.7.15<br>[root@master ~]# docker pull busybox:1.25.0<br>下载所需的mysql镜像<br>[root@master ~]# helm delete mysql --purge <br>//删除之前的MySQL服务并清除缓存<br></code></pre></td></tr></table></figure><h3 id="（4）设置共享目录">（4）设置共享目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# yum -y install rpcbind nfs-utils<br>//安装nfs<br>[root@master ~]# mkdir /data<br>//创建共享目录<br>[root@master ~]# vim /etc/exports<br>/data *(rw,sync,no_root_squash)<br>//设置共享目录权限<br>[root@master ~]# systemctl restart rpcbind<br>[root@master ~]# systemctl restart nfs-server<br>//重启nfs服务<br><br>测试一下<br>[root@master ~]# showmount -e<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302105307662.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302105307662.png" alt="image-20200302105307662"></a></p><h3 id="（5）创建pv">（5）创建pv</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# vim nfs-pv1.yml <br>apiVersion: v1<br>kind: PersistentVolume<br>metadata:<br>  name: mysqlpv<br>spec:<br>  capacity:<br>    storage: 8Gi<br>  accessModes:<br>    - ReadWriteOnce<br>  persistentVolumeReclaimPolicy: Recycle<br>  nfs:<br>    path: /data/mysqlpv<br>    server: 192.168.1.21<br>[root@master xgp]# mkdir /data/mysqlpv<br>//创建所需目录<br></code></pre></td></tr></table></figure><h4 id="执行一下-2">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# kubectl apply -f nfs-pv1.yml<br></code></pre></td></tr></table></figure><h4 id="查看一下-4">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# kubectl get pv<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302110137247.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302110137247.png" alt="image-20200302110137247"></a></p><h3 id="（6）创建一个mysql服务">（6）创建一个mysql服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# helm install stable/mysql -n bdqn-mysql --set mysqlRootPassword=123.com<br></code></pre></td></tr></table></figure><h4 id="查看一下-5">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302111518710.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302111518710.png" alt="image-20200302111518710"></a></p><h3 id="（7）进入pod并查看一下">（7）进入pod并查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# kubectl exec -it bdqn-mysql-mysql-7b89c7b99-8ff2r -- mysql -u root -p123.com<br><span class="hljs-meta">mysql&gt;</span><span class="bash"> show databases;</span><br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>+--------------------+<br>4 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><h2 id="4、mysql服务的升级与回滚">4、mysql服务的升级与回滚</h2><h3 id="（1）mysql服务的升级">（1）mysql服务的升级</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]# helm upgrade --set imageTag=5.7.15 bdqn-mysql stable/mysql -f values.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-6">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]# kubectl get deployments. -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302115511986.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302115511986.png" alt="image-20200302115511986"></a></p><h3 id="（2）mysql服务的回滚">（2）mysql服务的回滚</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]#  helm history bdqn-mysql<br>//查看历史版本<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302115645118.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302115645118.png" alt="image-20200302115645118"></a></p><h4 id="回滚到版本一">回滚到版本一</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]# helm rollback bdqn-mysql 1<br></code></pre></td></tr></table></figure><h4 id="查看一下-7">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]# kubectl get deployments. -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302115823991.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302115823991.png" alt="image-20200302115823991"></a></p><h1>三、小实验</h1><p><strong>在部署mysql的时候，如何开启storageclass，以及如何将service资源对象的类型更改为NodePort, 如何使用?</strong></p><p><strong>将上述部署的实例进行升级回滚操作。升级的时候镜像改为： mysql:5.7.15版本。回滚到最初的版本。</strong></p><h2 id="1、基于NFS服务，创建NFS服务。">1、基于NFS服务，创建NFS服务。</h2><p><strong>下载nfs所需安装包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node02 ~]# yum -y install nfs-utils  rpcbind<br></code></pre></td></tr></table></figure><p><strong>创建共享目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# mkdir -p /xgp/wsd<br></code></pre></td></tr></table></figure><p><strong>创建共享目录的权限</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim /etc/exports<br>/xgp *(rw,sync,no_root_squash)<br></code></pre></td></tr></table></figure><p><strong>开启nfs和rpcbind（三台都要）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# systemctl start nfs-server.service <br>[root@master ~]# systemctl start rpcbind<br></code></pre></td></tr></table></figure><p><strong>测试一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# showmount -e<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302143413268.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302143413268.png" alt="image-20200302143413268"></a></p><h2 id="2、创建StorageClass资源对象。">2、创建StorageClass资源对象。</h2><h3 id="（1）创建rbac权限。">（1）创建rbac权限。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim rbac.yaml <br>apiVersion: v1<br>kind: ServiceAccount<br>metadata:<br>  name: nfs-provisioner<br>  namespace: default<br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRole<br>metadata:<br>  name: nfs-provisioner-runner<br>  namespace: default<br>rules:<br>   -  apiGroups: [""]<br>      resources: ["persistentvolumes"]<br>      verbs: ["get", "list", "watch", "create", "delete"]<br>   -  apiGroups: [""]<br>      resources: ["persistentvolumeclaims"]<br>      verbs: ["get", "list", "watch", "update"]<br>   -  apiGroups: ["storage.k8s.io"]<br>      resources: ["storageclasses"]<br>      verbs: ["get", "list", "watch"]<br>   -  apiGroups: [""]<br>      resources: ["events"]<br>      verbs: ["watch", "create", "update", "patch"]<br>   -  apiGroups: [""]<br>      resources: ["services", "endpoints"]<br>      verbs: ["get","create","list", "watch","update"]<br>   -  apiGroups: ["extensions"]<br>      resources: ["podsecuritypolicies"]<br>      resourceNames: ["nfs-provisioner"]<br>      verbs: ["use"]<br>---<br>kind: ClusterRoleBinding<br>apiVersion: rbac.authorization.k8s.io/v1<br>metadata:<br>  name: run-nfs-provisioner<br>subjects:<br>  - kind: ServiceAccount<br>    name: nfs-provisioner<br>    namespace: default        #必写字段<br>roleRef:<br>  kind: ClusterRole<br>  name: nfs-provisioner-runner<br>  apiGroup: rbac.authorization.k8s.io<br></code></pre></td></tr></table></figure><h4 id="执行一下-3">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f rbac.yaml<br></code></pre></td></tr></table></figure><h3 id="（2）创建Deployment资源对象，用Pod代替-真正的NFS服务。">（2）创建Deployment资源对象，用Pod代替 真正的NFS服务。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim nfs-deployment.yaml <br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: nfs-client-provisioner<br>spec:<br>  replicas: 1<br>  strategy:<br>    type: Recreate<br>  template:<br>    metadata:<br>      labels:<br>        app: nfs-client-provisioner<br>    spec:<br>      serviceAccount: nfs-provisioner<br>      containers:<br>        - name: nfs-client-provisioner<br>          image: registry.cn-hangzhou.aliyuncs.com/open-ali/nfs-client-provisioner<br>          volumeMounts:<br>            - name: nfs-client-root<br>              mountPath:  /persistentvolumes<br>          env:<br>            - name: PROVISIONER_NAME<br>              value: xgp<br>            - name: NFS_SERVER<br>              value: 192.168.1.21<br>            - name: NFS_PATH<br>              value: /xgp/wsd<br>      volumes:<br>        - name: nfs-client-root<br>          nfs:<br>            server: 192.168.1.21<br>            path: /xgp/wsd<br></code></pre></td></tr></table></figure><h4 id="执行一下-4">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f nfs-deployment.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-8">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212104037272.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212104037272.png" alt="image-20200212104037272"></a></p><h3 id="（3）创建storageclass的yaml文件">（3）创建storageclass的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim xgp-storageclass.yaml <br>apiVersion: storage.k8s.io/v1<br>kind: StorageClass<br>metadata:<br>  name: xgp-nfs<br>provisioner: xgp  #通过provisioner字段关联到上述Deploy<br>reclaimPolicy: Retain<br></code></pre></td></tr></table></figure><h4 id="执行一下-5">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f test-storageclass.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-9">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get sc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302163422262.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302163422262.png" alt="image-20200302163422262"></a></p><h2 id="3、创建一个mysql服务">3、创建一个mysql服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# docker pull mysql:5.7.14<br>[root@master ~]# docker pull mysql:5.7.15<br>[root@master ~]# docker pull busybox:1.25.0<br>//下载所需镜像<br>[root@master yaml]# helm fetch stable/mysql<br>//直接下载stable/mysql的chart包<br>[root@master yaml]# tar -zxf mysql-0.3.5.tgz <br>//解压mysql包<br>[root@master yaml]# cd mysql/<br>[root@master mysql]# vim values.yaml <br>//修改values.yaml文件，添加storageClass存储卷和更改svc的模式为NodePort<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302164514380.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302164514380.png" alt="image-20200302164514380"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302164620871.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302164620871.png" alt="image-20200302164620871"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]# helm install stable/mysql -n xgp-mysql --set mysqlRootPassword=123.com -f values.yaml <br>//基于values.yaml和stable/mysql开启一个密码为123.com的mysqlpod<br></code></pre></td></tr></table></figure><h3 id="查看一下-10">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]# kubectl get svc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302174753877.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302174753877.png" alt="image-20200302174753877"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]# kubectl get pod -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302170330864.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302170330864.png" alt="image-20200302170330864"></a></p><h2 id="4、进入pod并查看一下">4、进入pod并查看一下</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]#  kubectl exec -it xgp-mysql-mysql-67c6fb5f9-dn7s2 -- mysql -u root -p123.com<br><span class="hljs-meta">mysql&gt;</span><span class="bash"> show databases;</span><br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>+--------------------+<br>4 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><h2 id="5、mysql服务的升级与回滚">5、mysql服务的升级与回滚</h2><h3 id="（1）mysql服务的升级-2">（1）mysql服务的升级</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]# helm upgrade --set imageTag=5.7.15 xgp-mysql stable/mysql -f values.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-11">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]# kubectl get deployments. -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302115511986.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302115511986.png" alt="image-20200302115511986"></a></p><h3 id="（2）服务的回滚">（2）服务的回滚</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]#  helm history xgp-mysql<br>//查看历史版本<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302175135110.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302175135110.png" alt="image-20200302175135110"></a></p><h4 id="回滚到版本一-2">回滚到版本一</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]# helm rollback xgp-mysql 1<br></code></pre></td></tr></table></figure><h4 id="查看一下-12">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]# kubectl get deployments. -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302115823991.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200302115823991.png" alt="image-20200302115823991"></a></p><h2 id="6、进入pod并查看一下">6、进入pod并查看一下</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master mysql]#  kubectl exec -it xgp-mysql-mysql-67c6fb5f9-dn7s2 -- mysql -u root -p123.com<br><span class="hljs-meta">mysql&gt;</span><span class="bash"> show databases;</span><br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>+--------------------+<br>4 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><h1>四、总结</h1><p><strong>Helm作为kubernetes应用的包管理以及部署工具，提供了应用打包，发布，版本管理以及部署，升级，回退等功能。Helm以Chart软件包的形式简化Kubernetes的应用管理，提高了对用户的友好性。</strong></p><h2 id="使用心得">使用心得</h2><p><strong>helm 客户端的功能非常简单，直接参考官网文档即可。</strong></p><p><strong>列一下相关使用心得：</strong></p><ul><li><strong>Helm 的所有功能都是围绕着 chart、release 和 repository 的；</strong></li><li><strong>仅初始化客户端相关配置且仅建立本地仓库，可执行 <code>helm init --client-only --skip-refresh</code>；</strong></li><li><strong>查找 chart 的方式是通过 HELM_HOME（默认是 ~/.helm 目录）下的 repositories 目录进行的，几个重要文件或目录为 cache、repositories/cache；</strong></li><li><strong>修改 chart index.yaml 的 url，可执行 <code>helm serve --url http://demo.com</code> 来重新 reindex；</strong></li><li><strong>依赖关系管理，requirements定义，子 chart 值定义；</strong></li><li><strong>install 、 update 的方式管理不方便，这样需要维护 chart 的版本关系，集成 install 和 update ，组成类似 k8s 中的 apply 命令；</strong></li><li><strong>package 命令 -u 可以更新依赖，建议推到 repositiories 前先 package ，否则后期可能出现依赖检测不全的错误；</strong></li><li><strong>release 相关的信息存储在 k8s 的 configmap 中，命名形式为 release_name.v1 的格式。 rollback 相关功能就是通过存储在 configmap 中的信息进行回滚的；</strong></li><li><strong>Helm 客户端与 k8s 中的 TillerServer 是通过 k8s 提供的 port-forward 来实现的，而 port-forward 需要在指定节点上部署 socat；</strong></li><li><strong>TillerServer 可以不部署在 k8s 中， 此时 Helm 客户端需要通过 HELM_HOST 环境变量来指定 TillerServer 的地址和端口；</strong></li><li><strong>建议 TillerServer 部署在 k8s 中，既然 Helm 为 CNCF 的一员，那么就尽量把云原生做到极致吧；</strong></li><li><strong>写 chart 时多参考官方最佳实践，<a href="https://docs.helm.sh/chart_best_practices/" target="_blank" rel="noopener">The Chart Best Practices Guide</a>；</strong></li></ul><h2 id="不足">不足</h2><p><strong>Helm 虽然提供了 install、update 命令来安装或更新对应的 release，但这给使用者带来了需要维护 release 状态的压力。举个例子，在还没安装 release 之前，release 是不存在的，update 操作是会失败的。反之已经存在的 release，install 操作也会失败。其实大部分情况下我是不需要知道 release 的状态的，不管它存在还是不存在，我执行的命令就是我希望的意图，我希望 release 能成为我执行命令后的状态。这一点上 k8s 的 apply 命令就非常好，不需要用户来维护资源的状态。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chart </tag>
            
            <tag> helm </tag>
            
            <tag> tiller </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s的HPA自动扩容与缩容</title>
      <link href="/posts/5f70.html"/>
      <url>/posts/5f70.html</url>
      
        <content type="html"><![CDATA[<h1>HPA介绍</h1><p><strong>Kubernetes HPA（水平Pod自动缩放）Pod水平自动伸缩，通过此功能，只需简单的配置，即可便可以利用监控指标（cpu使用率、磁盘、内存等）自动的扩容或缩容服务中Pod数量，当业务需求增加时，系统将为您无缝地自动增加适量容器，提高系统稳定性。此处将详细讲解HPA的核心设计原理和基于Hepaster的使用方法</strong>。</p><h3 id="前提条件">前提条件</h3><p><strong>系统应该能否获取到当前Pod的资源使用情况 (意思是可以执行kubectl top pod命令,并且能够得到反馈信息)。</strong></p><p><strong>若要实现自动扩缩容的功能，还需要部署heapster服务，用来收集及统计资源的利用率，支持kubectl top命令，heapster服务集成在prometheus（普罗米修斯） MertricServer服务中，所以说，为了方便，我这里基于prometheus服务的环境上进行部署HPA（动态扩缩容）的服务。</strong></p><h3 id="实验环境">实验环境</h3><table><thead><tr><th>主机</th><th>IP地址</th><th>服务</th></tr></thead><tbody><tr><td>master</td><td>192.168.1.21</td><td>k8s</td></tr><tr><td>node01</td><td>192.168.1.22</td><td>k8s</td></tr><tr><td>node02</td><td>192.168.1.23</td><td>k8s</td></tr></tbody></table><p><strong>基于<a href>https://blog.51cto.com/14320361/2473879</a> 的实验继续进行</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/20200607215857.png" alt="k8s的HPA自动扩容与缩容"></p><ul><li><strong>heapster：这个组件之前是集成在k8s集群的,不过在1.12版本之后被移除了。如果还想使用此功能，应该部署metricServer, 这个k8s集群资源使用情况的聚合器。</strong></li><li><strong>Cousom：同样处于beta阶段(autoscaling/v2beta1)，但是涉及到自定义的REST API的开发，复杂度会大一些，并且当需要从自定义的监控中获取数据时，只能设置绝对值，无法设置使用率。</strong></li></ul><h4 id="自动扩展主要分为两种：">自动扩展主要分为两种：</h4><ul><li><strong>水平扩展(scale out)，针对于实例数目的增减。</strong></li><li><strong>垂直扩展(scal up)，即单个实例可以使用的资源的增减, 比如增加cpu和增大内存。</strong><br><strong>HPA属于前者。它可以根据CPU使用率或应用自定义metrics自动扩展Pod数量(支持 replication controller、deployment 和 replica set)。</strong></li></ul><h3 id="工作流程">工作流程</h3><ul><li><strong>创建HPA资源，设定目标CPU使用率限额，以及最大/最小实例数，一定要设置Pod的资源限制参数: request，否则HPA不会工作。</strong></li><li><strong>控制管理器每隔30s(在kube-controller-manager.service中可以通过–-horizontal-pod-autoscaler-sync-period修改)查询metrics的资源使用情况。</strong></li><li><strong>然后与创建时设定的值和指标做对比(平均值之和/限额)，求出目标调整的实例个数。</strong></li><li><strong>目标调整的实例数不能超过第一条中设定的最大/最小实例数。如果没有超过，则扩容；超过，则扩容至最大的实例个数。</strong></li><li><strong>重复第2-4步。</strong></li></ul><p><strong>这里，我们使用一个测试镜像， 这个镜像基于php-apache制作的docker镜像，包含了一些可以运行cpu密集计算任务的代码。</strong></p><h2 id="1、创建一个deployment控制器">1、创建一个deployment控制器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]#docker pull mirrorgooglecontainers/hpa-example:latest<br>//下载hpa-example镜像<br><br>[root@master ~]# kubectl run php-apache --image=mirrorgooglecontainers/hpa-example --requests=cpu=200m --expose  --port=80<br>//基于hpa-example镜像，运行一个deployment控制器，请求CPU的资源为200m，暴露一个80端口<br></code></pre></td></tr></table></figure><h3 id="查看一下">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get deployments.<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228102643352.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228102643352.png" alt="image-20200228102643352"></a></p><h2 id="2、创建HPA控制器">2、创建HPA控制器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl autoscale deployment php-apache --cpu-percent=50 --min=1 --max=10<br>//当deployment资源对象的CPU使用率达到50%时，就进行扩容，最多可以扩容到10个<br></code></pre></td></tr></table></figure><h3 id="查看一下-2">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get hpa<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228101908398.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228101908398.png" alt="image-20200228101908398"></a></p><h2 id="3、测试（master开启三个端口）">3、测试（master开启三个端口）</h2><p><strong>新开启多个终端，对pod进行死循环请求php-apache的pod</strong></p><h3 id="端口一">端口一</h3><h4 id="（1）创建一个应用，用来不停的访问我们刚刚创建的php-apache的svc资源。">（1）创建一个应用，用来不停的访问我们刚刚创建的php-apache的svc资源。</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl run -i --tty load-generator --image=busybox /bin/sh<br></code></pre></td></tr></table></figure><h4 id="（2）进入Pod内，执行以下这条命令-用来模拟访问php-apache的svc资源。">（2）进入Pod内，执行以下这条命令.用来模拟访问php-apache的svc资源。</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# while true; do wget -q -O- http://php-apache.default.svc.cluster.local ; done<br>//不停地向php-apache的svc资源，发送ok<br></code></pre></td></tr></table></figure><h3 id="端口二">端口二</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get hpa -w<br>//实时查看pod的cpu状态<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200228133816724.png" alt="image-20200228133816724"></p><p><strong>可以看到php-apache的cpu使用情况已经超过了50%</strong></p><h3 id="端口三">端口三</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master images]# kubectl get pod -w<br>//实时查看pod的状态<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200228134105507.png" alt="image-20200228134105507"></p><p><strong>可以看到当php-apache的cpu使用情况超过50%后，就会不断生成新的php-apache来进行负载均衡（目前设置的上线时10个），当然，如果cpu使用情况下降到50%，master就会陆续地删除php-apache，这样的使用可以减少不必要的资源浪费、资源分配不均等情况。</strong></p><h1>二、资源限制</h1><h2 id="1、基于Pod">1、基于Pod</h2><p><strong>Kubernetes对资源的限制实际上是通过cgroup来控制的，cgroup 是容器的一组用来控制内核如何运行进程的相关属性集合。针对内存、CPU 和各种设备都有对应的cgroup</strong></p><p><strong>默认情况下，Pod运行没有CPU和内存的限额。这意味着系统中的任何 Pod将能够像执行该Pod所在的节点一样，消耗足够多的CPU和内存。一般会针对某些应用的pod资源进行资源限制，这个资源限制是通过</strong></p><p><strong>resources的requests和limits来实现</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim cgroup-pod.yaml<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200228153809932.png" alt="image-20200228153809932"></p><p><strong>requests: 要分配的资源，limits为最高请求的资源值。可以简单的理解为初始值和最大值。</strong></p><h2 id="2、基于名称空间"><strong>2、基于名称空间</strong></h2><h3 id="1）-计算资源配额">1） 计算资源配额</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim compute-resources.yaml<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200228153818288.png" alt="image-20200228153818288"></p><h3 id="2）配置对象数量配额限制">2）配置对象数量配额限制</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim object-counts.yaml<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200228153828002.png" alt="image-20200228153828002"></p><h3 id="3）-配置CPU和内存的LimitRange">3） 配置CPU和内存的LimitRange</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim limitRange.yaml<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200228153834705.png" alt="image-20200228153834705"></p><p><strong>default 即 limit的值。</strong></p><p><strong>defaultRequest 即 request的值。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HPA </tag>
            
            <tag> heapster </tag>
            
            <tag> top </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s群集的三种的Web-UI界面部署（dashboard、weave-scope、Prometheus）</title>
      <link href="/posts/4f99.html"/>
      <url>/posts/4f99.html</url>
      
        <content type="html"><![CDATA[<h1>一、k8s的UI访问界面-dashboard</h1><p><strong>在dashboard中，虽然可以做到创建、删除、修改资源等操作，但通常情况下，我们会把它当做健康k8s集群的软件。</strong></p><p><strong>作为Kubernetes的Web用户界面，用户可以通过Dashboard在Kubernetes集群中部署容器化的应用，对应用进行问题处理和管理，并对集群本身进行管理。通过Dashboard，用户可以查看集群中应用的运行情况，同时也能够基于Dashboard创建或修改部署、任务、服务等Kubernetes的资源。通过部署向导，用户能够对部署进行扩缩容，进行滚动更新、重启Pod和部署新应用。当然，通过Dashboard也能够查看Kubernetes资源的状态。</strong></p><h2 id="1、Dashboard提供的功能">1、Dashboard提供的功能</h2><p><strong>在默认情况下，Dashboard显示默认(default)命名空间下的对象，也可以通过命名空间选择器选择其他的命名空间。在Dashboard用户界面中能够显示集群大部分的对象类型。</strong></p><h3 id="1）集群管理"><strong>1）集群管理</strong></h3><p><strong>集群管理视图用于对节点、命名空间、持久化存储卷、角色和存储类进行管理。 节点视图显示CPU和内存的使用情况，以及此节点的创建时间和运行状态。 命名空间视图会显示集群中存在哪些命名空间，以及这些命名空间的运行状态。角色视图以列表形式展示集群中存在哪些角色，这些角色的类型和所在的命名空间。 持久化存储卷以列表的方式进行展示，可以看到每一个持久化存储卷的存储总量、访问模式、使用状态等信息；管理员也能够删除和编辑持久化存储卷的YAML文件。</strong></p><h3 id="2）-工作负载"><strong>2）</strong> <strong>工作负载</strong></h3><p><strong>工作负载视图显示部署、副本集、有状态副本集等所有的工作负载类型。在此视图中，各种工作负载会按照各自的类型进行组织。 工作负载的详细信息视图能够显示应用的详细信息和状态信息，以及对象之间的关系。</strong></p><h3 id="3）-服务发现和负载均衡"><strong>3）</strong> <strong>服务发现和负载均衡</strong></h3><p><strong>服务发现视图能够将集群内容的服务暴露给集群外的应用，集群内外的应用可以通过暴露的服务调用应用，外部的应用使用外部的端点，内部的应用使用内部端点</strong>。</p><h3 id="4）-存储"><strong>4）</strong> <strong>存储</strong></h3><p><strong>存储视图显示被应用用来存储数据的持久化存储卷申明资源。</strong></p><h3 id="5）-配置"><strong>5）</strong> <strong>配置</strong></h3><p><strong>配置视图显示集群中应用运行时所使用配置信息，Kubernetes提供了配置字典（ConfigMaps）和秘密字典（Secrets），通过配置视图，能够编辑和管理配置对象，以及查看隐藏的敏感信息。</strong></p><h3 id="6）-日志视图"><strong>6）</strong> <strong>日志视图</strong></h3><p><strong>Pod列表和详细信息页面提供了查看日志视图的链接，通过日志视图不但能够查看Pod的日志信息，也能够查看Pod容器的日志信息。通过Dashboard能够根据向导创建和部署一个容器化的应用，当然也可以通过手工的方式输入指定应用信息，或者通过上传YAML和JSON文件来创建和不受应用。</strong></p><h2 id="2、下载所需yaml文件和镜像">2、下载所需yaml文件和镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-rc5/aio/deploy/recommended.yaml<br>[root@master https]# docker pull kubernetesui/dashboard:v2.0.0-rc5<br></code></pre></td></tr></table></figure><h2 id="3、修改-recommended-yaml">3、修改 recommended.yaml</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]#vim recommended.yaml <br>---<br>kind: Service<br>apiVersion: v1<br>metadata:<br>  labels:<br>    k8s-app: kubernetes-dashboard<br>  name: kubernetes-dashboard<br>  namespace: kubernetes-dashboard<br>spec:<br>  type: NodePort            #添加40<br>  ports:<br>    - port: 443<br>      targetPort: 8443<br>  selector:<br>    k8s-app: kubernetes-dashboard<br></code></pre></td></tr></table></figure><h3 id="执行一下">执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl apply -f recommended.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl get svc -n kubernetes-dashboard<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226085710776.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226085710776.png" alt="image-20200226085710776"></a></p><h2 id="3、浏览器访问https-192-168-1-21-32306">3、浏览器访问https://192.168.1.21:32306</h2><p><strong>PS:如果是使用的旧版本的dashboard, 使用谷歌浏览器登录，可能是不成功的，需要换成其他的浏览器，比如:火狐。</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226110629545.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226110629545.png" alt="image-20200226110629545"></a></p><h2 id="4、基于token的方法登录dashboard">4、基于token的方法登录dashboard</h2><h3 id="1-创建一个dashboard的管理用户">&lt;1&gt;创建一个dashboard的管理用户</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl create serviceaccount dashboard-admin -n kube-system<br></code></pre></td></tr></table></figure><h3 id="2-绑定用户为集群管理用户">&lt;2&gt;绑定用户为集群管理用户</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl create clusterrolebinding dashboard-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin<br></code></pre></td></tr></table></figure><h3 id="3-获取Token">&lt;3&gt;获取Token</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl get secrets -n kube-system | grep dashboard-admin<br>//先得到Token的名称<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226090141138.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226090141138.png" alt="image-20200226090141138"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl describe secrets -n kube-system  dashboard-admin-token-62bh9<br>//查看上述得到的secret资源的详细信息，会得到token<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226090425136.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226090425136.png" alt="image-20200226090425136"></a></p><h3 id="4-在浏览器上使用token登录。">&lt;4&gt;在浏览器上使用token登录。</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226090838680.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226090838680.png" alt="image-20200226090838680"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226091007042.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226091007042.png" alt="image-20200226091007042"></a></p><p><strong>创建一个资源</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226094008072.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226094008072.png" alt="image-20200226094008072"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226094127460.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226094127460.png" alt="image-20200226094127460"></a></p><p><strong>查看是否创建成功</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226094149479.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226094149479.png" alt="image-20200226094149479"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226094209114.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226094209114.png" alt="image-20200226094209114"></a></p><h2 id="5、基于kubeconfig配置文件的方法登录dashboard">5、基于kubeconfig配置文件的方法登录dashboard</h2><h3 id="1-获取Token">&lt;1&gt;获取Token</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl get secrets -n kube-system | grep dashboard-admin<br>//先得到Token的名称<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226090141138.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226090141138.png" alt="image-20200226090141138"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl describe secrets -n kube-system  dashboard-admin-token-62bh9<br>//查看上述得到的secret资源的详细信息，会得到token<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226090425136.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226090425136.png" alt="image-20200226090425136"></a></p><h3 id="2-生成kubeconfig配置文件。">&lt;2&gt;生成kubeconfig配置文件。</h3><p><strong>设置一个环境变量代表获取的token</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# DASH_TOKEN=$(kubectl get secrets -n kube-system dashboard-admin-token-62bh9  -o jsonpath=&#123;.data.token&#125; | base64 -d)<br></code></pre></td></tr></table></figure><p><strong>将k8s集群的配置信息写入kubeconfig配置文件中。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl config set-cluster kubernetes --server=192.168.1.21:6443 --kubeconfig=/root/.dashboard-admin.conf<br>[root@master https]# kubectl config set-credentials dashboard-admin --token=$DASH_TOKEN --kubeconfig=/root/.dashboard-admin.conf<br>[root@master https]# kubectl config set-context dashboard-admin@kubernetes --cluster=kubernetes --user=dashboard-admin --kubeconfig=/root/.dashboard-admin.conf<br>[root@master https]# kubectl config use-context dashboard-admin@kubernetes --kubeconfig=/root/.dashboard-admin.conf<br></code></pre></td></tr></table></figure><h3 id="3-将生成的-root-dashboard-admin-conf的配置文件，导出并做保存。">&lt;3&gt;将生成的/root/.dashboard-admin.conf的配置文件，导出并做保存。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# sz /root/.dashboard-admin.conf <br>//导出到自己习惯的位置即可<br></code></pre></td></tr></table></figure><h3 id="4-从浏览器选择kubeconfig的登录方式，然后导入配置文件即可。">&lt;4&gt;从浏览器选择kubeconfig的登录方式，然后导入配置文件即可。</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226100349876.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226100349876.png" alt="image-20200226100349876"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226100424656.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226100424656.png" alt="image-20200226100424656"></a></p><h1>二、部署weave-scope监控k8s集群</h1><p><strong>Weave Scope 是 Docker 和 Kubernetes 可视化监控工具。Scope 提供了至上而下的集群基础设施和应用的完整视图，用户可以轻松对分布式的容器化应用进行实时监控和问题诊断。</strong></p><h3 id="使用scope">使用scope</h3><ul><li><p><strong>Scope 会自动构建应用和集群的逻辑拓扑。比如点击顶部 PODS，会显示所有 Pod 以及 Pod 之间的依赖关系。</strong></p></li><li><p>点击 HOSTS，会显示各个节点之间的关系。</p><h3 id="实时资源监控">实时资源监控</h3></li><li><p><strong>可以在 Scope 中查看资源的 CPU 和内存使用情况。</strong></p></li><li><p>支持的资源有 Host、Pod 和 Container。**</p><h3 id="在线操作">在线操作</h3></li><li><p><strong>Scope 还提供了便捷的在线操作功能，比如选中某个 Host，点击 &gt;_ 按钮可以直接在浏览器中打开节点的命令行终端</strong></p></li><li><p><strong>点击 Deployment 的 + 可以执行 Scale Up 操作</strong></p></li><li><p><strong>可以查看 Pod 的日志</strong></p></li><li><p><strong>可以 attach、restart、stop 容器，以及直接在 Scope 中排查问题</strong></p><h3 id="强大的搜索功能">强大的搜索功能</h3></li><li><p><strong>Scope 支持关键字搜索和定位资源。</strong></p></li><li><p><strong>还可以进行条件搜索，比如查找和定位 MEMORY &gt; 100M 的 Pod。</strong></p></li></ul><h2 id="1、在github上查找scope的yaml文件">1、在github上查找scope的yaml文件</h2><h3 id="（1）github上搜索scope"><strong>（1）github上搜索scope</strong></h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226104345720.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226104345720.png" alt="image-20200226104345720"></a></p><h3 id="（2）进入k8s的部署scope的说明"><strong>（2）进入k8s的部署scope的说明</strong></h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226104445086.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226104445086.png" alt="image-20200226104445086"></a></p><h3 id="（3）选择k8s的部署"><strong>（3）选择k8s的部署</strong></h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226104603800.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226104603800.png" alt="image-20200226104603800"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226104711134.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226104711134.png" alt="image-20200226104711134"></a></p><h3 id="（4）复制上面的链接，并下载yaml文件">（4）复制上面的链接，并下载yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# wget https://cloud.weave.works/k8s/scope.yaml<br></code></pre></td></tr></table></figure><h2 id="2、修改下载的yaml文件并运行">2、修改下载的yaml文件并运行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim scope.yaml  #编辑yaml文件<br><span class="hljs-meta">#</span><span class="bash">跳转至213行，修改其service的端口类型</span><br>    spec:<br>      type: NodePort         #修改类型为NodePort<br>      ports:<br>        - name: app<br>          port: 80<br>          protocol: TCP<br>          targetPort: 4040<br></code></pre></td></tr></table></figure><h3 id="（1）执行一下">（1）执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl apply -f scope.yaml<br></code></pre></td></tr></table></figure><h3 id="（2）查看容器的运行情况，确定处于正常运行">（2）查看容器的运行情况，确定处于正常运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl get  pod -o wide -n weave<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226105456676.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226105456676.png" alt="image-20200226105456676"></a></p><ul><li><strong>DaemonSet weave-scope-agent，集群每个节点上都会运行的 scope agent 程序，负责收集数据。</strong></li><li><strong>Deployment weave-scope-app，scope 应用，从 agent 获取数据，通过 Web UI 展示并与用户交互。</strong></li><li><strong>Service weave-scope-app，默认是 ClusterIP 类型，我们已经在上面的命令中添加了参数k8s-service-type=NodePort修改为 NodePort。</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl get svc -n weave<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226105545660.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226105545660.png" alt="image-20200226105545660"></a></p><blockquote><p><strong>#DaemonSet资源对象：weave-scope-agent（代理）：负责收集节点的信息；</strong><br><strong>#deployment资源对象:weave-scope-app(应用)：从agent获取数据，通过web UI展示并与用户交互；</strong><br><strong>#DaemonSet资源对象的特性和deployment相比，就是DaemonSet资源对象会在每个节点上都运行且只能运行一个pod。</strong><br><strong>#由于每个节点都需要监控，所以用到了DaemonSet这种资源对象</strong></p></blockquote><h2 id="3、浏览器访问一下http-192-168-1-21-31841">3、浏览器访问一下http://192.168.1.21:31841/</h2><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226105729990.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226105729990.png" alt="image-20200226105729990"></a></p><p><strong>在scope的web界面中，可以查看很多的东西，pod、node节点等详细信息，包括打开容器的终端，查看其日志信息等等</strong></p><h2 id="总结">总结</h2><p>• <strong>weave scope可以以其简洁的可视化为我们更生动形象的展现出service/controller/pod等资源对象的管理及简单的web ui操作，方便故障排除及时定位</strong><br>• <strong>weave scope作为web ui目前缺少登录验证，可以利用其他方式里面web服务器的验证做安全管控。</strong></p><h1>三、部署Prometheus服务</h1><p><em><strong>PS:在这里部署的prometheus,并不是Prometheus官网提供的，而是使用的coreos提供的prometheus项目。</strong></em></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/20200607215313.png" alt="k8s群集的三种的Web-UI界面部署（dashboard、scope、Prometheus）"></p><h3 id="在部署之前，先来了解一下Prometheus各个组件的作用吧！"><strong>在部署之前，先来了解一下Prometheus各个组件的作用吧！</strong></h3><ul><li><strong>MetricsServer:</strong> 是k8s集群资源使用情况的聚合器，收集数据给k8s集群内使用，如kubectl,hpa,scheduler等。</li><li><strong>Prometheus Operator</strong> : 是一个系统检测和警报工具箱，用来存储监控数据。</li><li><strong>Prometheus node-exporter</strong> ：收集k8s集群资源的数据，指定告警规则。</li><li><strong>Prometheus</strong> ：收集apiserver，scheduler，controller-manager，kubelet组件的数据，通过http协议传输。</li><li><strong>Grafana:</strong> 可视化数据统计和监控平台。</li></ul><h3 id="特征">特征</h3><p><strong>Prometheus 相比于其他传统监控工具主要有以下几个特点：</strong></p><ul><li><strong>具有由 metric 名称和键/值对标识的时间序列数据的多维数据模型</strong></li><li><strong>有一个灵活的查询语言</strong></li><li><strong>不依赖分布式存储，只和本地磁盘有关</strong></li><li><strong>通过 HTTP 的服务拉取时间序列数据</strong></li><li><strong>也支持推送的方式来添加时间序列数据</strong></li><li><strong>还支持通过服务发现或静态配置发现目标</strong></li><li><strong>多种图形和仪表板支持</strong></li></ul><h2 id="1、在github上搜索coreos-prometheus">1、在github上搜索coreos/prometheus</h2><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226111843047.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226111843047.png" alt="image-20200226111843047"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226112039813.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226112039813.png" alt="img"></a></p><p><strong>复制链接</strong></p><h2 id="2、克隆github上的promethes项目">2、克隆github上的promethes项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master promethes]# yum -y install git<br>//下载git命令<br>[root@master promethes]# git clone  https://github.com/coreos/kube-prometheus.git<br>//克隆github上的项目<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226114748815.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226114748815.png" alt="image-20200226114748815"></a></p><h2 id="3、修改grafapa-service-yaml文件-更改为nodePort的暴露方式，暴露端口为31001-。">3、修改grafapa-service.yaml文件, 更改为nodePort的暴露方式，暴露端口为31001.。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master promethes]# cd kube-prometheus/manifests/<br>//进入kube-prometheus的manifests目录<br>[root@master manifests]# vim grafana-service.yaml    #修改grafana的yaml文件<br><br>apiVersion: v1<br>kind: Service<br>metadata:<br>  labels:<br>    app: grafana<br>  name: grafana<br>  namespace: monitoring<br>spec:<br>  type: NodePort       #改为NodePort类型<br>  ports:<br>  - name: http<br>    port: 3000<br>    targetPort: http<br>    nodePort: 31001    #映射到宿主机31001端口<br>  selector:<br>    app: grafana<br></code></pre></td></tr></table></figure><h2 id="3-修改prometheus-service-yaml文件，-更改为nodePort的暴露方式，暴露端口为31002">3.修改prometheus-service.yaml文件， 更改为nodePort的暴露方式，暴露端口为31002.</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master manifests]# vim prometheus-service.yaml    #修改prometheus的yaml文件<br><br>apiVersion: v1<br>kind: Service<br>metadata:<br>  labels:<br>    prometheus: k8s<br>  name: prometheus-k8s<br>  namespace: monitoring<br>spec:<br>  type: NodePort      #改为NodePort类型<br>  ports:<br>  - name: web<br>    port: 9090<br>    targetPort: web<br>    nodePort: 31002    #映射到宿主机31002端口<br>  selector:<br>    app: prometheus<br>    prometheus: k8s<br>  sessionAffinity: ClientIP<br></code></pre></td></tr></table></figure><h2 id="4、修改alertmanager-service-yaml文件，-更改为nodePort的暴露方式，暴露端口为31003">4、修改alertmanager-service.yaml文件， 更改为nodePort的暴露方式，暴露端口为31003</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master manifests]# vim alertmanager-service.yaml    #修改alertmanager的yaml文件<br><br>apiVersion: v1<br>kind: Service<br>metadata:<br>  labels:<br>    alertmanager: main<br>  name: alertmanager-main<br>  namespace: monitoring<br>spec:<br>  type: NodePort             #改为NodePort类型<br>  ports:<br>  - name: web<br>    port: 9093<br>    targetPort: web<br>    nodePort: 31003         #映射到宿主机31003端口<br>  selector:<br>    alertmanager: main<br>    app: alertmanager<br>  sessionAffinity: ClientIP<br></code></pre></td></tr></table></figure><h2 id="5、将setup目录中所有的yaml文件-全部运行。是运行以上yaml文件的基础环境配置。">5、将setup目录中所有的yaml文件,全部运行。是运行以上yaml文件的基础环境配置。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master manifests]# cd setup/<br>//进入setup/目录<br>[root@master manifests]# kubectl apply -f setup/<br>//运行setup目录中所有的yaml文件<br></code></pre></td></tr></table></figure><h2 id="6、将主目录-kube-prometheus-中所有的yaml文件-全部运行。">6、将主目录(kube-prometheus)中所有的yaml文件,全部运行。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master manifests]# cd ..<br>//返回上一级目录（kube-prometheus）<br>[root@master kube-prometheus]# kubectl apply -f manifests/<br>//运行kube-prometheus目录中所有的yaml文件<br></code></pre></td></tr></table></figure><h3 id="查看一下-2">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -n monitoring<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226203237647.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226203237647.png" alt="image-20200226203237647"></a></p><p><strong>部署成功之后，可以运行一条命令， 查看资源使用情况(MetricsServer必须部署成功)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master images]# kubectl top node<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228085819377.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228085819377.png" alt="image-20200228085819377"></a></p><h2 id="7、浏览器访问一下http-192-168-1-21-31001">7、浏览器访问一下http://192.168.1.21:31001</h2><p><strong>客户端访问群集中任意节点的IP+30100端口，即可看到以下界面（默认用户名和密码都是admin）</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226203416325.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226203416325.png" alt="image-20200226203416325"></a></p><p><strong>根据提示更改密码：</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226203613578.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226203613578.png" alt="image-20200226203613578"></a></p><h3 id="（1）添加模板">（1）添加模板</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226203911457.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226203911457.png" alt="image-20200226203911457"></a></p><p><strong>依次点击“import”进行导入下面三个模板：</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226204011409.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226204011409.png" alt="image-20200226204011409"></a></p><h3 id="（2）进行以下点击，即可查看群集内的监控状态">（2）进行以下点击，即可查看群集内的监控状态</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226204247627.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226204247627.png" alt="image-20200226204247627"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226204306014.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226204306014.png" alt="image-20200226204306014"></a></p><p><strong>以下可看到监控状态</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226204632455.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226204632455.png" alt="image-20200226204632455"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226204638784.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200226204638784.png" alt="image-20200226204638784"></a></p><h2 id="8、导入监控模板">8、导入监控模板</h2><p><strong>从grafana的官网搜索</strong><a href="https://grafana.com/" target="_blank" rel="noopener">https://grafana.com/</a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228093639900.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228093639900.png" alt="image-20200228093639900"></a></p><p><strong>复制以下这个模板的id</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228093854640.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228093854640.png" alt="img"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228094048611.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228094048611.png" alt="image-20200228094048611"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228094320274.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228094320274.png" alt="image-20200228094320274"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228094224276.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228094224276.png" alt="image-20200228094224276"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228094348407.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200228094348407.png" alt="image-20200228094348407"></a></p><p><strong>现在可以看到监控画面了</strong></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dashboard </tag>
            
            <tag> weave-scope </tag>
            
            <tag> Prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s中ingress资源的应用</title>
      <link href="/posts/7f86.html"/>
      <url>/posts/7f86.html</url>
      
        <content type="html"><![CDATA[<h1>Ingress实现虚拟主机的方案</h1><h2 id="环境介绍">环境介绍</h2><table><thead><tr><th>主机</th><th>IP地址</th><th>服务</th></tr></thead><tbody><tr><td><strong>master</strong></td><td><strong>192.168.1.21</strong></td><td><strong>k8s</strong></td></tr><tr><td><strong>node01</strong></td><td><strong>192.168.1.22</strong></td><td><strong>k8s</strong></td></tr><tr><td><strong>node02</strong></td><td><strong>192.168.1.23</strong></td><td><strong>k8s</strong></td></tr></tbody></table><p><strong>基于<a href> https://blog.51cto.com/14320361/2464655</a> 的实验继续进行</strong></p><h2 id="1、首先确定要运行ingress-nginx-controller服务。"><strong>1、首先确定要运行ingress-nginx-controller服务。</strong></h2><h3 id="在gitbub上找到所需的ingress的yaml文件">在gitbub上找到所需的ingress的yaml文件</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103818065.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103818065.png" alt="image-20200219103818065"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103248246.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103248246.png" alt="image-20200219103248246"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103252620.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103252620.png" alt="image-20200219103252620"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103537536.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103537536.png" alt="image-20200219103537536"></a></p><h3 id="4-master下载">4. master下载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.29.0/deploy/static/mandatory.yaml<br></code></pre></td></tr></table></figure><h3 id="5-修改-mandatory-yaml-文件">5. 修改 mandatory.yaml 文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# vim mandatory.yaml<br>      hostNetwork: true   #213<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219104346146.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219104346146.png" alt="image-20200219104346146"></a></p><h4 id="（1）执行一下">（1）执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# kubectl apply -f mandatory.yaml<br></code></pre></td></tr></table></figure><h4 id="（2）查看一下">（2）查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# kubectl get pod -n ingress-nginx<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224123916253.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224123916253.png" alt="image-20200224123916253"></a></p><h2 id="2、将ingress-nginx-controller暴露为一个Service资源对象。"><strong>2、将ingress-nginx-controller暴露为一个Service资源对象。</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim service-nodeport.yaml <br><br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: ingress-nginx<br>  namespace: ingress-nginx<br>  labels:<br>    app.kubernetes.io/name: ingress-nginx<br>    app.kubernetes.io/part-of: ingress-nginx<br>spec:<br>  type: NodePort<br>  ports:<br>    - name: http<br>      port: 80<br>      targetPort: 80<br>      protocol: TCP<br>    - name: https<br>      port: 443<br>      targetPort: 443<br>      protocol: TCP<br>  selector:<br>    app.kubernetes.io/name: ingress-nginx<br>    app.kubernetes.io/part-of: ingress-nginx<br><br>---<br></code></pre></td></tr></table></figure><h4 id="（1）执行一下-2"><strong>（1）执行一下</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# kubectl apply -f service-nodeport.yaml<br></code></pre></td></tr></table></figure><h4 id="（2）查看一下-2"><strong>（2）查看一下</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# kubectl get svc -n ingress-nginx<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219111029408.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219111029408.png" alt="image-20200219111029408"></a></p><h2 id="3、创建一个deployment资源，和一个service资源，-并相互关联。">3、创建一个deployment资源，和一个service资源， 并相互关联。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim deploy1.yaml<br><br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: deploy1<br>spec:<br>  replicas: 2<br>  template:<br>    metadata:<br>      labels:<br>        app: nginx1<br>    spec:<br>      containers:<br>      - name: nginx1<br>        image: nginx<br>---<br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: svc-1<br>spec:<br>  selector:<br>    app: nginx1<br>  ports:<br>    - port: 80<br>      targetPort: 80<br></code></pre></td></tr></table></figure><h4 id="执行一下">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f deploy1.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224091013907.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224091013907.png" alt="image-20200224091013907"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get svc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224091036678.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224091036678.png" alt="image-20200224091036678"></a></p><h3 id="然后复制deploy1-yaml资源工创建另外”一对“服务。">然后复制deploy1.yaml资源工创建另外”一对“服务。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim deploy2.yaml<br><br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: deploy2<br>spec:<br>  replicas: 2<br>  template:<br>    metadata:<br>      labels:<br>        app: nginx2<br>    spec:<br>      containers:<br>      - name: nginx2<br>        image: nginx<br>---<br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: svc-2<br>spec:<br>  selector:<br>    app: nginx2<br>  ports:<br>    - port: 80<br>      targetPort: 80<br></code></pre></td></tr></table></figure><h4 id="执行一下-2">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f deploy2.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-2">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get deployments.<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224091747509.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224091747509.png" alt="image-20200224091747509"></a></p><h2 id="4-创建ingress的yaml文件，关联是svc1和svc2">4. 创建ingress的yaml文件，关联是svc1和svc2</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim ingress.yaml<br>apiVersion: extensions/v1beta1<br>kind: Ingress<br>metadata:<br>  name: ingress-1<br>spec:<br>  rules:<br>    - host: www1.bdqn.com<br>      http:<br>        paths:<br>        - path: /<br>          backend:<br>            serviceName: svc-1<br>            servicePort: 80<br>---<br>apiVersion: extensions/v1beta1<br>kind: Ingress<br>metadata:<br>  name: ingress-2<br>spec:<br>  rules:<br>    - host: www2.bdqn.com<br>      http:<br>        paths:<br>        - path: /<br>          backend:<br>            serviceName: svc-2<br>            servicePort: 80<br></code></pre></td></tr></table></figure><h4 id="执行一下-3">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f ingress.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-3">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get ingresses.<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224092438021.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224092438021.png" alt="image-20200224092438021"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl describe ingresses. ingress-1<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224092823654.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224092823654.png" alt="image-20200224092823654"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl describe ingresses. ingress-2<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224092846086.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224092846086.png" alt="image-20200224092846086"></a></p><h2 id="5、由于实验环境限制，所以自己用来模拟-一个域名。">5、由于实验环境限制，所以自己用来模拟-一个域名。</h2><h4 id="进入本机的-C-Windows-System32-drivers-etc-，-修改hosts文件，添加Pod（ingress-controller）运行所在的节点IP。">进入本机的 C:\Windows\System32\drivers\etc ， 修改hosts文件，添加Pod（ingress-controller）运行所在的节点IP。</h4><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224092744445.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224092744445.png" alt="image-20200224092744445"></a></p><h4 id="访问一下">访问一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get svc -n ingress-nginx <br>//查看映射的端口<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224093328158.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224093328158.png" alt="image-20200224093328158"></a></p><p><a href="http://www1.bdqn.com:30817/" target="_blank" rel="noopener">http://www1.bdqn.com:30817/</a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224094944536.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224094944536.png" alt="image-20200224094944536"></a></p><p><a href="http://www2.bdqn.com:30817/" target="_blank" rel="noopener">http://www2.bdqn.com:30817/</a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224095008674.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224095008674.png" alt="image-20200224095008674"></a></p><h4 id="总结上述示例的pod是如何一步一步可以使client访问到的，总结如下：">总结上述示例的pod是如何一步一步可以使client访问到的，总结如下：</h4><p><strong>后端pod===》service====》ingress规则====》写入Ingress-nginx-controller配置文件并自动重载使更改生效===》对本机进行域名解析====》实现client通过域名的IP+端口都可以访问到后端pod</strong></p><h1>Ingress资源实现https代理安全访问。</h1><p><strong>在上面的操作中，实现了使用ingress-nginx为后端所有pod提供一个统一的入口，那么，有一个非常严肃的问题需要考虑，就是如何为我们的pod配置CA证书来实现HTTPS访问？在pod中直接配置CA么？那需要进行多少重复性的操作？而且，pod是随时可能被kubelet杀死再创建的。当然这些问题有很多解决方法，比如直接将CA配置到镜像中，但是这样又需要很多个CA证书。</strong></p><p><strong>这里有更简便的一种方法，就拿上面的情况来说，后端有多个pod，pod与service进行关联，service又被ingress规则发现并动态写入到ingress-nginx-controller容器中，然后又为ingress-nginx-controller创建了一个Service映射到群集节点上的端口，来供client来访问。</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224143045045.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224143045045.png" alt="image-20200224143045045"></a></p><p><strong>在上面的一系列流程中，关键的点就在于ingress规则，我们只需要在ingress的yaml文件中，为域名配置CA证书即可，只要可以通过HTTPS访问到域名，至于这个域名是怎么关联到后端提供服务的pod，这就是属于k8s群集内部的通信了，即便是使用http来通信，也无伤大雅。</strong></p><h2 id="1-生成证书">1. 生成证书</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# mkdir https<br>//创建一个放置证书的目录<br>[root@master yaml]# cd https/<br>[root@master https]# openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj "/CN=testsvc /O=testsvc"<br>//生成证书<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224100716121.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224100716121.png" alt="image-20200224100716121"></a></p><h2 id="2-创建secret资源，-保存证书。">2. 创建secret资源， 保存证书。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl create secret tls tls-secret --key=tls.key --cert tls.crt<br></code></pre></td></tr></table></figure><h2 id="3、创建一个deploy3-yaml文件，模拟一个web服务。">3、创建一个deploy3.yaml文件，模拟一个web服务。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim deploy3.yaml<br><br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: deploy3<br>spec:<br>  replicas: 2<br>  template:<br>    metadata:<br>      labels:<br>        app: nginx3<br>    spec:<br>      containers:<br>      - name: nginx3<br>        image: nginx<br>---<br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: svc-3<br>spec:<br>  selector:<br>    app: nginx3<br>  ports:<br>    - port: 80<br>      targetPort: 80<br></code></pre></td></tr></table></figure><h4 id="执行一下-4">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl apply -f deploy3.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-4">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224104212886.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224104212886.png" alt="image-20200224104212886"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl get svc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224104240133.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224104240133.png" alt="image-20200224104240133"></a></p><h2 id="4、创建对应的ingress规则。">4、创建对应的ingress规则。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# vim ingress.yaml<br><br>apiVersion: extensions/v1beta1<br>kind: Ingress<br>metadata:<br>  name: ingress-3<br>spec:<br>  tls:<br>    - hosts:<br>      - www3.bdqn.com           #域名<br>      secretName: tls-secret    #保存的证书<br>  rules:<br>    - host: www3.bdqn.com<br>      http:<br>        paths:<br>        - path: /<br>          backend:<br>            serviceName: svc-3<br>            servicePort: 80<br></code></pre></td></tr></table></figure><h3 id="执行一下-5">执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl apply -f ingress.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下-5">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl get ingresses.<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224105525215.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224105525215.png" alt="image-20200224105525215"></a></p><h2 id="5-查找对应service-nodePort的443端口映射的端口，直接用浏览器访问即可。">5.查找对应service nodePort的443端口映射的端口，直接用浏览器访问即可。</h2><h4 id="进入本机的-C-Windows-System32-drivers-etc-，-修改hosts文件，添加Pod（ingress-controller）运行所在的节点IP。-2">进入本机的 C:\Windows\System32\drivers\etc ， 修改hosts文件，添加Pod（ingress-controller）运行所在的节点IP。</h4><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224105118183.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224105118183.png" alt="image-20200224105118183"></a></p><h4 id="查看映射端口">查看映射端口</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master https]# kubectl get svc -n ingress-nginx<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224105347424.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224105347424.png" alt="image-20200224105347424"></a></p><p><a href="https://www3.bdqn.com:31372/" target="_blank" rel="noopener">https://www3.bdqn.com:31372/</a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224105409448.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200224105409448.png" alt="image-20200224105409448"></a></p><p><strong>k8s集群利用了“一切皆为资源”的原理，把生成的ca证书当成一个公共的资源来使用，使用时只需绑定保存的ca证书即可，不像之前一样，需要一个一个的创建ca证书，然后在关联起来，方便好用又快捷。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ingress-nginx </tag>
            
            <tag> https </tag>
            
            <tag> ca </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S的inress-nginx</title>
      <link href="/posts/c92f.html"/>
      <url>/posts/c92f.html</url>
      
        <content type="html"><![CDATA[<h1>一、Ingress 及 Ingress Controller 简介</h1><p><em><strong>Ingress简单的理解: 原先暴露的service,现在给定个统一的访问入口。</strong></em></p><p><strong>Ingress 是 k8s 资源对象，用于对外暴露服务，该资源对象定义了不同主机名（域名）及 URL 和对应后端 Service（k8s Service）的绑定，根据不同的路径路由 http 和 https 流量。而 Ingress Contoller 是一个 pod 服务，封装了一个 web 前端负载均衡器，同时在其基础上实现了动态感知 Ingress 并根据 Ingress 的定义动态生成 前端 web 负载均衡器的配置文件，比如 Nginx Ingress Controller 本质上就是一个 Nginx，只不过它能根据 Ingress 资源的定义动态生成 Nginx 的配置文件，然后动态 Reload。个人觉得 Ingress Controller 的重大作用是将前端负载均衡器和 Kubernetes 完美地结合了起来，一方面在云、容器平台下方便配置的管理，另一方面实现了集群统一的流量入口，而不是像 nodePort 那样给集群打多个孔。</strong>。</p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/20200607214201.png" alt="K8S的inress-nginx"></p><p><strong>所以，总的来说要使用 Ingress，得先部署 Ingress Controller 实体（相当于前端 Nginx），然后再创建 Ingress （相当于 Nginx 配置的 k8s 资源体现），Ingress Controller 部署好后会动态检测 Ingress 的创建情况生成相应配置。Ingress Controller 的实现有很多种：有基于 Nginx 的，也有基于 HAProxy的，还有基于 OpenResty 的 Kong Ingress Controller 等，更多 Controller 见：<a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/%EF%BC%8C%E6%9C%AC%E6%96%87%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/，本文使用基于</a> Nginx 的 Ingress Controller：ingress-nginx。</strong></p><h1>二、Ingress 组成</h1><ul><li><strong>将Nginx的配置抽象成一个Ingress对象，每添加一个新的服务只需写一个新的Ingress的yaml文件即可</strong></li><li><strong>将新加入的Ingress转化成Nginx的配置文件并使之生效</strong></li><li><strong>ingress controller</strong></li><li><strong>ingress服务</strong></li></ul><h1>三、ingress的工作原理</h1><h2 id="ingress具体的工作原理如下"><strong>ingress具体的工作原理如下:</strong></h2><p><strong>ingress contronler通过与k8s的api进行交互，动态的去感知k8s集群中ingress服务规则的变化，然后读取它，并按照定义的ingress规则，转发到k8s集群中对应的service。</strong></p><p><strong>而这个ingress规则写明了哪个域名对应k8s集群中的哪个service，然后再根据ingress-controller中的nginx配置模板，生成一段对应的nginx配置。</strong></p><p><strong>然后再把该配置动态的写到ingress-controller的pod里，该ingress-controller的pod里面运行着一个nginx服务，控制器会把生成的nginx配置写入到nginx的配置文件中，然后reload一下，使其配置生效。以此来达到域名分配置及动态更新的效果。</strong></p><h1>四、Ingress 可以解决什么问题？</h1><h2 id="动态配置服务">动态配置服务</h2><p><strong>如果按照传统方式, 当新增加一个服务时, 我们可能需要在流量入口加一个反向代理指向我们新的k8s服务. 而如果用了Ingress, 只需要配置好这个服务, 当服务启动时, 会自动注册到Ingress的中, 不需要而外的操作.</strong></p><h2 id="减少不必要的暴露端口">减少不必要的暴露端口</h2><p><strong>配置过k8s的都清楚, 第一步是要关闭防火墙的, 主要原因是k8s的很多服务会以NodePort方式映射出去, 这样就相当于给宿主机打了很多孔, 既不安全也不优雅. 而Ingress可以避免这个问题, 除了Ingress自身服务可能需要映射出去, 其他服务都不要用NodePort方式</strong></p><h1>五、Ingress-nginx配置示例</h1><h2 id="1-创建一个web服务，用deployment资源，-用httpd镜像，然后创建一个service资源与之关联。">1) 创建一个web服务，用deployment资源， 用httpd镜像，然后创建一个service资源与之关联。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# vim deploy_1.yaml<br>apiVersion: v1<br>kind: Namespace<br>metadata:<br>  name: bdqn-ns<br>  labels:<br>    name: bdqn-ns<br>---<br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: httpd-deploy<br>  namespace: bdqn-ns<br>spec:<br>  replicas: 2<br>  template:<br>    metadata:<br>      labels:<br>        app: bdqn-ns<br>    spec:<br>      containers:<br>      - name: httpd<br>        image: httpd<br>---<br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: httpd-svc<br>  namespace: bdqn-ns<br>spec:<br>  type: NodePort<br>  selector:<br>    app: bdqn-ns<br>  ports:<br>  - name: http-port<br>    port: 80<br>    targetPort: 80<br>    nodePort: 31033<br></code></pre></td></tr></table></figure><h3 id="执行一下">执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# kubectl apply -f deploy_1.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# kubectl get svc -n bdqn-ns<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219093450798.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219093450798.png" alt="image-20200219093450798"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# kubectl get pod -n bdqn-ns<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219093511785.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219093511785.png" alt="image-20200219093511785"></a></p><h3 id="访问一下">访问一下</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219093653692.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219093653692.png" alt="image-20200219093653692"></a></p><h2 id="2-创建一个web服务，用deployment-资源，用tomcat-8-5-45镜像。">2) 创建一个web服务，用deployment 资源，用tomcat:8.5.45镜像。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# vim deploy_2.yaml <br><br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: tomcat-deploy<br>  namespace: bdqn-ns<br>spec:<br>  replicas: 2<br>  template:<br>    metadata:<br>      labels:<br>        app: bdqn-tomcat<br>    spec:<br>      containers:<br>      - name: tomcat<br>        image: tomcat:8.5.45<br>---<br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: tomcat-svc<br>  namespace: bdqn-ns<br>spec:<br>  type: NodePort<br>  selector:<br>    app: bdqn-tomcat<br>  ports:<br>  - name: tomcat-port<br>    port: 8080<br>    targetPort: 8080<br>    nodePort: 32033<br></code></pre></td></tr></table></figure><h3 id="执行一下-2">执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# kubectl apply -f deploy_2.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下-2">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# kubectl get pod -n bdqn-ns<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219094056123.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219094056123.png" alt="image-20200219094056123"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# kubectl get svc -n bdqn-ns<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219094146341.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219094146341.png" alt="image-20200219094146341"></a></p><h3 id="访问一下-2">访问一下</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219100037136.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219100037136.png" alt="image-20200219100037136"></a></p><h2 id="3-在k8s集群前边部署一个反向代理服务器，这个服务器代理这k8s集群内部的service资源。">3) 在k8s集群前边部署一个反向代理服务器，这个服务器代理这k8s集群内部的service资源。</h2><h3 id="1-Ingress"><strong>1. Ingress:</strong></h3><p><strong>（1）Ingress controller:</strong></p><p><strong>将新加入的Ingress转化为反向代理服务器的配置文件，并使之生效。(动态的感知k8s集群内Ingress资源的变化。）</strong></p><p><strong>（2）Ingress :</strong></p><p><strong>Ingress:将反向代理服务器的配置抽象成一个Ingress对象，每添加一个新的服务，只需要写一个新的Ingress的yaml文件即可。</strong></p><h3 id="2-Nginx-反向代理服务器。">2. Nginx :反向代理服务器。</h3><p><strong>需要解决了两个问题:</strong></p><p><strong>1、动态的配置服务。</strong></p><p><strong>2、减少不必要的端口暴露。</strong></p><p><strong>基于nginx的ingress controller根据不同的开发公司，又分为两种:<br>​ 1、k8s社区版的: Ingerss - nginx.<br>​ 2、nginx公司自己开发的: nginx- ingress .</strong></p><h3 id="3-在gitbub上找到所需的ingress的yaml文件">3. 在gitbub上找到所需的ingress的yaml文件</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103818065.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103818065.png" alt="image-20200219103818065"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103248246.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103248246.png" alt="image-20200219103248246"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103252620.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103252620.png" alt="image-20200219103252620"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103537536.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103537536.png" alt="image-20200219103537536"></a></p><h3 id="4-master下载">4. master下载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.29.0/deploy/static/mandatory.yaml<br></code></pre></td></tr></table></figure><h3 id="5-修改-mandatory-yaml-文件">5. 修改 mandatory.yaml 文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# vim mandatory.yaml<br>      hostNetwork: true   #213<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219104346146.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219104346146.png" alt="image-20200219104346146"></a></p><p><strong>---------如果ingress-controller镜像下载不成功，可以直接使用下边的镜像。</strong><br><strong>docker pull <a href="http://registry.cn-hangzhou.aliyuncs.com/ilanni/nginx-ingress-controller:0.22.0" target="_blank" rel="noopener">registry.cn-hangzhou.aliyuncs.com/ilanni/nginx-ingress-controller:0.22.0</a></strong></p><p><strong>需要注意的是，如果使用上述镜像，需要将deployment资源指定的镜像名称进行修改。</strong></p><p><strong>修改的是madatory.yaml文件里的deployment资源。</strong></p><p><strong>在deployment资源中，如果添加了此字段，意味着Pod中运行的应用可以直接使用node节点的端口，这样node节 点主机所在网络的其他主机，就可以通过访问该端口访问此应用。(类似于docker映射到宿主机 上的端口。)</strong></p><h4 id="（1）执行一下">（1）执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# kubectl apply -f mandatory.yaml<br></code></pre></td></tr></table></figure><h4 id="（2）查看一下">（2）查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# kubectl get pod -n ingress-nginx<br></code></pre></td></tr></table></figure><h3 id="6-创建一个service的yaml文件">6. 创建一个service的yaml文件</h3><h4 id="（1）执行一下-2">（1）执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# kubectl apply -f mandatory.yaml<br></code></pre></td></tr></table></figure><h4 id="（2）查看一下-2">（2）查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# vim mandatory-svc.yaml <br><br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: ingress-nginx<br>  namespace: ingress-nginx<br>spec:<br>  type: NodePort<br>  ports:<br>  - name: httpd<br>    port: 80<br>    targetPort: 80<br>  - name: https<br>    port: 443<br>  selector:<br>    app: ingress-nginx<br></code></pre></td></tr></table></figure><p><strong>（1）执行一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# kubectl apply -f mandatory-svc.yaml<br></code></pre></td></tr></table></figure><p><strong>（2）查看一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ingress]# kubectl get svc -n ingress-nginx<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219111029408.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219111029408.png" alt="image-20200219111029408"></a></p><h2 id="4）创建Ingress资源。">4）创建Ingress资源。</h2><p><strong>ingress ：</strong><br><strong>ingress-nginx-controller: 动态感知ingress 资源的变化</strong><br><strong>ingress: 创建svc与ingress-nginx-controller 关联的规则</strong></p><h3 id="（1）编写ingress的yaml文件">（1）编写ingress的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim ingress.yaml <br>apiVersion: extensions/v1beta1<br>kind: Ingress<br>metadata:<br>  name: bdqn-ingress<br>  namespace: bdqn-ns<br>  annotations:<br>    nginx.ingress.kubernetes.io/rewrite-target: /<br>spec:<br>  rules:             #规则 <br>  - host: ingress.bdqn.com   #域名<br>    http:<br>      paths:<br>      - path: /<br>        backend:<br>          serviceName: httpd-svc       #关联service<br>          servicePort: 80              #关联service的映射端口<br>      - path: /tomcat<br>        backend:<br>          serviceName: tomcat-svc      #关联service<br>          servicePort: 8080           #关联service的映射端口<br></code></pre></td></tr></table></figure><h4 id="执行一下-3">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f ingress.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-3">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod -n ingress-nginx -o wide<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200221094602218.png" alt="image-20200221094602218"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get ingresses. -n bdqn-ns<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200221092912191.png" alt="image-20200221092912191"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl describe ingresses. -n bdqn-ns<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200221093013134.png" alt="image-20200221093013134"></p><h4 id="进入pod查看一下">进入pod查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl exec -it -n ingress-nginx nginx-ingress-controller-5954d475b6-24k92 /bin/sh<br>/etc/nginx $ cat nginx.conf<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200221094404491.png" alt="image-20200221094404491"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200221094408211.png" alt="image-20200221094408211"></p><h3 id="（2）访问一下">（2）访问一下</h3><h4 id="进入本机的-C-Windows-System32-drivers-etc-，-修改hosts文件，添加Pod（ingress-controller）运行所在的节点IP。"><strong>进入本机的 C:\Windows\System32\drivers\etc ， 修改hosts文件，添加Pod（ingress-controller）运行所在的节点IP。</strong></h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200221103807318.png" alt="image-20200221103807318"></p><h4 id="访问http-ingress-bdqn-com">访问http://ingress.bdqn.com/</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200221095323635.png" alt="image-20200221095323635"></p><h4 id="访问http-ingress-bdqn-com-tomcat">访问http://ingress.bdqn.com/tomcat</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200221102354657.png" alt="image-20200221102354657"></p><h2 id="5）为ingress-nginx创建一个service（使用官网的service文件就可以）">5）为ingress-nginx创建一个service（使用官网的service文件就可以）</h2><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103818065.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103818065.png" alt="image-20200219103818065"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103248246.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103248246.png" alt="image-20200219103248246"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103252620.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200219103252620.png" alt="image-20200219103252620"></a></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200221103351973.png" alt="image-20200221103351973"></p><p><em><strong>复制上面的网址</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# wget  https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.29.0/deploy/static/provider/baremetal/service-nodeport.yaml<br>//下载文件到master节点<br></code></pre></td></tr></table></figure><h3 id="执行一下，下载的service文件">执行一下，下载的service文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f service-nodeport.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下-4">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get service -n ingress-nginx<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200221103644779.png" alt="image-20200221103644779"></p><h3 id="访问一下-3">访问一下</h3><h4 id="进入本机的-C-Windows-System32-drivers-etc-，-修改hosts文件，添加Pod（ingress-controller）运行所在的节点IP。-2">进入本机的 C:\Windows\System32\drivers\etc ， 修改hosts文件，添加Pod（ingress-controller）运行所在的节点IP。</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200221103835847.png" alt="image-20200221103835847"></p><h3 id="访问http-ingress-bdqn-com-30817">访问http://ingress.bdqn.com:30817/</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200221103927247.png" alt="image-20200221103927247"></p><h3 id="访问http-ingress-bdqn-com-30817-tomcat">访问http://ingress.bdqn.com:30817/tomcat</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200221103950477.png" alt="image-20200221103950477"></p><p><strong>Service -Nodeport:因为ingress - nginx - controller运行在了集群内的其中一个节点，为了保证即使这个节点宕机，我们对应的域名仍然能够正常访问服务，所以我们将ingress -nginx- controller也暴露为一个service资源。</strong></p><h2 id="六、练习">六、练习:</h2><p><strong>创建一个deploymen资源，基于nginx镜像，repolicas：2个.然后创建一个service资源关联这个deployment资源。最后创建一个ingress资源，<a href="http://xn--svcingress-ui2pp14ahmcbv2dk27ivg4b.bdqn.com/nginx" target="_blank" rel="noopener">将上述svc关联到ingress.bdqn.com/nginx</a> 目录下。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim lianxi.yaml<br>apiVersion: v1<br>kind: Namespace<br>metadata:<br>  name: xgp-666<br>  labels:<br>    name: xgp-666<br>---<br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: xgp<br>  namespace: xgp-666<br>spec:<br>  replicas: 2<br>  template:<br>    metadata:<br>      labels:<br>        app: xgp-nginx<br>    spec:<br>      containers:<br>        - name: xgp-nginx<br>          image: nginx<br>---<br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: xgp-svc<br>  namespace: xgp-666<br>spec:<br>  type: NodePort<br>  selector:<br>    app: xgp-nginx<br>  ports:<br>  - name: xgp-port<br>    port: 80<br>    targetPort: 80<br>    nodePort: 30000<br>---<br>apiVersion: extensions/v1beta1<br>kind: Ingress<br>metadata:<br>  name: xgp-ingress<br>  namespace: xgp-666<br>  annotations:<br>    nginx.ingress.kubernetes.io/rewrite-target: /<br>spec:<br>  rules:<br>  - host: ingress.xgp.com<br>    http:<br>      paths:<br>      - path: /<br>        backend:<br>          serviceName: xgp-svc<br>          servicePort: 80<br></code></pre></td></tr></table></figure><h3 id="执行一下-4">执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f lianxi.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下-5">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl describe ingresses. -n xgp-666<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200221112302483.png" alt="image-20200221112302483"></p><h3 id="进入本机的-C-Windows-System32-drivers-etc-，-修改hosts文件，添加Pod（ingress-controller）运行所在的节点IP。-3"><strong>进入本机的 C:\Windows\System32\drivers\etc ， 修改hosts文件，添加Pod（ingress-controller）运行所在的节点IP。</strong></h3><h3 id="添加完之后访问一下http-ingress-xgp-com">添加完之后访问一下http://ingress.xgp.com/</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200221112416946.png" alt="image-20200221112416946"></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> ingress </tag>
            
            <tag> ingress controller </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s的Secret（密文）和configmap（明文）的使用教程</title>
      <link href="/posts/a387.html"/>
      <url>/posts/a387.html</url>
      
        <content type="html"><![CDATA[<h1>一、Secret</h1><p><em><strong>Secret :用来保存一些敏感信息，比如数据库的用户名密码或者秘钥。</strong></em></p><h2 id="概览">概览</h2><p><strong>Secret是用来保存小片敏感数据的k8s资源，例如密码，token，或者秘钥。这类数据当然也可以存放在Pod或者镜像中，但是放在Secret中是为了更方便的控制如何使用数据，并减少暴露的风险。<br>用户可以创建自己的secret，系统也会有自己的secret。<br>Pod需要先引用才能使用某个secret，Pod有2种方式来使用secret：作为volume的一个域被一个或多个容器挂载；在拉取镜像的时候被kubelet引用。</strong></p><h3 id="內建的Secrets">內建的Secrets</h3><p><strong>由ServiceAccount创建的API证书附加的秘钥<br>k8s自动生成的用来访问apiserver的Secret，所有Pod会默认使用这个Secret与apiserver通信</strong></p><h2 id="1-Secret类型">1. Secret类型</h2><p><strong>Secret有三种类型：</strong></p><ul><li><strong>Opaque：使用base64编码存储信息，可以通过base64 --decode解码获得原始数据，因此安全性弱。</strong></li><li><strong><a href="http://kubernetes.io/dockerconfigjson%EF%BC%9A%E7%94%A8%E4%BA%8E%E5%AD%98%E5%82%A8docker" target="_blank" rel="noopener">kubernetes.io/dockerconfigjson：用于存储docker</a> registry的认证信息。</strong></li><li><strong><a href="http://kubernetes.io/service-account-token%EF%BC%9A%E7%94%A8%E4%BA%8E%E8%A2%AB" target="_blank" rel="noopener">kubernetes.io/service-account-token：用于被</a> serviceaccount 引用。serviceaccout 创建时 Kubernetes 会默认创建对应的 secret。Pod 如果使用了 serviceaccount，对应的 secret 会自动挂载到 Pod 的 /run/secrets/kubernetes.io/serviceaccount 目录中</strong>。</li></ul><h2 id="举例-保存数据库的用户名和密码">举例:保存数据库的用户名和密码</h2><blockquote><p><strong>用户名：</strong> <strong>root</strong><br><strong>密码：</strong> <strong><a href="http://123.com/" target="_blank" rel="noopener">123.com</a></strong></p></blockquote><h3 id="1、通过–from-literal（文字的）">1、通过–from-literal（文字的）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# kubectl create secret generic mysecret1 --from-literal=username=root --from-literal=password=123.com<br></code></pre></td></tr></table></figure><blockquote><p><strong>generic：通用的，一般的加密方式</strong></p></blockquote><h4 id="查看一下">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# kubectl get secrets<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200214100419966.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200214100419966.png" alt="img"></a></p><p><strong>类型是Opaque（不透明的）</strong></p><h3 id="2、通过from-file（文件）">2、通过from-file（文件）</h3><h4 id="新建两个文件并分别写入用户名和密码">新建两个文件并分别写入用户名和密码</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# echo root &gt; username<br>[root@master secret]# echo 123.com  &gt; password<br></code></pre></td></tr></table></figure><h4 id="创建一个secret">创建一个secret</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]#  kubectl create secret generic mysecret2 --from-file=username --from-file=password<br></code></pre></td></tr></table></figure><h4 id="查看一下-2">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# kubectl get secrets<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200214103506842.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200214103506842.png" alt="image-20200214103506842"></a></p><h3 id="3、通过-from-env-file">3、通过-- from- env-file:</h3><h4 id="创建一个文件写入用户名和密码">创建一个文件写入用户名和密码</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]#vim env.txt <br>username=root<br>password=123.com<br></code></pre></td></tr></table></figure><h4 id="创建一个secret-2">创建一个secret</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# kubectl create secret generic mysecret3 --from-env-file=env.txt<br></code></pre></td></tr></table></figure><h4 id="查看一下-3">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# kubectl get secrets<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200214103905956.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200214103905956.png" alt="image-20200214103905956"></a></p><h3 id="4、通过yaml配置文件">4、通过yaml配置文件</h3><h4 id="（1）把需要保存的数据加密（”base64“的方式）">（1）把需要保存的数据加密（”base64“的方式）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# echo root | base64<br>cm9vdAo=<br>[root@master secret]# echo 123.com | base64<br>MTIzLmNvbQo=<br></code></pre></td></tr></table></figure><blockquote><p><strong>解码：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# echo -n cm9vdAo | base64 --decode <br>root<br>[root@master secret]# echo -n MTIzLmNvbQo | base64 --decode <br>123.com<br></code></pre></td></tr></table></figure></blockquote><h4 id="（2）编写secre4的yaml文件">（2）编写secre4的yaml文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# vim secret4.yaml<br>apiVersion: v1<br>kind: Secret<br>metadata:<br>  name: mysecret4<br>data:<br>  username: cm9vdAo=<br>  password: MTIzLmNvbQo=<br></code></pre></td></tr></table></figure><h5 id="执行一下">执行一下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# kubectl apply -f secret4.yaml<br></code></pre></td></tr></table></figure><h4 id="（3）查看一下">（3）查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# kubectl get secrets<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200214104544899.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200214104544899.png" alt="image-20200214104544899"></a></p><h2 id="如果来使用Secret资源">如果来使用Secret资源</h2><h3 id="1-以Volume挂载的方式">1. 以Volume挂载的方式</h3><h3 id="使用Secret">使用Secret</h3><p><strong>secret可以作为数据卷挂载或者作为环境变量暴露给Pod中的容器使用，也可以被系统中的其他资源使用。比如可以用secret导入与外部系统交互需要的证书文件等。</strong></p><p><strong>在Pod中以文件的形式使用secret</strong></p><blockquote><ol><li><strong>创建一个Secret，多个Pod可以引用同一个Secret</strong></li><li><strong>修改Pod的定义，在spec.volumes[]加一个volume，给这个volume起个名字，spec.volumes[].secret.secretName记录的是要引用的Secret名字</strong></li><li><strong>在每个需要使用Secret的容器中添加一项spec.containers[].volumeMounts[]，指定spec.containers[].volumeMounts[].readOnly = true，spec.containers[].volumeMounts[].mountPath要指向一个未被使用的系统路径。</strong></li><li><strong>修改镜像或者命令行使系统可以找到上一步指定的路径。此时Secret中data字段的每一个key都是指定路径下面的一个文件名</strong></li></ol></blockquote><h4 id="编写pod的yaml文件"><strong>编写pod的yaml文件</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# vim pod.yaml <br><br>apiVersion: v1<br>kind: Pod<br>metadata:<br>  name: mypod<br>spec:<br>  containers:<br>  - name: mypod<br>    image: busybox<br>    args:<br>      - /bin/sh<br>      - -c<br>      - sleep 300000<br>    volumeMounts:<br>    - name: secret-test<br>      mountPath: "/etc/secret-test"  #pod中的路径<br>      readOnly: true                 #是否只读<br>  volumes:<br>  - name: secret-test<br>    secret:<br>      secretName: mysecret1<br></code></pre></td></tr></table></figure><p><strong>还可以自定义存放数据的文件名</strong></p><h4 id="执行一下-2">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# kubectl apply -f pod.yaml<br></code></pre></td></tr></table></figure><h3 id="Secret文件权限">Secret文件权限</h3><p><strong>可以指定secret文件的权限，类似linux系统文件权限，如果不指定默认权限是0644，等同于linux文件的-rw-r–r--权限</strong></p><h4 id="进入容器查看保存的数据">进入容器查看保存的数据</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# kubectl exec -it mypod /bin/sh<br>/ # cd /etc/secret-test/<br>/etc/secret-test # ls<br>pasword   username<br>/etc/secret-test # cat username <br>root<br>/etc/secret-test # cat pasword <br>123.com<br></code></pre></td></tr></table></figure><h4 id="测试是否有只读权限">测试是否有只读权限</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">123.com/etc/secret-test # echo admin &gt; username<br>/bin/sh: can't create username: Read-only file system<br></code></pre></td></tr></table></figure><h3 id="1-1-自定义存放数据的文件名的yaml文件">1.1 自定义存放数据的文件名的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]#  vim pod.yaml <br>apiVersion: v1<br>kind: Pod<br>metadata:<br>  name: mypod<br>spec:<br>  containers:<br>  - name: mypod<br>    image: busybox<br>    args:<br>      - /bin/sh<br>      - -c<br>      - sleep 300000<br>    volumeMounts:<br>    - name: secret-test<br>      mountPath: "/etc/secret-test"  #pod中的路径<br>      readOnly: true                 #是否只读<br>  volumes:<br>  - name: secret-test<br>    secret:<br>      secretName: mysecret1<br>      items:<br>      - key: username<br>        path: my-group/my-username   #自定义的容器中的目录<br>      - key: password<br>        path: my-group/my-password   #自定义的容器中的目录<br></code></pre></td></tr></table></figure><h4 id="执行一下-3">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f pod.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-4">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# kubectl exec -it mypod /bin/sh<br>//进入容器查看<br><span class="hljs-meta"> #</span><span class="bash"> cat /etc/secret-test/my-group/my-password </span><br>123.com <br><span class="hljs-meta"> #</span><span class="bash"> cat /etc/secret-test/my-group/my-username </span><br>root<br></code></pre></td></tr></table></figure><h3 id="1-2-如果，现在将secret资源内保存的数据进行更新，请问，使用此数据的应用内，数据是是否也会更新">1.2 如果，现在将secret资源内保存的数据进行更新，请问，使用此数据的应用内，数据是是否也会更新?</h3><p><strong>会实时更新(这里引用数据，是以volumes挂 载使用数据的方式)。</strong></p><p><strong>更新mysecret1的数据: password —&gt; admin YWRtaW4K (base64)</strong></p><p><strong>可以通过edit 命令，直接修改。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# kubectl edit secrets mysecret1<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200217162834490.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200217162834490.png" alt="image-20200217162834490"></a></p><h4 id="查看一下-5">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# kubectl exec -it mypod /bin/sh<br>//进入容器查看<br><span class="hljs-meta"> #</span><span class="bash"> cat /etc/secret-test/my-group/my-password </span><br>admin<br><span class="hljs-meta"> #</span><span class="bash"> cat /etc/secret-test/my-group/my-username </span><br>root<br></code></pre></td></tr></table></figure><p><em><strong>数据已经成功更新了</strong></em></p><h3 id="2、以环境变量的方式">2、以环境变量的方式</h3><blockquote><p><strong>创建一个Secret，多个Pod可以引用同一个Secret</strong><br><strong>修改pod的定义，定义环境变量并使用env[].valueFrom.secretKeyRef指定secret和相应的key</strong><br><strong>修改镜像或命令行，让它们可以读到环境变量</strong></p></blockquote><p><strong>编写pod的yaml文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# vim pod-env.yaml <br>apiVersion: v1<br>kind: Pod<br>metadata:<br>  name: mypod2<br>spec:<br>  containers:<br>  - name: mypod<br>    image: busybox<br>    args:<br>      - /bin/sh<br>      - -c<br>      - sleep 300000<br>    env:<br>      - name: SECRET_USERNAME<br>        valueFrom:<br>          secretKeyRef:<br>            name: mysecret2<br>            key: username<br>      - name: SECRET_PASSWORD<br>        valueFrom:<br>          secretKeyRef:<br>            name: mysecret2<br>            key: password<br></code></pre></td></tr></table></figure><h4 id="执行一下-4">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# kubectl apply -f pod-env.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-6">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200214111931566.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200214111931566.png" alt="image-20200214111931566"></a></p><h4 id="进入容器查看保存的数据-2">进入容器查看保存的数据</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# kubectl exec -it mypod2 /bin/sh<br>/ # echo $SECRET_USERNAME<br>root<br>/ # echo $SECRET_PASSWORD<br>123.com<br></code></pre></td></tr></table></figure><h3 id="2-1-更新sevret文件的内容">2.1 更新sevret文件的内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl edit secrets mysecret2<br>//修改保存文件的内容<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200217162834490.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200217162834490.png" alt="image-20200217162834490"></a></p><h4 id="查看一下-7">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master secret]# kubectl exec -it mypod2 /bin/sh<br>/ # echo $SECRET_USERNAME<br>root<br>/ # echo $SECRET_PASSWORD<br>123.com<br></code></pre></td></tr></table></figure><p><em><strong>等待了一定时间后，可以看到这个数据并没有没有改变</strong></em></p><h2 id="总结">总结</h2><p><strong>如果引用secret数据的应用， 要求会随着secret资源对象内保存的数据的更新，而实时更新，那么应该使用volumes挂载的方式引用资源因为用环境变量的方式引用不会实时更新数据。</strong></p><h1>二、ConfigMap</h1><p><strong>和Secret资源类似，不同之处在于，secret 资源保存的是敏感信息，而Configmap保存的是以明文方式存放的数据。</strong></p><p><strong>Configmap的创建与使用方式与Secret非常类似，不同点只在于数据以明文形式存放（不过，我觉得Secret的密文形式也并不密文，只能算得上是简单编码）。</strong></p><p><strong>和Secret资源类似，不同之处在于，secret 资源保存的是敏感信息，而Configmap保存的是以明文方式存放的数据。</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/20200607213735.png" alt="k8s的Secret（密文）和configmap（明文）的使用教程"></p><blockquote><p><strong>username：adam</strong></p><p><strong>age：18</strong></p></blockquote><h2 id="创建的四种方式">创建的四种方式</h2><h3 id="1、通过-from-literal-文字的">1、通过-- from- literal(文字的):</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl create configmap myconfigmap1 --from-literal=username=adam --from-literal=age=18<br></code></pre></td></tr></table></figure><h4 id="查看一下-8">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get cm<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200217103048235.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200217103048235.png" alt="image-20200217103048235"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl describe cm<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200217103123130.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200217103123130.png" alt="image-20200217103123130"></a></p><h3 id="2、通过–from-file-文件">2、通过–from-file (文件) :</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# echo adam &gt; username<br>[root@master yaml]# echo 18 &gt; age<br></code></pre></td></tr></table></figure><h4 id="创建">创建</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl create configmap myconfigmap2 --from-file=username --from-file=age<br></code></pre></td></tr></table></figure><h4 id="查看一下-9">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl describe cm<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200217103509006.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200217103509006.png" alt="image-20200217103509006"></a></p><h3 id="3、通过–from-env-file">3、通过–from- env-file:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim env.txt <br>username=adam<br>age=18<br></code></pre></td></tr></table></figure><h4 id="创建-2">创建</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl create configmap  myconfigmap3 --from-env-file=env.txt<br></code></pre></td></tr></table></figure><h4 id="查看一下-10">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master configmap]# kubectl describe cm<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200217165039190.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200217165039190.png" alt="image-20200217165039190"></a></p><h3 id="4、通过yaml配置文件-2">4、通过yaml配置文件:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim configmap.yaml<br>apiVersion: v1<br>kind: ConfigMap<br>metadata:<br>  name: myconfigmap4<br>data:<br>  username: 'adam'<br>  age: '18'<br></code></pre></td></tr></table></figure><h4 id="创建-3">创建</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f configmap.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-11">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl describe cm<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200217104428521.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200217104428521.png" alt="image-20200217104428521"></a></p><h2 id="如何来使用configmap资源">如何来使用configmap资源</h2><h3 id="1-以Volume挂载的方式-2">1. 以Volume挂载的方式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim v-pod.yaml <br>apiVersion: v1<br>kind: Pod<br>metadata:<br>  name: pod1<br>spec:<br>  containers:<br>  - name: mypod<br>    image: busybox<br>    args:<br>      - /bin/sh<br>      - -c<br>      - sleep 300000<br>    volumeMounts:<br>    - name: cmp-test<br>      mountPath: "/etc/cmp-test"<br>      readOnly: true<br>    volumes:<br>  - name: cmp-test<br>    configMap:<br>      name: myconfigmap1<br></code></pre></td></tr></table></figure><h4 id="执行一下-5">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master configmap]# kubectl apply -f v-pod.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-12">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master configmap]# kubectl exec -it pod1 /bin/sh<br>//进入容器查看一下<br><span class="hljs-meta"> #</span><span class="bash"> cat /etc/cmp-test/age </span><br>18/ <br><span class="hljs-meta"> #</span><span class="bash"> cat /etc/cmp-test/username </span><br>adam/<br></code></pre></td></tr></table></figure><h3 id="1-1-自定义存放数据的文件名的yaml文件-2">1.1 自定义存放数据的文件名的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master configmap]# vim v-pod2.yaml <br>apiVersion: v1<br>kind: Pod<br>metadata:<br>  name: pod3<br>spec:<br>  containers:<br>  - name: mypod<br>    image: busybox<br>    args:<br>      - /bin/sh<br>      - -c<br>      - sleep 300000<br>    volumeMounts:<br>    - name: cmp-test<br>      mountPath: "/etc/cmp-test"<br>      readOnly: true<br>    volumes:<br>  - name: cmp-test<br>    configMap:<br>      name: myconfigmap1<br>      items:<br>      - key: username<br>        path: my-group/my-username   #自定义的容器中的目录<br>      - key: age<br>        path: my-group/my-age   #自定义的容器中的目录<br></code></pre></td></tr></table></figure><h4 id="执行一下-6">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master configmap]# kubectl apply -f v-pod2.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-13">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master configmap]# kubectl exec -it pod3 /bin/sh<br>//进入容器查看<br><span class="hljs-meta">#</span><span class="bash"> cat /etc/cmp-test/my-group/my-username </span><br>adam/ <br><span class="hljs-meta">#</span><span class="bash"> cat /etc/cmp-test/my-group/my-age </span><br>18/<br></code></pre></td></tr></table></figure><h3 id="1-2-如果，现在将secret资源内保存的数据进行更新，请问，使用此数据的应用内，数据是是否也会更新-2">1.2 如果，现在将secret资源内保存的数据进行更新，请问，使用此数据的应用内，数据是是否也会更新?</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master configmap]# kubectl edit cm myconfigmap1<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200217172107999.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200217172107999.png" alt="image-20200217172107999"></a></p><h4 id="查看一下-14">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master configmap]# kubectl exec -it pod3 /bin/sh<br>//进入容器查看<br><span class="hljs-meta">#</span><span class="bash"> cat /etc/cmp-test/my-group/my-username </span><br>adam/ <br><span class="hljs-meta">#</span><span class="bash"> cat /etc/cmp-test/my-group/my-age </span><br>10<br></code></pre></td></tr></table></figure><p><em><strong>可以看到更新成功</strong></em></p><h3 id="2-以环境变量的方式">2.以环境变量的方式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master configmap]# vim e-pod.yaml <br>apiVersion: v1<br>kind: Pod<br>metadata:<br>  name: pod2<br>spec:<br>  containers:<br>  - name: mypod<br>    image: busybox<br>    args:<br>      - /bin/sh<br>      - -c<br>      - sleep 300000<br>    env:<br>      - name: CONFIGMAP_NAME<br>        valueFrom:<br>          configMapKeyRef:<br>            name: myconfigmap2<br>            key: username<br>      - name: CONFIGMAP_AGE<br>        valueFrom:<br>          configMapKeyRef:<br>            name: myconfigmap2<br>            key: age<br></code></pre></td></tr></table></figure><h4 id="执行一下-7">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master configmap]# kubectl apply -f e-pod.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-15">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master configmap]# kubectl exec -it pod2 /bin/sh<br>//进入容器查看一下<br><span class="hljs-meta"> #</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$CONFIGMAP_NAME</span></span><br>adam<br><span class="hljs-meta"> #</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$CONFIGMAP_AGE</span></span><br>18<br></code></pre></td></tr></table></figure><h3 id="2-1-更新sevret文件的内容-2">2.1 更新sevret文件的内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master configmap]# kubectl edit cm myconfigmap2<br> //修改保存文件的内容<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200217172701793.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200217172701793.png" alt="image-20200217172701793"></a></p><h4 id="查看一下-16">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master configmap]# kubectl exec -it pod2 /bin/sh<br>//进入容器查看一下<br><span class="hljs-meta"> #</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$CONFIGMAP_NAME</span></span><br>adam<br><span class="hljs-meta"> #</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$CONFIGMAP_AGE</span></span><br>18<br></code></pre></td></tr></table></figure><p><em><strong>等待了一定时间后，可以看到这个数据并没有没有改变</strong></em></p><p><strong>可以看出这个configmap和secret的更新效果基本没有区别。</strong></p><h2 id="总结configmap、与secret资源有什么相同和不同之处。"><strong>总结configmap、与secret资源有什么相同和不同之处。</strong></h2><h3 id="Secret-与-ConfigMap-对比">Secret 与 ConfigMap 对比</h3><p><strong>相同点：</strong></p><blockquote><p><strong>key/value的形式</strong></p><p><strong>属于某个特定的namespace</strong></p><p><strong>可以导出到环境变量</strong></p><p><strong>可以通过目录/文件形式挂载</strong></p><p><strong>通过 volume 挂载的配置信息均可热更新</strong></p></blockquote><p><strong>不同点：</strong></p><blockquote><p><strong>Secret 可以被 ServerAccount 关联</strong></p><p><strong>Secret 可以存储 docker register 的鉴权信息，用在 ImagePullSecret 参数中，用于拉取私有仓库的镜像</strong></p><p><strong>Secret 支持 Base64 加密</strong></p><p><strong>Secret 分为 <a href="https://kubernetes.io/service-account-token%E3%80%81kubernetes.io/dockerconfigjson%E3%80%81Opaque" target="_blank" rel="noopener">kubernetes.io/service-account-token、kubernetes.io/dockerconfigjson、Opaque</a> 三种类型，而 Configmap 不区分类型</strong></p></blockquote><h2 id="总结以volumes挂载、和环境变量方式引用资源的相同和不同之处。">总结以volumes挂载、和环境变量方式引用资源的相同和不同之处。</h2><p><strong>volumes挂载(可根据更改数据更新)：引用自己创建的secret（密文）或configmap（明文），挂载到容器中指定的目录下。查看保存的文件时，根据自己所填路径和secret或configmap创建的文件，进行查看。</strong></p><p><strong>环境变量(不因更改数据更新)：引用自己创建的secret（密文）或configmap（明文），挂载到容器中指定的目录下。查看保存的文件时，根据自己环境变量，进行查看。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> secret </tag>
            
            <tag> pod </tag>
            
            <tag> configmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s的StatefulSet（有状态服务）实现</title>
      <link href="/posts/af4b.html"/>
      <url>/posts/af4b.html</url>
      
        <content type="html"><![CDATA[<h1>StatefulSet介绍</h1><h3 id="遇到的问题：">遇到的问题：</h3><p><strong>使用Deployment创建的Pod是无状态的，当挂在Volume之后，如果该Pod挂了，Replication Controller会再run一个来保证可用性，但是由于是无状态的，Pod挂了的时候与之前的Volume的关系就已经断开了，新起来的Pod无法找到之前的Pod。但是对于用户而言，他们对底层的Pod挂了没有感知，但是当Pod挂了之后就无法再使用之前挂载的磁盘了。</strong></p><h4 id="StatefulSet-是一种给Pod提供唯一标志的控制器，它可以保证部署和扩展的顺序。"><strong>StatefulSet: 是一种给Pod提供唯一标志的控制器，它可以保证部署和扩展的顺序。</strong></h4><blockquote><p><strong>Pod一致性：包含次序（启动、停止次序）、网络一致性。此一致性与Pod相关，与被调度到哪个node节点无关。</strong></p><p><strong>稳定的次序：对于N个副本的StatefulSet，每个Pod都在[0，N)的范围内分配一个数字序号，且是唯一的。</strong></p><p><strong>稳定的网络：Pod的hostname模式为(statefulset名称)- (序号)。</strong></p><p><strong>稳定的存储：通过VolumeClaimTemplate为每个Pod创建一个PV。删除、减少副本，不会删除相关的卷。</strong></p></blockquote><h4 id="1-RC、-RS、Deployment、DS。-无状态服务"><strong>(1) RC、 RS、Deployment、DS。-----&gt; 无状态服务</strong></h4><blockquote><p><strong>template(模板):根据模板 创建出来的Pod,它们J的状态都是一模一样的(除了名称，IP, 域名之外)</strong></p><p><strong>可以理解为:任何一个Pod, 都可以被删除，然后用新生成的Pod进行替换。</strong></p></blockquote><h4 id="2-有状态的服务-需要记录前一-次或者多次通信中的相关事件，以作为一下通信的分类标准。比如-mysql等数据库服务。-Pod的名称，不能随意变化。数据持久化的目录也是不一样，每一个Pod都有自己独有的数据持久化存储目录。"><strong>(2) 有状态的服务: 需要记录前一 次或者多次通信中的相关事件，以作为一下通信的分类标准。比如: mysql等数据库服务。(Pod的名称，不能随意变化。数据持久化的目录也是不一样，每一个Pod都有自己独有的数据持久化存储目录。)</strong></h4><blockquote><p><strong>mysql:主从关系。</strong></p></blockquote><p><strong>如果把之前无状态的服务比喻为牛、羊等牲畜，因为，这些到一定时候就可以出售。那么，有状态就比喻为:宠物，而宠物不像牲畜一样到达一定时候出售，人们往往会照顾宠物的一生。</strong></p><h4 id="3-每一个Pod-对应一个PVC-每一个PVC对应一个PV。"><strong>(3) 每一个Pod----&gt;对应一个PVC----&gt;每一个PVC对应一个PV。</strong></h4><blockquote><p><strong>storageclass:自动创建PV</strong></p><p><strong>需要解决:自动创建PVC。</strong></p></blockquote><h1>实现原理</h1><p><strong>与 ReplicaSet 和 Deployment 资源一样，StatefulSet 也使用控制器的方式实现，它主要由 StatefulSetController、StatefulSetControl 和 StatefulPodControl 三个组件协作来完成 StatefulSet 的管理，StatefulSetController 会同时从 PodInformer 和 ReplicaSetInformer 中接受增删改事件并将事件推送到队列中：</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/20200607212629.png" alt="k8s的StatefulSet（有状态服务）实现"><br><strong>控制器 StatefulSetController 会在 Run 方法中启动多个 Goroutine 协程，这些协程会从队列中获取待处理的 StatefulSet 资源进行同步，接下来我们会先介绍 Kubernetes 同步 StatefulSet 的过程。</strong></p><h2 id="1，例子">1，例子</h2><h3 id="（1）创建一个statefulset的yaml文件">（1）创建一个statefulset的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim statefulset.yaml<br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: headless-svc<br>  labels:<br>    app: headless-svc<br>spec:<br>  ports:<br>  - port: 80<br>  selector:<br>    app: headless-pod<br>  clusterIP: None     #没有同一的ip<br>---<br>apiVersion: apps/v1<br>kind: StatefulSet<br>metadata:<br>  name: statefulset-test<br>spec:<br>  serviceName: headless-svc<br>  replicas: 3<br>  selector:<br>    matchLabels:<br>      app: headless-pod<br>  template:<br>    metadata:<br>      labels:<br>        app: headless-pod<br>    spec:<br>      containers:<br>      - name: myhttpd<br>        image: httpd<br>        ports:<br>        - containerPort: 80<br></code></pre></td></tr></table></figure><p><strong>Deployment : Deploy+RS+随机字符串(Pod的名称。)没有顺序的，可</strong><br><strong>以没随意替代的。</strong></p><blockquote><p><strong>1、headless-svc :无头服务。因为没有IP地址，所以它不具备负载均衡的功能了。因为statefulset要求Pod的名称是有顺序的，每一个Pod都不能被随意取代，也就是即使Pod重建之后，名称依然不变。为后端的每一个Pod去命名。</strong></p><p><strong>2、statefulSet:定义具体的应用</strong></p><p><strong>3、volumeClaimT emplates:自动创建PVC，为后端的Pod提供专有的存储。</strong></p></blockquote><h3 id="执行一下">执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f statefulset.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get svc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212100101082.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212100101082.png" alt="image-20200212100101082"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod<br>//可看到这些pod是有顺序的<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212102001181.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212102001181.png" alt="image-20200212102001181"></a></p><h1>一、创建StorageClass资源对象。</h1><h2 id="1、基于NFS服务，创建NFS服务。">1、基于NFS服务，创建NFS服务。</h2><p><strong>下载nfs所需安装包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node02 ~]# yum -y install nfs-utils  rpcbind<br></code></pre></td></tr></table></figure><p><strong>创建共享目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# mkdir /nfsdata<br></code></pre></td></tr></table></figure><p><strong>创建共享目录的权限</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim /etc/exports<br>/nfsdata *(rw,sync,no_root_squash)<br></code></pre></td></tr></table></figure><p><strong>开启nfs和rpcbind</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# systemctl start nfs-server.service <br>[root@master ~]# systemctl start rpcbind<br></code></pre></td></tr></table></figure><p><strong>测试一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# showmount -e<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205105654925.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205105654925.png" alt="image-20200205105654925"></a></p><h2 id="2、创建rbac权限。">2、创建rbac权限。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim rbac-rolebind.yaml <br>apiVersion: v1<br>kind: ServiceAccount<br>metadata:<br>  name: nfs-provisioner<br>  namespace: default<br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRole<br>metadata:<br>  name: nfs-provisioner-runner<br>  namespace: default<br>rules:<br>   -  apiGroups: [""]<br>      resources: ["persistentvolumes"]<br>      verbs: ["get", "list", "watch", "create", "delete"]<br>   -  apiGroups: [""]<br>      resources: ["persistentvolumeclaims"]<br>      verbs: ["get", "list", "watch", "update"]<br>   -  apiGroups: ["storage.k8s.io"]<br>      resources: ["storageclasses"]<br>      verbs: ["get", "list", "watch"]<br>   -  apiGroups: [""]<br>      resources: ["events"]<br>      verbs: ["watch", "create", "update", "patch"]<br>   -  apiGroups: [""]<br>      resources: ["services", "endpoints"]<br>      verbs: ["get","create","list", "watch","update"]<br>   -  apiGroups: ["extensions"]<br>      resources: ["podsecuritypolicies"]<br>      resourceNames: ["nfs-provisioner"]<br>      verbs: ["use"]<br>---<br>kind: ClusterRoleBinding<br>apiVersion: rbac.authorization.k8s.io/v1<br>metadata:<br>  name: run-nfs-provisioner<br>subjects:<br>  - kind: ServiceAccount<br>    name: nfs-provisioner<br>    namespace: default        #必写字段<br>roleRef:<br>  kind: ClusterRole<br>  name: nfs-provisioner-runner<br>  apiGroup: rbac.authorization.k8s.io<br></code></pre></td></tr></table></figure><h3 id="执行一下-2">执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f rbac-rolebind.yaml<br></code></pre></td></tr></table></figure><h2 id="3、创建Deployment资源对象，用Pod代替-真正的NFS服务。">3、创建Deployment资源对象，用Pod代替 真正的NFS服务。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim nfs-deployment.yaml <br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: nfs-client-provisioner<br>spec:<br>  replicas: 1<br>  strategy:<br>    type: Recreate<br>  template:<br>    metadata:<br>      labels:<br>        app: nfs-client-provisioner<br>    spec:<br>      serviceAccount: nfs-provisioner<br>      containers:<br>        - name: nfs-client-provisioner<br>          image: registry.cn-hangzhou.aliyuncs.com/open-ali/nfs-client-provisioner<br>          volumeMounts:<br>            - name: nfs-client-root<br>              mountPath:  /persistentvolumes<br>          env:<br>            - name: PROVISIONER_NAME<br>              value: bdqn<br>            - name: NFS_SERVER<br>              value: 192.168.1.21<br>            - name: NFS_PATH<br>              value: /nfsdata<br>      volumes:<br>        - name: nfs-client-root<br>          nfs:<br>            server: 192.168.1.21<br>            path: /nfsdata<br></code></pre></td></tr></table></figure><h3 id="执行一下-3">执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f nfs-deployment.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下-2">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212104037272.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212104037272.png" alt="image-20200212104037272"></a></p><h2 id="4、创建storageclass的yaml文件">4、创建storageclass的yaml文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim test-storageclass.yaml <br>apiVersion: storage.k8s.io/v1<br>kind: StorageClass<br>metadata:<br>  name: stateful-nfs<br>provisioner: bdqn  #通过provisioner字段关联到上述Deploy<br>reclaimPolicy: Retain<br></code></pre></td></tr></table></figure><h3 id="执行一下-4">执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f test-storageclass.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下-3">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get sc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212104551911.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212104551911.png" alt="image-20200212104551911"></a></p><h1>二，解决自动创建pvc</h1><h2 id="1、创建statefulset的yaml文件">1、创建statefulset的yaml文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim statefulset.yaml <br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: headless-svc<br>  labels:<br>    app: headless-svc<br>spec:<br>  ports:<br>  - port: 80<br>    name: myweb<br>  selector:<br>    app: headless-pod<br>  clusterIP: None<br>---<br>apiVersion: apps/v1<br>kind: StatefulSet<br>metadata:<br>  name: statefulset-test<br>spec:<br>  serviceName: headless-svc<br>  replicas: 3<br>  selector:<br>    matchLabels:<br>      app: headless-pod<br>  template:<br>    metadata:<br>      labels:<br>        app: headless-pod<br>    spec:<br>      containers:<br>      - image: httpd<br>        name: myhttpd<br>        ports:<br>        - containerPort: 80<br>          name: httpd<br>        volumeMounts:<br>        - mountPath: /mnt<br>          name: test<br>  volumeClaimTemplates:  #&gt; 自动创建PVC，为后端的Pod提供专有的存储。**<br>  - metadata:<br>      name: test<br>      annotations:   #这是指定storageclass<br>        volume.beta.kubernetes.io/storage-class: stateful-nfs<br>    spec:<br>      accessModes:<br>        - ReadWriteOnce<br>      resources:<br>        requests:<br>          storage: 100Mi<br></code></pre></td></tr></table></figure><p><strong>在此示例中：</strong></p><ul><li><strong>创建了一个名为 <code>headless-svc</code> 的 <a href="https://cloud.google.com/kubernetes-engine/docs/concepts/service?hl=zh-cn" target="_blank" rel="noopener">Service</a> 对象，由 <code>metadata: name</code> 字段指示。该 Service 会定位一个名为 <code>headless-svc</code> 的应用，由 <code>labels: app: headless-svc</code> 和 <code>selector: app: headless-pod</code> 指示。该 Service 会公开端口 80 并将其命名为 <code>web</code>。而且该 Service 会控制网域并将互联网流量路由到 StatefulSet 部署的容器化应用。</strong></li><li><strong>使用三个副本 Pod (<code>replicas: 3</code>) 创建了一个名为 <code>web</code> 的 StatefulSet。</strong></li><li><strong>Pod 模板 (<code>spec: template</code>) 指示其 Pod 标记为 <code>app: headless-pod</code>。</strong></li><li><strong>Pod 规范 (<code>template: spec</code>) 指示 StatefulSet 的 Pod 运行一个容器 <code>myhttpd</code>，该容器运行版本为 <code>httpd</code> 映像。容器映像由 <a href="https://cloud.google.com/container-registry/docs/concepts/overview?hl=zh-cn" target="_blank" rel="noopener">Container Registry</a> 托管。</strong></li><li><strong>Pod 规范使用由 Service 打开的 <code>web</code> 端口。</strong></li><li><strong><code>template: spec: volumeMounts</code> 指定一个名为 <code>test</code> 的 <code>mountPath</code>。<code>mountPath</code> 是容器中应装载存储卷的路径。</strong></li><li><strong>StatefulSet 预配了一个具有 100mb 预配存储空间的 <a href="https://cloud.google.com/kubernetes-engine/docs/concepts/persistent-volumes?hl=zh-cn" target="_blank" rel="noopener">PersistentVolumeClaim</a>：<code>test</code>。</strong></li></ul><h3 id="执行一下-5">执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f statefulset.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下-4">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212105434510.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212105434510.png" alt="image-20200212105434510"></a></p><p><em><strong>如果第一个pod出现了问题，后面的pod就不会生成。</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get statefulsets<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212105502430.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212105502430.png" alt="image-20200212105502430"></a></p><h2 id="2、-验证一下数据存储">2、 验证一下数据存储</h2><h4 id="容器中创建文件">容器中创建文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl exec -it statefulset-test-0 /bin/sh<br><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">cd</span> /mnt</span><br><span class="hljs-meta">#</span><span class="bash"> touch testfile</span><br><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">exit</span></span><br></code></pre></td></tr></table></figure><h4 id="宿主机查看一下">宿主机查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# ls /nfsdata/default-test-statefulset-test-0-pvc-bf1ae1d0-f496-4d69-b33b-39e8aa0a6e8d/<br>testfile<br></code></pre></td></tr></table></figure><h1>三、小实验</h1><p><strong>以自己的名称创建一个名称空间，以下所有资源都运行在此空间中。用statefuset资源运行一个httpd web服务，要求3个Pod，但是每个Pod的主界面内容不一样，并且都要做专有的数据持久化，尝试删除其中一个Pod，查看新生成的Pod，总结对比与之前Deployment资源控制器控制的Pod有什么不同之处？</strong></p><h2 id="（一）创建StorageClass资源对象。">（一）创建StorageClass资源对象。</h2><p><em><strong>注意：nfs服务要开启</strong></em></p><h3 id="1、创建namespace的yaml文件">1、创建namespace的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim namespace.yaml <br>kind: Namespace<br>apiVersion: v1<br>metadata:<br>  name: xgp-lll    #namespave的名称<br></code></pre></td></tr></table></figure><h4 id="执行一下-6">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f namespace.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-5">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get namespaces<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212113542729.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212113542729.png" alt="image-20200212113542729"></a></p><h3 id="2-创建rbac权限。">2. 创建rbac权限。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim rbac-rolebind.yaml<br>apiVersion: v1<br>kind: ServiceAccount<br>metadata:<br>  name: nfs-provisioner<br>  namespace: xgp-lll<br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRole<br>metadata:<br>  name: nfs-provisioner-runner<br>  namespace: xgp-lll<br>rules:<br>   -  apiGroups: [""]<br>      resources: ["persistentvolumes"]<br>      verbs: ["get", "list", "watch", "create", "delete"]<br>   -  apiGroups: [""]<br>      resources: ["persistentvolumeclaims"]<br>      verbs: ["get", "list", "watch", "update"]<br>   -  apiGroups: ["storage.k8s.io"]<br>      resources: ["storageclasses"]<br>      verbs: ["get", "list", "watch"]<br>   -  apiGroups: [""]<br>      resources: ["events"]<br>      verbs: ["watch", "create", "update", "patch"]<br>   -  apiGroups: [""]<br>      resources: ["services", "endpoints"]<br>      verbs: ["get","create","list", "watch","update"]<br>   -  apiGroups: ["extensions"]<br>      resources: ["podsecuritypolicies"]<br>      resourceNames: ["nfs-provisioner"]<br>      verbs: ["use"]<br>---<br>kind: ClusterRoleBinding<br>apiVersion: rbac.authorization.k8s.io/v1<br>metadata:<br>  name: run-nfs-provisioner<br>subjects:<br>  - kind: ServiceAccount<br>    name: nfs-provisioner<br>    namespace: xgp-lll<br>roleRef:<br>  kind: ClusterRole<br>  name: nfs-provisioner-runner<br>  apiGroup: rbac.authorization.k8s.io<br></code></pre></td></tr></table></figure><h4 id="执行一下-7">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f rbac-rolebind.yaml<br></code></pre></td></tr></table></figure><h3 id="3、创建Deployment资源对象，用Pod代替-真正的NFS服务。-2">3、创建Deployment资源对象，用Pod代替 真正的NFS服务。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim nfs-deployment.yaml <br><br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: nfs-client-provisioner<br>  namespace: xgp-lll<br>spec:<br>  replicas: 1<br>  strategy:<br>    type: Recreate<br>  template:<br>    metadata:<br>      labels:<br>        app: nfs-client-provisioner<br>    spec:<br>      serviceAccount: nfs-provisioner<br>      containers:<br>        - name: nfs-client-provisioner<br>          image: registry.cn-hangzhou.aliyuncs.com/open-ali/nfs-client-provisioner<br>          volumeMounts:<br>            - name: nfs-client-root<br>              mountPath:  /persistentvolumes<br>          env:<br>            - name: PROVISIONER_NAME<br>              value: xgp<br>            - name: NFS_SERVER<br>              value: 192.168.1.21<br>            - name: NFS_PATH<br>              value: /nfsdata<br>      volumes:<br>        - name: nfs-client-root<br>          nfs:<br>            server: 192.168.1.21<br>            path: /nfsdata<br></code></pre></td></tr></table></figure><h4 id="执行一下-8">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f nfs-deployment.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-6">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod  -n xgp-lll<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212115808607.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212115808607.png" alt="image-20200212115808607"></a></p><h3 id="4、创建storageclass的yaml文件-2">4、创建storageclass的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim test-storageclass.yaml <br>apiVersion: storage.k8s.io/v1<br>kind: StorageClass<br>metadata:<br>  name: stateful-nfs<br>  namespace: xgp-lll<br>provisioner: xgp  #通过provisioner字段关联到上述Deploy<br>reclaimPolicy: Retain<br></code></pre></td></tr></table></figure><h4 id="执行一下-9">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f test-storageclass.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-7">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get sc -n  xgp-lll<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212120207679.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212120207679.png" alt="image-20200212120207679"></a></p><h2 id="（二）解决自动创建pvc">（二）解决自动创建pvc</h2><h3 id="1、创建statefulset的yaml文件-2">1、创建statefulset的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs shell">apiVersion: v1<br>kind: Service<br>metadata:<br>  name: headless-svc<br>  namespace: xgp-lll<br>  labels:<br>    app: headless-svc<br>spec:<br>  ports:<br>  - port: 80<br>    name: myweb<br>  selector:<br>    app: headless-pod<br>  clusterIP: None<br>---<br>apiVersion: apps/v1<br>kind: StatefulSet<br>metadata:<br>  name: statefulset-test<br>  namespace: xgp-lll<br>spec:<br>  serviceName: headless-svc<br>  replicas: 3<br>  selector:<br>    matchLabels:<br>      app: headless-pod<br>  template:<br>    metadata:<br>      labels:<br>        app: headless-pod<br>    spec:<br>      containers:<br>      - image: httpd<br>        name: myhttpd<br>        ports:<br>        - containerPort: 80<br>          name: httpd<br>        volumeMounts:<br>        - mountPath: /usr/local/apache2/htdocs<br>          name: test<br>  volumeClaimTemplates:  #&gt; 自动创建PVC，为后端的Pod提供专有的存储。**<br>  - metadata:<br>      name: test<br>      annotations:   #这是指定storageclass<br>        volume.beta.kubernetes.io/storage-class: stateful-nfs<br>    spec:<br>      accessModes:<br>        - ReadWriteOnce<br>      resources:<br>        requests:<br>          storage: 100Mi<br></code></pre></td></tr></table></figure><h3 id="执行一下-10">执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f statefulset.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下-8">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod -n xgp-lll<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212121256221.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212121256221.png" alt="image-20200212121256221"></a></p><h3 id="2、-验证一下数据存储-2">2、 验证一下数据存储</h3><h4 id="容器中创建文件-2">容器中创建文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">第一个<br>[root@master yaml]# kubectl exec -it -n xgp-lll statefulset-test-0 /bin/bash <br>root@statefulset-test-0:/usr/local/apache2# echo 123 &gt; /usr/local/apache2/htdocs/index.html<br><br>第二个<br>[root@master yaml]# kubectl exec -it -n xgp-lll statefulset-test-1 /bin/bash <br>root@statefulset-test-2:/usr/local/apache2# echo 456 &gt; /usr/local/apache2/htdocs/index.html<br><br>第三个<br>[root@master yaml]# kubectl exec -it -n xgp-lll statefulset-test-2 /bin/bash <br>root@statefulset-test-1:/usr/local/apache2# echo 789 &gt; /usr/local/apache2/htdocs/index.html<br></code></pre></td></tr></table></figure><h4 id="宿主机查看一下-2">宿主机查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">第一个<br>[root@master yaml]# cat /nfsdata/xgp-lll-test-statefulset-test-0-pvc-ccaa02df-4721-4453-a6ec-4f2c928221d7/index.html <br>123<br><br>第二个<br>[root@master yaml]# cat /nfsdata/xgp-lll-test-statefulset-test-1-pvc-88e60a58-97ea-4986-91d5-a3a6e907deac/index.html <br>456<br><br><br>第三个<br>[root@master yaml]# cat /nfsdata/xgp-lll-test-statefulset-test-2-pvc-4eb2bbe2-63d2-431a-ba3e-b7b8d7e068d3/index.html <br>789<br></code></pre></td></tr></table></figure><h4 id="访问一下">访问一下</h4><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212131705416.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200212131705416.png" alt="image-20200212131705416"></a></p><p><strong>扩容、缩容:在此过程中，Pod的生成或删除操作也是有顺序性的。</strong></p><p><strong>升级操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl explain sts.spec.updateStrategy.rollingUpdate.partition<br></code></pre></td></tr></table></figure><p><strong>partition：如果partition后面的值等于N, N+的都会更新。默认值为0（所有都会更新）。</strong></p><h1>总结：</h1><ol><li><strong>StatefulSet 的控制器直接管理的是 Pod。通过在 Pod 的名字里加上事先约定好的编号，保证应用拓扑状态的服务稳定。</strong></li><li><strong>Kubernetes 通过 Headless Service，为这些有编号的 Pod，在 DNS 服务器中生成带有同样编号的 DNS 记录，生成唯一的网络标识。</strong></li><li><strong>StatefulSet 为每一个 Pod 分配并创建一个同样编号的 PVC。保证了每一个 Pod 都拥有一个独立的 Volume，保证数据不会丢失。</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> StatefulSet </tag>
            
            <tag> nfs-deployment </tag>
            
            <tag> Storage Class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s的存储类</title>
      <link href="/posts/15ab.html"/>
      <url>/posts/15ab.html</url>
      
        <content type="html"><![CDATA[<h4 id="k8s有很多的服务，很多的资源对象。">k8s有很多的服务，很多的资源对象。</h4><p><strong>如果要去创建服务，做数据持久化，需要预先知道可用<code>PV</code>有哪些?</strong></p><p><strong>如果为了这个服务去提前创建<code>PV</code>，那么我们还需要知道，这个服务，大概需要多大的空间?</strong></p><h3 id="环境介绍">环境介绍</h3><table><thead><tr><th>主机</th><th>IP地址</th><th>服务</th></tr></thead><tbody><tr><td>master</td><td>192.168.1.21</td><td>k8s</td></tr><tr><td>node01</td><td>192.168.1.22</td><td>k8s</td></tr><tr><td>node02</td><td>192.168.1.23</td><td>k8s</td></tr></tbody></table><p>基于<a href> https://blog.51cto.com/14320361/2464655</a> 的实验继续进行</p><h1>存储类介绍</h1><p><strong>Kubernetes集群管理员通过提供不同的存储类，可以满足用户不同的服务质量级别、备份策略和任意策略要求的存储需求。动态存储卷供应使用StorageClass进行实现，其允许存储卷按需被创建。如果没有动态存储供应，Kubernetes集群的管理员将不得不通过手工的方式类创建新的存储卷。通过动态存储卷，Kubernetes将能够按照用户的需要，自动创建其需要的存储。</strong></p><p><strong>基于StorageClass的动态存储供应整体过程如下图所示：</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/20200607211947.png" alt></p><blockquote><p><strong>1）集群管理员预先创建存储类（StorageClass）；</strong><br><strong>2）用户创建使用存储类的持久化存储声明(PVC：PersistentVolumeClaim)；</strong><br><strong>3）存储持久化声明通知系统，它需要一个持久化存储(PV: PersistentVolume)；</strong><br><strong>4）系统读取存储类的信息；</strong><br><strong>5）系统基于存储类的信息，在后台自动创建PVC需要的PV；</strong><br><strong>6）用户创建一个使用PVC的Pod；</strong><br><strong>7）Pod中的应用通过PVC进行数据的持久化；</strong><br><strong>8）而PVC使用PV进行数据的最终持久化处理。</strong></p></blockquote><h2 id="先来简单看一下这张图实现的过程，然后我们再来研究一下">先来简单看一下这张图实现的过程，然后我们再来研究一下</h2><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/20200607212122.png" alt="k8s的存储类"></p><blockquote><p><strong>说在前面的话，静态供给的话，会需要我们手动去创建pv，如果没有足够的资源，找不到合适的pv，那么pod就会处于pending等待的状态，就是说找不到合适的伴侣了，所以解决这两种问题，就给出了这种动态供给，主要是能够自动帮你创建pv<br>，就是你需要多大的容量，就自动给你创建多大的容量，也就是pv，k8s帮你创建了，创建pvc的时候就需要找pv了，这个时候就交给这个存储类了，而存储类呢，去帮你创建这些pv,存储类呢，就是实现了对指定存储的一个支持，直接帮你去调用api去创建存储类，所以就不需要人工的去帮你创建pv了。<br>而你去想想，当节点比较多，业务比较多的时候，再去人工手动创建pv，量还是很大的，而且也不是很好去维护。<br>而动态供给主要的一个实现就是StorageClass存储对象，其实它就是声明你使用哪个存储，然后呢帮你去连接，再帮你去自动创建pv。</strong></p></blockquote><p>举个例子更好去理解<br>话不多说下图<br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/20200607212132.png" alt="k8s的存储类"></p><blockquote><p><strong>其实它是一个基于NFS实现的一个pv供给，它大概流程是这样的，我们可能会创建一个statefulset有状态的应用存储，然后有一个管理的nfs-storageClass，因为nfs目前是不支持这个自动的创建pv的，我们可以利用社区实现的插件来完成这个pv的自动创建，也就是StorageClass这一块，创建完之后，然后pod再去引用。</strong></p></blockquote><h1>一，Storage Class（存储类）</h1><p><em><strong>作用：它可以动态的自动的创建所需要的PV</strong></em></p><p><strong>Provisioner（供给方，提供者）：及提供了存储资源的存储系统。k8s内建有多重供给方，这些供给方的名字都以“<a href="https://kubernetes.io/" target="_blank" rel="noopener">kubernetes.io</a>”为前缀。并且还可以自定义。</strong></p><p><strong>Parameters（参数）：存储类使用参数描述要关联到的存储卷，注意不同的供给方参数也不同。</strong></p><p><strong>ReclaimPlicy: PV的回收策略，可用值有Delete(默认)和Retain</strong></p><h3 id="（1）确定基于NFS服务来做的SC。NFS开启">（1）确定基于NFS服务来做的SC。NFS开启</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# showmount -e<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210102349600.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210102349600.png" alt="image-20200210102349600"></a></p><h3 id="（2）需要RBAC权限。">（2）需要RBAC权限。</h3><p><em><strong>RBAC：rbac是k8s的API的安全策略，是基于用户的访问权限的控制。规定了谁，可以有什么样的权限。</strong></em></p><p><strong>为了给SC资源操作k8s集群的权限。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim rbac-rolebind.yaml<br>kind: Namespace<br>apiVersion: v1<br>metadata:<br>  name: bdqn-test<br>---<br>apiVersion: v1<br>kind: ServiceAccount<br>metadata:<br>  name: nfs-provisioner<br>  namespace: bdqn-test<br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRole<br>metadata:<br>  name: nfs-provisioner-runner<br>  namespace: bdqn-test<br>rules:<br>   -  apiGroups: [""]<br>      resources: ["persistentvolumes"]<br>      verbs: ["get", "list", "watch", "create", "delete"]<br>   -  apiGroups: [""]<br>      resources: ["persistentvolumeclaims"]<br>      verbs: ["get", "list", "watch", "update"]<br>   -  apiGroups: ["storage.k8s.io"]<br>      resources: ["storageclasses"]<br>      verbs: ["get", "list", "watch"]<br>   -  apiGroups: [""]<br>      resources: ["events"]<br>      verbs: ["watch", "create", "update", "patch"]<br>   -  apiGroups: [""]<br>      resources: ["services", "endpoints"]<br>      verbs: ["get","create","list", "watch","update"]<br>   -  apiGroups: ["extensions"]<br>      resources: ["podsecuritypolicies"]<br>      resourceNames: ["nfs-provisioner"]<br>      verbs: ["use"]<br>---<br>kind: ClusterRoleBinding<br>apiVersion: rbac.authorization.k8s.io/v1<br>metadata:<br>  name: run-nfs-provisioner<br>subjects:<br>  - kind: ServiceAccount<br>    name: nfs-provisioner<br>    namespace: bdqn-test<br>roleRef:<br>    kind: ClusterRole<br>    name: nfs-provisioner-runner<br>    apiGroup: rbac.authorization.k8s.io<br></code></pre></td></tr></table></figure><p><strong>运行一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f rbac-rolebind.yaml<br></code></pre></td></tr></table></figure><h3 id="（3）nfs-deployment">（3）nfs-deployment</h3><p><em><strong>作用：其实它是一个NFS客户端。但它通过K8S的内置的NFS驱动挂载远端的NFS服务器到本地目录；然后将自身作为storage provider，关联storage class。</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim nfs-deployment.yaml<br><br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: nfs-client-provisioner<br>  namespace: bdqn-test<br>spec:<br>  replicas: 1<br>  strategy:<br>    type: Recreate<br>  template:<br>    metadata:<br>      labels:<br>        app: nfs-client-provisioner<br>    spec:<br>      serviceAccount: nfs-provisioner    #指定账户<br>      containers:<br>        - name: nfs-client-provisioner<br>          image: registry.cn-hangzhou.aliyuncs.com/open-ali/nfs-client-provisioner<br>          volumeMounts:<br>            - name: nfs-client-root<br>              mountPath:  /persistentvolumes   #指定容器内的挂载目录<br>          env:<br>            - name: PROVISIONER_NAME            #这是这个容器内置的变量<br>              value: bdqn-test                  #这是上面变量的值（名字）<br>            - name: NFS_SERVER                  #内置变量，用于指定nfs服务的IP<br>              value: 192.168.1.21<br>            - name: NFS_PATH                    #内置变量，指定的是nfs共享的目录<br>              value: /nfsdata<br>      volumes:                                  #这下面是指定上面挂载到容器内的nfs的路径及IP<br>        - name: nfs-client-root<br>          nfs:<br>            server: 192.168.1.21<br>            path: /nfsdata<br></code></pre></td></tr></table></figure><p><strong>执行一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f nfs-deployment.yaml<br></code></pre></td></tr></table></figure><h3 id="（4）创建storageclass">（4）创建storageclass</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim test-storageclass.yaml<br><br>apiVersion: storage.k8s.io/v1<br>kind: StorageClass<br>metadata:<br>  name: stateful-nfs<br>  namespace: bdqn-test<br>provisioner: bdqn-test  #这里要和第三个nfs-client-provisioner的env环境变量中的value值对应。<br>reclaimPolicy: Retain   #回收策略为：retain，还有一个默认的值为“default”<br></code></pre></td></tr></table></figure><p><strong>执行一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f test-storageclass.yaml<br></code></pre></td></tr></table></figure><h3 id="（5）创建PVC">（5）创建PVC</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim test-pvc.yaml<br><br>apiVersion: v1<br>kind: PersistentVolumeClaim<br>metadata:<br>  name: test-claim<br>  namespace: bdqn-test<br>spec:<br>  storageClassName: stateful-nfs   #定义存储类的名字，要和SC的名字对应<br>  accessModes:<br>    - ReadWriteMany         #访问模式为RWM<br>  resources:<br>    requests:<br>      storage: 500Mi<br></code></pre></td></tr></table></figure><p><strong>执行一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f test-pvc.yaml<br></code></pre></td></tr></table></figure><p><strong>查看一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pvc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210221418144.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210221418144.png" alt="image-20200210221418144"></a></p><h3 id="（6）创建一个Pod">（6）创建一个Pod</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim test-pod.yaml<br>kind: Pod<br>apiVersion: v1<br>metadata:<br>  name: test-pod<br>  namespace: bdqn-test<br>spec:<br>  containers:<br>  - name: test-pod<br>    image: busybox<br>    args:<br>      - /bin/sh<br>      - -c<br>      - sleep 30000<br>    volumeMounts:<br>      - name: nfs-pvc<br>        mountPath: /test<br>  restartPolicy: OnFailure<br>  volumes:<br>    - name: nfs-pvc<br>      persistentVolumeClaim:<br>        claimName: test-claim  #这的名字要和PVC的名字一致<br></code></pre></td></tr></table></figure><p><strong>执行一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f  test-pod.yaml<br></code></pre></td></tr></table></figure><p><strong>查看一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod -n bdqn-test<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210111008028.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210111008028.png" alt="image-20200210111008028"></a></p><h3 id="（7）容器中添加内容，并查看挂载目录">（7）容器中添加内容，并查看挂载目录</h3><p><strong>进入容器修改页面内容</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl exec -it test-pod -n bdqn-test /bin/sh<br>/ # cd test/<br>/test # touch test-file<br>/test # echo 123456 &gt; test-file <br>/test # cat test-file <br>123456<br></code></pre></td></tr></table></figure><p><strong>查看挂载目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# ls /nfsdata/<br>bdqn-test-test-claim-pvc-79ddfcf1-65ae-455f-9e03-5bcfe6c6ce15<br>web1<br>web2<br>[root@master yaml]# cat /nfsdata/bdqn-test-test-claim-pvc-79ddfcf1-65ae-455f-9e03-5bcfe6c6ce15/test-file <br>123456<br></code></pre></td></tr></table></figure><h1>二，如果，K8S集群中， 有很多类似的PV, PVC在去向PV申请空间的时候，不仅会考虑名称以及访问控制模式，还会考虑你申请空间的大小，会分配给你最合适大小的PV。</h1><h3 id="运行一个web服务，采用Deployment资源，基于nginx镜像，replicas为3个。数据持久化目录为nginx服务的主访问目录：-usr-share-nginx-html"><em>运行一个web服务，采用Deployment资源，基于nginx镜像，replicas为3个。数据持久化目录为nginx服务的主访问目录：/usr/share/nginx/html</em></h3><p><strong>创建一个PVC,与上述资源进行关联。</strong></p><h4 id="1-基于nfs服务来做的PV和pvc">1. 基于nfs服务来做的PV和pvc</h4><p><strong>下载nfs所需安装包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node02 ~]# yum -y install nfs-utils  rpcbind<br></code></pre></td></tr></table></figure><p><strong>创建共享目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# mkdir /nfsdata<br></code></pre></td></tr></table></figure><p><strong>创建共享目录的权限</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim /etc/exports<br>/nfsdata *(rw,sync,no_root_squash)<br></code></pre></td></tr></table></figure><p><strong>开启nfs和rpcbind</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# systemctl start nfs-server.service <br>[root@master ~]# systemctl start rpcbind<br></code></pre></td></tr></table></figure><p><strong>测试一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# showmount -e<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205105654925.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205105654925.png" alt="image-20200205105654925"></a></p><h4 id="2-先创建两个PV-web-pV1-1G-web-pv2-2G">2.先创建两个PV, web- pV1(1G) ,web-pv2 (2G)</h4><p><strong>web1</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim web.yaml <br><br>apiVersion: v1<br>kind: PersistentVolume<br>metadata:<br>  name: web-pv<br>spec :<br>  capacity:<br>    storage: 1Gi<br>  accessModes:<br>    - ReadWriteOnce<br>  persistentVolumeReclaimPolicy: Recycle<br>  storageClassName: nfs<br>  nfs:<br>    path: /nfsdata/web1<br>    server: 192.168.1.21<br></code></pre></td></tr></table></figure><p><strong>web2</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim web2.yaml <br><br>apiVersion: v1<br>kind: PersistentVolume<br>metadata:<br>  name: web-pv2<br>spec :<br>  capacity :<br>    storage: 2Gi<br>  accessModes:<br>    - ReadWriteOnce<br>  persistentVolumeReclaimPolicy: Recycle<br>  storageClassName: nfs<br>  nfs:<br>    path: /nfsdata/web2<br>    server: 192.168.1.21<br></code></pre></td></tr></table></figure><h4 id="3-创建所需文件夹">3.创建所需文件夹</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# mkdir /nfsdata/web1<br>[root@master yaml]# mkdir /nfsdata/web2<br></code></pre></td></tr></table></figure><h4 id="4-执行一下web和web2">4.执行一下web和web2</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f web.yaml <br>[root@master yaml]# kubectl apply -f web2.yaml<br></code></pre></td></tr></table></figure><h4 id="5-查看一下">5.查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pv<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210094332726.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210094332726.png" alt="image-20200210094332726"></a></p><h4 id="6-创建web的pvc的yaml文件">6.创建web的pvc的yaml文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim web-pvc.yaml <br><br>apiVersion: v1<br>kind: PersistentVolumeClaim<br>metadata:<br>  name: web-pvc<br>spec:<br>  accessModes:<br>  - ReadWriteOnce<br>  resources:<br>    requests:<br>      storage: 1Gi<br>  storageClassName: nfs<br></code></pre></td></tr></table></figure><p>执行一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f web-pvc.yaml<br></code></pre></td></tr></table></figure><p>查看一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pvc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210094701343.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210094701343.png" alt="image-20200210094701343"></a></p><p><strong>系统会自动给pvc一个相近内存的pv，所以选择了1G的那个</strong></p><h4 id="7-创建pod的yaml文件">7.创建pod的yaml文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim web-pod.yaml<br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: web-pod<br>spec:<br>  selector:<br>    matchLabels:<br>      app: nginx<br>  template:<br>    metadata:<br>      labels:<br>        app: nginx<br>    spec:<br>      containers:<br>      - image: nginx<br>        name: nginx<br>        volumeMounts:<br>        - name: web-test<br>          mountPath: /usr/share/nginx/html<br>      volumes:<br>      - name: web-test<br>        persistentVolumeClaim:<br>          claimName: web-pvc<br></code></pre></td></tr></table></figure><h5 id="执行一下">执行一下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f web-pod.yaml<br></code></pre></td></tr></table></figure><h5 id="查看一下">查看一下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210125236332.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210125236332.png" alt="image-20200210125236332"></a></p><h4 id="8-访问一下nginx的网页">8. 访问一下nginx的网页</h4><h5 id="查看一下nginx的ip">查看一下nginx的ip</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210134937483.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210134937483.png" alt="image-20200210134937483"></a></p><h5 id="进入容器设置网页内容">进入容器设置网页内容</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@master yaml]# kubectl exec -it web-pod-8686d9c594-qxhr9 /bin/bash<br>root@web-pod-8686d9c594-qxhr9:/# cd /usr/share/nginx/html/<br>root@web-pod-8686d9c594-qxhr9:/usr/share/nginx/html# ls<br>root@web-pod-8686d9c594-qxhr9:/usr/share/nginx/html# echo 123456 &gt; index.html<br>root@web-pod-8686d9c594-qxhr9:/usr/share/nginx/html# exit<br></code></pre></td></tr></table></figure><h5 id="访问一下">访问一下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# curl 10.244.2.17<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210135153791.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210135153791.png" alt="image-20200210135153791"></a></p><h1>三，如果两个PV，大小一样，名称一样，访问控制模式不一样，PVC会关联哪一个? (验证PV和PVC 关联的时候，访问模式必须一样)</h1><h3 id="两个PV，大小一样，名称一样，访问控制模式不一样">两个PV，大小一样，名称一样，访问控制模式不一样</h3><h4 id="1-创建两个pv">&lt;1&gt;创建两个pv</h4><h5 id="web1">web1</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim web1.yaml <br>apiVersion: v1<br>kind: PersistentVolume<br>metadata:<br>  name: web-pv<br>spec :<br>  capacity:<br>    storage: 1Gi<br>  accessModes:<br>    - ReadWriteOnce  #能以读-写mount到单个的节点<br>  persistentVolumeReclaimPolicy: Recycle<br>  storageClassName: nfs<br>  nfs:<br>    path: /nfsdata/web1<br>    server: 192.168.1.21<br></code></pre></td></tr></table></figure><h5 id="web2">web2</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim web2.yaml <br>apiVersion: v1<br>kind: PersistentVolume<br>metadata:<br>  name: web-pv<br>spec :<br>  capacity:<br>    storage: 1Gi<br>  accessModes:<br>    - ReadWriteMany        #能以读-写mount到多个的节点<br>  persistentVolumeReclaimPolicy: Recycle<br>  storageClassName: nfs<br>  nfs:<br>    path: /nfsdata/web1<br>    server: 192.168.1.21<br></code></pre></td></tr></table></figure><h5 id="创建所需文件">创建所需文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# mkdir /nfsdata/web1<br></code></pre></td></tr></table></figure><h5 id="执行一下-2">执行一下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f web1.yaml <br>[root@master yaml]# kubectl apply -f web2.yaml<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210140007119.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210140007119.png" alt="image-20200210140007119"></a></p><h4 id="2-创建pvc">&lt;2&gt;创建pvc</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim web-pvc.yaml <br>apiVersion: v1<br>kind: PersistentVolumeClaim<br>metadata:<br>  name: web-pvc<br>spec:<br>  accessModes:<br>  - ReadWriteMany    #能以读-写mount到多个的节点<br>  resources:<br>    requests:<br>      storage: 1Gi<br>  storageClassName: nfs<br></code></pre></td></tr></table></figure><h5 id="执行一下-3">执行一下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f web-pvc.yaml<br></code></pre></td></tr></table></figure><h4 id="3-查看一下">&lt;3&gt;查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pv<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210140227667.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210140227667.png" alt="image-20200210140227667"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pvc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210140258049.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210140258049.png" alt="image-20200210140258049"></a></p><p><strong>现在可以看到pv和pvc关联成功，但是为什么只有一个pv呢？（pv挂载的目录要相同）</strong></p><p><strong>那是因为当创建了两个相同名字的pv时它并不会认为这是两个不同的pv，而会把他们当成是同一个pv，后创建的pv会刷新前面创建的pv。然后，当创建了pvc，并且pvc的访问模式和后面创建pv的访问模式一样，他们就会关联成功，反之不成功。（当然这些条件下还需要考虑，pv的内存）</strong></p><h1>三，小实验</h1><h2 id="（1）以自己的名称创建一个名称空间。以下所有资源都在此名称空间之下。">（1）以自己的名称创建一个名称空间。以下所有资源都在此名称空间之下。</h2><h3 id="1-编写namespace的yam文件">&lt;1&gt;编写namespace的yam文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim namespace.yaml <br>kind: Namespace<br>apiVersion: v1<br>metadata:<br>  name: xgp-znb<br></code></pre></td></tr></table></figure><h3 id="2-执行一下">&lt;2&gt;执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f namespace.yaml<br></code></pre></td></tr></table></figure><h3 id="3-查看一下-2">&lt;3&gt;查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get ns<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210141843553.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210141843553.png" alt="image-20200210141843553"></a></p><h2 id="（2）设置rbac权限。">（2）设置rbac权限。</h2><p><strong>下载所需镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull registry.cn-hangzhou.aliyuncs.com/open-ali/nfs-client-provisioner<br></code></pre></td></tr></table></figure><h3 id="1-编写rbac的yam文件">&lt;1&gt;编写rbac的yam文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim rbac-rolebind.yaml<br>kind: Namespace<br>apiVersion: v1<br>metadata:<br>  name: xgp-znb<br>---<br>apiVersion: v1<br>kind: ServiceAccount<br>metadata:<br>  name: nfs-provisioner<br>  namespace: xgp-znb<br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRole<br>metadata:<br>  name: nfs-provisioner-runner<br>  namespace: xgp-znb<br>rules:<br>   -  apiGroups: [""]<br>      resources: ["persistentvolumes"]<br>      verbs: ["get", "list", "watch", "create", "delete"]<br>   -  apiGroups: [""]<br>      resources: ["persistentvolumeclaims"]<br>      verbs: ["get", "list", "watch", "update"]<br>   -  apiGroups: ["storage.k8s.io"]<br>      resources: ["storageclasses"]<br>      verbs: ["get", "list", "watch"]<br>   -  apiGroups: [""]<br>      resources: ["events"]<br>      verbs: ["watch", "create", "update", "patch"]<br>   -  apiGroups: [""]<br>      resources: ["services", "endpoints"]<br>      verbs: ["get","create","list", "watch","update"]<br>   -  apiGroups: ["extensions"]<br>      resources: ["podsecuritypolicies"]<br>      resourceNames: ["nfs-provisioner"]<br>      verbs: ["use"]<br>---<br>kind: ClusterRoleBinding<br>apiVersion: rbac.authorization.k8s.io/v1<br>metadata:<br>  name: run-nfs-provisioner<br>subjects:<br>  - kind: ServiceAccount<br>    name: nfs-provisioner<br>    namespace: xgp-znb<br>roleRef:<br>  kind: ClusterRole<br>  name: nfs-provisioner-runner<br>  apiGroup: rbac.authorization.k8s.io<br></code></pre></td></tr></table></figure><h3 id="2-执行一下-2">&lt;2&gt;执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f  rbac-rolebind.yaml<br></code></pre></td></tr></table></figure><h2 id="（3）创建nfs-deployment-yaml">（3）创建nfs-deployment.yaml</h2><h3 id="1-编写deployment的yam文件">&lt;1&gt;编写deployment的yam文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim nfs-deployment.yaml<br><br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: nfs-client-provisioner<br>  namespace: xgp-znb<br>spec:<br>  replicas: 1<br>  strategy:<br>    type: Recreate<br>  template:<br>    metadata:<br>      labels:<br>        app: nfs-client-provisioner<br>    spec:<br>      serviceAccount: nfs-provisioner<br>      containers:<br>        - name: nfs-client-provisioner<br>          image: registry.cn-hangzhou.aliyuncs.com/open-ali/nfs-client-provisioner<br>          volumeMounts:<br>            - name: nfs-client-root<br>              mountPath:  /persistentvolumes<br>          env:<br>            - name: PROVISIONER_NAME<br>              value: xgp-znb<br>            - name: NFS_SERVER<br>              value: 192.168.1.21<br>            - name: NFS_PATH<br>              value: /nfsdata<br>      volumes:<br>        - name: nfs-client-root<br>          nfs:<br>            server: 192.168.1.21<br>            path: /nfsdata<br></code></pre></td></tr></table></figure><h3 id="2-执行一下-3">&lt;2&gt;执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f nfs-deployment.yaml<br></code></pre></td></tr></table></figure><h2 id="（4）创建storageclass自动创建PV。">（4）创建storageclass自动创建PV。</h2><h3 id="1-编写storageclass的yam文件">&lt;1&gt;编写storageclass的yam文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim storageclass.yaml<br>apiVersion: storage.k8s.io/v1<br>kind: StorageClass<br>metadata:<br>  name: test-sc<br>provisioner: xgp-znb   #通过provisioner字段关联到上述Deploy<br>reclaimPolicy: Retain<br></code></pre></td></tr></table></figure><h3 id="2-执行一下-4">&lt;2&gt;执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f storageclass.yaml<br></code></pre></td></tr></table></figure><h2 id="（5）创建PVC-2">（5）创建PVC</h2><h3 id="1-编写PVC的yaml文件">&lt;1&gt;编写PVC的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim pvc.yaml<br>apiVersion: v1<br>kind: PersistentVolumeClaim<br>metadata:<br>  name: test-claim<br>  namespace: xgp-znb<br>spec:<br>  storageClassName: test-sc<br>  accessModes:<br>    - ReadWriteMany<br>  resources:<br>    requests:<br>      storage: 500Mi<br></code></pre></td></tr></table></figure><h3 id="2-执行一下-5">&lt;2&gt;执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f pvc.yaml<br></code></pre></td></tr></table></figure><h3 id="3-查看一下-3">&lt;3&gt;查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pvc -n xgp-znb<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210144220121.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210144220121.png" alt="image-20200210144220121"></a></p><h2 id="（6）创建一个Pod-基于nginx运行一个web服务，使用Deployment资源对象，replicas-3-持久化存储目录为默认主目录">（6）创建一个Pod, 基于nginx运行一个web服务，使用Deployment资源对象，replicas=3.持久化存储目录为默认主目录</h2><h3 id="1-编写deployment的yam文件-2">&lt;1&gt;编写deployment的yam文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim pod.yaml <br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: web-pod<br>  namespace: xgp-znb<br>spec:<br>  replicas: 3<br>  selector:<br>    matchLabels:<br>      app: nginx<br>  template:<br>    metadata:<br>      labels:<br>        app: nginx<br>    spec:<br>      containers:<br>      - image: nginx<br>        name: nginx<br>        volumeMounts:<br>        - name: web-test<br>          mountPath: /usr/share/nginx/html<br>      volumes:<br>      - name: web-test<br>        persistentVolumeClaim:<br>          claimName: test-claim<br></code></pre></td></tr></table></figure><h3 id="2-执行一下-6">&lt;2&gt;执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f pvc.yaml<br></code></pre></td></tr></table></figure><h3 id="3-查看一下-4">&lt;3&gt;查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod -n xgp-znb<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210211126708.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210211126708.png" alt="image-20200210211126708"></a></p><h2 id="（7）访问nginx页面">（7）访问nginx页面</h2><h3 id="修改nginx主页">修改nginx主页</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl exec -it web-pod-8cd956cc7-6szjb -n xgp-znb /bin/bash<br>//进入容器之中<br>root@web-pod-8cd956cc7-6szjb:/# echo  xgp-znb &gt; /usr/share/nginx/html/index.html<br>//添加自定义内容主机<br></code></pre></td></tr></table></figure><h3 id="访问一下-2">访问一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# curl 10.244.2.18<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210211901467.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200210211901467.png" alt="image-20200210211901467"></a></p><h1>四，五个可移植性建议</h1><ol><li><strong>把你的 pvc，和 其它一系列配置放一起， 比如说deployment，configmap</strong></li><li><strong>不要把你的pv放在其它配置里， 因为用户可能没有权限创建pv</strong></li><li><strong>初始化pvc 模版的时候， 提供一个storageclass</strong></li><li><strong>在你的工具软件中，watch那些没有bound的pvc，并呈现给用户</strong></li><li><strong>集群启动的时候启用DefaultStorageClass， 但是不要指定某一类特定的class， 因为不同provisioner的class，参数很难一致</strong></li></ol><h1>五，四个阶段(volumn phase)</h1><h4 id="1-在PVC中绑定一个PV，可以根据下面几种条件组合选择"><strong>1. 在PVC中绑定一个PV，可以根据下面几种条件组合选择</strong></h4><ul><li><strong>Access Modes， 按照访问模式选择pv</strong></li><li><strong>Resources， 按照资源属性选择， 比如说请求存储大小为8个G的pv</strong></li><li><strong>Selector， 按照pv的label选择</strong></li><li><strong>Class， 根据StorageClass的class名称选择, 通过annotation指定了Storage Class的名字, 来绑定特定类型的后端存储</strong></li></ul><h4 id="2-关于根据class过滤出pv的说明：">2. 关于根据class过滤出pv的说明：</h4><blockquote><p><strong>所有的 PVC 都可以在不使用 StorageClass 注解的情况下，直接使用某个动态存储。把一个StorageClass 对象标记为 “default” 就可以了。StorageClass 用注解<a href="https://link.zhihu.com/?target=http%3A//storageclass.beta.kubernetes.io/is-default-class">http://storageclass.beta.kubernetes.io/is-default-class</a> 就可以成为缺省存储。有了缺省的 StorageClass，用户创建 PVC 就不用 storage-class 的注解了，1.4 中新加入的DefaultStorageClass 准入控制器会自动把这个标注指向缺省存储类。PVC 指定特定storageClassName，如fast时， 绑定名称为fast的storageClassPVC中指定storageClassName为“”时， 绑定no class的pv（pv中无class annotation， 或者其值为“”）PVC不指定storageClassName时， DefaultStorageClass admission plugin 开启与否（在apiserver启动时可以指定）， 对default class的解析行为是不同的。当DefaultStorageClass admission plugin启用时， 针对没有storageClass annotation的pvc，DefaultStorageClass会分配一个默认的class， 这个默认的class需要用户指定，比如在创建storageclass对象时加入annotation,如 <a href="https://link.zhihu.com/?target=http%3A//storageclass.beta.kubernetes.io/is-default-class%3A">http://storageclass.beta.kubernetes.io/is-default-class:</a> “true” 。如果有多个默认的class， 则pvc会被拒绝创建， 如果用户没有指定默认的class， 则这个DefaultStorageClass admission plugin不会起任何作用。 pvc会找那些no class的pv做绑定。当DefaultStorageClass admission plugin没有启用时， 针对没有storageClass annotation的pvc， 会绑定no class的pv（pv中无class annotation， 或者其值为“”）</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Storage Class </tag>
            
            <tag> pv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s存储方式的介绍及应用 （持久化，mysql对数据持久化的应用）</title>
      <link href="/posts/ba49.html"/>
      <url>/posts/ba49.html</url>
      
        <content type="html"><![CDATA[<h1>k8s存储: (持久化)</h1><p><strong>docker容器是有生命周期的。</strong></p><p><strong>volume</strong></p><p><strong>1，存储类（Storage class）是k8s资源类型的一种，它是有管理员为管理PV更加方便创建的一个逻辑组，可以按照存储系统的性能高低，或者综合服务质量，备份策略等分类。不过k8s本身不知道类别到底是什么，它这是作为一个描述。</strong></p><p><strong>2，存储类的好处之一就是支持PV的动态创建，当用户用到持久性存储时，不必再去提前创建PV，而是直接创建PVC就可以了，非常的方便。</strong></p><p><strong>3，存储类对象的名称很重要，并且出了名称之外，还有3个关键字段<br>Provisioner（供给方）:<br>及提供了存储资源的存储系统。k8s内建有多重供给方，这些供给方的名字都以“<a href="http://kubernetes.io" target="_blank" rel="noopener">kubernetes.io</a>”为前缀。并且还可以自定义。<br>Parameters(参数)：存储类使用参数描述要关联到的存储卷，注意不同的供给方参数也不同。<br>reclaimPolicy:PV的回收策略，可用值有Delete(默认)和Retain</strong></p><h1>简介</h1><p><strong>1, 由于容器本身是非持久化的，因此需要解决在容器中运行应用程序遇到的一些问题。首先，当容器崩溃时，kubelet将重新启动容器，但是写入容器的文件将会丢失，容器将会以镜像的初始状态重新开始；第二，在通过一个Pod中一起运行的容器，通常需要共享容器之间一些文件。Kubernetes通过存储卷解决上述的两个问题。</strong></p><p><strong>2, 在Docker有存储卷的概念卷，但Docker中存储卷只是磁盘的或另一个容器中的目录，并没有对其生命周期进行管理。Kubernetes的存储卷有自己的生命周期，它的生命周期与使用的它Pod生命周期一致。因此，相比于在Pod中运行的容器来说，存储卷的存在时间会比的其中的任何容器都长，并且在容器重新启动时会保留数据。当然，当Pod停止存在时，存储卷也将不再存在。在Kubernetes支持多种类型的卷，而Pod可以同时使用各种类型和任意数量的存储卷。在Pod中通过指定下面的字段来使用存储卷：</strong><br><strong>spec.volumes：通过此字段提供指定的存储卷<br>spec.containers.volumeMounts：通过此字段将存储卷挂接到容器中</strong></p><h2 id="环境介绍">环境介绍</h2><table><thead><tr><th>主机</th><th>IP地址</th><th>服务</th></tr></thead><tbody><tr><td>master</td><td>192.168.1.21</td><td>k8s</td></tr><tr><td>node01</td><td>192.168.1.22</td><td>k8s</td></tr><tr><td>node02</td><td>192.168.1.23</td><td>k8s</td></tr></tbody></table><h2 id="1-emptyDir（空目录）-类似docker-数据持久化的-docer-manager-volume">1.emptyDir（空目录）:类似docker 数据持久化的:docer manager volume</h2><p><strong>使用场景:在同一 个Pod里，不同的容器，共享数据卷。</strong></p><p><strong>如果容器被删除，数据仍然存在，如果Pod被 删除，数据也会被删除。</strong></p><h3 id="1-介绍">&lt;1&gt; 介绍</h3><p><strong>一个emptyDir 第一次创建是在一个pod被指定到具体node的时候，并且会一直存在在pod的生命周期当中，正如它的名字一样，它初始化是一个空的目录，pod中的容器都可以读写这个目录，这个目录可以被挂在到各个容器相同或者不相同的的路径下。当一个pod因为任何原因被移除的时候，这些数据会被永久删除。注意：一个容器崩溃了不会导致数据的丢失，因为容器的崩溃并不移除pod.</strong></p><h3 id="emptyDir的使用场景如下：">emptyDir的使用场景如下：</h3><blockquote><ul><li>空白的初始空间，例如合并/排序算法中，临时将数据保存在磁盘上。</li><li>长时间计算中存储检查点（中间结果），以便容器崩溃时，可以从上一次存储的检查点（中间结果）继续进行，而不是从头开始。</li><li>作为两个容器的共享存储，使得第一个内容管理的容器可以将生成的数据存入其中，同时由一个webserver容器对外提供这些页面。</li><li>默认情况下，emptyDir数据卷存储在node节点的存储介质（机械硬盘、SSD或网络存储）上。</li></ul></blockquote><h3 id="2-emptyDir-磁盘的作用：">&lt;2&gt;emptyDir 磁盘的作用：</h3><p><strong>（1）普通空间，基于磁盘的数据存储<br>（2）作为从崩溃中恢复的备份点<br>（3）存储那些那些需要长久保存的数据，例web服务中的数据<br>默认的，emptyDir 磁盘会存储在主机所使用的媒介上，可能是SSD，或者网络硬盘，这主要取决于你的环境。当然，我们也可以将emptyDir.medium的值设置为Memory来告诉Kubernetes 来挂在一个基于内存的目录tmpfs，因为<br>tmpfs速度会比硬盘块度了，但是，当主机重启的时候所有的数据都会丢失。</strong></p><blockquote><p><strong>测试编写一个yaml文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim emptyDir.yaml<br>apiVersion: v1<br>kind: Pod<br>metadata:<br>  name: producer-consumer<br>spec:<br>  containers:<br>  - image: busybox<br>    name: producer<br>    volumeMounts:<br>    - mountPath: /producer_dir<br>      name: shared-volume<br>    args:<br>    - /bin/sh<br>    - -c<br>    - echo "hello k8s" &gt; /producer_dir/hello; sleep 30000<br>  - image: busybox<br>    name: consumer<br>    volumeMounts:<br>    - mountPath: /consumer_dir<br>      name: shared-volume<br>    args:<br>    - /bin/sh<br>    - -c<br>    - cat /consumer_dir/hello; sleep 30000<br>  volumes:<br>  - name: shared-volume<br>    emptyDir: &#123;&#125;<br></code></pre></td></tr></table></figure><p><strong>执行一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f emptyDir.yaml <br></code></pre></td></tr></table></figure><p><strong>查看一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod  <br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205095431565.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205095431565.png" alt="image-20200205095431565"></a></p><p><strong>查看日志</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl logs  producer-consumer producer<br>[root@master yaml]# kubectl logs  producer-consumer consumer<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205095543780.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205095543780.png" alt="image-20200205095543780"></a></p><p><strong>查看挂载的目录</strong></p><p><strong>node节点查看容器名，并通过容器名查看挂载的目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node01 shared-volume]# docker ps <br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205102007328.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205102007328.png" alt="image-20200205102007328"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node01 shared-volume]# docker inspect k8s_consumer_producer-consumer_default_9ec83f9e-e58b-4bf8-8e16-85b0f83febf9_0<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205102048470.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205102048470.png" alt="image-20200205102048470"></a></p><p><strong>进入挂载目录查看一下</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205102128953.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205102128953.png" alt="image-20200205102128953"></a></p></blockquote><h2 id="2-hostPath-Volume-类似docker-数据持久化的-bind-mount">2.hostPath Volume:类似docker 数据持久化的:bind mount</h2><p><strong>如果Pod被删除，数据会保留，相比较emptyDir要好一点。不过一旦host崩溃，hostPath也无法访问 了。</strong></p><p><strong>docker或者k8s集群本身的存储会采用hostPath这种方式。</strong></p><h3 id="1-介绍-2">&lt;1&gt; 介绍</h3><p><strong>hostPath宿主机路径，就是把pod所在的宿主机之上的脱离pod中的容器名称空间的之外的宿主机的文件系统的某一目录和pod建立关联关系，在pod删除时，存储数据不会丢失。</strong></p><h3 id="2-作用">&lt;2&gt; 作用</h3><p><strong>如果Pod被删除，数据会保留，相比较emptyDir要好一点。不过一旦host崩溃，hostPath也无法访问 了。</strong></p><p><strong>docker或者k8s集群本身的存储会采用hostPath这种方式。</strong></p><h4 id="适用场景如下：">适用场景如下：</h4><blockquote><p>某容器需要访问 Docker，可使用 hostPath 挂载宿主节点的 /var/lib/docker<br>在容器中运行 cAdvisor，使用 hostPath 挂载宿主节点的 /sys</p></blockquote><h2 id="3-Persistent-Volume-PV-持久卷-提前做好的，数据持久化的数据存放目录。">3.Persistent Volume| PV(持久卷) 提前做好的，数据持久化的数据存放目录。</h2><h3 id="Psesistent-Volume-Claim-PVC-持久卷使用声明-申请"><strong>Psesistent Volume Claim| PVC( 持久卷使用声明|申请)</strong></h3><h2 id="Psesistent-Volume-Claim-PVC-持久卷使用声明-申请-2"><strong>Psesistent Volume Claim| PVC( 持久卷使用声明|申请)</strong></h2><p><strong>PersistentVolume（PV）是集群中已由管理员配置的一段网络存储。 集群中的资源就像一个节点是一个集群资源。 PV是诸如卷之类的卷插件，但是具有独立于使用PV的任何单个pod的生命周期。 该API对象捕获存储的实现细节，即NFS，iSCSI或云提供商特定的存储系统。</strong></p><h2 id="PVC和PV的概念">PVC和PV的概念</h2><p><strong>我们前面提到kubernetes提供那么多存储接口，但是首先kubernetes的各个Node节点能管理这些存储，但是各种存储参数也需要专业的存储工程师才能了解，由此我们的kubernetes管理变的更加复杂的。由此kubernetes提出了PV和PVC的概念，这样开发人员和使用者就不需要关注后端存储是什么，使用什么参数等问题。如下图：</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/20200607210917.png" alt="k8s存储方式的介绍及应用 （持久化，mysql对数据持久化的应用）"></p><blockquote><p><strong>PersistentVolume（PV）是集群中已由管理员配置的一段网络存储。 集群中的资源就像一个节点是一个集群资源。 PV是诸如卷之类的卷插件，但是具有独立于使用PV的任何单个pod的生命周期。 该API对象捕获存储的实现细节，即NFS，iSCSI或云提供商特定的存储系统。</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/20200607210935.png" alt="k8s存储方式的介绍及应用 （持久化，mysql对数据持久化的应用）"></p><blockquote><p><strong>PersistentVolumeClaim（PVC）是用户存储的请求。PVC的使用逻辑：在pod中定义一个存储卷（该存储卷类型为PVC），定义的时候直接指定大小，pvc必须与对应的pv建立关系，pvc会根据定义去pv申请，而pv是由存储空间创建出来的。pv和pvc是kubernetes抽象出来的一种存储资源。</strong></p><p><strong>虽然PersistentVolumeClaims允许用户使用抽象存储资源，但是常见的需求是，用户需要根据不同的需求去创建PV，用于不同的场景。而此时需要集群管理员提供不同需求的PV，而不仅仅是PV的大小和访问模式，但又不需要用户了解这些卷的实现细节。 对于这样的需求，此时可以采用StorageClass资源。这个在前面就已经提到过此方案。</strong></p><p><strong>PV是集群中的资源。 PVC是对这些资源的请求，也是对资源的索赔检查。 PV和PVC之间的相互作用遵循这个生命周期：</strong></p></blockquote></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Provisioning（配置）---&gt; Binding（绑定）---&gt;Using（使用）---&gt; Releasing（释放） ---&gt; Recycling（回收）<br></code></pre></td></tr></table></figure><h3 id="（1）基于nfs服务来做的PV和pvc"><strong>（1）基于nfs服务来做的PV和pvc</strong></h3><p><strong>nfs使的我们可以挂在已经存在的共享到的我们的Pod中，和emptyDir不同的是，emptyDir会被删除当我们的Pod被删除的时候，但是nfs不会被删除，仅仅是解除挂在状态而已，这就意味着NFS能够允许我们提前对数据进行处理，而且这些数据可以在Pod之间相互传递.并且，nfs可以同时被多个pod挂在并进行读写</strong><br><em>注意：必须先保证NFS服务器正常运行在我们进行挂在nfs的时候</em></p><p><strong>下载nfs所需安装包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node02 ~]# yum -y install nfs-utils  rpcbind<br></code></pre></td></tr></table></figure><p><strong>创建共享目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# mkdir /nfsdata<br></code></pre></td></tr></table></figure><p><strong>创建共享目录的权限</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim /etc/exports<br>/nfsdata *(rw,sync,no_root_squash)<br></code></pre></td></tr></table></figure><p><strong>开启nfs和rpcbind</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# systemctl start nfs-server.service <br>[root@master ~]# systemctl start rpcbind<br></code></pre></td></tr></table></figure><p><strong>测试一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# showmount -e<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205105654925.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205105654925.png" alt="image-20200205105654925"></a></p><h4 id="1-创建nfs-pv的yaml文件"><strong>&lt;1&gt;创建nfs-pv的yaml文件</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# cd yaml/<br>[root@master yaml]# vim nfs-pv.yaml<br>apiVersion: v1<br>kind: PersistentVolume<br>metadata:<br>  name: test-pv<br>spec:<br>  capacity:   #pv容量的大小<br>    storage: 1Gi<br>  accessModes:  #访问pv的模式<br>    - ReadWriteOnce #能以读-写mount到单个的节点<br>  persistentVolumeReclaimPolicy: Recycle<br>  storageClassName: nfs<br>  nfs:<br>    path: /nfsdata/pv1<br>    server: 192.168.1.21<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"> accessModes:(PV支持的访问模式)<br>   - ReadWriteOnce: 能以读-写mount到单个的节点<br>   - ReadWriteMany: 能以读-写mount到多个的节点。<br>- ReadOnlyMnce:  能以只读的方式mount到多个节点。<br></code></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">persistentVolumeReclaimPolicy : (PV存储空间的回收策略是什么)<br>trueRecycle: 自动清除数据。<br>trueRetain: 需要管理员手动回收。<br>trueDelete: 云存储专用。<br></code></pre></td></tr></table></figure></blockquote><h4 id="2-执行一下"><strong>&lt;2&gt;执行一下</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f nfs-pv.yaml<br></code></pre></td></tr></table></figure><h4 id="3-查看一下">&lt;3&gt;查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pv<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205111307317.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205111307317.png" alt="image-20200205111307317"></a></p><h4 id="1-创建nfs-pvc的yaml文件"><strong>&lt;1&gt;创建nfs-pvc的yaml文件</strong></h4><p><strong>PersistentVolumeClaim（PVC）是用户存储的请求。PVC的使用逻辑：在pod中定义一个存储卷（该存储卷类型为PVC），定义的时候直接指定大小，pvc必须与对应的pv建立关系，pvc会根据定义去pv申请，而pv是由存储空间创建出来的。pv和pvc是kubernetes抽象出来的一种存储资源。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim nfs-pvc.yaml<br><br>apiVersion: v1<br>kind: PersistentVolumeClaim<br>metadata:<br>  name: test-pvc<br>spec:<br>  accessModes:<br>    - ReadWriteOnce<br>  resources:<br>    requests:<br>      storage: 1Gi<br>  storageClassName: nfs<br></code></pre></td></tr></table></figure><h4 id="2-执行一下-2"><strong>&lt;2&gt;执行一下</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f nfs-pvc.yaml<br></code></pre></td></tr></table></figure><h4 id="3-查看一下-2">&lt;3&gt;查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pvc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205113407860.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205113407860.png" alt="image-20200205113407860"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pv<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205113512580.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200205113512580.png" alt="image-20200205113512580"></a></p><h3 id="（2）创建一个pod资源">（2）创建一个pod资源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim pod.yaml<br>kind: Pod<br>apiVersion: v1<br>metadata:<br>  name: test-pod<br>spec:<br>  containers:<br>    - name: pod1<br>      image: busybox<br>      args:<br>      - /bin/sh<br>      - -c<br>      - sleep 30000<br>      volumeMounts:<br>      - mountPath: "/mydata"<br>        name: mydata<br>  volumes:<br>    - name: mydata<br>      persistentVolumeClaim:<br>        claimName: test-pvc<br></code></pre></td></tr></table></figure><h4 id="1-执行一下">&lt;1&gt; 执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f pod.yaml<br></code></pre></td></tr></table></figure><h4 id="2-查看一下">&lt;2&gt;查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207100212328.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207100212328.png" alt="image-20200207100212328"></a></p><p><strong>可以看到现在没有开启成功</strong></p><h5 id="查看一下test-pod的信息看看是哪里的问题">查看一下test-pod的信息看看是哪里的问题</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl describe pod test-pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207123950227.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207123950227.png" alt="image-20200207123950227"></a></p><h5 id="那是因为pv的本地挂载目录没有创建好">那是因为pv的本地挂载目录没有创建好</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# mkdir /nfsdata/pv1/<br>//要和nfs-pv.yaml的名字一样<br></code></pre></td></tr></table></figure><h5 id="重新创建一下pod">重新创建一下pod</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl delete -f pod.yaml <br>[root@master yaml]# kubectl apply -f pod.yaml <br>[root@master yaml]# kubectl get pod -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207102822785.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207102822785.png" alt="image-20200207102822785"></a></p><h3 id="（3）test-pod创建hello创建文件并添加内容">（3）test-pod创建hello创建文件并添加内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl exec test-pod touch /mydata/hello<br></code></pre></td></tr></table></figure><p><strong>进入容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl exec -it test-pod  /bin/sh<br>/ # echo 123 &gt; /mydata/hello<br>/ # exit<br></code></pre></td></tr></table></figure><p><strong>挂载目录查看一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# cat  /nfsdata/pv1/hello<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207104239153.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207104239153.png" alt="image-20200207104239153"></a></p><p><strong>和刚刚的一样</strong></p><h3 id="（4）测试回收策略">（4）测试回收策略</h3><h4 id="删除pod和pvc，pv">删除pod和pvc，pv</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl delete pod test-pod <br>[root@master yaml]# kubectl delete pvc test-pvc <br>[root@master yaml]# kubectl delete pv test-pv<br></code></pre></td></tr></table></figure><h4 id="查看一下">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pv<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207104454636.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207104454636.png" alt="image-20200207104454636"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# cat  /nfsdata/pv1/hello<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207104520048.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207104520048.png" alt="image-20200207104520048"></a></p><p><em><strong>文件已被回收</strong></em></p><h3 id="（5）修改pv的回收策略为手动">（5）修改pv的回收策略为手动</h3><h4 id="修改">修改</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim nfs-pv.yaml <br>apiVersion: v1<br>kind: PersistentVolume<br>metadata:<br>  name: test-pv<br>spec :<br>  capacity :<br>    storage: 1Gi<br>  accessModes:<br>    - ReadWriteOnce<br>  persistentVolumeReclaimPolicy: Retain   #修改<br>  storageClassName: nfs<br>  nfs:<br>    path: /nfsdata/pv1<br>    server: 192.168.1.21<br></code></pre></td></tr></table></figure><h4 id="执行一下">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f nfs-pv.yaml<br></code></pre></td></tr></table></figure><h4 id="创建pod">创建pod</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f pod.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-2">查看一下</h4><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207105203009.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207105203009.png" alt="image-20200207105203009"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl describe pod test-pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207105248025.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207105248025.png" alt="image-20200207105248025"></a></p><h4 id="创建pvc">创建pvc</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f nfs-pvc.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下pod">查看一下pod</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207105402354.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207105402354.png" alt="image-20200207105402354"></a></p><h3 id="（6）test-pod创建hello创建文件并添加内容">（6）test-pod创建hello创建文件并添加内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl exec test-pod touch /mydata/k8s<br></code></pre></td></tr></table></figure><h4 id="查看一下挂载目录">查看一下挂载目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# ls /nfsdata/pv1/<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207105618318.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207105618318.png" alt="image-20200207105618318"></a></p><h4 id="删除pod和pvc，pv，再次查看挂载目录">删除pod和pvc，pv，再次查看挂载目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl delete pod test-pod <br>[root@master yaml]# kubectl delete pvc test-pvc<br>[root@master yaml]# kubectl delete pv test-pv<br></code></pre></td></tr></table></figure><h4 id="查看挂载目录">查看挂载目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# ls /nfsdata/pv1/<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207105757641.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207105757641.png" alt="image-20200207105757641"></a></p><p><em><strong>内容还在</strong></em></p><h2 id="4-mysql对数据持久化的应用">4.mysql对数据持久化的应用</h2><p><strong>下面演示如何为 MySQL 数据库提供持久化存储，步骤为：</strong></p><ul><li><strong>创建 PV 和 PVC。</strong></li><li><strong>部署 MySQL。</strong></li><li><strong>向 MySQL 添加数据。</strong></li><li><strong>模拟节点宕机故障，Kubernetes 将 MySQL 自动迁移到其他节点。</strong></li><li><strong>验证数据一致性。</strong></li></ul><p><strong>最小化安装系统需要</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install mariadb<br></code></pre></td></tr></table></figure><h2 id="（1）通过之前的yaml文件，创建pv和pvc">（1）通过之前的yaml文件，创建pv和pvc</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f  nfs-pv.yaml <br>[root@master yaml]# kubectl apply -f  nfs-pvc.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下-3">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pv<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207110132199.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207110132199.png" alt="image-20200207110132199"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pvc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207110140002.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207110140002.png" alt="image-20200207110140002"></a></p><h2 id="（2）编写一个mysql的yaml文件">（2）编写一个mysql的yaml文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim mysql.yaml<br><br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: test-mysql<br>spec:<br>  selector:<br>    matchLabels:    #支持等值的标签<br>      app: mysql<br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: test-mysql<br>spec:<br>  selector:<br>    matchLabels:<br>      app: mysql<br>  template:<br>    metadata:<br>      labels:<br>        app: mysql<br>    spec:<br>      containers:<br>      - image: mysql:5.6<br>        name: mysql<br>        env:<br>        - name: MYSQL_ROOT_PASSWORD<br>          value: 123.com<br>        volumeMounts:<br>        - name: mysql-storage<br>          mountPath: /var/lib/mysql<br>      volumes:<br>      - name: mysql-storage<br>        persistentVolumeClaim:<br>          claimName: test-pvc<br></code></pre></td></tr></table></figure><h3 id="执行一下-2">执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f mysql.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下-4">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207110741833.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207110741833.png" alt="image-20200207110741833"></a></p><h2 id="（3）进入mysql容器">（3）进入mysql容器</h2><p><strong>① 切换到数据库 mysql。<br>② 创建数据库表 my_id。<br>③ 插入一条数据。<br>④ 确认数据已经写入。<br>关闭 k8s-node2，模拟节点宕机故障。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl exec -it test-mysql-569f8df4db-rkpwm  -- mysql -u root -p123.com<br></code></pre></td></tr></table></figure><h3 id="创建数据库">创建数据库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">mysql&gt;</span><span class="bash"> create database yun33;</span><br></code></pre></td></tr></table></figure><h3 id="切换数据库">切换数据库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">mysql&gt;</span><span class="bash"> use yun33;</span><br></code></pre></td></tr></table></figure><h3 id="创建表">创建表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">mysql&gt;</span><span class="bash"> create table my_id( id int(4))；</span><br></code></pre></td></tr></table></figure><h3 id="在表中插入数据">在表中插入数据</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">mysql&gt;</span><span class="bash"> insert my_id values(9527);</span><br></code></pre></td></tr></table></figure><h3 id="查看表">查看表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">mysql&gt;</span><span class="bash"> select * from my_id;</span><br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207113808540.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207113808540.png" alt="image-20200207113808540"></a></p><h2 id="（4）查看本地的挂载目录">（4）查看本地的挂载目录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# ls /nfsdata/pv1/<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207113909796.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207113909796.png" alt="image-20200207113909796"></a></p><h3 id="查看一下pod-2">查看一下pod</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod -o wide -w<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207114050117.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207114050117.png" alt="image-20200207114050117"></a></p><h3 id="挂起node01">挂起node01</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207114607518.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207114607518.png" alt="image-20200207114607518"></a></p><h2 id="（5）查看node02上面数据是否和刚才一样（验证数据的一致性）">（5）查看node02上面数据是否和刚才一样（验证数据的一致性）</h2><h3 id="进入数据库">进入数据库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]#  kubectl exec -it test-mysql-569f8df4db-nsdnz  -- mysql -u root -p123.com<br></code></pre></td></tr></table></figure><h3 id="查看数据库">查看数据库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">mysql&gt;</span><span class="bash"> show databases;</span><br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207115253123.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207115253123.png" alt="image-20200207115253123"></a></p><h3 id="查看表-2">查看表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show tables;<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207115352727.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207115352727.png" alt="image-20200207115352727"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from my_id;<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207113808540.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200207113808540.png" alt="image-20200207113808540"></a></p><p><em><strong>可以看到数据还在</strong></em></p><h2 id="5-排错方法">5. 排错方法</h2><blockquote><p><strong>kubectl describe</strong><br><strong>//查看详细信息，找出问题</strong><br><strong>kubectl logs</strong><br><strong>//查看日志，找出问题</strong><br><strong>/var/ log/messages</strong><br><strong>//查看该节点的kubelet的日志。</strong></p></blockquote><h2 id="5-总结">5. 总结</h2><p><strong>本章我们讨论了 Kubernetes 如何管理存储资源。<br>emptyDir 和 hostPath 类型的 Volume 很方便，但可持久性不强，Kubernetes 支持多种外部存储系统的 Volume。<br>PV 和 PVC 分离了管理员和普通用户的职责，更适合生产环境。我们还学习了如何通过 StorageClass 实现更高效的动态供给。<br>最后，我们演示了如何在 MySQL 中使用 PersistentVolume 实现数据持久性。</strong></p><h4 id="PV的访问控制类型"><strong>PV的访问控制类型</strong></h4><p><strong>accessModes:(PV支持的访问模式)</strong></p><ul><li><strong>ReadWriteOnce: 能以读-写mount到单个的节点</strong></li><li><strong>ReadWriteMany: 能以读-写mount到多个的节点。</strong></li><li><strong>ReadOnlyOnce: 能以只读的方式mount到单个节点。</strong></li></ul><h4 id="PV的空间回收策略"><strong>PV的空间回收策略</strong></h4><p><strong>persistentVolumeReclaimPolicy : (PV存储空间的回收策略是什么)</strong></p><p><strong>Recycle: 自动清除数据。</strong></p><p><strong>Retain: 需要管理员手动回收。</strong></p><p><strong>Delete: 云存储专用。</strong></p><h4 id="PV和PVC相互关联"><strong>PV和PVC相互关联</strong></h4><p><strong>是通过accessModes和storageClassName模块关联的</strong></p><h4 id="Pod不断的重启">Pod不断的重启:</h4><p><strong>1、swap,没有关闭，导致集群运行不正常。</strong><br><strong>2、内存不足，运行服务也会重后。</strong></p><p><strong>kubectl describe</strong><br><strong>kubectl logs</strong><br><strong>/var/ log/messages</strong><br><strong>查看该节点的kubelet的日志。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pv </tag>
            
            <tag> pvc </tag>
            
            <tag> emptyDir </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s复习</title>
      <link href="/posts/fehv.html"/>
      <url>/posts/fehv.html</url>
      
        <content type="html"><![CDATA[<h1>虚拟化</h1><p><strong>云计算的分类</strong>:</p><blockquote><p><strong>基础及服务: laas</strong><br><strong>平台及服务: paas</strong><br><strong>软件及服务: saas</strong></p></blockquote><p>**docker虚拟化的底层原理: ** Namespace + Cgroup</p><p>**Namespace六项隔离: **</p><blockquote><p><strong>IPC:  共享内存,消息列队</strong><br><strong>MNT:  挂载点 文件系统</strong><br><strong>NET:  网络栈</strong><br><strong>PID:  进程编号</strong><br><strong>USER:  用户 组</strong><br><strong>UTS:  主机名 域名</strong><br><strong>namespace 六项隔离 实现了容器与宿主机 容器与容器之间的隔离</strong></p></blockquote><p>**Cgroup 四项作用: **</p><blockquote><p>**1） 资源的限制: **cgroup可以对进程组使用的资源总额进行限制<br>**2） 优先级分配: **通过分配的cpu时间片数量以及硬盘IO带宽的大小，实际上相当于控制了进程运行的优先级别<br>**3） 资源统计: ** group可以统计系统资源使用量，比如gpu使用时间，内存使用量等，用于按量计费。同时还支持挂起动能，也就是说通过cgroup把所有 资源限制起来,对资源都不能使用，注意着并不是说我们的程序不能使用了,知识不能使用资源，处于等待状态。<br>**4） 进程控制: **可以对进程组执行挂起、恢复等操作。</p></blockquote><p><strong>镜像是容器运行的核心，容器是镜像运行的后的实例。</strong></p><p><strong>DockerHub| registry ----&gt; pull</strong><br><strong>image :  save &gt; | load &lt;</strong><br><strong>run ----&gt; Container ----&gt; commit</strong>*<br><strong>Dockerfile</strong></p><p><strong>Docker 三剑客。</strong></p><blockquote><p><strong>docker machine: 自动化部署多台dockerHost 。</strong></p><p><strong>Docker-compose:  它可以同时控制多个容器。</strong></p><p><strong>yaml。</strong></p><p>**Docker Swarm: **</p><p><strong>从单个的服务向集群的形势发展。</strong></p><p><strong>高可用、高性能、高并发 : 为了防止单点故障。</strong></p><p><strong>Service: 服务 ----&gt; 包括运行什么服务，需要多个 rep1icas（副本）, 外网如何访问。</strong></p></blockquote><h3 id="k8s"><strong>k8s</strong></h3><p>关闭防火墙、禁用selinux、修改主机名并加入域名解析、关闭swap 、时间同步、免密登录、打开iptables桥接</p><blockquote><p><strong>对硬件的基本要求:  CPU: 2核 MEM: 2G</strong></p><p><strong>主机名: master node01 node02</strong></p><p><strong>时间必须同步</strong></p></blockquote><p><strong>kubctl: k8s客户端 kubeadm: 工具 kubelet: 客户端代理</strong></p><p>**组件: **</p><p><strong>三层网络:  DockerHost &gt; Pod &gt; Service</strong></p><p>**Deployment:  Service: **</p><h3 id="master组件">**master组件:  **</h3><p><strong>kube- api( application interface) k8s的前端接口</strong></p><p>**Scheduler[集群分发调度器]**负责决定将Pod放在哪个Node上运行。在调度时，会充分考虑集群的拓扑结构，当前各个节点的负载情况，以及应对高可用、性能、数据亲和性和需求。</p><p><strong>Controller Manager[内部管理控制中心]</strong>: 负责管理集群的各种资源，保证资源处于预期的状态。它由多种Controller组成，包括Replication Controller、Endpoints Controller、Namespace Controller、Serviceaccounts Controller等。</p><p>**Etcd: **负责保存k8s集群的配置信息和各种资源的状态信息。当数据发生变化时，etcd会快速的通知k8s相关组件。[（第三方组件）它有可替换方案。Consul、zookeeper](https: <a href="//wsdlxgp.top/posts/1b18.html">//wsdlxgp.top/posts/1b18.html</a>)</p><p>**Flanner: **是k8s集群网络，可以保证Pod的跨主机通信。也有替换方案。</p><h3 id="Node组件">Node组件:</h3><p><strong>Kubelet[节点上的Pod管家]</strong>: 它是Node的agent(代理)，当Scheduler确定某 个Node上运行Pod之后，会将Pod的具体配置信息发送给该节点的kubelet,kubelet会根据这些信息创建和运行容器，并向Master报告运行状态。</p><p>**kube-proxy[负载均衡、路由转发]: **负责将访问service的TCP/UDP数据流转发到后端的容器。如果有多个副本，kube-proxy会实现负载均衡。</p><h3 id="yaml文件的一级字段">yaml文件的一级字段:</h3><p>**VERSION: **<br>​ **KIND: **<br>​ **METADATA: **<br>​ **SPEC : **</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim web.yaml<br>kind:  Deployment  #资源对象是控制器<br>apiVersion:  extensions/v1beta1   #api的版本<br>metadata:       #描述kind（资源类型）<br>  name:  web   #定义控制器名称<br>  namespace:   #名称空间<br>spec: <br>  replicas:  2   #副本数量<br>  template:      #模板<br>    metadata:     <br>      labels:    #标签<br>        app:  web_server<br>    spec: <br>      containers:    #指定容器<br>      - name:  nginx  #容器名称<br>        image:  nginx   #使用的镜像<br></code></pre></td></tr></table></figure><p>**Deployment（控制器): **</p><p>**ReplicationController: **用来确保由其管控的Pod对象副本数量，能够满足用户期望，多则删除，少则通过模本创建</p><p>**RS（RpelicaSet）: **RS也是用于保证与label selector匹配的pod数量维持在期望状态</p><p>**Service: **</p><p><strong>type: 默认Cluster IP</strong></p><p><strong>NodePort:  30000-32767</strong></p><p><strong>Deployment和Service关联: 标签和标签选择器</strong></p><p>**Namespace: **</p><p><strong>Pod: 最小单位</strong></p><p>**镜像的下载策略: **</p><blockquote><p>**Always: **镜像标签为“laster”或镜像不存在时，总是从指定的仓库中获取镜像。</p><p>**IfNotPresent: **仅当本地镜像不存在时才从目标仓库下载。</p><p>**Never: **禁止从仓库中下载镜像，即只使用本地镜像。</p></blockquote><p><strong>默认的标签 为latest: always</strong></p><p>**Pod的重启策略: **</p><blockquote><p>**Always: **（默认情况下使用）但凡Pod对象终止就将其重启；<br>​ **OnFailure: **仅在Pod对象出现错误时才将其重启；<br>​ **Never: **从不重启；</p></blockquote><p>**Pod的健康检查: **<br>​ Liveness:  探测失败重启pod<br>​ Readiness:  探测失败将pod设置为不可用<br>kubelet: 控制pod</p><p>DaemonSet : 会在每一个节点都会运行，并且只运行一个Pod</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swarm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s的Job/CronJob资源对象及添加api版本</title>
      <link href="/posts/fbf7.html"/>
      <url>/posts/fbf7.html</url>
      
        <content type="html"><![CDATA[<h1>Job资源对象</h1><blockquote><p>**服务类的Pod容器：**RC、RS、DS、Deployment</p><p>**工作类的Pod容器：**Job—&gt;执行一次，或者批量执行处理程序，完成之后退出容器。</p></blockquote><p><strong>注意： 如果容器内执行任务有误，会根据容器的重启策略操作容器，不过这里</strong><br><strong>的容器重启策略只能是: Never和 OnFailure。</strong></p><h1>概念</h1><p><strong>在有些场景下，是想要运行一些容器执行某种特定的任务，任务一旦执行完成，容器也就没有存在的必要了。在这种场景下，创建pod就显得不那么合适。于是就是了Job，Job指的就是那些一次性任务。通过Job运行一个容器，当其任务执行完以后，就自动退出，集群也不再重新将其唤醒。</strong></p><p><strong>从程序的运行形态上来区分，可以将Pod分为两类：长时运行服务（jboss、mysql等）和一次性任务（数据计算、测试）。RC创建的Pod都是长时运行的服务，Job多用于执行一次性任务、批处理工作等，执行完成后便会停止（status.phase变为Succeeded）。</strong></p><h1>环境介绍</h1><table><thead><tr><th>主机</th><th>IP地址</th><th>服务</th></tr></thead><tbody><tr><td>master</td><td>192.168.1.21</td><td>k8s</td></tr><tr><td>node01</td><td>192.168.1.22</td><td>k8s</td></tr><tr><td>node02</td><td>192.168.1.23</td><td>k8s</td></tr></tbody></table><p><strong>基于<a href> https://blog.51cto.com/14320361/2464655</a> 的实验继续进行</strong></p><h1>一、kubernetes支持以下几种job</h1><blockquote><ul><li><strong>非并行job：通常创建一个pod直至其成功结束。</strong></li><li><strong>固定结束次数的job：设置spec.completions,创建多个pod，直到.spec.completions个pod成功结束。</strong></li><li><strong>带有工作队列的并行job：设置.spec.Parallelism但不设置.spec.completions,当所有pod结束并且至少一个成功时，job就认为是成功。</strong></li></ul></blockquote><h2 id="Job-Controller">Job Controller</h2><p><strong>Job Controller负责根据Job Spec创建pod，并持续监控pod的状态，直至其成功结束，如果失败，则根据restartPolicy（只支持OnFailure和Never，不支持Always）决定是否创建新的pod再次重试任务。</strong></p><h2 id="例子"><strong>例子</strong></h2><h3 id="（1）编写一个job的yaml文件">（1）编写一个job的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim jop.yaml<br>kind: Job<br>apiVersion: batch/v1<br>metadata:<br>  name: test-job<br>spec:<br>  template:<br>    metadata:<br>      name: test-job<br>    spec:<br>      containers:<br>      - name: hello<br>        image: busybox<br>        command: ["echo","hello k8s job!"]<br>      restartPolicy: Never<br></code></pre></td></tr></table></figure><h3 id="（2）执行一下">（2）执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f jop.yaml<br></code></pre></td></tr></table></figure><h3 id="（3）查看一下">（3）查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200115090831524.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200115090831524.png" alt="image-20200115090831524"></a></p><h4 id="查看日志">查看日志</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl logs test-job-gs45w<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200115091213349.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200115091213349.png" alt="image-20200115091213349"></a></p><p><strong>我们可以看到job与其他资源对象不同，仅执行一次性任务，默认pod借宿运行后job即结束，状态为Completed。</strong></p><h3 id="（4）修改一下jop的yaml文件，把echo命令换成乱码">（4）修改一下jop的yaml文件，把echo命令换成乱码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim jop.yaml<br>kind: Job<br>apiVersion: batch/v1<br>metadata:<br>  name: test-job<br>spec:<br>  template:<br>    metadata:<br>      name: test-job<br>    spec:<br>      containers:<br>      - name: hello<br>        image: busybox<br>        command: ["asdasxsddwefew","hello k8s job!"] #修改<br>      restartPolicy: Never<br></code></pre></td></tr></table></figure><h3 id="（5）先删除之前的pod">（5）先删除之前的pod</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl delete jobs.batch test-job<br></code></pre></td></tr></table></figure><h3 id="（6）执行一下">（6）执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f jop.yaml<br></code></pre></td></tr></table></figure><h3 id="（7）查看一下">（7）查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod -w<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200115091647925.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200115091647925.png" alt="image-20200115091647925"></a></p><p><em><strong>它会一直创建pod直到完成命令。</strong></em></p><h3 id="（8）修改一下jop的yaml文件，修改重启策略">（8）修改一下jop的yaml文件，修改重启策略</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim jop.yaml <br>kind: Job<br>apiVersion: batch/v1<br>metadata:<br>  name: test-job<br>spec:<br>  template:<br>    metadata:<br>      name: test-job<br>    spec:<br>      containers:<br>      - name: hello<br>        image: busybox<br>        command: ["asdasxsddwefew","hello k8s job!"]<br>      restartPolicy: OnFailure<br></code></pre></td></tr></table></figure><h3 id="（9）先删除之前的pod">（9）先删除之前的pod</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl delete jobs.batch test-job<br></code></pre></td></tr></table></figure><h3 id="（10）执行一下">（10）执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f jop.yaml<br></code></pre></td></tr></table></figure><h3 id="（11）查看一下">（11）查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod -w<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200115092801882.png" alt="image-20200115092801882"></p><p><em><strong>它会一直重启pod完成命令，直到重启到一定次数就会删除job。</strong></em></p><h1>二、提高Job的执行效率</h1><h2 id="1-我们可以在Job-spec字段下加上parallelism选项。表示同时运行多少个Pod执行任务。">1. 我们可以在Job.spec字段下加上<a href="https://wsdlxgp.top/posts/e9be.html">parallelism</a>选项。表示同时运行多少个Pod执行任务。</h2><hr><h3 id="（1）编写一个job的yaml文件-2">（1）编写一个job的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim jop.yaml<br>kind: Job<br>apiVersion: batch/v1<br>metadata:<br>  name: test-job<br>spec:<br>  parallelism: 2    #同时启用几个pod<br>  template:<br>    metadata:<br>      name: test-job<br>    spec:<br>      containers:<br>      - name: hello<br>        image: busybox<br>        command: ["echo","hello k8s job!"]<br>      restartPolicy: OnFailure<br></code></pre></td></tr></table></figure><h3 id="（3）执行一下">（3）执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f jop.yaml<br></code></pre></td></tr></table></figure><h3 id="（4）查看一下">（4）查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200115093854913.png" alt="image-20200115093854913"></p><h4 id="查看日志-2">查看日志</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200115094002236.png" alt="image-20200115094002236"></p><h2 id="2-我们可以在Job-spec字段下加上complations选项。表示总共需要完成Pod的数量">2. 我们可以在Job.spec字段下加上complations选项。表示总共需要完成Pod的数量</h2><h3 id="（1）编写一个job的yaml文件-3">（1）编写一个job的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim jop.yaml<br>kind: Job<br>apiVersion: batch/v1<br>metadata:<br>  name: test-job<br>spec:<br>  complations: 8            #运行pod的总数量8个<br>  parallelism: 2            #同时运行2个pod<br>  template:<br>    metadata:<br>      name: test-job<br>    spec:<br>      containers:<br>      - name: hello<br>        image: busybox<br>        command: ["echo","hello k8s job!"]<br>      restartPolicy: OnFailure<br></code></pre></td></tr></table></figure><p><strong>job 字段解释：</strong></p><blockquote><p><strong>标志Job结束需要成功运行的Pod个数，默认为1</strong><br><strong>parallelism：标志并行运行的Pod的个数，默认为1</strong><br><strong>activeDeadlineSeconds：标志失败Pod的重试最大时间，超过这个时间不会继续重试.</strong></p></blockquote><h3 id="（2）先删除之前的pod">（2）先删除之前的pod</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl delete jobs.batch test-job<br></code></pre></td></tr></table></figure><h3 id="（3）执行一下-2">（3）执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f jop.yaml<br></code></pre></td></tr></table></figure><h3 id="（4）查看一下-2">（4）查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200115094519494.png" alt="image-20200115094519494"></p><p><strong>可以看到pod是两个两个的启动的。</strong></p><h2 id="3-如何定时执行Job">3. 如何定时执行Job</h2><h3 id="（1）编写一个cronjob的yaml文件">（1）编写一个cronjob的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim cronjop.yaml<br>kind: CronJob<br>apiVersion: batch/v1beta1<br>metadata:<br>  name: hello<br>spec:<br>  schedule: "*/1 * * * *" #限定时间<br>  jobTemplate:<br>    spec:<br>      template:<br>        spec:<br>          containers:<br>          - name: hello<br>            image: busybox<br>            command: ["echo","hello","cronjob"]<br>          restartPolicy: OnFailure<br></code></pre></td></tr></table></figure><h3 id="（2）先删除之前的pod-2">（2）先删除之前的pod</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl delete jobs.batch test-job<br></code></pre></td></tr></table></figure><h3 id="（3）执行一下-3">（3）执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f jop.yaml<br></code></pre></td></tr></table></figure><h3 id="（4）查看一下-3">（4）查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200115095857428.png" alt="image-20200115095857428"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get cronjobs.batch<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200115095920740.png" alt="image-20200115095920740"></p><p><strong>此时查看Pod的状态，会发现，每分钟都会运行一个新的Pod来执行命令规定的任</strong><br><strong>务。</strong></p><h2 id="练习：规定2020-1-15-10-5分运行上面的crontab任务。">练习：规定2020.1.15.10.5分运行上面的crontab任务。</h2><h3 id="（1）编写一个cronjob的yaml文件-2">（1）编写一个cronjob的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim cronjop.yaml<br>kind: CronJob<br>apiVersion: batch/v1beta1<br>metadata:<br>  name: hello<br>spec:<br>  schedule: "5 10 15 1 *" #限定时间<br>  jobTemplate:<br>    spec:<br>      template:<br>        spec:<br>          containers:<br>          - name: hello<br>            image: busybox<br>            command: ["echo","hello","cronjob"]<br>          restartPolicy: OnFailure<br></code></pre></td></tr></table></figure><h3 id="（2）先删除之前的pod-3">（2）先删除之前的pod</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl delete cronjobs.batch hello<br></code></pre></td></tr></table></figure><h3 id="（3）执行一下-4">（3）执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f jop.yaml<br></code></pre></td></tr></table></figure><h3 id="（4）查看一下-4">（4）查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200115100855819.png" alt="image-20200115100855819"></p><p><strong>这时会发现，如果规定具体时间，可能并不会执行任务。</strong></p><h3 id="（5）添加apiVersion库">（5）添加apiVersion库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim /etc/kubernetes/manifests/kube-apiserver.yaml <br>spec:<br>  containers:<br>  - command:<br>    - kube-apiserver<br>    - --runtime-config=batch/v2alpha1=true    #添加<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200115104218361.png" alt="image-20200115104218361"></p><h3 id="（6）重启kubelet">（6）重启kubelet</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# systemctl restart kubelet.service<br></code></pre></td></tr></table></figure><h3 id="（7）查看api版本">（7）查看api版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl api-versions<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200115104521662.png" alt="image-20200115104521662"></p><h3 id="（8）编写一个cronjob的yaml文件">（8）编写一个cronjob的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim cronjop.yaml<br>kind: CronJob<br>apiVersion: batch/v1beta1<br>metadata:<br>  name: hello<br>spec:<br>  schedule: "47 10 15 1 *" #限定时间<br>  jobTemplate:<br>    spec:<br>      template:<br>        spec:<br>          containers:<br>          - name: hello<br>            image: busybox<br>            command: ["echo","hello","cronjob"]<br>          restartPolicy: OnFailure<br></code></pre></td></tr></table></figure><h3 id="（9）执行一下">（9）执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f jop.yaml<br></code></pre></td></tr></table></figure><h3 id="（4）查看一下-5">（4）查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod -w<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200115100855819.png" alt="image-20200115100855819"></p><p><strong>注意：此时仍然不能正常运行指定时间的Job，这是因为K8s官方在cronjob这个资源对象的支持中还没有完善此功能，还待开发。</strong></p><p><strong>跟Job资源一样在cronjob.spec.jobTemplate.spec 下同样支持并发Job参数:</strong><br><strong>parallelism，也支持完成Pod的总数参数: completionsr</strong></p><h1>总结</h1><p><strong>Job 作为 Kubernetes 中用于处理任务的资源，与其他的资源没有太多的区别，它也使用 Kubernetes 中常见的控制器模式，监听 Informer 中的事件并运行 <code>syncHandler</code> 同步任务</strong></p><p><strong>而 CronJob 由于其功能的特殊性，每隔 10s 会从 apiserver 中取出资源并进行检查是否应该触发调度创建新的资源，需要注意的是 CronJob 并不能保证在准确的目标时间执行，执行会有一定程度的滞后。</strong></p><p><strong>两个控制器的实现都比较清晰，只是边界条件比较多，分析其实现原理时一定要多注意。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Job </tag>
            
            <tag> apiVersion </tag>
            
            <tag> CronJob </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s的ReplicaSet，DaemonSet及标签</title>
      <link href="/posts/5281.html"/>
      <url>/posts/5281.html</url>
      
        <content type="html"><![CDATA[<h1>环境介绍</h1><table><thead><tr><th>主机</th><th>IP地址</th><th>服务</th></tr></thead><tbody><tr><td>master</td><td>192.168.1.21</td><td>k8s</td></tr><tr><td>node01</td><td>192.168.1.22</td><td>k8s</td></tr><tr><td>node02</td><td>192.168.1.23</td><td>k8s</td></tr></tbody></table><p>基于<a href> https://blog.51cto.com/14320361/2464655</a> 的实验继续进行</p><h1>ReplicaSet简单介绍</h1><h2 id="1-RC：ReplicationController（老一代的pod控制器）">1. RC：ReplicationController（老一代的pod控制器）</h2><p><strong>用来确保由其管控的Pod对象副本数量，能够满足用户期望，多则删除，少则通过模本创建</strong></p><h3 id="特点：">特点：</h3><ul><li><strong>确保Pod资源对象的数量精准。</strong></li><li><strong>确保pod健康运行。</strong></li><li><strong>弹性伸缩</strong></li></ul><p><strong>同样，它也可以通过yaml或json格式的资源清单来创建。其中spec字段一般嵌套以下字段：</strong></p><ul><li><strong>replicas：期望的Pod对象副本数量。</strong></li><li><strong>selector：当前控制器匹配Pod对此项副本的标签选择器</strong></li><li><strong>template：pod副本的模板</strong></li></ul><p><strong>与RC相比而言，RS不仅支持*基于等值*的标签选择器，而且还支持*基于集合*的标签选择器。</strong></p><h2 id="2-标签：解决同类型的资源对象，为了更好的管理，按照标签分组。">2. 标签：解决同类型的资源对象，为了更好的管理，按照标签分组。</h2><h3 id="常用的标签分类：">常用的标签分类：</h3><ul><li><strong>release（版本）：stable（稳定版）、canary（金丝雀版本）、beta（测试版本）</strong></li><li><strong>environment（环境变量）：dev（开发）、qa（测试）、production（生产）</strong></li><li><strong>application（应用）：ui、as（application software应用软件）、pc、sc</strong></li><li><strong>tier（架构层级）：frontend（前端）、backend（后端）、cache（缓存）</strong></li><li><strong>partition（分区）：customerA（客户A）、customerB（客户B）</strong></li><li><strong>track（品控级别）：daily（每天）、weekly（每周）</strong></li></ul><p><strong>标签要做到：见名知意。</strong></p><h2 id="3-测试">3.测试</h2><h3 id="（1）编写一个pod的yaml文件">（1）编写一个pod的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim label.yaml <br><br>kind: Pod<br>apiVersion: v1<br>metadata:<br>  name: labels<br>  labels:<br>    env: qa<br>    tier: frontend<br>spec:<br>  containers:<br>  - name: myapp<br>    image: httpd<br></code></pre></td></tr></table></figure><h4 id="1-执行一下">&lt;1&gt;执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f label.yaml  --record<br></code></pre></td></tr></table></figure><h4 id="2-查看一下">&lt;2&gt;查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod  --show-labels <br>//通过--show-labels显示资源对象的<br></code></pre></td></tr></table></figure><p><a href="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200114095943595.png" target="_blank" rel="noopener"><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200114095943595.png" alt="image-20200114095943595"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get po -L env,tier<br>//显示某个键对应的值<br></code></pre></td></tr></table></figure><p><a href="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200114100043922.png" target="_blank" rel="noopener"><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200114100043922.png" alt="image-20200114100043922"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get po -l env,tier<br>//通过-l 查看仅包含某个标签的资源。<br></code></pre></td></tr></table></figure><p><a href="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200114100200895.png" target="_blank" rel="noopener"><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200114100200895.png" alt="image-20200114100200895"></a></p><h3 id="（2）添加标签">（2）添加标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl label pod  labels app=pc<br>//给pod资源添加标签<br></code></pre></td></tr></table></figure><h3 id="（3）修改标签">（3）修改标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl label pod labels env=dev --overwrite<br>//修改标签<br>[root@master ~]# kubectl get pod -l tier --show-labels <br>//查看标签<br></code></pre></td></tr></table></figure><p><a href="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200114100607585.png" target="_blank" rel="noopener"><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200114100607585.png" alt="image-20200114100607585"></a></p><h3 id="（4）编写一个service的yaml文件">（4）编写一个service的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim service.yaml<br>kind: Service<br>apiVersion: v1<br>metadata:<br>  name: service<br>spec:<br>  type: NodePort<br>  selector:<br>    env: qa<br>  ports:<br>  - protocol: TCP<br>    port: 90<br>    targetPort: 80<br>    nodePort: 30123<br></code></pre></td></tr></table></figure><h4 id="1-执行一下-2">&lt;1&gt;执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f service.yaml<br></code></pre></td></tr></table></figure><h4 id="2-查看一下-2">&lt;2&gt;查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl describe svc<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200114101837151.png" alt="image-20200114101837151"></p><h4 id="3-访问一下">&lt;3&gt;访问一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# curl 127.0.0.1:30123<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200114101915248.png" alt="image-20200114101915248"></p><p><strong>如果标签有多个，标签选择器选择其中一个，也可以关联成功。相反，如果选择器有多个，那么标签必须完全满足条件，才可以关联成功。</strong></p><h2 id="4-标签选择器：标签的查询过滤条件。">4. 标签选择器：标签的查询过滤条件。</h2><p><strong><a href="https://wsdlxgp.top/posts/7772.html">基于等值关系的（equality-based）</a>：“=”，“==”，“！ =”前面两个都是相等，最后一个是不等于。</strong></p><p><strong><a href="https://wsdlxgp.top/posts/7772.html">基于集合关系（set-based）</a>:in、notin、exists三种。选择器列表间为“逻辑与”关系，使用ln或者NotIn操作时，其valuas不强制要求为非空的字符串列表，而使用Exists或DostNotExist时，其values必须为空</strong></p><h4 id="使用标签选择器的逻辑：">使用标签选择器的逻辑：</h4><ul><li><strong>同时指定的多个选择器之间的逻辑关系为“与”操作。</strong></li><li><strong>使用空值的标签选择器意味着每个资源对象都将把选中。</strong></li><li><strong>空的标签选择器无法选中任何资源。</strong></li></ul><h3 id="（1）例子">（1）例子</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200114110334223.png" alt="image-20200114110334223"></p><h4 id="编写一个selector的yaml’文件">编写一个selector的yaml’文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim selector.yaml<br>selector:<br>  matchLabels:<br>    app: nginx<br>  mathExpressions:<br>    - &#123;key: name,operator: In,values: [zhangsan,lisi]&#125;<br>    - &#123;key: age,operator: Exists,values:&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>selector：当前控制器匹配Pod对此项副本的标签选择器</strong></li><li><strong>matchLabels: 指定键值对表示的标签选择器。</strong></li><li><strong>mathExpressions:：基于表达式来指定的标签选择器。</strong></li></ul><h1>DaemonSet</h1><p><em><strong>它也是一种pod控制器。</strong></em></p><p><em><strong>RC，RS , deployment , daemonset.都是pod控制器。statfukSet，RBAC</strong></em></p><h3 id="1-使用场景：">1. 使用场景：</h3><p><strong>如果必须将pod运行在固定的某个或某几个节点，且要优先于其他的pod的启动。通常情况下，默认会将每一个节点都运行，并且只能运行一个pod。这种情况推荐使用DeamonSet资源对象。</strong></p><ul><li><strong>监控程序；</strong></li><li><strong>日志收集程序；</strong></li><li><strong>集群存储程序；</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get ds -n kube-system <br>//查看一下DaemonSet<br></code></pre></td></tr></table></figure><h3 id="2-DaemonSet-与-Deployment-的区别">2. DaemonSet 与 Deployment 的区别</h3><ul><li><strong>Deployment 部署的副本 Pod 会分布在各个 Node 上，每个 Node 都可能运行好几个副本。</strong></li><li><strong>DaemonSet 的不同之处在于：每个 Node 上最多只能运行一个副本。</strong></li></ul><h3 id="3-运行一个web服务，在每一个节点运行一个pod。">3. 运行一个web服务，在每一个节点运行一个pod。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim daemonset.yaml<br><br>kind: DaemonSet<br>apiVersion: extensions/v1beta1<br>metadata:<br>  name: test-ds<br>spec:<br>  template:<br>    metadata:<br>      labels:<br>        name: test-ds<br>    spec:<br>      containers:<br>      - name: test-ds<br>        image: httpd<br></code></pre></td></tr></table></figure><h4 id="1-执行一下-3">&lt;1&gt;执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f daemonset.yaml<br></code></pre></td></tr></table></figure><h4 id="2-查看一下-3">&lt;2&gt;查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get ds<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200114112936161.png" alt="image-20200114112936161"></p><h1>总结</h1><h2 id="1）总结RC、RS、Deplyment、DaemonSet控制器的特点及使用场景。"><strong>1）总结RC、RS、Deplyment、DaemonSet控制器的特点及使用场景。</strong></h2><h3 id="1-Replication-Controller（RC）">&lt;1&gt;Replication Controller（RC）</h3><h4 id="介绍及使用场景">介绍及使用场景</h4><p><strong><code>Replication Controller</code>简称<code>RC</code>，<code>RC</code>是<code>Kubernetes</code>系统中的核心概念之一，简单来说，<code>RC</code>可以保证在任意时间运行<code>Pod</code>的副本数量，能够保证<code>Pod</code>总是可用的。如果实际<code>Pod</code>数量比指定的多那就结束掉多余的，如果实际数量比指定的少就新启动一些<code>Pod</code>，当<code>Pod</code>失败、被删除或者挂掉后，<code>RC</code>都会去自动创建新的<code>Pod</code>来保证副本数量，所以即使只有一个<code>Pod</code>，我们也应该使用<code>RC</code>来管理我们的<code>Pod</code>。</strong></p><h4 id="主要功能">主要功能</h4><ul><li><strong>确保pod数量：RC用来管理正常运行Pod数量，一个RC可以由一个或多个Pod组成，在RC被创建后，系统会根据定义好的副本数来创建Pod数量。在运行过程中，如果Pod数量小于定义的，就会重启停止的或重新分配Pod，反之则杀死多余的。</strong></li><li><strong>确保pod健康：当pod不健康，运行出错或者无法提供服务时，RC也会杀死不健康的pod，重新创建新的。</strong></li><li><strong>弹性伸缩 ：在业务高峰或者低峰期的时候，可以通过RC动态的调整pod的数量来提高资源的利用率。同时，配置相应的监控功能（Hroizontal Pod Autoscaler），会定时自动从监控平台获取RC关联pod的整体资源使用情况，做到自动伸缩。</strong></li><li><strong>滚动升级：滚动升级为一种平滑的升级方式，通过逐步替换的策略，保证整体系统的稳定，在初始化升级的时候就可以及时发现和解决问题，避免问题不断扩大。</strong></li></ul><h3 id="2-Replication-Set（RS）">&lt;2&gt;Replication Set（RS）</h3><p><strong>被认为 是“升级版”的RC。RS也是用于保证与label selector匹配的pod数量维持在期望状态。</strong></p><blockquote><p><strong>实际上<code>RS</code>和<code>RC</code>的功能基本一致，目前唯一的一个区别就是<code>RC</code>只支持基于等式的<code>selector</code>（env=dev或app=nginx），但<code>RS</code>还支持基于集合的<code>selector</code>（version in (v1, v2)），这对复杂的运维管理就非常方便了。</strong></p><p><strong><code>kubectl</code>命令行工具中关于<code>RC</code>的大部分命令同样适用于我们的<code>RS</code>资源对象。不过我们也很少会去单独使用<code>RS</code>，它主要被<code>Deployment</code>这个更加高层的资源对象使用，除非用户需要自定义升级功能或根本不需要升级<code>Pod</code>，在一般情况下，我们推荐使用<code>Deployment</code>而不直接使用<code>Replica Set</code>。</strong></p></blockquote><h4 id="区别在于">区别在于</h4><p><strong>1、RC只支持基于等式的selector（env=dev或environment!=qa），但RS还支持新的，基于集合的selector（version in (v1.0, v2.0)或env notin (dev, qa)），这对复杂的运维管理很方便。</strong></p><p><strong>2、升级方式</strong></p><ul><li><strong>RS不能使用kubectlrolling-update进行升级</strong></li><li><strong>kubectl rolling-update专用于rc</strong></li><li><strong>RS升级使用deployment或者kubectl replace命令</strong></li><li><strong>社区引入这一API的初衷是用于取代vl中的RC，也就是说当v1版本被废弃时，RC就完成了它的历史使命，而由RS来接管其工作</strong></li></ul><h3 id="3-DaemonSet">&lt;3&gt;DaemonSet</h3><h4 id="1-特点：">1. 特点：</h4><p><strong>如果必须将pod运行在固定的某个或某几个节点，且要优先于其他的pod的启动。通常情况下，默认会将每一个节点都运行，并且只能运行一个pod。这种情况推荐使用DeamonSet资源对象。</strong></p><p><strong>一个DaemonSet对象能确保其创建的Pod在集群中的每一台（或指定）Node上都运行一个副本。如果集群中动态加入了新的Node，DaemonSet中的Pod也会被添加在新加入Node上运行。删除一个DaemonSet也会级联删除所有其创建的Pod。</strong></p><h4 id="2-使用环境"><strong>2. 使用环境</strong></h4><ul><li><strong>监控程序；</strong></li><li><strong>日志收集程序；</strong></li><li><strong>集群存储程序；</strong></li></ul><h3 id="4-Deployment">&lt;4&gt;Deployment</h3><h4 id="1-什么是Deployment">1. 什么是Deployment</h4><p><strong>Kubernetes Deployment提供了官方的用于更新Pod和Replica Set（下一代的Replication Controller）的方法，您可以在Deployment对象中只描述您所期望的理想状态（预期的运行状态），Deployment控制器为您将现在的实际状态转换成您期望的状态，例如，您想将所有的webapp:v1.0.9升级成webapp:v1.1.0，您只需创建一个Deployment，Kubernetes会按照Deployment自动进行升级。现在，您可以通过Deployment来创建新的资源（pod，rs，rc），替换已经存在的资源等。</strong></p><p><strong>你只需要在Deployment中描述你想要的目标状态是什么，Deployment controller就会帮你将Pod和Replica Set的实际状态改变到你的目标状态。你可以定义一个全新的Deployment，也可以创建一个新的替换旧的Deployment。</strong></p><h4 id="2-典型的用例">2. 典型的用例</h4><ul><li><strong>使用Deployment来创建ReplicaSet。ReplicaSet在后台创建pod。检查启动状态，看它是成功还是失败。</strong></li><li><strong>然后，通过更新Deployment的PodTemplateSpec字段来声明Pod的新状态。这会创建一个新的ReplicaSet，Deployment会按照控制的速率将pod从旧的ReplicaSet移动到新的ReplicaSet中。</strong></li><li><strong>如果当前状态不稳定，回滚到之前的Deployment revision。每次回滚都会更新Deployment的revision。</strong></li><li><strong>扩容Deployment以满足更高的负载。</strong></li><li><strong>暂停Deployment来应用PodTemplateSpec的多个修复，然后恢复上线。</strong></li><li><strong>根据Deployment 的状态判断上线是否hang住了。</strong></li><li><strong>清除旧的不必要的ReplicaSet。</strong></li></ul><h4 id="3-使用环境">3. 使用环境</h4><p><strong>Deployment集成了上线部署、滚动升级、创建副本、暂停上线任务，恢复上线任务，回滚到以前某一版本（成功/稳定）的Deployment等功能，在某种程度上，Deployment可以帮我们实现无人值守的上线，大大降低我们的上线过程的复杂沟通、操作风险。</strong></p><ul><li><strong>定义Deployment来创建Pod和ReplicaSet</strong></li><li><strong>滚动升级和回滚应用</strong></li><li><strong>扩容和缩容</strong></li><li><strong>暂停和继续Deployment</strong></li></ul><h4 id="3-DaemonSet-与-Deployment-的区别">3. DaemonSet 与 Deployment 的区别</h4><ul><li><strong>Deployment 部署的副本 Pod 会分布在各个 Node 上，每个 Node 都可能运行好几个副本。</strong></li><li><strong>DaemonSet 的不同之处在于：每个 Node 上最多只能运行一个副本。</strong></li></ul><h2 id="2）使用DaemonSet控制器运行httpd服务，要求名称以自己的名称命名。标签为：tier-backend-env-dev"><strong>2）使用DaemonSet控制器运行httpd服务，要求名称以自己的名称命名。标签为：tier=backend,env=dev.</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim daemonset.yaml <br>kind: DaemonSet<br>apiVersion: extensions/v1beta1<br>metadata:<br>  name: xgp-ds<br>spec:<br>  template:<br>    metadata:<br>      labels:<br>        tier: backend<br>        env: dev<br>    spec:<br>      containers:<br>      - name: xgp-ds<br>        image: httpd<br></code></pre></td></tr></table></figure><h3 id="查看一下">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod  --show-labels<br></code></pre></td></tr></table></figure><p><a href="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200114100043922.png" target="_blank" rel="noopener"><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200114100043922.png" alt="image-20200114100043922"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -L env,tier<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200114095943595.png" alt="image-20200114095943595"></p><h2 id="3-创建service资源对象与上述资源进行关联，要有验证。"><strong>3) 创建service资源对象与上述资源进行关联，要有验证。</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim service.yaml <br>kind: Service<br>apiVersion: v1<br>metadata:<br>  name: service<br>spec: <br>  type: NodePort<br>  selector: <br>    env: dev<br>  ports:    <br>  - protocol: TCP<br>    port: 90 <br>    targetPort: 80<br>    nodePort: 30123<br></code></pre></td></tr></table></figure><h3 id="执行一下">执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f service.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下-2">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl describe svc<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200114120345596.png" alt="image-20200114120345596"></p><h3 id="访问一下">访问一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# curl 127.0.0.1:30123<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200114120444524.png" alt="image-20200114120444524"></p><h2 id="4）整理关于标签和标签选择器都有什么作用？"><strong>4）整理关于标签和标签选择器都有什么作用？</strong></h2><p><strong>&lt;1&gt;标签：解决同类型的资源对象，为了更好的管理，按照标签分组。</strong></p><p><strong>&lt;2&gt;标签选择器：标签的查询过滤条件。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Replica </tag>
            
            <tag> SetDaemonSet </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pod健康检查详解（liveness，readiness，滚动更新）</title>
      <link href="/posts/af5b.html"/>
      <url>/posts/af5b.html</url>
      
        <content type="html"><![CDATA[<h2 id="环境介绍">环境介绍</h2><table><thead><tr><th>主机</th><th>IP地址</th><th>服务</th></tr></thead><tbody><tr><td>master</td><td>192.168.1.21</td><td>k8s+httpd+nginx</td></tr><tr><td>node01</td><td>192.168.1.22</td><td>k8s</td></tr><tr><td>node02</td><td>192.168.1.23</td><td>k8s</td></tr></tbody></table><p><strong>基于<a href> https://blog.51cto.com/14320361/2464655</a> 的实验继续进行</strong></p><h2 id="一、Pod的liveness和readiness探针">一、Pod的liveness和readiness探针</h2><p><strong>Kubelet使用liveness probe（存活探针）来确定何时重启容器。例如，当应用程序处于运行状态但无法做进一步操作，liveness探针将捕获到deadlock，重启处于该状态下的容器，使应用程序在存在bug的情况下依然能够继续运行下去</strong><br><strong>Kubelet使用readiness probe（就绪探针）来确定容器是否已经就绪可以接受流量。只有当Pod中的容器都处于就绪状态时kubelet才会认定该Pod处于就绪状态。该信号的作用是控制哪些Pod应该作为service的后端。如果Pod处于非就绪状态，那么它们将会被从service的load balancer中移除。</strong></p><h2 id="Probe支持以下三种检查方法：">Probe支持以下三种检查方法：</h2><h4 id="1-exec-命令">&lt;1&gt;exec-命令</h4><p><strong>在用户容器内执行一次命令，如果命令执行的退出码为0，则认为应用程序正常运行，其他任务应用程序运行不正常。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">livenessProbe:<br>  exec:<br>    command:<br>    - cat<br>    - /home/laizy/test/hostpath/healthy<br></code></pre></td></tr></table></figure><h4 id="2-TCPSocket">&lt;2&gt;TCPSocket</h4><p><strong>将会尝试打开一个用户容器的Socket连接（就是IP地址：端口）。如果能够建立这条连接，则认为应用程序正常运行，否则认为应用程序运行不正常。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">livenessProbe:<br>tcpSocket:<br>   port: 8080<br></code></pre></td></tr></table></figure><h4 id="3-HTTPGet">&lt;3&gt;HTTPGet</h4><p><strong>调用容器内Web应用的web hook，如果返回的HTTP状态码在200和399之间，则认为应用程序正常运行，否则认为应用程序运行不正常。每进行一次HTTP健康检查都会访问一次指定的URL。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">httpGet: #通过httpget检查健康，返回200-399之间，则认为容器正常<br>  path: / #URI地址<br>  port: 80 #端口号<br><span class="hljs-meta">  #</span><span class="bash">host: 127.0.0.1 <span class="hljs-comment">#主机地址</span></span><br>  scheme: HTTP #支持的协议，http或者https<br>httpHeaders：’’ #自定义请求的header<br></code></pre></td></tr></table></figure><h2 id="参数说明">参数说明</h2><blockquote><p>**initialDelaySeconds：**容器启动后第一次执行探测是需要等待多少秒。</p><p>**periodSeconds：**执行探测的频率。默认是10秒，最小1秒。</p><p>**timeoutSeconds：**探测超时时间。默认1秒，最小1秒。</p><p>**successThreshold：**探测失败后，最少连续探测成功多少次才被认定为成功。默认是1。对于liveness必须是1。最小值是1。</p></blockquote><h2 id="探针探测的结果有以下三者之一：">探针探测的结果有以下三者之一：</h2><blockquote><p>Success：Container通过了检查。<br>Failure：Container未通过检查。<br>Unknown：未能执行检查，因此不采取任何措施。</p></blockquote><h3 id="1-LivenessProbe（活跃度）">1. LivenessProbe（活跃度）</h3><h4 id="（1）编写一个livenss的yaml文件">（1）编写一个livenss的yaml文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node02 ~]# vim livenss.yaml<br>kind: Pod<br>apiVersion: v1<br>metadata:<br>  name: liveness<br>  labels:<br>    test: liveness<br>spec:<br>  restartPolicy: OnFailure<br>  containers:<br>  - name: liveness<br>    image: busybox<br>    args:<br>    - /bin/sh<br>    - -c<br>    - touch /tmp/test; sleep 60; rm -rf /tmp/test; sleep 300<br>    livenessProbe:              #存活探测<br>      exec:                     #通过执行命令来检查服务是否正常<br>        command:                #命令模式<br>        - cat<br>        - /tmp/test<br>      initialDelaySeconds: 10    #pod运行10秒后开始探测<br>      periodSeconds: 5           #检查的频率，每5秒探测一次<br></code></pre></td></tr></table></figure><p><strong>该配置文件给Pod配置了一个容器。periodSeconds 规定kubelet要每隔5秒执行一次liveness probe。initialDelaySeconds 告诉kubelet在第一次执行probe之前要的等待10秒钟。探针检测命令是在容器中执行 cat /tmp/healthy 命令。如果命令执行成功，将返回0，kubelet就会认为该容器是活着的并且很健康。如果返回非0值，kubelet就会杀掉这个容器并重启它。</strong></p><h4 id="（2）运行一下">（2）运行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f liveness.yaml<br></code></pre></td></tr></table></figure><h4 id="（3）查看一下">（3）查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -w<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113091518720.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113091518720.png" alt="image-20200113091518720"></a></p><p><strong>Liveness活跃度探测，根据探测某个文件是否存在，来确定某个服务是否正常运行，如果存在则正常，负责，它会根据你设置的Pod的重启策略操作Pod。</strong></p><h3 id="2-Readiness（敏感探测、就绪性探测）">2. Readiness（敏感探测、就绪性探测）</h3><p><strong>ReadinessProbe探针的使用场景livenessProbe稍有不同，有的时候应用程序可能暂时无法接受请求，比如Pod已经Running了，但是容器内应用程序尚未启动成功，在这种情况下，如果没有ReadinessProbe，则Kubernetes认为它可以处理请求了，然而此时，我们知道程序还没启动成功是不能接收用户请求的，所以不希望kubernetes把请求调度给它，则使用ReadinessProbe探针。<br>ReadinessProbe和livenessProbe可以使用相同探测方式，只是对Pod的处置方式不同，ReadinessProbe是将Pod IP:Port从对应的EndPoint列表中删除，而livenessProbe则Kill容器并根据Pod的重启策略来决定作出对应的措施。<br>ReadinessProbe探针探测容器是否已准备就绪，如果未准备就绪则kubernetes不会将流量转发给此Pod。<br>ReadinessProbe探针与livenessProbe一样也支持exec、httpGet、TCP的探测方式，配置方式相同，只不过是将livenessProbe字段修改为ReadinessProbe。</strong></p><h4 id="（1）编写一个readiness的yaml文件">（1）编写一个readiness的yaml文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim readiness.yaml <br>kind: Pod<br>apiVersion: v1<br>metadata:<br>  name: readiness<br>  labels:<br>    test: readiness<br>spec:<br>  restartPolicy: Never<br>  containers:<br>  - name: readiness<br>    image: busybox<br>    args:<br>    - /bin/sh<br>    - -c<br>    - touch /tmp/test; sleep 60; rm -rf /tmp/test; sleep 300<br>    readinessProbe:<br>      exec:<br>        command:<br>        - cat<br>        - /tmp/test<br>      initialDelaySeconds: 10<br>      periodSeconds: 5<br></code></pre></td></tr></table></figure><h4 id="（2）运行一下-2">（2）运行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f readiness.yaml<br></code></pre></td></tr></table></figure><h4 id="（3）查看一下-2">（3）查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -w<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113095301156.png" alt="image-20200113095301156"></p><h3 id="3-总结liveness和readiness探测">3. 总结liveness和readiness探测</h3><blockquote><p><strong>（1）liveness和readiness是两种健康检查机制，k8s将两种探测采取相同的默认行为，即通过判断容器启动进程的返回值是否为零，来判断探测是否成功。</strong></p><p><strong>（2）两种探测配置方法完全一样，不同之处在于探测失败后的行为。</strong></p><blockquote><p><strong>liveness探测是根据重启策略操作容器，大多数是重启容器。</strong></p><p><strong>readiness则是将容器设置为不可用，不接收Service转发的请求。</strong></p></blockquote><p><strong>（3）两种探测方法可建议独立存在，也可以同时存在。用livensess判断是否需要重启，实现自愈；用readiness判断容器是否已经准备好对外提供服务。</strong></p></blockquote><h1>二、 检测的应用</h1><h2 id="1-在scale-扩容-缩容-中的应用。">1. 在scale(扩容/缩容) 中的应用。</h2><h4 id="（1）编写一个readiness的yaml文件-2">（1）编写一个readiness的yaml文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim hcscal.yaml<br>kind: Deployment<br>apiVersion: extensions/v1beta1<br>metadata:<br>  name: web<br>spec:<br>  replicas: 3<br>  template: <br>    metadata:<br>      labels:<br>        run: web<br>    spec:<br>      containers:<br>      - name: web<br>        image: httpd<br>        ports:<br>        - containerPort: 80<br>        readinessProbe:<br>          httpGet:<br>            scheme: HTTP   #探测的协议<br>            path: /healthy  #访问的目录<br>            port: 80<br>          initialDelaySeconds: 10<br>          periodSeconds: 5<br><br>---<br>kind: Service<br>apiVersion: v1<br>metadata:<br>  name: web-svc<br>spec:<br>  type: NodePort<br>  selector:<br>    run: web<br>  ports:<br>  - protocol: TCP<br>    port: 90<br>    targetPort: 80<br>    nodePort: 30321<br></code></pre></td></tr></table></figure><p><strong>在配置文件中，使用httpd镜像，创建出一个Pod，其中periodSeconds字段指定kubelet每5秒执行一次探测，initialDelaySeconds字段告诉kubelet延迟等待10秒，探测方式为向容器中运行的服务发送HTTP GET请求，请求8080端口下的/healthz, 任何大于或等于200且小于400的代码表示成功。任何其他代码表示失败。</strong></p><h4 id="httpGet探测方式有如下可选的控制字段">httpGet探测方式有如下可选的控制字段</h4><blockquote><p><strong>host：要连接的主机名，默认为Pod IP，可以在http request head中设置host头部。</strong><br><strong>scheme: 用于连接host的协议，默认为HTTP。</strong><br><strong>path：http服务器上的访问URI。</strong><br><strong>httpHeaders：自定义HTTP请求headers，HTTP允许重复headers。</strong><br><strong>port： 容器上要访问端口号或名称。</strong></p></blockquote><h4 id="（2）运行一下-3">（2）运行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f readiness.yaml<br></code></pre></td></tr></table></figure><h4 id="（3）查看一下-3">（3）查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -w<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113102400721.png" alt="image-20200113102400721"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -o wide<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113104819603.png" alt="image-20200113104819603"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get service -o wide<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113104858861.png" alt="image-20200113104858861"></p><h4 id="（4）访问一下">（4）访问一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# curl  10.244.1.21/healthy<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113104931451.png" alt="image-20200113104931451"></p><h4 id="（5）pod在指定目录创建一个文件">（5）pod在指定目录创建一个文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl exec web-69d659f974-7s9bc touch /usr/local/apache2/htdocs/healthy<br></code></pre></td></tr></table></figure><h4 id="（6）查看一下">（6）查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -w<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113105045616.png" alt="image-20200113105045616"></p><h2 id="2-在更新过程中的使用">2. 在更新过程中的使用</h2><h4 id="（1）编写一个readiness的yaml文件-3">（1）编写一个readiness的yaml文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim app.v1.yaml<br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: app<br>spec:<br>  replicas: 10<br>  template:<br>    metadata:<br>      labels:<br>        run: app<br>    spec:<br>      containers:<br>      - name: app<br>        image: busybox<br>        args:<br>        - /bin/sh<br>        - -c<br>        - sleep 10; touch /tmp/healthy; sleep 3000<br>        readinessProbe:<br>          exec:<br>            command:<br>            - cat<br>            - /tmp/healthy<br>          initialDelaySeconds: 10<br>          periodSeconds: 5<br></code></pre></td></tr></table></figure><h4 id="（2）运行一下并记录版本信息">（2）运行一下并记录版本信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f readiness.yaml --record<br></code></pre></td></tr></table></figure><h5 id="查看一下">查看一下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl rollout history deployment app<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113110638083.png" alt="image-20200113110638083"></p><h4 id="（3）查看一下-4">（3）查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -w<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113110659355.png" alt="image-20200113110659355"></p><h2 id="3-升级一下Deployment">3.升级一下Deployment</h2><h4 id="（1）编写一个readiness的yaml文件-4">（1）编写一个readiness的yaml文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# cp app.v1.yaml app.v2.yaml<br>[root@master ~]# vim app.v2.yaml <br><br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: app<br>spec:<br>  replicas: 10<br>  template:<br>    metadata:<br>      labels:<br>        run: app<br>    spec:<br>      containers:<br>      - name: app<br>        image: busybox<br>        args:<br>        - /bin/sh<br>        - -c<br>        - sleep 3000        #修改命令<br>        readinessProbe:<br>          exec:<br>            command:<br>            - cat<br>            - /tmp/healthy<br>          initialDelaySeconds: 10<br>          periodSeconds: 5<br></code></pre></td></tr></table></figure><h4 id="（2）运行一下并记录版本信息-2">（2）运行一下并记录版本信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f readiness.yaml --record<br></code></pre></td></tr></table></figure><h5 id="查看一下-2">查看一下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl rollout history deployment app<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113111024791.png" alt="image-20200113111024791"></p><h4 id="（3）查看一下-5">（3）查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -w<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113111125387.png" alt="image-20200113111125387"></p><h4 id="（4）再次升级一下deployment">（4）再次升级一下deployment</h4><h5 id="1-编写一个readiness的yaml文件">&lt;1&gt; 编写一个readiness的yaml文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# cp app.v1.yaml app.v3.yaml<br>[root@master ~]# vim app.v2.yaml <br><br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: app<br>spec:<br>  replicas: 10<br>  template:<br>    metadata:<br>      labels:<br>        run: app<br>    spec:<br>      containers:<br>      - name: app<br>        image: busybox<br>        args:<br>        - /bin/sh<br>        - -c<br>        - sleep 3000        #修改命令<br></code></pre></td></tr></table></figure><h5 id="2-运行一下并记录版本信息">&lt;2&gt; 运行一下并记录版本信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f readiness.yaml --record<br></code></pre></td></tr></table></figure><h5 id="查看一下-3">查看一下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl rollout history deployment app<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113111559864.png" alt="image-20200113111559864"></p><h5 id="3-查看一下">&lt;3&gt; 查看一下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -w<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113111625947.png" alt="image-20200113111625947"></p><h2 id="4-回滚v2版本">4. 回滚v2版本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl rollout undo deployment app --to-revision=2<br></code></pre></td></tr></table></figure><h3 id="查看一下-4">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113112216777.png" alt="image-20200113112216777"></p><h3 id="（1）编写一个readiness的yaml文件-5">（1）编写一个readiness的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim app.v2.yaml <br>apiVersion: extensions/v1beta1<br>kind: Deployment<br>metadata:<br>  name: app<br>spec:<br>  strategy:<br>    rollingUpdate:<br>      maxSurge: 2<br>      maxUnavailable: 2<br>  replicas: 10<br>  template:<br>    metadata:<br>      labels:<br>        run: app<br>    spec:<br>      containers:<br>      - name: app<br>        image: busybox<br>        args:<br>        - /bin/sh<br>        - -c<br>        - sleep 3000<br>        readinessProbe:<br>          exec:<br>            command:<br>            - cat<br>            - /tmp/healthy<br>          initialDelaySeconds: 10<br>          periodSeconds: 5<br></code></pre></td></tr></table></figure><p><strong>maxSurge：此参数控制滚动更新过程中，副本总数超过预期数的值。可以是整数，也可以是百分比，默认是1。</strong></p><p><strong>maxUnavailable：不可用pod的值，默认为1，可以是整数，也可以是百分比。</strong></p><p><strong>参数介绍</strong></p><blockquote><h4 id="minReadySeconds">minReadySeconds:</h4><p><strong>Kubernetes在等待设置的时间后才进行升级</strong><br><strong>如果没有设置该值，Kubernetes会假设该容器启动起来后就提供服务了</strong><br><strong>如果没有设置该值，在某些极端情况下可能会造成服务服务正常运行</strong></p><h4 id="maxSurge">maxSurge:</h4><p><strong>升级过程中最多可以比原先设置多出的POD数量</strong><br><strong>例如：maxSurage=1，replicas=5,则表示Kubernetes会先启动1一个新的Pod后才删掉一个旧的POD，整个升级过程中最多会有5+1个POD。</strong></p><h4 id="maxUnavaible">maxUnavaible:</h4><p><strong>升级过程中最多有多少个POD处于无法提供服务的状态</strong><br><strong>当maxSurge不为0时，该值也不能为0</strong><br><strong>例如：maxUnavaible=1，则表示Kubernetes整个升级过程中最多会有1个POD处于无法服务的状态</strong></p></blockquote><h4 id="（2）-运行一下并记录版本信息">（2） 运行一下并记录版本信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f app.v2.yaml --record<br></code></pre></td></tr></table></figure><h5 id="查看一下-5">查看一下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl rollout history deployment app<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113114726856.png" alt="image-20200113114726856"></p><h4 id="（3）-查看一下">（3） 查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -w<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113114755658.png" alt="image-20200113114755658"></p><h2 id="三、小实验">三、小实验</h2><h3 id="1）写一个Deployment资源对象，要求2个副本，nginx镜像。使用Readiness探测，自定义文件-test是否存在，容器开启之后10秒开始探测，时间间隔为10秒。"><strong>1）写一个Deployment资源对象，要求2个副本，nginx镜像。使用Readiness探测，自定义文件/test是否存在，容器开启之后10秒开始探测，时间间隔为10秒。</strong></h3><h5 id="（1）编写一个readiness的yaml文件-6">（1）编写一个readiness的yaml文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim nginx.yaml<br><br>kind: Deployment<br>apiVersion: extensions/v1beta1<br>metadata:<br>  name: web<br>spec:<br>  replicas: 2<br>  template:<br>    metadata:<br>      labels:<br>        run: web<br>    spec:<br>      containers:<br>      - name: readiness<br>        image: 192.168.1.21:5000/nginx:v1<br>        readinessProbe:<br>          exec:<br>            command:<br>            - cat<br>            - /usr/share/nginx/html/test<br>          initialDelaySeconds: 10<br>          periodSeconds: 10<br></code></pre></td></tr></table></figure><h5 id="（2）运行一下并记录版本信息-3">（2）运行一下并记录版本信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f nginx.yaml --record<br></code></pre></td></tr></table></figure><h5 id="查看一下-6">查看一下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl rollout history deployment web<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113122256692.png" alt="image-20200113122256692"></p><h5 id="（3）查看一下-6">（3）查看一下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -w<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113141908252.png" alt="image-20200113141908252"></p><h3 id="2）在运行之后两个Pod里，进入一个Pod，创建文件-test。"><strong>2）在运行之后两个Pod里，进入一个Pod，创建文件/test。</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl exec -it web-864c7cf7fc-gpxq4  /bin/bash<br>root@web-68444bff8-xm22z:/# touch /usr/share/nginx/html/test<br></code></pre></td></tr></table></figure><h4 id="查看一下-7">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod -w<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113142148105.png" alt="image-20200113142148105"></p><h3 id="3）创建一个Service资源对象，跟上述Deployment进行关联，运行之后，查看Service资源详细信息，确认EndPoint负载均衡后端Pod。"><strong>3）创建一个Service资源对象，跟上述Deployment进行关联，运行之后，查看Service资源详细信息，确认EndPoint负载均衡后端Pod。</strong></h3><h4 id="（1）编写service的yaml文件">（1）编写service的yaml文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim nginx-svc.yaml<br>kind: Service<br>apiVersion: v1<br>metadata:<br>  name: web-svc<br>spec:<br>  type: NodePort<br>  selector:<br>    run: web<br>  ports:<br>  - protocol: TCP<br>    port: 90<br>    targetPort: 80<br>    nodePort: 30321<br></code></pre></td></tr></table></figure><h4 id="（2）执行一下">（2）执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f nginx-svc.yaml<br></code></pre></td></tr></table></figure><h4 id="（3）给两个pod刚更改页面">（3）给两个pod刚更改页面</h4><h5 id="查看一下pod">查看一下pod</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod -o wide<br></code></pre></td></tr></table></figure><h5 id="更改页面">更改页面</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl exec -it  web-864c7cf7fc-gpxq4  /bin/bash<br>root@web-864c7cf7fc-gpxq4:/# echo "123"&gt;/usr/share/nginx/html/test<br>root@web-864c7cf7fc-gpxq4:/# exit<br><br>[root@master yaml]# kubectl exec -it  web-864c7cf7fc-pcrs9   /bin/bash<br>root@web-864c7cf7fc-pcrs9:/# echo "321"&gt;/usr/share/nginx/html/test<br>root@web-864c7cf7fc-pcrs9:/# exit<br></code></pre></td></tr></table></figure><h3 id="4）观察状态之后，尝试将另一个Pod也写入-test文件，然后再去查看SVC对应的EndPoint的负载均衡情况。"><strong>4）观察状态之后，尝试将另一个Pod也写入/test文件，然后再去查看SVC对应的EndPoint的负载均衡情况。</strong></h3><h4 id="（1）查看一下service">（1）查看一下service</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get service<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113144624099.png" alt="image-20200113144624099"></p><h4 id="（2）访问一下">（2）访问一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# curl 192.168.1.21:30321/test<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113144514174.png" alt="image-20200113144514174"></p><h3 id></h3><h3 id="5）通过httpGet的探测方式，重新运行一下deployment资源，总结对比一下这两种Readiness探测方式。"><strong>5）通过httpGet的探测方式，重新运行一下deployment资源，总结对比一下这两种Readiness探测方式。</strong></h3><h4 id="（1）修改deployment的yaml文件">（1）修改deployment的yaml文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# vim nginx.yaml <br>kind: Deployment<br>apiVersion: extensions/v1beta1<br>metadata:<br>  name: web<br>spec:<br>  replicas: 2<br>  template:<br>    metadata:<br>      labels:<br>        run: web<br>    spec:<br>      containers:<br>      - name: readiness<br>        image: 192.168.1.21:5000/nginx:v1<br>        readinessProbe:<br>          httpGet:<br>            scheme: HTTP<br>            path: /usr/share/nginx/html/test<br>            port: 80<br>          initialDelaySeconds: 10<br>          periodSeconds: 10<br></code></pre></td></tr></table></figure><h4 id="（2）执行一下-2">（2）执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl apply -f nginx.yaml<br></code></pre></td></tr></table></figure><h4 id="（3）查看一下pod">（3）查看一下pod</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# kubectl get pod -w<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113151034766.png" alt="image-20200113151034766"></p><p><em><strong>maxSurge：此参数控制滚动更新过程中，副本总数超过预期数的值。可以是整数，也可以是百分比，默认是1。所以现在是3台pod</strong></em></p><h4 id="（4）访问一下-2">（4）访问一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master yaml]# curl 192.168.1.21:30321/test<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200113151225572.png" alt="image-20200113151225572"></p><h3 id="6）总结对比liveness和readiness探测的相同和不同之处，以及它们的使用场景。"><strong>6）总结对比liveness和readiness探测的相同和不同之处，以及它们的使用场景。</strong></h3><h3 id="1-readiness和liveness的核心区别">&lt;1&gt;readiness和liveness的核心区别</h3><p>实际上readiness 和liveness 就如同字面意思。readiness 就是意思是否可以访问，liveness就是是否存活。如果一个readiness 为fail 的后果是把这个pod 的所有service 的endpoint里面的改pod ip 删掉，意思就这个pod对应的所有service都不会把请求转到这pod来了。但是如果liveness 检查结果是fail就会直接kill container，当然如果你的restart policy 是always 会重启pod。</p><h3 id="2-什么样才叫readiness／liveness检测失败呢">&lt;2&gt;什么样才叫readiness／liveness检测失败呢?</h3><p><strong>实际上k8s提供了3中检测手段，</strong></p><blockquote><p>http get 返回200-400算成功，别的算失败<br>tcp socket 你指定的tcp端口打开，比如能telnet 上<br>cmd exec 在容器中执行一个命令 推出返回0 算成功。<br>每中方式都可以定义在readiness 或者liveness 中。比如定义readiness 中http get 就是意思说如果我定义的这个path的http get 请求返回200-400以外的http code 就把我从所有有我的服务里面删了吧，如果定义在liveness里面就是把我kill 了。</p></blockquote><h3 id="3-readiness和readiness的使用环境">&lt;3&gt;readiness和readiness的使用环境</h3><p><strong>比如如果一个http 服务你想一旦它访问有问题我就想重启容器。那你就定义个liveness 检测手段是http get。反之如果有问题我不想让它重启，只是想把它除名不要让请求到它这里来。就配置readiness。</strong></p><blockquote><p>注意，liveness不会重启pod，pod是否会重启由你的restart policy（重启策略）控制。</p></blockquote><p>参考：<br><a href="https://www.jianshu.com/p/16a375199cf2" target="_blank" rel="noopener">https://www.jianshu.com/p/16a375199cf2</a></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> liveness </tag>
            
            <tag> readiness </tag>
            
            <tag> 滚动更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s中pod的资源对象（名称空间，获取策略，重启策略，健康检查）</title>
      <link href="/posts/74b2.html"/>
      <url>/posts/74b2.html</url>
      
        <content type="html"><![CDATA[<h1>一，k8s的资源对象</h1><p><em><strong>Deployment、Service、Pod是k8s最核心的3个资源对象</strong></em></p><blockquote><p>**Deployment：**最常见的无状态应用的控制器，支持应用的扩缩容、滚动升级等操作。</p><p>**Service：**为弹性变动且存在生命周期的Pod对象提供了一个固定的访问接口，用于服务发现和服务访问。</p><p>**Pod：**是运行容器以及调度的最小单位。同一个pod可以同时运行多个容器，这些容器共享net、UTS、IPC，除此之外还有USER、PID、MOUNT。</p><p>**ReplicationController：**用于确保每个Pod副本在任意时刻都能满足目标数量，简单来说，它用于每个容器或容器组总是运行并且可以访问的：老一代无状态的Pod应用控制器。</p><p>**RwplicatSet：**新一代的无状态的Pod应用控制器，它与RC的不同之处在于支持的标签选择器不同，RC只支持等值选择器（键值对），RS还额外支持基于集合的选择器。</p><p>**StatefulSet：**用于管理有状态的持久化应用，如database服务程序，它与Deployment不同之处在于，它会为每一个pod创建一个独有的持久性标识符，并确保每个pod之间的顺序性。</p><p>**DaemonSet：**用于确保每一个节点都运行了某个pod的一个副本，新增的节点一样会被添加到此类pod，在节点移除时，此pod会被回收。</p><p>**Job：**用于管理运行完成后即可终止的应用，例如批量处理做作业任务；</p><p>**volume：**pv pvc<br><strong>ConfigMap：</strong><br><strong>Secret：</strong><br><strong>Role：</strong><br><strong>ClusterRole：</strong><br><strong>RoleBinding：</strong><br><strong>cluster RoleBinding：</strong><br><strong>service account：</strong><br><strong>Helm：</strong></p></blockquote><h2 id="Pod的生命周期被定义为以下几个阶段。">Pod的生命周期被定义为以下几个阶段。</h2><blockquote><ul><li><strong>Pending：Pod已经被创建，但是一个或者多个容器还未创建，这包括Pod调度阶段，以及容器镜像的下载过程。</strong></li><li><strong>Running：Pod已经被调度到Node，所有容器已经创建，并且至少一个容器在运行或者正在重启。</strong></li><li><strong>Succeeded：Pod中所有容器正常退出。</strong></li><li><strong>Failed：Pod中所有容器退出，至少有一个容器是一次退出的。</strong></li></ul></blockquote><h1>环境介绍</h1><table><thead><tr><th>主机</th><th>IP地址</th><th>服务</th></tr></thead><tbody><tr><td>master</td><td>192.168.1.21</td><td>k8s</td></tr><tr><td>node01</td><td>192.168.1.22</td><td>k8s</td></tr><tr><td>node02</td><td>192.168.1.23</td><td>k8s</td></tr></tbody></table><h1>二，Namespace：名称空间</h1><p><strong>默认的名称空间：</strong></p><blockquote><p><strong>Namespace（命名空间）是kubernetes系统中的另一个重要的概念，通过将系统内部的对象“分配”到不同的Namespace中，形成逻辑上分组的不同项目、小组或用户组，便于不同的分组在共享使用整个集群的资源的同时还能被分别管理。</strong></p><p><strong>Kubernetes集群在启动后，会创建一个名为“default”的Namespace，如果不特别指明Namespace，则用户创建的Pod、RC、Service都被系统创建到“default”的Namespace中。</strong></p></blockquote><h2 id="1-查看名称空间">1.查看名称空间</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get namespaces<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109094700728.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109094700728.png" alt="image-20200109094700728"></a></p><h2 id="2-查看名称空间详细信息">2.查看名称空间详细信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl describe ns default<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109095006067.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109095006067.png" alt="image-20200109095006067"></a></p><h2 id="3-创建名称空间">3.创建名称空间</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl create ns bdqn<br></code></pre></td></tr></table></figure><h3 id="查看一下">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get namespaces<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109095153448.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109095153448.png" alt="image-20200109095153448"></a></p><h2 id="4-创建namespace的yaml文件">4.创建namespace的yaml文件</h2><h3 id="（1）查看格式">（1）查看格式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl explain ns<br>//查看nasespace的yaml文件的格式<br></code></pre></td></tr></table></figure><h3 id="（2）创建namespace的yaml文件">（2）创建namespace的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim test-ns.yaml<br>apiVersion: v1<br>kind: Namespace<br>metadata:<br>  name: test<br></code></pre></td></tr></table></figure><h3 id="（3）运行namespace的yaml文件">（3）运行namespace的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f test-ns.yaml<br></code></pre></td></tr></table></figure><h3 id="（4）查看一下">（4）查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get ns<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109095808777.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109095808777.png" alt="image-20200109095808777"></a></p><h2 id="4-删除名称空间">4.删除名称空间</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl delete ns test <br>[root@master ~]# kubectl delete -f test-ns.yaml<br></code></pre></td></tr></table></figure><p><strong>注意：namespace资源对象进用于资源对象的隔离，并不能隔绝不同名称空间的Pod之间的通信。那是网络策略资源的功能。</strong></p><h2 id="5-查看指定名称空间">5.查看指定名称空间</h2><p><strong>可使用–namespace或-n选项</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -n kube-system <br>[root@master ~]# kubectl get pod --namespace kube-system<br></code></pre></td></tr></table></figure><h1>三，Pod</h1><h2 id="1-编写一个pod的yaml文件">1.编写一个pod的yaml文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim pod.yaml<br>kind: Pod<br>apiVersion: v1<br>metadata:<br>  name: test-pod<br>spec:<br>  containers:<br>  - name: test-app<br>    image: 192.168.1.21:5000/web:v1<br></code></pre></td></tr></table></figure><p><em><strong>pod的yaml文件不支持replicas字段</strong></em></p><h3 id="（1）运行一下">（1）运行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f pod.yaml<br></code></pre></td></tr></table></figure><h3 id="（2）查看一下">（2）查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109100836911.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109100836911.png" alt="image-20200109100836911"></a></p><p><em><strong>ps：这个pod因为是自己创建的，所以删除之后k8s并不会自动生成，相当于docker中创建</strong></em></p><h2 id="2-指定pod的namespace名称空间">2.指定pod的namespace名称空间</h2><h3 id="（1）修改pod的yaml文件">（1）修改pod的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim pod.yaml<br>kind: Pod        #资源类型<br>apiVersion: v1   #api版本<br>metadata:<br>  name: test-pod    #指定控制器名称<br>  namespace: bdqn   #指定namespace（名称空间）<br>spec:<br>  containers:      #容器<br>  - name: test-app  #容器名称<br>    image: 192.168.1.21:5000/web:v1  #镜像<br></code></pre></td></tr></table></figure><h5 id="执行一下">执行一下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f pod.yaml<br></code></pre></td></tr></table></figure><h3 id="（2）查看一下-2">（2）查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]#  kubectl get pod -n bdqn <br>//根据namespace名称查看<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109101521992.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109101521992.png" alt="image-20200109101521992"></a></p><h2 id="3-pod中镜像获取策略">3.pod中镜像获取策略</h2><blockquote><p>**Always：**镜像标签为“laster”或镜像不存在时，总是从指定的仓库中获取镜像。</p><p>**IfNotPresent：**仅当本地镜像不存在时才从目标仓库下载。</p><p>**Never：**禁止从仓库中下载镜像，即只使用本地镜像。</p></blockquote><p><em><strong>注意：对于标签为“laster”或者标签不存在，其默认的镜像下载策略为“Always”，而对于其他的标签镜像，默认策略为“IfNotPresent”。</strong></em></p><h2 id="4-观察pod和service的不同并关联">4.观察pod和service的不同并关联</h2><h3 id="（1）pod的yaml文件（指定端口）">（1）pod的yaml文件（指定端口）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim pod.yaml <br>kind: Pod          #资源类型<br>apiVersion: v1      #api版本<br>metadata:<br>  name: test-pod       #指定控制器名称<br>  namespace: bdqn   #指定namespace（名称空间）<br>spec:<br>  containers:                          #容器<br>  - name: test-app                    #容器名称<br>    image: 192.168.1.21:5000/web:v1   #镜像<br>    imagePullPolicy: IfNotPresent   #获取的策略<br>    ports:<br>    - protocol: TCP<br>      containerPort: 80<br></code></pre></td></tr></table></figure><h4 id="1-删除之前的pod">&lt;1&gt;删除之前的pod</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl delete pod -n bdqn test-pod<br></code></pre></td></tr></table></figure><h4 id="2-执行一下">&lt;2&gt;执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f pod.yaml<br></code></pre></td></tr></table></figure><h4 id="3-查看一下">&lt;3&gt;查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -n bdqn<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109110215669.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109110215669.png" alt="image-20200109110215669"></a></p><h3 id="（2）pod的yaml文件（修改端口）">（2）pod的yaml文件（修改端口）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim pod.yaml <br>kind: Pod<br>apiVersion: v1<br>metadata:<br>  name: test-pod<br>  namespace: bdqn<br>spec:<br>  containers:<br>  - name: test-app<br>    image: 192.168.1.21:5000/web:v1<br>    imagePullPolicy: IfNotPresent<br>    ports:<br>    - protocol: TCP<br>      containerPort: 90   #改一下端口<br></code></pre></td></tr></table></figure><h4 id="1-删除之前的pod-2">&lt;1&gt;删除之前的pod</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl delete pod -n bdqn test-pod<br></code></pre></td></tr></table></figure><h4 id="2-执行一下-2">&lt;2&gt;执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f pod.yaml<br></code></pre></td></tr></table></figure><h4 id="3-查看一下-2">&lt;3&gt;查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -n bdqn -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109110409584.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109110409584.png" alt="image-20200109110409584"></a></p><h4 id="4-访问一下">&lt;4&gt;访问一下</h4><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109110430334.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109110430334.png" alt="image-20200109110430334"></a></p><p><strong>会发现修改的90端口并不生效，他只是一个提示字段并不生效。</strong></p><h3 id="（3）pod的yaml文件（添加标签）">（3）pod的yaml文件（添加标签）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim pod.yaml <br>kind: Pod<br>apiVersion: v1<br>metadata:<br>  name: test-pod<br>  namespace: bdqn<br>  labels:                 #标签<br>    app: test-web          #标签名称<br>spec:<br>  containers:<br>  - name: test-app<br>    image: 192.168.1.21:5000/web:v1<br>    imagePullPolicy: IfNotPresent<br>    ports:<br>    - protocol: TCP<br>      containerPort: 90   #改一下端口<br></code></pre></td></tr></table></figure><h4 id="pod">--------------------------------------pod---------------------------------------------</h4><h2 id="（4）编写一个service的yaml文件">（4）编写一个service的yaml文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim test-svc.yaml <br>apiVersion: v1      #api版本<br>kind: Service          #资源类型<br>metadata:<br>  name: test-svc       #指定控制器名称<br>  namespace: bdqn   #指定namespace（名称空间）<br>spec:<br>  selector:          #标签<br>    app: test-web    #标签名称（须和pod的标签名称一致）<br>  ports:              <br>  - port: 80          #宿主机端口<br>    targetPort: 80    #容器端口<br></code></pre></td></tr></table></figure><p><em><strong>会发现添加的80端口生效了，所以不能乱改。</strong></em></p><h4 id="1-执行一下">&lt;1&gt;执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f test-svc.yaml<br></code></pre></td></tr></table></figure><h4 id="2-查看一下">&lt;2&gt;查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get svc -n bdqn<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109121106859.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109121106859.png" alt="image-20200109121106859"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl describe svc -n bdqn test-svc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109121139399.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109121139399.png" alt="image-20200109121139399"></a></p><h4 id="4-访问一下-2">&lt;4&gt;访问一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# curl 10.98.57.97<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109121205607.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109121205607.png" alt="image-20200109121205607"></a></p><h4 id="service">--------------------------------------service---------------------------------------------</h4><h1>四，容器的重启策略</h1><p><strong>Pod的重启策略（RestartPolicy）应用与Pod内所有容器，并且仅在Pod所处的Node上由kubelet进行判断和重启操作。当某个容器异常退出或者健康检查失败时，kubelet将根据RestartPolicy的设置来进行相应的操作。</strong></p><blockquote><p><strong>Always：</strong>（默认情况下使用）但凡Pod对象终止就将其重启；<br>**OnFailure：**仅在Pod对象出现错误时才将其重启；<br>**Never：**从不重启；</p></blockquote><h1>五，pod的默认健康检查</h1><p><strong>每个容器启动时都会执行一个进程，此进程由 Dockerfile 的 CMD 或 ENTRYPOINT 指定。如果进程退出时返回码非零，则认为容器发生故障，Kubernetes 就会根据 <code>restartPolicy</code> 重启容器。</strong></p><h2 id="（1）编写健康检查的yaml文件">（1）编写健康检查的yaml文件</h2><p><strong>下面我们模拟一个容器发生故障的场景，Pod 配置文件如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim healcheck.yaml <br>apiVersion: v1<br>kind: Pod<br>metadata:<br>  labels:<br>    test: healcheck<br>  name:  healcheck<br>spec:<br>  restartPolicy: OnFailure  #指定重启策略<br>  containers:<br>  - name:  healcheck<br>    image: busybox:latest<br>    args:                   #生成pod时运行的命令<br>    - /bin/sh<br>    - -c<br>    - sleep 20; exit 1<br></code></pre></td></tr></table></figure><h3 id="1-执行一下-2">&lt;1&gt;执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f  healcheck.yaml<br></code></pre></td></tr></table></figure><h3 id="2-查看一下-2">&lt;2&gt;查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109121809350.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109121809350.png" alt="image-20200109121809350"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -w | grep healcheck<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109121817775.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109121817775.png" alt="image-20200109121817775"></a></p><p><strong>在上面的例子中，容器进程返回值非零，Kubernetes 则认为容器发生故障，需要重启。但有不少情况是发生了故障，但进程并不会退出。</strong></p><h1>六，小实验</h1><h2 id="1）以自己的名称创建一个k8s名称空间，以下所有操作都在此名称空间中。">1）以自己的名称创建一个k8s名称空间，以下所有操作都在此名称空间中。</h2><h3 id="（1）创建名称空间">（1）创建名称空间</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl create ns xgp<br></code></pre></td></tr></table></figure><h3 id="（2）查看一下-3">（2）查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get ns xgp<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109133106300.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109133106300.png" alt="image-20200109133106300"></a></p><h2 id="2）创建一个Pod资源对象，使用的是私有仓库中私有镜像，其镜像的下载策略为：NEVER。-Pod的重启策略为：-Never">2）创建一个Pod资源对象，使用的是私有仓库中私有镜像，其镜像的下载策略为：NEVER。 Pod的重启策略为： Never.</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim pod.yaml<br>kind: Pod<br>apiVersion: v1<br>metadata:<br>  name: test-pod<br>  namespace: xgp<br>  labels:<br>    app: test-web<br>spec:<br>  restartPolicy: Never<br>  containers:<br>  - name: www<br>    image: 192.168.1.21:5000/web:v1<br>    imagePullPolicy: Never<br>    args:                   <br>    - /bin/sh<br>    - -c<br>    - sleep 90; exit 1<br>    ports:<br>    - protocol: TCP<br>      containerPort: 80<br></code></pre></td></tr></table></figure><h2 id="3）创建出容器之后，执行非正常退出，查看Pod的最终状态。">3）创建出容器之后，执行非正常退出，查看Pod的最终状态。</h2><h3 id="（1）执行一下上面pod的yaml文件">（1）执行一下上面pod的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f pod.yaml<br></code></pre></td></tr></table></figure><h3 id="（2）动态查看ns中test-pod的信息">（2）动态查看ns中test-pod的信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -n xgp  -w | grep test-pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109135543482.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109135543482.png" alt="image-20200109135543482"></a></p><blockquote><p><strong>删除test-pod</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl delete pod -n xgp test-pod <br></code></pre></td></tr></table></figure></blockquote><h2 id="4-创建一个Service资源对象，与上述Pod对象关联，验证他们的关联性。">4) 创建一个Service资源对象，与上述Pod对象关联，验证他们的关联性。</h2><h3 id="（1）修改pod的yaml文件-2">（1）修改pod的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim pod.yaml<br>kind: Pod<br>apiVersion: v1<br>metadata:<br>  name: test-pod<br>  namespace: xgp<br>  labels:<br>    app: test-web<br>spec:<br>  restartPolicy: Never<br>  containers:<br>  - name: www<br>    image: 192.168.1.21:5000/web:v1<br>    imagePullPolicy: Never<br>    ports:<br>    - protocol: TCP<br>      containerPort: 80<br></code></pre></td></tr></table></figure><h3 id="（1）编写service的yaml文件">（1）编写service的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim svc.yaml <br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: test-svc<br>  namespace: xgp<br>spec:<br>  selector:<br>    app: test-web<br>  ports:<br>  - port: 80<br>    targetPort: 80<br></code></pre></td></tr></table></figure><h3 id="（2）执行一下">（2）执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f svc.yaml<br></code></pre></td></tr></table></figure><h3 id="（3）查看一下">（3）查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get  pod -o wide -n xgp<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109141712910.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109141712910.png" alt="image-20200109141712910"></a></p><h3 id="（4）访问一下">（4）访问一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# curl 10.244.1.21<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200109141749352.png" alt="image-20200109141749352"></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Namespace </tag>
            
            <tag> PodRestart </tag>
            
            <tag> Policy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s创建资源(3)（负载均衡原理，回滚指定版本，label控制pod的位置）</title>
      <link href="/posts/c3bf.html"/>
      <url>/posts/c3bf.html</url>
      
        <content type="html"><![CDATA[<h1>Deployment介绍</h1><p><strong>Deployment是kubernetes 1.2引入的概念，用来解决Pod的编排问题。Deployment可以理解为RC的升级版（RC+Reolicat Set）。特点在于可以随时知道Pod的部署进度，即对Pod的创建、调度、绑定节点、启动容器完整过程的进度展示。</strong></p><h2 id="使用场景">使用场景</h2><blockquote><p>创建一个Deployment对象来生成对应的Replica Set并完成Pod副本的创建过程。<br>检查Deployment的状态来确认部署动作是否完成（Pod副本的数量是否达到预期值）。<br>更新Deployment以创建新的Pod(例如镜像升级的场景)。<br>如果当前Deployment不稳定，回退到上一个Deployment版本。<br>挂起或恢复一个Deployment。</p></blockquote><h1>Service介绍</h1><p><a href="https://img-blog.csdn.net/20170809212910268?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" target="_blank" rel="noopener"><img src="https://img-blog.csdn.net/20170809212910268?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV3aF8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></a></p><p><strong>Service定义了一个服务的访问入口地址，前端应用通过这个入口地址访问其背后的一组由Pod副本组成的集群实例，Service与其后端的Pod副本集群之间是通过Label Selector来实现“无缝对接”。RC保证Service的Pod副本实例数目保持预期水平。</strong></p><h2 id="外部系统访问Service的问题">外部系统访问Service的问题</h2><table><thead><tr><th style="text-align:left">IP类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Node IP</td><td style="text-align:left">Node节点的IP地址</td></tr><tr><td style="text-align:left">Pod IP</td><td style="text-align:left">Pod的IP地址</td></tr><tr><td style="text-align:left">Cluster IP</td><td style="text-align:left">Service的IP地址</td></tr></tbody></table><h1>环境介绍</h1><table><thead><tr><th>主机</th><th>IP地址</th><th>服务</th></tr></thead><tbody><tr><td><strong>master</strong></td><td><strong>192.168.1.21</strong></td><td><strong>k8s</strong></td></tr><tr><td><strong>node01</strong></td><td><strong>192.168.1.22</strong></td><td><strong>k8s</strong></td></tr><tr><td><strong>node02</strong></td><td><strong>192.168.1.23</strong></td><td><strong>k8s</strong></td></tr></tbody></table><h1>一，Delpoyment和service的简单使用</h1><h2 id="1-练习写一个yaml文件，要求使用自己的私有镜像，要求副本数量为三个。">1.练习写一个yaml文件，要求使用自己的私有镜像，要求副本数量为三个。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim xgp.yaml<br>kind: Deployment<br>apiVersion: extensions/v1beta1<br>metadata:<br>  name: xgp-web<br>spec:<br>  replicas: 3<br>  template:<br>    metadata:<br>      labels:<br>        app: xgp-server<br>    spec:<br>      containers:<br>      - name: web<br>        image: 192.168.1.21:5000/web:v1<br></code></pre></td></tr></table></figure><h3 id="（1）执行一下">（1）执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f xgp.yaml  --recore<br></code></pre></td></tr></table></figure><h3 id="（2）查看一下">（2）查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108090638488.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108090638488.png" alt="image-20200108090638488"></a></p><h3 id="（3）访问一下">（3）访问一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# curl 10.244.2.16<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108090817058.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108090817058.png" alt="image-20200108090817058"></a></p><h3 id="（4）更新一下yaml文件，副本加一">（4）更新一下yaml文件，副本加一</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim xgp.yaml<br>kind: Deployment<br>apiVersion: extensions/v1beta1<br>metadata:<br>  name: xgp-web<br>spec:<br>  replicas: 4<br>  template:<br>    metadata:<br>      labels:<br>        app: xgp-server<br>    spec:<br>      containers:<br>      - name: web<br>        image: 192.168.1.21:5000/web:v1<br></code></pre></td></tr></table></figure><h4 id="1-执行一下">&lt;1&gt;执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f xgp.yaml --recore<br></code></pre></td></tr></table></figure><h4 id="2-查看一下">&lt;2&gt;查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108091104534.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108091104534.png" alt="image-20200108091104534"></a></p><p><em><strong>副本数量加一，如果yaml文件的副本为0，则副本数量还是之前的状态，并不会更新。</strong></em></p><h2 id="2-练习写一个service文件">2.练习写一个service文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim xgp-svc.yaml<br>kind: Service<br>apiVersion: v1<br>metadata:<br>  name: xgp-svc<br>spec:<br>  selector:<br>    app: xgp-server<br>  ports:<br>    - protocol: TCP<br>      port: 80<br>      targetPort: 80<br></code></pre></td></tr></table></figure><h3 id="（1）执行一下-2">（1）执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f xgp-svc.yaml<br></code></pre></td></tr></table></figure><h3 id="（2）查看一下-2">（2）查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get svc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108091909396.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108091909396.png" alt="image-20200108091909396"></a></p><h3 id="（3）访问一下-2">（3）访问一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# curl 10.107.119.49<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108092011164.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108092011164.png" alt="image-20200108092011164"></a></p><h2 id="3-修改yaml文件">3.修改yaml文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim xgp.yaml <br>kind: Deployment<br>apiVersion: extensions/v1beta1<br>metadata:<br>  name: xgp-web<br>spec:<br>  replicas: 3<br>  template:<br>    metadata:<br>      labels:<br>        app: xgp-server<br>    spec:<br>      containers:<br>      - name: web<br>        image: 192.168.1.21:5000/web:v1<br>        ports:<br>          - containerPort: 80  #提示端口<br></code></pre></td></tr></table></figure><p><em><strong>注意：在Delpoyment资源对象中，可以添加Port字段，但此字段仅供用户查看，并不实际生效</strong></em></p><h3 id="执行一下">执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f xgp.yaml --recore<br></code></pre></td></tr></table></figure><h2 id="4-service文件映射端口">4.service文件映射端口</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim xgp-svc.yaml <br>kind: Service<br>apiVersion: v1<br>metadata:<br>  name: xgp-svc<br>spec:<br>  type: NodePort<br>  selector:<br>    app: xgp-server<br>  ports:<br>    - protocol: TCP<br>      port: 80<br>      targetPort: 80<br>      nodePort: 30123<br></code></pre></td></tr></table></figure><h3 id="执行一下-2">执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f xgp-svc.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get svc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108094404773.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108094404773.png" alt="image-20200108094404773"></a></p><h3 id="访问一下">访问一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# curl 127.0.0.1:30123<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108094439682.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108094439682.png" alt="image-20200108094439682"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108094501253.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108094501253.png" alt="image-20200108094501253"></a></p><h2 id="5-修改三个pod页面内容">5.修改三个pod页面内容</h2><h3 id="（1）查看一下pod信息">（1）查看一下pod信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108094953119.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108094953119.png" alt="image-20200108094953119"></a></p><h3 id="（2）修改POD页面内容（三台不一样）">（2）修改POD页面内容（三台不一样）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl exec -it xgp-web-8d5f9656f-8z7d9 /bin/bash<br>//根据pod名称进入pod之中<br></code></pre></td></tr></table></figure><h3 id="进入容器后修改页面内容">进入容器后修改页面内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@xgp-web-8d5f9656f-8z7d9:/usr/local/apache2# echo xgp-v1 &gt; htdocs/index.html <br>root@xgp-web-8d5f9656f-8z7d9:/usr/local/apache2# exit<br></code></pre></td></tr></table></figure><h3 id="访问一下-2">访问一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# curl 127.0.0.1:30123<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108095626532.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108095626532.png" alt="image-20200108095626532"></a></p><h1>二.分析一下k8s负载均衡原理</h1><h3 id="（1）查看service的暴露IP">（1）查看service的暴露IP</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get svc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108101539835.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108101539835.png" alt="image-20200108101539835"></a></p><h3 id="（2）查看一下iptabes规则">（2）查看一下iptabes规则</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# iptables-save <br>//查看已配置的规则<br></code></pre></td></tr></table></figure><blockquote><p>SNAT：Source NAT（源地址转换）</p><p>DNAT：Destination NAT（目标地址转换）</p><p>MASQ：动态的源地址转换</p></blockquote><h3 id="（3）根据service的暴露IP，查看对应的iptabes规则">（3）根据service的暴露IP，查看对应的iptabes规则</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# iptables-save | grep 10.107.119.49<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108101726315.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108101726315.png" alt="image-20200108101726315"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# iptables-save | grep KUBE-SVC-ESI7C72YHAUGMG5S<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108102003596.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108102003596.png" alt="image-20200108102003596"></a></p><h3 id="（4）对应一下IP是否一致">（4）对应一下IP是否一致</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# iptables-save | grep KUBE-SEP-ZHDQ73ZKUBMELLJB<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108102137062.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108102137062.png" alt="image-20200108102137062"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108102203144.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108102203144.png" alt="image-20200108102203144"></a></p><p><strong>Service实现的负载均衡：默认使用的是iptables规则。IPVS</strong></p><h1>三.回滚到指定版本</h1><h3 id="（1）删除之前创建的delpoy和service">（1）删除之前创建的delpoy和service</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl  delete -f xgp.yaml <br>[root@master ~]# kubectl  delete -f xgp-svc.yaml<br></code></pre></td></tr></table></figure><h3 id="（2）准备三个版本所使用的私有镜像，来模拟每次升级不同的镜像">（2）准备三个版本所使用的私有镜像，来模拟每次升级不同的镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim xgp1.yaml  （三个文件名不相同）<br>kind: Deployment<br>apiVersion: extensions/v1beta1<br>metadata:<br>  name: xgp-web<br>spec:<br>  revisionHistoryLimit: 10<br>  replicas: 3<br>  template:<br>    metadata:<br>      labels:<br>        app: xgp-server<br>    spec:<br>      containers:<br>      - name: web<br>        image: 192.168.1.21:5000/web:v1  （三台版本不同）<br>        ports:<br>          - containerPort: 80<br></code></pre></td></tr></table></figure><p>此处3个yaml文件 指定不同版本的镜像</p><h3 id="（3）运行三个服务，并记录三个版本信息">（3）运行三个服务，并记录三个版本信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f xgp-1.yaml --record <br>[root@master ~]# kubectl apply -f xgp-2.yaml --record <br>[root@master ~]# kubectl apply -f xgp-3.yaml --record<br></code></pre></td></tr></table></figure><h3 id="（4）查看有哪些版本信息">（4）查看有哪些版本信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl rollout history deployment xgp-web<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108105842447.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108105842447.png" alt="image-20200108105842447"></a></p><h3 id="（5）运行之前的service文件">（5）运行之前的service文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f xgp-svc.yaml<br></code></pre></td></tr></table></figure><h3 id="（6）查看service暴露端口">（6）查看service暴露端口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get svc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108110014614.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108110014614.png" alt="image-20200108110014614"></a></p><h3 id="（7）测试访问">（7）测试访问</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# curl 127.0.0.1:30123<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108110049396.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108110049396.png" alt="image-20200108110049396"></a></p><h3 id="（8）回滚到指定版本">（8）回滚到指定版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl rollout undo deployment xgp-web --to-revision=1<br>//这里指定的是版本信息的编号<br></code></pre></td></tr></table></figure><h4 id="1-访问一下">&lt;1&gt;访问一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# curl 127.0.0.1:30123<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108110337266.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108110337266.png" alt="image-20200108110337266"></a></p><h4 id="2-查看有哪些版本信息">&lt;2&gt;查看有哪些版本信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl rollout history deployment xgp-web<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108110443558.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108110443558.png" alt="image-20200108110443558"></a></p><p><em><strong>编号1已经被编号2替代，从而生的是一个新的编号4</strong></em></p><h1>四.用label控制pod的位置</h1><blockquote><p>默认情况下，scheduler会将pod调度到所有可用的Node，不过有些情况我们希望将 Pod 部署到指定的 Node，比如将有大量磁盘 I/O 的 Pod 部署到配置了 SSD 的 Node；或者 Pod 需要 GPU，需要运行在配置了 GPU 的节点上。</p><p>kubernetes通过label来实现这个功能</p><p>label 是 key-value 对，各种资源都可以设置 label，灵活添加各种<strong>自定义属性</strong>。比如执行如下命令标注 k8s-node1 是配置了 SSD 的节点</p></blockquote><h4 id="首先我们给node1节点打上一个ssd的标签">首先我们给node1节点打上一个ssd的标签</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl label nodes node02 disk=ssd<br></code></pre></td></tr></table></figure><h3 id="（1）查看标签">（1）查看标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get nodes --show-labels | grep node02<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108111354832.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108111354832.png" alt="image-20200108111354832"></a></p><h3 id="（2）删除副本一">（2）删除副本一</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl delete -f xgp-1.yaml <br>deployment.extensions "xgp-web" deleted<br>[root@master ~]# kubectl delete svc xgp-svc<br></code></pre></td></tr></table></figure><h3 id="（3）修改副本一的yaml文件">（3）修改副本一的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim xgp-1.yaml <br><br>kind: Deployment<br>apiVersion: extensions/v1beta1<br>metadata:<br>  name: xgp-web<br>spec:<br>  revisionHistoryLimit: 10<br>  replicas: 3<br>  template:<br>    metadata:<br>      labels:<br>        app: xgp-server<br>    spec:<br>      containers:<br>      - name: web<br>        image: 192.168.1.21:5000/web:v1<br>        ports:<br>          - containerPort: 80<br>      nodeSelector:    #添加节点选择器<br>        disk: ssd      #和标签内容一致<br></code></pre></td></tr></table></figure><h3 id="（4）执行一下">（4）执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f xgp-1.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-2">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108112059395.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108112059395.png" alt="image-20200108112059395"></a></p><p><em><strong>现在pod都在node02上运行</strong></em></p><h3 id="（5）删除标签">（5）删除标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl  label nodes node02 disk-<br></code></pre></td></tr></table></figure><h4 id="查看一下-3">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get nodes --show-labels | grep node02<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108112245347.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108112245347.png" alt="image-20200108112245347"></a></p><p><em><strong>没有disk标签了</strong></em></p><h1>五，小实验</h1><h3 id="1）使用私有镜像v1版本部署一个Deployment资源对象，要求副本Pod数量为3个，并创建一个Service资源对象相互关联，指定要求3个副本Pod全部运行在node01节点上，记录一个版本。"><strong>1）使用私有镜像v1版本部署一个Deployment资源对象，要求副本Pod数量为3个，并创建一个Service资源对象相互关联，指定要求3个副本Pod全部运行在node01节点上，记录一个版本。</strong></h3><h4 id="（1）用label控制pod的位置">（1）用label控制pod的位置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl label nodes node01 disk=ssd<br></code></pre></td></tr></table></figure><h4 id="（2）编写源yaml文件">（2）编写源yaml文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim xgp.yaml<br>kind: Deployment<br>apiVersion: extensions/v1beta1<br>metadata:<br>  name: xgp-web<br>spec:<br>  replicas: 3<br>  template:<br>    metadata:<br>      labels:<br>        app: xgp-server<br>    spec:<br>      containers:<br>      - name: web<br>        image: 192.168.1.21:5000/web:v1<br>        ports:<br>          - containerPort: 80<br>      nodeSelector:    <br>        disk: ssd<br></code></pre></td></tr></table></figure><h4 id="（3）编写源service文件">（3）编写源service文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim xgp-svc.yaml<br>kind: Service<br>apiVersion: v1<br>metadata:<br>  name: xgp-svc<br>spec:<br>  type: NodePort<br>  selector:<br>    app: xgp-server<br>  ports:<br>    - protocol: TCP<br>      port: 80<br>      targetPort: 80<br>      nodePort: 30123<br></code></pre></td></tr></table></figure><h4 id="（4）执行yaml文件，创建控制器。执行service文件创建映射端口">（4）执行yaml文件，创建控制器。执行service文件创建映射端口</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f  xgp.yaml <br>[root@master ~]# kubectl apply -f xgp-svc.yaml<br></code></pre></td></tr></table></figure><h4 id="（5）查看一下pod节点">（5）查看一下pod节点</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108122424654.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108122424654.png" alt="image-20200108122424654"></a></p><h4 id="（6）记录一个版本">（6）记录一个版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl rollout history deployment xgp-web &gt; pod.txt<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108142016701.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108142016701.png" alt="image-20200108142016701"></a></p><h4 id="（7）访问一下">（7）访问一下</h4><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108122518278.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108122518278.png" alt="image-20200108122518278"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108122534683.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108122534683.png" alt="image-20200108122534683"></a></p><h3 id="2）根据上述Deployment，升级为v2版本，记录一个版本。"><strong>2）根据上述Deployment，升级为v2版本，记录一个版本。</strong></h3><h4 id="（1）修改yaml文件镜像版本">（1）修改yaml文件镜像版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim xgp.yaml <br>kind: Deployment<br>apiVersion: extensions/v1beta1<br>metadata:<br>  name: xgp-web<br>spec:<br>  replicas: 3<br>  template:<br>    metadata:<br>      labels:<br>        app: xgp-server<br>    spec:<br>      containers:<br>      - name: web<br>        image: 192.168.1.21:5000/web:v2    #修改版本为二<br>        ports:<br>          - containerPort: 80<br>      nodeSelector:<br>        disk: ssd<br></code></pre></td></tr></table></figure><h4 id="（2）刷新一下yaml文件">（2）刷新一下yaml文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f xgp.yaml --recore<br></code></pre></td></tr></table></figure><h4 id="（3）访问一下-3">（3）访问一下</h4><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108141825924.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108141825924.png" alt="image-20200108141825924"></a></p><h4 id="（4）记录一个版本">（4）记录一个版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl rollout history deployment xgp-web &gt; pod.txt<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108142030157.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108142030157.png" alt="image-20200108142030157"></a></p><h3 id="3）最后升级到v3版本，这时，查看Service关联，并且分析访问流量的负载均衡详细情况。"><strong>3）最后升级到v3版本，这时，查看Service关联，并且分析访问流量的负载均衡详细情况。</strong></h3><h4 id="1）修改yaml文件镜像版本">1）修改yaml文件镜像版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim xgp.yaml <br>kind: Deployment<br>apiVersion: extensions/v1beta1<br>metadata:<br>  name: xgp-web<br>spec:<br>  replicas: 3<br>  template:<br>    metadata:<br>      labels:<br>        app: xgp-server<br>    spec:<br>      containers:<br>      - name: web<br>        image: 192.168.1.21:5000/web:v3   #修改版本为二<br>        ports:<br>          - containerPort: 80<br>      nodeSelector:<br>        disk: ssd<br></code></pre></td></tr></table></figure><h4 id="（2）刷新一下yaml文件-2">（2）刷新一下yaml文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f xgp.yaml --recore<br></code></pre></td></tr></table></figure><h4 id="（3）访问一下-4">（3）访问一下</h4><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108142329749.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108142329749.png" alt="image-20200108142329749"></a></p><h4 id="（5）分析访问流量的负载均衡详细情况">（5）分析访问流量的负载均衡详细情况</h4><h5 id="1-查看一下service映射端口">&lt;1&gt;查看一下service映射端口</h5><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108142504637.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108142504637.png" alt="image-20200108142504637"></a></p><h5 id="2-以ip为起点，分析访问流量的负载均衡详细情况">&lt;2&gt;以ip为起点，分析访问流量的负载均衡详细情况</h5><p><strong>Service实现的负载均衡：默认使用的是iptables规则。IPVS</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# iptables-save | grep 10.107.27.229<br>//根据service的暴露IP，查看对应的iptabes规则<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108143052433.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108143052433.png" alt="image-20200108143052433"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# iptables-save | grep KUBE-SVC-ESI7C72YHAUGMG5S<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108143359463.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108143359463.png" alt="image-20200108143359463"></a></p><p><em><strong>这里显示了各节点的负载比例</strong></em></p><h5 id="3-对应一下IP是否一致">&lt;3&gt;对应一下IP是否一致</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# iptables-save | grep KUBE-SEP-VDKW5WQIWOLZMJ6G<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108143547946.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108143547946.png" alt="image-20200108143547946"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108143608942.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108143608942.png" alt="image-20200108143608942"></a></p><h3 id="4）回滚到指定版本v1，并作验证。"><strong>4）回滚到指定版本v1，并作验证。</strong></h3><h4 id="1-回滚到指定版本">&lt;1&gt;回滚到指定版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl rollout undo deployment xgp-web --to-revision=1<br>//这里指定的是版本信息的编号<br></code></pre></td></tr></table></figure><h4 id="2-访问一下">&lt;2&gt;访问一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# curl 127.0.0.1:30123<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108110337266.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200108110337266.png" alt="image-20200108110337266"></a></p><blockquote><p><strong>排错思路</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# less /var/log/messages  | grep kubelet<br>[root@master ~]# kubectl  logs -n  kube-system kube-scheduler-master <br>[root@master ~]# kubectl describe pod xgp-web-7d478f5bb7-bd4bj <br></code></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> service </tag>
            
            <tag> Deployment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s创建资源(2)&lt;基于配置清单&gt;</title>
      <link href="/posts/9569.html"/>
      <url>/posts/9569.html</url>
      
        <content type="html"><![CDATA[<h1>一，两种创建资源的方法</h1><h2 id="1-基于命令的方式：">1. 基于命令的方式：</h2><ol><li><strong>简单直观快捷，上手快。</strong></li><li><strong>适合临时测试或实验。</strong></li></ol><h2 id="2-基于配置清单的方式：">2. 基于配置清单的方式：</h2><ol><li><strong>配置文件描述了 <code>What</code>，即应用最终要达到的状态。</strong></li><li><strong>配置文件提供了创建资源的模板，能够重复部署。</strong></li><li><strong>可以像管理代码一样管理部署。</strong></li><li><strong>适合正式的、跨环境的、规模化部署。</strong></li><li><strong>这种方式要求熟悉配置文件的语法，有一定难度。</strong></li></ol><h2 id="环境介绍">环境介绍</h2><table><thead><tr><th>主机</th><th>IP地址</th><th>服务</th></tr></thead><tbody><tr><td>master</td><td>192.168.1.21</td><td>k8s</td></tr><tr><td>node01</td><td>192.168.1.22</td><td>k8s</td></tr><tr><td>node02</td><td>192.168.1.23</td><td>k8s</td></tr></tbody></table><h1>二. 配置清单（yam，yaml）</h1><p><strong>在k8s中，一般使用yaml格式的文件来创建符合我们预期期望的pod，这样的yaml文件我们一般称为资源清单</strong></p><blockquote><p><strong>/etc/kubernetes/manifests/</strong> k8s存放（yam、yaml）文件的地方</p><p><strong>kubectl explain deployment（通过explain参数加上资源类别就能看到该资源应该怎么定义）</strong></p><p><strong>kubectl explain deployment.metadata</strong> 通过资源类别加上带有Object标记的字段，我们就可以看到一级字段下二级字段的内容有那些怎么去定义等</p><p><strong>kubectl explain deployment.metadata.ownerReferences</strong> 通过加上不同级别的字段名称来看下字段下的内容，而且前面的[]号代表对象列表</p></blockquote><h2 id="1-常见yaml文件写法，以及字段的作用">1.常见yaml文件写法，以及字段的作用</h2><p><strong>(1) apiVersion：api版本信息</strong></p><p><em><strong>（用来定义当前属于哪个组和那个版本，这个直接关系到最终提供使用的是那个版本）</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master manifests]# kubectl api-versions<br>//查看到当前所有api的版本<br></code></pre></td></tr></table></figure><p><strong>(2) kind: 资源对象的类别</strong></p><p><em><strong>(用来定义创建的对象是属于什么类别，是pod，service，还是deployment等对象，可以按照其固定的语法格式来自定义。)</strong></em><br><strong>(3) metadata: 元数据 名称字段（必写）</strong></p><blockquote><p><strong>提供以下几个字段</strong>：<br>　　<strong>creationTimestamp: &quot;2019-06-24T12:18:48Z&quot;</strong><br>　　<strong>generateName: myweb-5b59c8b9d-</strong><br>　　<strong>labels: （对象标签）</strong><br>　　　　<strong>pod-template-hash: 5b59c8b9d</strong><br>　　　　<strong>run: myweb</strong><br>　　<strong>name: myweb-5b59c8b9d-gwzz5 （pods对象的名称，同一个类别当中的pod对象名称是唯一的，不能重复）</strong><br>　　<strong>namespace: default （对象所属的名称空间，同一名称空间内可以重复，这个名称空间也是k8s级别的名称空间，不和容器的名称空间混淆）</strong><br>　　<strong>ownerReferences:</strong></p><p>- <strong>apiVersion: apps/v1</strong><br>　　　　<strong>blockOwnerDeletion: true</strong><br>　　　　<strong>controller: true</strong><br>　　　　<strong>kind: ReplicaSet</strong><br>　　　　<strong>name: myweb-5b59c8b9d</strong><br>　　　　<strong>uid: 37f38f64-967a-11e9-8b4b-000c291028e5</strong><br>　　<strong>resourceVersion: &quot;943&quot;</strong><br>　　<strong>selfLink: /api/v1/namespaces/default/pods/myweb-5b59c8b9d-gwzz5</strong><br>　　<strong>uid: 37f653a6-967a-11e9-8b4b-000c291028e5</strong><br>　　<strong>annotations（资源注解，这个需要提前定义，默认是没有的）</strong><br><strong>通过这些标识定义了每个资源引用的path：即/api/group/version/namespaces/名称空间/资源类别/对象名称</strong></p></blockquote><p><strong>(4) spec： 用户期望的状态</strong></p><p><em><strong>（这个字段最重要，因为spec是用来定义目标状态的‘disired state’，而且资源不通导致spec所嵌套的字段也各不相同，也就因为spec重要且字段不相同，k8s在内部自建了一个spec的说明用于查询）</strong></em></p><p><strong>(5) status：资源现在处于什么样的状态</strong></p><p><em><strong>（当前状态，’current state‘，这个字段有k8s集群来生成和维护，不能自定义，属于一个只读字段）</strong></em></p><h2 id="2-编写一个yaml文件">2.编写一个yaml文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim web.yaml<br>kind: Deployment  #资源对象是控制器<br>apiVersion: extensions/v1beta1   #api的版本<br>metadata:      #描述kind（资源类型）<br>  name: web   #定义控制器名称<br>spec:<br>  replicas: 2   #副本数量<br>  template:     #模板<br>    metadata:    <br>      labels:   #标签<br>        app: web_server<br>    spec:<br>      containers:   #指定容器<br>      - name: nginx  #容器名称<br>        image: nginx   #使用的镜像<br></code></pre></td></tr></table></figure><h3 id="执行一下">执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f web.yaml<br></code></pre></td></tr></table></figure><h3 id="查看一下">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get deployments.  -o wide<br>//查看控制器信息<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107100450262.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107100450262.png" alt="image-20200107100450262"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -o wide<br>//查看pod节点信息<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107101803209.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107101803209.png" alt="image-20200107101803209"></a></p><h2 id="3-编写一个service-yaml文件">3.编写一个service.yaml文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim web-svc.yaml<br>kind: Service  #资源对象是副本<br>apiVersion: v1   #api的版本<br>metadata:<br>  name: web-svc<br>spec:<br>  selector:     #标签选择器<br>    app: web-server  #须和web.yaml的标签一致<br>  ports:              #端口<br>  - protocol: TCP<br>    port: 80            #宿主机的端口<br>    targetPort: 80      #容器的端口<br></code></pre></td></tr></table></figure><blockquote><p><strong>使用相同标签和标签选择器内容，使两个资源对象相互关联。</strong></p><p><strong>创建的service资源对象，默认的type为ClusterIP，意味着集群内任意节点都可访问。它的作用是为后端真正服务的pod提供一个统一的接口。如果想要外网能够访问服务，应该把type改为NodePort</strong></p></blockquote><h3 id="（1）执行一下">（1）执行一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f web-svc.yaml<br></code></pre></td></tr></table></figure><h3 id="（2）查看一下">（2）查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get svc<br>//查看控制器信息<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107110717972.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107110717972.png" alt="image-20200107110717972"></a></p><h3 id="（3）访问一下">（3）访问一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# curl 10.111.193.168<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107110837353.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107110837353.png" alt="image-20200107110837353"></a></p><h2 id="4-外网能够访问服务">4.外网能够访问服务</h2><h3 id="（1）修改web-svc-yaml文件">（1）修改web-svc.yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">kind: Service  #资源对象是副本<br>apiVersion: v1   #api的版本<br>metadata:<br>  name: web-svc<br>spec:<br>  type: NodePort    #添加 更改网络类型<br>  selector:     #标签选择器<br>    app: web_server  #须和web.yaml的标签一致<br>  ports:              #端口<br>  - protocol: TCP<br>    port: 80            #宿主机的端口<br>    targetPort: 80      #容器的端口<br>    nodePort: 30086     #指定群集映射端口，范围是30000-32767<br></code></pre></td></tr></table></figure><h3 id="（2）刷新一下">（2）刷新一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]#  kubectl apply -f web-svc.yaml<br></code></pre></td></tr></table></figure><h3 id="（3）查看一下">（3）查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get svc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107111338940.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107111338940.png" alt="image-20200107111338940"></a></p><h3 id="（4）浏览器测试">（4）浏览器测试</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107111451952.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107111451952.png" alt="image-20200107111451952"></a></p><h1>三、小实验</h1><blockquote><p><strong>基于上一篇博客实验继续进行</strong></p></blockquote><h3 id="1-使用yaml文件的方式创建一个Deployment资源对象，要求镜像使用个人私有镜像v1版本。replicas为3个。">1.使用yaml文件的方式创建一个Deployment资源对象，要求镜像使用个人私有镜像v1版本。replicas为3个。</h3><h3 id="编写yaml文件">编写yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim www.yaml<br>kind: Deployment<br>apiVersion: extensions/v1beta1<br>metadata:<br>  name: xgp<br>spec:<br>  replicas: 3<br>  template:<br>    metadata:<br>      labels:<br>        app: www_server<br>    spec:<br>      containers:<br>      - name: web<br>        image: 192.168.1.21:5000/web:v1<br></code></pre></td></tr></table></figure><h4 id="（1）执行一下-2">（1）执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f web-svc.yaml<br></code></pre></td></tr></table></figure><h4 id="（2）查看一下-2">（2）查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get deployments. -o wide<br>//查看控制器信息<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107120901208.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107120901208.png" alt="image-20200107120901208"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -o wide<br>//查看pod节点信息<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107121002152.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107121002152.png" alt="image-20200107121002152"></a></p><h4 id="（3）访问一下-2">（3）访问一下</h4><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107121147669.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107121147669.png" alt="image-20200107121147669"></a></p><h3 id="2-使用yaml文件的方式创建一个Service资源对象，要与上述Deployment资源对象关联，type类型为：-NodePort，端口为-30123"><strong>2.</strong> 使用yaml文件的方式创建一个Service资源对象，要与上述Deployment资源对象关联，type类型为： NodePort，端口为:30123.</h3><h4 id="编写service文件">编写service文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim www-svc.yaml<br>kind: Service<br>apiVersion: v1<br>metadata:<br>  name: www-svc<br>spec:<br>  type: NodePort<br>  selector:<br>    app: www_server<br>  ports:<br>  - protocol: TCP<br>    port: 80<br>    targetPort: 80<br>    nodePort: 30123<br></code></pre></td></tr></table></figure><h4 id="执行一下-2">执行一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f www-svc.yaml<br></code></pre></td></tr></table></figure><h4 id="查看一下-2">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get svc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107121929525.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107121929525.png" alt="image-20200107121929525"></a></p><h4 id="访问一下">访问一下</h4><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107122015559.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200107122015559.png" alt="image-20200107122015559"></a></p><h1>四. 总结</h1><h2 id="1-Pod的作用"><strong>1. Pod的作用</strong></h2><blockquote><p>在k8s中pod是最小的管理单位，在一个pod中通常会包含一个或多个容器。大多数情况下，一个Pod内只有一个Container容器。<br>在每一个Pod中都有一个特殊的Pause容器和一个或多个业务容器，Pause来源于pause-amd64镜像,Pause容器在Pod中具有非常重要的作用：</p><ul><li>Pause容器作为Pod容器的根容器，其本地于业务容器无关，它的状态代表了整个pod的状态。</li><li>Pod里的多个业务容器共享Pause容器的IP，每个Pod被分配一个独立的IP地址，Pod中的每个容器共享网络命名空间，包括IP地址和网络端口。Pod内的容器可以使用localhost相互通信。k8s支持底层网络集群内任意两个Pod之间进行通信。</li><li>Pod中的所有容器都可以访问共享volumes，允许这些容器共享数据。volumes还用于Pod中的数据持久化，以防其中一个容器需要重新启动而丢失数据。</li></ul></blockquote><h2 id="2-Service的作用"><strong>2. Service的作用</strong></h2><p><strong>Service 是后端真实服务的抽象，一个 Service 可以代表多个相同的后端服务</strong></p><p><strong>Service 为 POD 控制器控制的 POD 集群提供一个固定的访问端点，Service 的工作还依赖于 K8s 中的一个附件，就是 CoreDNS ，它将 Service 地址提供一个域名解析。</strong></p><h3 id="NodePort-类型的-service">NodePort 类型的 service</h3><blockquote><p><strong>clusterIP</strong>：指定 Service 处于 service 网络的哪个 IP，默认为动态分配</p><p><strong>NodePort 是在 ClusterIP 类型上增加了一个暴露在了 node 的网络命名空间上的一个 nodePort，所以用户可以从集群外部访问到集群了，因而用户的请求流程是：Client -&gt; NodeIP:NodePort -&gt; ClusterIP:ServicePort -&gt; PodIP:ContainerPort。</strong></p><p><strong>可以理解为 NodePort 增强了 ClusterIP 的功能，让客户端可以在每个集群外部访问任意一个 nodeip 从而访问到 clusterIP，再由 clusterIP 进行负载均衡至 POD。</strong></p></blockquote><h2 id="3-流量走向">3.流量走向</h2><p><strong>我们在创建完成一个服务之后，用户首先应该访问的是nginx反向代理的ip，然后通过nginx访问到后端的k8s服务器（master节点）的“NodePort暴露IP 及 映射的端口“，master的apiserver接受到客户端发送来的访问指令，将访问指令通知Controller Manager控制器，Scheduler执行调度任务，将访问指令分发到各节点之上，通过”master节点“的“ip+映射端口”访问到后端k8s节点的信息，节点的Kubelet（pod代理）当Scheduler确定让那个节点返回访问信息之后，kube-proxy将访问信息负载均衡到该节点的容器上，各容器返回信息，并向Master报告运行状态</strong></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> service </tag>
            
            <tag> yaml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s创建资源(1)、&lt;扩容与缩容&gt;和&lt;升级与回滚&gt;</title>
      <link href="/posts/dbea.html"/>
      <url>/posts/dbea.html</url>
      
        <content type="html"><![CDATA[<h1>两种创建资源的方法</h1><h2 id="基于命令的方式：">基于命令的方式：</h2><ol><li><strong>简单直观快捷，上手快。</strong></li><li><strong>适合临时测试或实验。</strong></li></ol><h2 id="基于配置文件的方式：">基于配置文件的方式：</h2><ol><li><strong>配置文件描述了 <code>What</code>，即应用最终要达到的状态。</strong></li><li><strong>配置文件提供了创建资源的模板，能够重复部署。</strong></li><li><strong>可以像管理代码一样管理部署。</strong></li><li><strong>适合正式的、跨环境的、规模化部署。</strong></li><li><strong>这种方式要求熟悉配置文件的语法，有一定难度。</strong></li></ol><h1>一，用命令行的方式创建资源</h1><table><thead><tr><th>主机</th><th>IP地址</th></tr></thead><tbody><tr><td>master</td><td>192.168.1.21</td></tr><tr><td>node01</td><td>192.168.1.22</td></tr><tr><td>node02</td><td>192.168.1.23</td></tr></tbody></table><h3 id="仅接受json格式"><em>仅接受json格式</em></h3><h2 id="配置清单（yml、yaml）">配置清单（yml、yaml）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# cd /etc/kubernetes/manifests/<br>//k8s的yml、yaml文件<br></code></pre></td></tr></table></figure><h2 id="1-node01和node02下载nginx镜像">1.node01和node02下载nginx镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull nginx<br>//下载nginx镜像<br></code></pre></td></tr></table></figure><h2 id="2-master创建Pod控制器（test-web），deployment">2.master创建Pod控制器（test-web），deployment</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl run test-web --image=nginx --replicas=5<br>//创建Pod控制器，deployment<br></code></pre></td></tr></table></figure><h2 id="3-查看控制器情况">3.查看控制器情况</h2><h3 id="（1）">（1）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get deployments.<br>//查看控制器情况<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106093615852.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106093615852.png" alt="image-20200106093615852"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod --all-namespaces -o wide<br>//显示pod的节点信息<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106093922849.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106093922849.png" alt="image-20200106093922849"></a></p><h3 id="（2）">（2）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get namespaces <br>//查看k8s名称空间<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106093850247.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106093850247.png" alt="image-20200106093850247"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl describe deployments. test-web<br>//查看资源详细信息<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106093723330.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106093723330.png" alt="image-20200106093723330"></a></p><p><em><strong>查看某种资源对象，没有指定名称空间，默认是在default名称空间。可以加上-n选项，查看指定名称空间的资源。</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -n kube-system<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106094343401.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106094343401.png" alt="image-20200106094343401"></a></p><h2 id="3-删除test-web控制器">3.删除test-web控制器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl delete deployments. test-web<br></code></pre></td></tr></table></figure><h2 id="4-master创建Pod控制器（web），deployment">4.master创建Pod控制器（web），deployment</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl run web --image=nginx --replicas=5<br></code></pre></td></tr></table></figure><h3 id="查看一下pod信息">查看一下pod信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -o wide<br>//查看一下pod的节点信息<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106095722353.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106095722353.png" alt="image-20200106095722353"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl describe deployments. web <br>//查看资源详细信息<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106100606861.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106100606861.png" alt="image-20200106100606861"></a></p><p><em><strong>注意：直接运行创建的deployment资源对象，是经常使用的一个控制器资源类型，除了deployment，还有rc、rs等等pod控制器，deployment是一个高级的pod控制器。</strong></em></p><h3 id="本机测试访问nginx">本机测试访问nginx</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# curl 10.244.1.7<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106100827131.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106100827131.png" alt="image-20200106100827131"></a></p><h2 id="5-创建service资源类型">5.创建service资源类型</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl expose deployment web --name=web-xgp --port=80 --type=NodePort<br>//创建service资源类型，这里我们设置了映射端口<br></code></pre></td></tr></table></figure><p><em><strong>如果想要外网能够访问服务，可以暴露deployment资源，得到service资源，但svc资源的类型必须为NodePort。</strong></em></p><p><strong>映射端口范围：30000-32767</strong></p><h3 id="查看service信息">查看service信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get svc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106101443348.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106101443348.png" alt="image-20200106101443348"></a></p><h3 id="浏览器测试访问http-192-168-1-21-30493">浏览器测试访问http://192.168.1.21:30493/</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106101624954.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106101624954.png" alt="image-20200106101624954"></a></p><h1>二、服务的扩容与缩容</h1><h2 id="1-查看控制器信息">1. 查看控制器信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get deployments. -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106104638757.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106104638757.png" alt="image-20200106104638757"></a></p><h2 id="2-扩容">2.扩容</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl scale deployment web --replicas=8<br></code></pre></td></tr></table></figure><h3 id="查看一下">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get deployments. -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106104757123.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106104757123.png" alt="image-20200106104757123"></a></p><h2 id="3-缩容">3.缩容</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl scale deployment web --replicas=4<br></code></pre></td></tr></table></figure><h3 id="查看一下-2">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get deployments. -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106105536316.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106105536316.png" alt="image-20200106105536316"></a></p><h2 id="3-通过修改web的yaml文件进行扩容缩容">3.通过修改web的yaml文件进行扩容缩容</h2><h3 id="备份web的yaml文件">备份web的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get deployments. -o yaml &gt; web.yaml<br></code></pre></td></tr></table></figure><h3 id="使用edit修改web的yaml文件">使用edit修改web的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl edit deployments. web<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106105924531.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106105924531.png" alt="image-20200106105924531"></a></p><h3 id="查看一下-3">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get deployments. -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106105816339.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106105816339.png" alt="image-20200106105816339"></a></p><h1>三、服务的升级与回滚</h1><h2 id="node01和node02下载1-15版本的nginx">node01和node02下载1.15版本的nginx</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# docker pull nginx:1.15<br></code></pre></td></tr></table></figure><h2 id="1-master设置服务升级">1.master设置服务升级</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]#  kubectl set image deployment web web=nginx:1.15<br></code></pre></td></tr></table></figure><h3 id="查看一下-4">查看一下</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106111227960.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106111227960.png" alt="image-20200106111227960"></a></p><h2 id="2-master设置服务回滚">2.master设置服务回滚</h2><h3 id="（1）修改配置文件回滚">（1）修改配置文件回滚</h3><h3 id="使用edit修改web的yaml文件-2">使用edit修改web的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl edit deployments. web<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106111523148.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106111523148.png" alt="image-20200106111523148"></a></p><h3 id="查看一下-5">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get deployments. -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106111319699.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106111319699.png" alt="image-20200106111319699"></a></p><h3 id="（2）命令回滚">（2）命令回滚</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl rollout undo deployment web<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106111733617.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106111733617.png" alt="image-20200106111733617"></a></p><p><em><strong>注意:只能回滚到上一次操作的状态</strong></em></p><h1>四、实验环境</h1><table><thead><tr><th>主机</th><th>IP地址</th><th>服务</th></tr></thead><tbody><tr><td>master</td><td>192.168.1.21</td><td>registry+Deployment</td></tr><tr><td>node01</td><td>192.168.1.22</td><td></td></tr><tr><td>node02</td><td>192.168.1.23</td><td></td></tr></tbody></table><h2 id="1-master-基于httpd制作自己的镜像，需要3个版本，v1-v2-v3-并且对应的版本镜像，访问的主目录内容不一样">1.master 基于httpd制作自己的镜像，需要3个版本，v1,v2,v3.并且对应的版本镜像，访问的主目录内容不一样</h2><h3 id="（1）master下载httpd镜像">（1）master下载httpd镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# docker pull httpd<br></code></pre></td></tr></table></figure><h3 id="（2）编写Dockerfile">（2）编写Dockerfile</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# vim Dockerfile<br>FROM httpd<br>COPY index.html /usr/local/apache2/htdocs/index.html<br></code></pre></td></tr></table></figure><h3 id="（3）创建测试网页v1">（3）创建测试网页v1</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]#echo "&lt;h1&gt;xgp | test-web | httpd:v1&lt;h1&gt;" &gt; index.html<br></code></pre></td></tr></table></figure><h3 id="（4）基于Dockerfile创建镜像-web1">（4）基于Dockerfile创建镜像 web1</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# docker build -t web1 .<br></code></pre></td></tr></table></figure><h3 id="（5）创建测试网页v2">（5）创建测试网页v2</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]#echo "&lt;h1&gt;xgp | test-web | httpd:v1&lt;h1&gt;" &gt; index.html<br></code></pre></td></tr></table></figure><h3 id="（6）基于Dockerfile创建镜像-web2">（6）基于Dockerfile创建镜像 web2</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# docker build -t web2 .<br></code></pre></td></tr></table></figure><h3 id="（7）创建测试网页v3">（7）创建测试网页v3</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# echo "&lt;h1&gt;xgp | test-web | httpd:v3&lt;h1&gt;" &gt; index.html<br></code></pre></td></tr></table></figure><h3 id="（8）基于Dockerfile创建镜像-web3">（8）基于Dockerfile创建镜像 web3</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# docker build -t web3 .<br></code></pre></td></tr></table></figure><h2 id="2-master部署私有仓库">2.master部署私有仓库</h2><h3 id="（1）master下载registry镜像">（1）master下载registry镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# docker pull registry<br></code></pre></td></tr></table></figure><h3 id="（2）启动registry">（2）启动registry</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# docker run -itd --name registry -p 5000:5000 --restart=always registry:latest<br></code></pre></td></tr></table></figure><h3 id="（3）修改docker配置文件，加入私有仓库（三台）">（3）修改docker配置文件，加入私有仓库（三台）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# vim /usr/lib/systemd/system/docker.service<br>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.1.21:5000<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106120848869.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106120848869.png" alt="image-20200106120848869"></a></p><h3 id="（4）重启docker（三台）">（4）重启docker（三台）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# systemctl daemon-reload <br>[root@master xgp]# systemctl restart docker<br></code></pre></td></tr></table></figure><h2 id="3-上传之前创建的三个web镜像到私有仓库">3.上传之前创建的三个web镜像到私有仓库</h2><h3 id="（1）修改镜像标签">（1）修改镜像标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# docker tag web1:latest 192.168.1.21:5000/web1:latest<br>[root@master xgp]# docker tag web2:latest 192.168.1.21:5000/web2:latest<br>[root@master xgp]# docker tag web3:latest 192.168.1.21:5000/web3:latest<br></code></pre></td></tr></table></figure><h3 id="（2）将三个web镜像上传到私有仓库">（2）将三个web镜像上传到私有仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# docker push  192.168.1.21:5000/web1:latest <br>[root@master xgp]# docker push  192.168.1.21:5000/web2:latest<br>[root@master xgp]# docker push  192.168.1.21:5000/web3:latest<br></code></pre></td></tr></table></figure><h2 id="4-部署一个Deployment资源对象，要求镜像使用上述私有镜像v1版本。6个副本Pod。">4.部署一个Deployment资源对象，要求镜像使用上述私有镜像v1版本。6个副本Pod。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# kubectl run www1 --image=192.168.1.21:5000/web1:latest --replicas=6<br></code></pre></td></tr></table></figure><h3 id="查看一下-6">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106122026271.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106122026271.png" alt="image-20200106122026271"></a></p><h3 id="本地访问一下">本地访问一下</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106122426308.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106122426308.png" alt="image-20200106122426308"></a></p><h3 id="5-将上述Deployment暴露一个service资源对象，使外网能否访问服务。">5.将上述Deployment暴露一个service资源对象，使外网能否访问服务。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]#  kubectl expose deployment www1 --name=web-xgp --port=80 --type=NodePort<br></code></pre></td></tr></table></figure><h3 id="查看一下-7">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# kubectl get svc<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106122313996.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106122313996.png" alt="image-20200106122313996"></a></p><h3 id="浏览器访问一下">浏览器访问一下</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106122340747.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106122340747.png" alt="image-20200106122340747"></a></p><h2 id="6-将上述Deployment进行扩容和缩容操作，扩容为8个副本Pod，然后缩容为4个副本Pod。">6.将上述Deployment进行扩容和缩容操作，扩容为8个副本Pod，然后缩容为4个副本Pod。</h2><h2 id="（1）扩容">（1）扩容</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# kubectl scale deployment www1 --replicas=8<br></code></pre></td></tr></table></figure><h3 id="查看一下-8">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# kubectl get deployments. -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106122722977.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106122722977.png" alt="image-20200106122722977"></a></p><h2 id="（2）缩容">（2）缩容</h2><h3 id="修改k8s配置文件">修改k8s配置文件</h3><h3 id="备份web的yaml文件-2">备份web的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get deployments. -o yaml &gt; www1.yaml<br></code></pre></td></tr></table></figure><h3 id="使用edit修改web的yaml文件-3">使用edit修改web的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl edit deployments. www1<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106105924531.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106105924531.png" alt="image-20200106105924531"></a></p><h3 id="查看一下-9">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master xgp]# kubectl get deployments. -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106122953397.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106122953397.png" alt="image-20200106122953397"></a></p><h2 id="7-将上述Deployment进行升级与回滚操作，将v1版本，升级到v2版本。">7.将上述Deployment进行升级与回滚操作，将v1版本，升级到v2版本。</h2><h2 id="（1）升级版本为web2">（1）升级版本为web2</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl set image deployment www1 www1=192.168.1.21:5000/web2<br></code></pre></td></tr></table></figure><h3 id="本机测试访问">本机测试访问</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# curl 127.0.0.1:30996<br>&lt;h1&gt;xgp | test-web | httpd:v2&lt;h1&gt;<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106125722931.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106125722931.png" alt="image-20200106125722931"></a></p><h3 id="浏览器测试访问">浏览器测试访问</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106125750021.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106125750021.png" alt="image-20200106125750021"></a></p><h2 id="（2）回滚版本到web1">（2）回滚版本到web1</h2><h3 id="1-修改配置文件回滚">&lt;1&gt;修改配置文件回滚</h3><h3 id="使用edit修改web的yaml文件-4">使用edit修改web的yaml文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl edit deployments. www1<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106130010344.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106130010344.png" alt="image-20200106130010344"></a></p><h3 id="查看一下-10">查看一下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get deployments. -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106130304423.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106130304423.png" alt="image-20200106130304423"></a></p><h3 id="访问一下">访问一下</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106130435212.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106130435212.png" alt="image-20200106130435212"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106130447693.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106130447693.png" alt="image-20200106130447693"></a></p><h3 id="2-命令回滚">&lt;2&gt;命令回滚</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl rollout undo deployment www1<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106130317956.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106130317956.png" alt="image-20200106130317956"></a></p><p><em><strong>注意:只能回滚到上一次操作的状态</strong></em></p><h3 id="访问一下-2">访问一下</h3><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106130357339.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106130357339.png" alt="image-20200106130357339"></a></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106130414060.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200106130414060.png" alt="image-20200106130414060"></a></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deployments </tag>
            
            <tag> registry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s架构，基本概念</title>
      <link href="/posts/e863.html"/>
      <url>/posts/e863.html</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>主机名</th><th>IP地址</th><th>服务</th></tr></thead><tbody><tr><td>master</td><td>192.168.1.21</td><td></td></tr><tr><td>node01</td><td>192.168.1.22</td><td></td></tr><tr><td>node02</td><td>192.168.1.23</td><td></td></tr></tbody></table><h1>kubernetes架构</h1><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/qqq.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/qqq.png" alt="image-20200104100759831"></a></p><p><strong>在这张系统架构图中，我们把服务分为运行在工作节点上的服务和组成集群级别控制板的服务。<br>Kubernetes节点有运行应用容器必备的服务，而这些都是受Master的控制。<br>每次个节点上当然都要运行Docker。Docker来负责所有具体的映像下载和容器运行。<br>Kubernetes主要由以下几个核心组件组成：</strong></p><h3 id="kubectl：k8s是命令行端，用来发送客户的操作指令。"><strong>kubectl</strong>：k8s是命令行端，用来发送客户的操作指令。</h3><h2 id="master节点">master节点</h2><p><strong>1. API server[资源操作入口]</strong>：是k8s集群的前端接口，各种各样客户端工具以及k8s的其他组件可以通过它管理k8s集群的各种资源。它提供了HTTP/HTTPS RESTful API,即K8S API。</p><blockquote><ul><li><strong>提供了资源对象的唯一操作入口，其他所有组件都必须通过它提供的API来操作资源数据，只有API Server与存储通信，其他模块通过API Server访问集群状态。</strong></li></ul><p><strong>第一，是为了保证集群状态访问的安全。</strong></p><p><strong>第二，是为了隔离集群状态访问的方式和后端存储实现的方式：API Server是状态访问的方式，不会因为后端存储技术etcd的改变而改变。</strong></p><ul><li><strong>作为kubernetes系统的入口，封装了核心对象的增删改查操作，以<a href="https://www.centos.bz/tag/restful/" target="_blank" rel="noopener">RESTFul</a>接口方式提供给外部客户和内部组件调用。对相关的资源数据“全量查询”+“变化监听”，实时完成相关的业务功能。</strong></li></ul></blockquote><p><strong>2. Scheduler[集群分发调度器]</strong>：负责决定将Pod放在哪个Node上运行。在调度时，会充分考虑集群的拓扑结构，当前各个节点的负载情况，以及应对高可用、性能、数据亲和性和需求。</p><blockquote><p><strong>1.Scheduler收集和分析当前Kubernetes集群中所有Minion节点的资源(内存、CPU)负载情况，然后依此分发新建的Pod到Kubernetes集群中可用的节点。</strong></p><p><strong>2.实时监测Kubernetes集群中未分发和已分发的所有运行的Pod。</strong></p><p><strong>3.Scheduler也监测Minion节点信息，由于会频繁查找Minion节点，Scheduler会缓存一份最新的信息在本地。</strong></p><p><strong>4.最后，Scheduler在分发Pod到指定的Minion节点后，会把Pod相关的信息Binding写回API Server。</strong></p></blockquote><p><strong>4. Controller Manager[内部管理控制中心]</strong>：负责管理集群的各种资源，保证资源处于预期的状态。它由多种Controller组成，包括Replication Controller、Endpoints Controller、Namespace Controller、Serviceaccounts Controller等。</p><blockquote><p><strong>实现集群故障检测和恢复的自动化工作，负责执行各种控制器，主要有：</strong></p><p><strong>1.endpoint-controller：定期关联<a href="https://www.centos.bz/tag/service/" target="_blank" rel="noopener">service</a>和pod(关联信息由endpoint对象维护)，保证service到pod的映射总是最新的。</strong></p><p><strong>2.replication-controller：定期关联replicationController和pod，保证replicationController定义的复制数量与实际运行pod的数量总是一致的。</strong></p></blockquote><p><strong>5. Etcd</strong>：负责保存k8s集群的配置信息和各种资源的状态信息。当数据发生变化时，etcd会快速的通知k8s相关组件。<a href="https://wsdlxgp.top/posts/cd85.html">（第三方组件）它有可替换方案。Consul、zookeeper</a></p><p><strong>6. Pod:</strong> k8s集群的最小组成单位。一个Pod内，可以运行一个或多个容器。大多数情况下，一个Pod内只有一个Container容器。</p><p><strong>7. Flanner</strong>：是k8s集群网络，可以保证Pod的跨主机通信。也有替换方案。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod --all-namespaces<br>//查看pod信息<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200104100759831.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200104100759831.png" alt="image-20200104100759831"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod --all-namespaces -o wide<br>//显示pod的节点信息<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200104101023909.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200104101023909.png" alt="image-20200104101023909"></a></p><h2 id="Node节点">Node节点</h2><p><strong>Kubelet[节点上的Pod管家]</strong>：它是Node的agent(代理)，当Scheduler确定某 个Node上运行Pod之后，会将Pod的具体配置信息发送给该节点的kubelet,kubelet会根据这些信息创建和运行容器，并向Master报告运行状态。</p><blockquote><ul><li><strong>负责Node节点上pod的创建、修改、监控、删除等全生命周期的管理</strong></li><li><strong>定时上报本Node的状态信息给API Server。</strong></li><li><strong>kubelet是Master API Server和Minion之间的桥梁，接收Master API Server分配给它的commands和work，与持久性键值存储etcd、file、server和http进行交互，读取配置信息。</strong></li><li><strong>具体的工作如下：</strong></li></ul><p><strong>设置容器的环境变量、给容器绑定<a href="https://www.centos.bz/tag/volume/" target="_blank" rel="noopener">Volume</a>、给容器绑定Port、根据指定的Pod运行一个单一容器、给指定的Pod创建network 容器。</strong></p><p><strong>同步Pod的状态、同步Pod的状态、从<a href="https://www.centos.bz/tag/cadvisor/" target="_blank" rel="noopener">cAdvisor</a>获取<a href="https://www.centos.bz/tag/container/" target="_blank" rel="noopener">Container</a> info、 pod info、 root info、 <a href="https://www.centos.bz/tag/machine/" target="_blank" rel="noopener">machine</a> info。</strong></p><p><strong>在容器中运行命令、杀死容器、删除Pod的所有容器。</strong></p></blockquote><p>**kube-proxy[负载均衡、路由转发]:**负责将访问service的TCP/UDP数据流转发到后端的容器。如果有多个副本，kube-proxy会实现负载均衡。</p><blockquote><ul><li><strong>Proxy是为了解决外部网络能够访问跨机器集群中容器提供的应用服务而设计的，运行在每个Node上。Proxy提供TCP/UDP sockets的proxy，每创建一种Service，Proxy主要从etcd获取Services和Endpoints的配置信息（也可以从file获取），然后根据配置信息在Minion上启动一个Proxy的进程并监听相应的服务端口，当外部请求发生时，Proxy会根据Load Balancer将请求分发到后端正确的容器处理。</strong></li><li><strong>Proxy不但解决了同一主宿机相同服务端口冲突的问题，还提供了Service转发服务端口对外提供服务的能力，Proxy后端使用了随机、轮循负载均衡算法。</strong></li></ul></blockquote><h2 id="除了核心组件，还有一些推荐的Add-ons：">除了核心组件，还有一些推荐的Add-ons：</h2><p><strong>kube-dns负责为整个集群提供DNS服务<br>Ingress Controller为服务提供外网入口<br>Heapster提供资源监控<br>Dashboard提供GUI<br>Federation提供跨可用区的集群<br>Fluentd-elasticsearch提供集群日志采集、存储与查询</strong></p><h2 id="一-分层架构">一. 分层架构</h2><p>Kubernetes设计理念和功能其实就是一个类似Linux的分层架构，如下图所示。<br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/20200607201704.png" alt="image-20200607201710035"></p><blockquote><p><strong>核心层：Kubernetes最核心的功能，对外提供API构建高层的应用，对内提供插件式应用执行环境</strong><br><strong>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS解析等）</strong><br><strong>管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态Provision等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy等）</strong><br><strong>接口层：kubectl命令行工具、客户端SDK以及集群联邦</strong><br><strong>生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴</strong><br><strong>Kubernetes外部：日志、监控、配置管理、CI、CD、Workflow、FaaS、OTS应用、ChatOps等</strong><br><strong>Kubernetes内部：CRI、CNI、CVI、镜像仓库、Cloud Provider、集群自身的配置和管理等</strong></p></blockquote><h2 id="二-在K8s中运行一个容器应用">二. 在K8s中运行一个容器应用</h2><h4 id="下面通过运行一个容器应用的过程，来一起理解一下K8s组件是如何协作的。">下面通过运行一个容器应用的过程，来一起理解一下K8s组件是如何协作的。</h4><p><strong>开发者开发一个应用后，打包Docker镜像，上传到Docker registry；然后编写一个yaml部署描述文件，以描述应用的结构和资源需求。开发者通过kubectl（或其它应用），将部署描述文件提交到API server，API server将部署需求更新到etcd。etcd在K8s管理结点中的作用相当于数据库，其它组件提交到API server的数据都存储于etcd。API server非常轻量，并不会直接去创建或管理Pod等资源，在多数场景下甚至不会去主动调用其它的K8s组件发出指令。其它组件通过建立和API server的长连接，监视关心的对象，监视到变化后，执行所负责的操作。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/20200607201902.png" alt="img"></p><p><strong>继续我们的启动应用之旅，如图所示，Controller Manager中的控制器监视到新的部署描述后，根据部署描述，创建ReplicaSet、Pod等资源。Scheduler监视到新的Pod资源后，结合集群的资源情况，选定一或多个工作结点运行Pod。工作结点上的Kubelet监视到有Pod被计划在自己的结点后，向Docker等Container runtime发出启动容器的指令，Docker engineer将按照指令从Docker registy拉取镜像，然后启动并运行容器。</strong></p><h2 id="三-K8s集群的高可用部署">三. K8s集群的高可用部署</h2><p><strong>通过之前的介绍，我们看到K8s可以在多个工作结点上启动并管理容器，下面来学习一下，如何实现管理结点的高可用部署。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/20200607201914.png" alt="img"></p><p><strong>上图的K8s高可用部署中有3个管理结点。etcd自身是一个分布式数据存储系统，按照其多实例部署方案，结点只需在启动时知道其它结点的IP和端口号即可组成高可用环境。和通常的应用服务器一样，API Server是无状态的，可以运行任意多个实例，且彼此之间无需互相知道。为了能使kubectl等客户端和Kubelet等组件连接到健康的API Server、减轻单台API Server的压力，需使用基础架构提供的负载均衡器作为多个API Server实例的入口。如上图的部署方法，每个主结点上都运行了一个etcd实例，这样API Server只需连接本地的etcd实例即可，无需再使用负载均衡器作为etcd的入口。</strong></p><p><strong>Controller Manager和Scheduler需要修改K8s集群，同时修改时可能引发并发问题。假设两个ReplicaSet Controller同时监视到需创建一个Pod，然后同时进行创建操作，就会创建出两个Pod。K8s为了避免这个问题，一组此类组件的实例将选举出一个leader，仅有leader处于活动状态，其它实例处于待命状态。Controller Manager和Scheduler也可以独立于API server部署，通过负载均衡器连接到多个API server实例。</strong></p><h2 id="范例">范例</h2><blockquote><h3 id="分析各个组件的作用以及架构工作流程">分析各个组件的作用以及架构工作流程:</h3><p><strong>1) kubectl发送部署 请求到API server</strong><br><strong>2) APIserver通知Controller Manager创建一个Deployment资源。</strong><br><strong>3) Scheduler执行调度任务,将两个副本Pod分发到node01和node02. 上。</strong><br><strong>4) node01和node02, 上的kubelet在各自节点上创建并运行Pod。</strong></p><h3 id="补充">补充</h3><p><strong>1.应用的配置和当前的状态信息保存在etcd中，执行kubectl get pod时API server会从etcd中读取这些数据。</strong></p><p><strong>2.flannel会为每个Pod分配一个IP。 但此时没有创建Service资源，目前kube-proxy还没有参与进来。</strong></p></blockquote><h3 id="运行一个例子（创建一个deployment资源对象-pod控制器-）">运行一个例子（创建一个deployment资源对象&lt;pod控制器&gt;）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl run test-web --image=httpd --replicas=2<br>//创建一个deployment资源对象。<br></code></pre></td></tr></table></figure><p><em><strong>运行完成之后，如果有镜像可直接开启，没有的话需要等待一会儿，node节点要在docker hup上下载</strong></em></p><h4 id="查看一下">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get  deployments.或 kubectl get  deploy<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200104110812772.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200104110812772.png" alt="image-20200104110812772"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200104110954406.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200104110954406.png" alt="image-20200104110954406"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod  -o wide<br>//显示pod的节点信息<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200104111128779.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200104111128779.png" alt="image-20200104111128779"></a></p><p><em><strong>如果，node节点没有运行test-web服务，需要在节点上重启一下</strong></em></p><h3 id="如果删除一个pod">如果删除一个pod</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl delete pod test-web-5b56bdff65-2njqf<br></code></pre></td></tr></table></figure><h4 id="查看一下-2">查看一下</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -o wide<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200104112418012.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200104112418012.png" alt="image-20200104112418012"></a></p><p><em><strong>现在发现容器还存在，因为控制器会自动发现，一旦与之前执行的命令有误差，他会自动补全。</strong></em></p><p><a href="https://blog.csdn.net/gongxsh00/article/details/79932136" target="_blank" rel="noopener">https://blog.csdn.net/gongxsh00/article/details/79932136</a></p><p><a href="https://www.jianshu.com/p/18edac81c718" target="_blank" rel="noopener">https://www.jianshu.com/p/18edac81c718</a></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> kubeadml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署k8s集群</title>
      <link href="/posts/6489.html"/>
      <url>/posts/6489.html</url>
      
        <content type="html"><![CDATA[<h1>一. Kubernetes 系统简介</h1><p><strong>首先，他是一个全新的基于容器技术的分布式架构领先方案。Kubernetes(k8s)是Google开源的容器集群管理系统（内部:Borg）。在Docker技术的基础上，为容器化的应用提供部署运行、资源调度、服务发现和动态伸缩等一系列完整功能，提高了大规模容器集群管理的便捷性。</strong><br>　　<strong>Kubernetes是一个完备的分布式系统支撑平台，具有完备的集群管理能力，多扩多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和发现机制、內建智能负载均衡器、强大的故障发现和自我修复能力、服务滚动升级和在线扩容能力、可扩展的资源自动调度机制以及多粒度的资源配额管理能力。同时Kubernetes提供完善的管理工具，涵盖了包括开发、部署测试、运维监控在内的各个环节。</strong></p><h3 id="Kubernetes中，Service是分布式集群架构的核心，一个Service对象拥有如下关键特征："><strong>Kubernetes中，Service是分布式集群架构的核心，一个Service对象拥有如下关键特征：</strong></h3><blockquote><p><strong>拥有一个唯一指定的名字</strong><br><strong>拥有一个虚拟IP（Cluster IP、Service IP、或VIP）和端口号</strong><br><strong>能够体统某种远程服务能力</strong><br><strong>被映射到了提供这种服务能力的一组容器应用上</strong></p></blockquote><p><strong>Service的服务进程目前都是基于Socket通信方式对外提供服务，比如Redis、Memcache、MySQL、Web Server，或者是实现了某个具体业务的一个特定的TCP Server进程，虽然一个Service通常由多个相关的服务进程来提供服务，每个服务进程都有一个独立的Endpoint（IP+Port）访问点，但Kubernetes能够让我们通过服务连接到指定的Service上。有了Kubernetes内奸的透明负载均衡和故障恢复机制，不管后端有多少服务进程，也不管某个服务进程是否会由于发生故障而重新部署到其他机器，都不会影响我们队服务的正常调用，更重要的是这个Service本身一旦创建就不会发生变化，意味着在Kubernetes集群中，我们不用为了服务的IP地址的变化问题而头疼了。</strong><br>　　<strong>容器提供了强大的隔离功能，所有有必要把为Service提供服务的这组进程放入容器中进行隔离。为此，Kubernetes设计了Pod对象，将每个服务进程包装到相对应的Pod中，使其成为Pod中运行的一个容器。为了建立Service与Pod间的关联管理，Kubernetes给每个Pod贴上一个标签Label，比如运行MySQL的Pod贴上name=mysql标签，给运行PHP的Pod贴上name=php标签，然后给相应的Service定义标签选择器Label Selector，这样就能巧妙的解决了Service于Pod的关联问题。</strong><br>　　<strong>在集群管理方面，Kubernetes将集群中的机器划分为一个Master节点和一群工作节点Node，其中，在Master节点运行着集群管理相关的一组进程kube-apiserver、kube-controller-manager和kube-scheduler，这些进程实现了整个集群的资源管理、Pod调度、弹性伸缩、安全控制、系统监控和纠错等管理能力，并且都是全自动完成的。Node作为集群中的工作节点，运行真正的应用程序，在Node上Kubernetes管理的最小运行单元是Pod。Node上运行着Kubernetes的kubelet、kube-proxy服务进程，这些服务进程负责Pod的创建、启动、监控、重启、销毁以及实现软件模式的负载均衡器。</strong><br>　　<strong>在Kubernetes集群中，它解决了传统IT系统中服务扩容和升级的两大难题。你只需为需要扩容的Service关联的Pod创建一个Replication Controller简称（RC），则该Service的扩容及后续的升级等问题将迎刃而解。在一个RC定义文件中包括以下3个关键信息。</strong><br><strong>目标Pod的定义</strong><br><strong>目标Pod需要运行的副本数量（Replicas）</strong><br><strong>要监控的目标Pod标签（Label）</strong></p><p><strong>在创建好RC后，Kubernetes会通过RC中定义的的Label筛选出对应Pod实例并实时监控其状态和数量，如果实例数量少于定义的副本数量，则会根据RC中定义的Pod模板来创建一个新的Pod，然后将新Pod调度到合适的Node上启动运行，知道Pod实例的数量达到预定目标，这个过程完全是自动化。</strong></p><h2 id="1-Kubernetes优势">1. Kubernetes优势:</h2><blockquote><p>- 容器编排<br>　　　　- 轻量级<br>　　　　- 开源<br>　　　　- 弹性伸缩<br>　　　　- 负载均衡</p></blockquote><h2 id="2-Kubernetes-特性">2. Kubernetes 特性</h2><p><strong>Endpoint Slices</strong><br>Kubernetes 集群中网络端点的可扩展跟踪。<br><strong>服务发现与负载均衡</strong><br>无需修改您的应用程序即可使用陌生的服务发现机制。Kubernetes 为容器提供了自己的 IP 地址和一个 DNS 名称，并且可以在它们之间实现负载平衡。<br><strong>自我修复</strong><br>重新启动失败的容器，在节点死亡时替换并重新调度容器，杀死不响应用户定义的健康检查的容器，并且在它们准备好服务之前不会它们公布给客户端。<br><strong>自动装箱</strong><br>根据资源需求和其他约束自动放置容器，同时不会牺牲可用性，将任务关键工作负载和尽力服务工作负载进行混合放置，以提高资源利用率并节省更多资源。<br>I<strong>Pv4/IPv6 双协议栈</strong><br>Allocation of IPv4 and IPv6 addresses to Pods and Services<br><strong>水平伸缩</strong><br>使用一个简单的命令、一个UI或基于CPU使用情况自动对应用程序进行伸缩。</p><h2 id="3-Kubernetes的Master和Node节点">3. Kubernetes的Master和Node节点</h2><h4 id="1-Master"><strong>1.Master</strong></h4><p><strong>k8s集群的管理节点，负责管理集群，提供集群的资源数据访问入口。拥有Etcd存储服务（可选），运行Api Server进程，Controller Manager服务进程及Scheduler服务进程，关联工作节点Node。Kubernetes API server提供HTTP Rest接口的关键服务进程，是Kubernetes里所有资源的增、删、改、查等操作的唯一入口。也是集群控制的入口进程；Kubernetes Controller Manager是Kubernetes所有资源对象的自动化控制中心；Kubernetes Schedule是负责资源调度（Pod调度）的进程</strong></p><h4 id="2-Node"><strong>2.Node</strong></h4><p><strong>Node是Kubernetes集群架构中运行Pod的服务节点（亦叫agent或minion）。Node是Kubernetes集群操作的单元，用来承载被分配Pod的运行，是Pod运行的宿主机。关联Master管理节点，拥有名称和IP、系统资源信息。运行docker eninge服务，守护进程kunelet及负载均衡器kube-proxy.</strong><br><strong>每个Node节点都运行着以下一组关键进程</strong><br><strong>kubelet：负责对Pod对于的容器的创建、启停等任务</strong><br><strong>kube-proxy：实现Kubernetes Service的通信与负载均衡机制的重要组件</strong><br><strong>Docker Engine（Docker）：Docker引擎，负责本机容器的创建和管理工作</strong></p><p><strong>Node节点可以在运行期间动态增加到Kubernetes集群中，默认情况下，kubelet会想master注册自己，这也是Kubernetes推荐的Node管理方式，kubelet进程会定时向Master汇报自身情报，如操作系统、Docker版本、CPU和内存，以及有哪些Pod在运行等等，这样Master可以获知每个Node节点的资源使用情况，冰实现高效均衡的资源调度策略。</strong></p><h2 id="4-Kubernetes-Node运行节点，运行管理业务容器，包含如下组件">4. Kubernetes Node运行节点，运行管理业务容器，包含如下组件:</h2><h3 id="（1）Kubelet">（1）Kubelet</h3><p><strong>负责管控容器，Kubelet会从Kubernetes API Server接收Pod的创建请求，启动和停止容器，监控容器运行状态并汇报给Kubernetes API Server。</strong></p><h3 id="（2）Kubernetes-Proxy">（2）Kubernetes Proxy</h3><p><strong>负责为Pod创建代理服务，Kubernetes Proxy会从Kubernetes API Server获取所有的Service信息，并根据Service的信息创建代理服务，实现Service到Pod的请求路由和转发，从而实现Kubernetes层级的虚拟转发网络。</strong></p><h3 id="（3）Docker">（3）Docker</h3><p><strong>Node上需要运行容器服务</strong></p><h2 id="k8s最基本的硬件要求">k8s最基本的硬件要求</h2><p><strong>CPU: 双核</strong><br><strong>Mem: 2G</strong><br><strong>3台dockerhost</strong><br><strong>时间必须同步</strong></p><h1>实验环境</h1><table><thead><tr><th>主机名</th><th>IP地址</th><th>服务</th></tr></thead><tbody><tr><td>master</td><td>192.168.1.21</td><td>dockerhost</td></tr><tr><td>node01</td><td>192.168.1.22</td><td>dockerhost</td></tr><tr><td>node02</td><td>192.168.1.23</td><td>dockerhost</td></tr></tbody></table><h2 id="环境准备">环境准备</h2><p><strong>分别将3台虚拟机命名，设置好对应IP，并将其写入域名解析/etc/hosts中，关闭防火墙，iptables，禁用selinux。还有要做到，时间必须一致。全部禁用swap</strong></p><h3 id="1-给三台docker命名">1.给三台docker命名</h3><p><strong>k8.1</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# hostnamectl set-hostname master<br>[root@localhost ~]# su -<br></code></pre></td></tr></table></figure><p><strong>k8.2</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# hostnamectl set-hostname node01<br>[root@localhost ~]# su -<br></code></pre></td></tr></table></figure><p><strong>k8.3</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# hostnamectl set-hostname node02<br>[root@localhost ~]# su -<br></code></pre></td></tr></table></figure><p>验证docker是否能使用及版本是否一样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# docker -v<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102093813472.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102093813472.png" alt="image-20200102093813472"></a></p><h3 id="2-关闭防火墙及禁用selinux">2.关闭防火墙及禁用selinux</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# systemctl stop firewalld<br>[root@master ~]# systemctl disable firewalld<br> [root@master ~]# vim /etc/selinux/config<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102115453524.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102115453524.png" alt="image-20200102115453524"></a></p><h3 id="3-禁用swap（三台）">3. 禁用swap（三台）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# swapoff -a<br>//临时禁用swap<br>[root@master ~]# free -h<br>[root@master ~]# vim /etc/fstab<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102094039749.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102094039749.png" alt="image-20200102094039749"></a></p><h3 id="4-添加域名解析（三台）">4.添加域名解析（三台）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# echo 192.168.1.21 master &gt;&gt; /etc/hosts<br>[root@master ~]# echo 192.168.1.22 node01 &gt;&gt; /etc/hosts<br>[root@master ~]# echo 192.168.1.23 node02 &gt;&gt; /etc/hosts<br></code></pre></td></tr></table></figure><h3 id="5-做免密登陆（三台）">5.做免密登陆（三台）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# ssh-keygen -t rsa<br>//生成密钥<br></code></pre></td></tr></table></figure><p><strong>复制密钥到其他主机</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">54  ssh-copy-id node01<br>55  ssh-copy-id node02<br></code></pre></td></tr></table></figure><h4 id="把域名解析复制到其他主机"><strong>把域名解析复制到其他主机</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">63  scp /etc/hosts node01:/etc<br>64  scp /etc/hosts node02:/etc<br></code></pre></td></tr></table></figure><h3 id="6-打开路由转发和iptables桥接功能（三台）">6.打开路由转发和iptables桥接功能（三台）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim /etc/sysctl.d/k8s.conf<br>//开启iptables桥接功能<br>net.bridge.bridge-nf-call-iptables = 1<br>net.bridge.bridge-nf-call-ip6tables = 1<br><br>[root@master ~]# echo net.ipv4.ip_forward = 1 &gt;&gt; /etc/sysctl.conf <br>//**打开路由转发<br><br>[root@master ~]# sysctl -p /etc/sysctl.d/k8s.conf <br>[root@master ~]# sysctl -p <br>//刷新一下<br></code></pre></td></tr></table></figure><p><strong>如果以上命令执行失败可能是缺少模块，可执行以下命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# modprobe br_netfiler<br></code></pre></td></tr></table></figure><p><strong>把路由转发和iptables桥接复制到其他主机</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# scp /etc/sysctl.d/k8s.conf  node01:/etc/sysctl.d/<br>[root@master ~]# scp /etc/sysctl.d/k8s.conf  node02:/etc/sysctl.d/<br>[root@master ~]# scp /etc/sysctl.conf  node02:/etc/<br>[root@master ~]# scp /etc/sysctl.conf  node01:/etc/<br></code></pre></td></tr></table></figure><p><strong>记得node01和node02也要执行以下命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# sysctl -p /etc/sysctl.d/k8s.conf <br>[root@master ~]# sysctl -p<br></code></pre></td></tr></table></figure><h1>master节点安装部署k8s</h1><h2 id="指定yum安装kubernetes的yum源（三台）">指定yum安装kubernetes的yum源（三台）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo<br>[kubernetes]<br>name=Kubernetes<br>baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/<br>enabled=1<br>gpgcheck=1<br>repo_gpgcheck=1<br>gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg<br>EOF<br></code></pre></td></tr></table></figure><p><strong>下载完成之后，查看一下仓库是否可用</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# yum repolist<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102095945934.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102095945934.png" alt="image-20200102095945934"></a></p><p><strong>创建本地缓存（三台）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# yum makecache fast<br></code></pre></td></tr></table></figure><h2 id="各节点安装所需安装包">各节点安装所需安装包</h2><h3 id="master下载"><strong>master下载</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# yum -y install kubeadm-1.15.0-0 kubelet-1.15.0-0 kubectl-1.15.0-0<br></code></pre></td></tr></table></figure><h3 id="node01和node02下载"><strong>node01和node02下载</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node01 ~]# yum -y install kubeadm-1.15.0-0 kubelet-1.15.0-0<br></code></pre></td></tr></table></figure><h3 id="三台主机把-kubelet加入开机自启"><strong>三台主机把 kubelet加入开机自启</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# systemctl enable kubelet<br></code></pre></td></tr></table></figure><h2 id="master导入，之前准备好的镜像"><strong>master导入，之前准备好的镜像</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# mkdir images<br>[root@master ~]# cd images/<br>[root@master images]# ls<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102101531123.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102101531123.png" alt="image-20200102101531123"></a></p><h3 id="创建一个导入镜像的脚本"><strong>创建一个导入镜像的脚本</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master images]# cat &gt; image.sh &lt;&lt;EOF<br><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-comment">#!/bin/bash</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> /root/images/*</span><br><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-keyword">do</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"> docker load &lt; <span class="hljs-variable">$i</span> </span><br><span class="hljs-meta">&gt;</span><span class="bash"> <span class="hljs-keyword">done</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"> EOF</span><br>[root@master images]# chmod +x image.sh<br></code></pre></td></tr></table></figure><h3 id="导入镜像">导入镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master images]# sh image.sh<br></code></pre></td></tr></table></figure><h3 id="初始化Kubernetes集群">初始化Kubernetes集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]#  kubeadm init --kubernetes-version=v1.15.0 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12 --ignore-preflight-errors=Swap<br></code></pre></td></tr></table></figure><p><strong>如果以上的命令报错，找出问题后先重置一下（下面的命令），然后再执行以上命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubeadm reset<br>//重置kubeadm<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102122213788.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102122213788.png" alt="image-20200102122213788"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master images]# kubectl get node<br>//查看当前节点信息<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102110808239.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102110808239.png" alt="image-20200102110808239"></a></p><p><strong>可以看出master的状态是未就绪（NotReady），之所以是这种状态是因为还缺少一个附件flannel，没有网络各Pod是无法通信的</strong></p><h3 id="也可以通过检查组件的健康状态"><strong>也可以通过检查组件的健康状态</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master images]# kubectl get cs<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102122413443.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102122413443.png" alt="image-20200102122413443"></a></p><h3 id="添加网络组件（flannel）">添加网络组件（flannel）</h3><p><strong>组件flannel可以通过https://github.com/coreos/flannel中获取</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml<br></code></pre></td></tr></table></figure><p>以上只是方式之一，在网络状况良好的情况下建议使用上述方法（调用远端文件执行一下），<strong>若网速较差，建议使用以下方法</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master images]# wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml<br><span class="hljs-meta">#</span><span class="bash">将github官网指定的.yml配置文件下载到本地</span><br>[root@master images]# ls | grep flannel.yml   #确定下载到了当前目录<br>kube-flannel.yml<br>[root@master images]# kubectl apply -f kube-flannel.yml  #指定下载的.yml文件执行相应命令<br></code></pre></td></tr></table></figure><p><em><strong>上述方法，二选一进行配置即可。</strong></em></p><p><strong>看到很多东西被创建是还不够的，还需要查看flannel是否处于正常启动并运行的状态，才算正在的部署完成</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master images]# kubectl get pods --all-namespaces<br>//查看所有的名称空间的pod（可以看到flannel网络运行正常）<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102122732587.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102122732587.png" alt="image-20200102122732587"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master images]# kubectl get pod -n kube-system<br>//查看名称空间为kube-system的pod<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102122826221.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102122826221.png" alt="image-20200102122826221"></a></p><p>查看当前节点信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get node<br>//查看当前节点信息（已经准备好了）<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102111853910.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102111853910.png" alt="image-20200102111853910"></a></p><h1>node两台节点，导入镜像并加入群集</h1><h2 id="导入镜像-2">导入镜像</h2><p>上传所需镜像包，也可以使用docker pull下载</p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102133744555.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102133744555.png" alt="image-20200102133744555"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node01 images]# docker load &lt; kube-proxy-1-15.tar &amp;&amp; docker load -i myflannel-11-0.tar  &amp;&amp; docker load -i pause-3-1.tar<br>[root@node01 images]# docker images<br>//查看本地镜像<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102134006724.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102134006724.png" alt="image-20200102134006724"></a></p><h2 id="node01和node02加入群集">node01和node02加入群集</h2><p><strong>这时使用的命令是初始化群集之后生成的令牌（只有24小时的时效）</strong></p><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102134336922.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102134336922.png" alt="image-20200102134336922"></a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node01 ~]# kubeadm join 192.168.1.21:6443 --token z0vknh.s6ib4eu4f8bre2nu     --discovery-token-ca-cert-hash sha256:8da72cc83f45d1247f42ce888658129b43726fe2af4ffc0c4e79faedb4050359<br></code></pre></td></tr></table></figure><h2 id="加入群集之后查看一下">加入群集之后查看一下</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master images]# kubectl get node<br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102114628989.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102114628989.png" alt="image-20200102114628989"></a></p><h1>各节点优化一下</h1><h2 id="设置table键的默认间距；">设置table键的默认间距；</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# vim .vimrc<br>set tabstop=2<br>[root@master ~]# source .vimrc<br></code></pre></td></tr></table></figure><h2 id="设置kubectl命令自动补全">设置kubectl命令自动补全</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# yum  -y install bash-completion<br>[root@master ~]#  source /usr/share/bash-completion/bash_completion <br>[root@master ~]# source &lt;(kubectl completion bash)<br>[root@master ~]# echo "source &lt;(kubectl completion bash)" &gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure><h2 id="确认k8s群集没有问题，并设置为开机自启">确认k8s群集没有问题，并设置为开机自启</h2><h3 id="master主机操作如下："><strong>master主机操作如下</strong>：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -n kube-system   <br><span class="hljs-meta">#</span><span class="bash">查看pod资源，类似于docker中的容器，确保返回的信息都是running</span><br><span class="hljs-meta">#</span><span class="bash">“-n kube-system”：是k8s的名称空间</span><br></code></pre></td></tr></table></figure><p><a href="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102142028971.png" target="_blank" rel="noopener"><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20200102142028971.png" alt="image-20200102142028971"></a></p><h3 id="master和node节点上都需要进行以下操作，以便设置为开机自启："><strong>master和node节点上都需要进行以下操作，以便设置为开机自启</strong>：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# systemctl enable kubelet<br>[root@master ~]# systemctl enable docker<br></code></pre></td></tr></table></figure><p><strong>设置为开机自启后，k8s群集的配置基本完成了，现在可以重启一下这三台服务器，如果重启后，执行下面的命令，状态都还是running，则表示绝对没有问题了。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@master ~]# kubectl get pod -n kube-system    #重启后验证状态是否还都是running<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> kubeadml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker swarm搭建（2）</title>
      <link href="/posts/420e.html"/>
      <url>/posts/420e.html</url>
      
        <content type="html"><![CDATA[<h1>什么是docker swarm?</h1><p>Swarm 在 Docker 1.12 版本之前属于一个独立的项目，在 Docker 1.12 版本发布之后，该项目合并到了 Docker 中，成为 Docker 的一个子命令。目前，Swarm 是 Docker 社区提供的唯一一个原生支持 Docker 集群管理的工具。它可以把多个 Docker 主机组成的系统转换为单一的虚拟 Docker 主机，使得容器可以组成跨主机的子网网络。</p><p>Docker Swarm 是一个为 IT 运维团队提供集群和调度能力的编排工具。用户可以把集群中所有 Docker Engine 整合进一个「虚拟 Engine」的资源池，通过执行命令与单一的主 Swarm 进行沟通，而不必分别和每个 Docker Engine 沟通。在灵活的调度策略下，IT 团队可以更好地管理可用的主机资源，保证应用容器的高效运行。<br>Swarm的基本架构如下图所示:<br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607192109592.png" alt="image-20200607192109592"></p><h1>Docker Swarm 优点</h1><p>任何规模都有高性能表现 对于企业级的 Docker Engine 集群和容器调度而言，可拓展性是关键。任何规模的公司——不论是拥有五个还是上千个服务器——都能在其环境下有效使用 Swarm。 经过测试，Swarm 可拓展性的极限是在 1000 个节点上运行 50000 个部署容器，每个容器的启动时间为亚秒级，同时性能无减损。</p><p><strong>灵活的容器调度</strong></p><p>Swarm 帮助 IT 运维团队在有限条件下将性能表现和资源利用最优化。Swarm 的内置调度器（scheduler）支持多种过滤器，包括：节点标签，亲和性和多种容器部策略如 binpack、spread、random 等等。</p><p><strong>服务的持续可用性</strong></p><p>Docker Swarm 由 Swarm Manager 提供高可用性，通过创建多个 Swarm master 节点和制定主 master 节点宕机时的备选策略。如果一个 master 节点宕机，那么一个 slave 节点就会被升格为 master 节点，直到原来的 master 节点恢复正常。 此外，如果某个节点无法加入集群，Swarm 会继续尝试加入，并提供错误警报和日志。在节点出错时，Swarm 现在可以尝试把容器重新调度到正常的节点上去。</p><p><strong>和 Docker API 及整合支持的兼容性</strong></p><p>Swarm 对 Docker API 完全支持，这意味着它能为使用不同 Docker 工具（如 Docker CLI，Compose，Trusted Registry，Hub 和 UCP）的用户提供无缝衔接的使用体验。</p><p>Docker Swarm 为 Docker 化应用的核心功能（诸如多主机网络和存储卷管理）提供原生支持</p><p>开发的 Compose 文件能（通过 docker-compose up ）轻易地部署到测试服务器或 Swarm 集群上。Docker Swarm 还可以从 Docker Trusted Registry 或 Hub 里 pull 并 run 镜像。</p><h2 id="一-实验环境">一. 实验环境</h2><table><thead><tr><th>主机</th><th>IP地址</th><th>服务</th></tr></thead><tbody><tr><td>docker01</td><td>192.168.1.11</td><td>swarm+service+webUI+registry</td></tr><tr><td>docker02</td><td>192.168.1.13</td><td>docker</td></tr><tr><td>docker03</td><td>192.168.1.20</td><td>docker</td></tr></tbody></table><p><em><strong>三台主机都关闭防火墙，禁用selinux，修改主机名，时间同步，并添加域名解析。</strong></em></p><p><em><strong>docker版本必须是：v1.12版本开始（可使用docker version查看版本）</strong></em></p><h3 id="1-关闭防火墙，禁用selinux"><strong>1.关闭防火墙，禁用selinux</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# systemctl stop firewalld<br>[root@localhost ~]# hostnamectl set-hostname docker03<br>[root@localhost ~]# su -<br></code></pre></td></tr></table></figure><h3 id="2-时间同步"><strong>2.时间同步</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /etc/localtime /etc/localtime.bk<br>cp /usr/share/zoneinfo/Asia/Shanghai/etc/localtime<br></code></pre></td></tr></table></figure><h3 id="3-修改主机名（三台都要）">3.修改主机名（三台都要）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# hostnamectl set-hostname docker01<br>[root@localhost ~]# su -<br></code></pre></td></tr></table></figure><h3 id="4-添加域名解析"><strong>4.添加域名解析</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# echo 192.168.1.11 docker01 &gt;&gt; /etc/hosts<br>[root@docker01 ~]# echo 192.168.1.13 docker02 &gt;&gt; /etc/hosts<br>[root@docker01 ~]# echo 192.168.1.20 docker03 &gt;&gt; /etc/hosts<br></code></pre></td></tr></table></figure><h2 id="二-docker01-初始化集群">二. docker01 初始化集群</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker swarm init --advertise-addr 192.168.1.11<br></code></pre></td></tr></table></figure><blockquote><p>**–advertise-addr：**指定与其它docker通信的地址。</p></blockquote><p><strong>上边返回的结果告诉我们：初始化成功，并且，如果想要添加work节点运行下面的命令：</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607192124442.png" alt="image-20200607192124442"></p><p><em><strong>注意：token令牌只有24小时的有效期</strong></em></p><p><strong>如果想要添加manager节点：运行下面命令</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607192134248.png" alt="image-20200607192134248"></p><h2 id="三，docker02和docker03以worker加入集群">三，docker02和docker03以worker加入集群</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker03 ~]# docker swarm join --token SWMTKN-1-5kxn9wloh7npnytklwbfciesr9di7uvu521gwnqm9h1n0pbokj-1e60wt0yr5583e4mzwbxnn3a8 192.168.1.11:2377<br></code></pre></td></tr></table></figure><h4 id="docker01查看集群">docker01查看集群</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node ls<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607192155610.png" alt="image-20200607192155610"><br><em>注意：这里的”*****“代表的是当前所属的节点</em></p><h2 id="四-设置manager-node（docker01）不参加工作">四.设置manager node（docker01）不参加工作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node update docker01 --availability drain<br></code></pre></td></tr></table></figure><blockquote><p>设置主机docker01以后不运行容器，但已经运行的容器并不会停止<br>“–availability”选项后面共有三个选项可配置，如下：<br>“active”：工作；“pause”：暂时不工作；“drain”：永久性的不工作</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node ls<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607192231514.png" alt="image-20200607192231514"></p><h2 id="五-docker01部署一个图形化webUI界面">五. docker01部署一个图形化webUI界面</h2><h3 id="1-docker01-导入镜像">1.docker01 导入镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01~]# docker pull dockersamples/visualizer<br></code></pre></td></tr></table></figure><h3 id="2-基于镜像启动一台容器">2.基于镜像启动一台容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -d -p 8080:8080 -e HOST=192.168.1.100 -e PORT=8080 -v /var/run/docker.sock:/var/run/docker.sock --name visualiaer  dockersamples/visualizer<br></code></pre></td></tr></table></figure><h3 id="3-通过浏览器访问验证http-192-168-1-11-8080">3.通过浏览器访问验证http://192.168.1.11:8080/</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607192240766.png" alt="image-20200607192240766"></p><p><em><strong>如果访问不到网页，需开启路由转发</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# echo net.ipv4.ip_forward = 1 &gt;&gt; /etc/sysctl.conf <br>[root@docker01 ~]# sysctl -p<br></code></pre></td></tr></table></figure><h2 id="六-Docker01部署一个私有仓库">六. Docker01部署一个私有仓库</h2><h3 id="Docker01部署"><strong>Docker01部署</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">72 docker pull registry<br>//下载registry镜像<br><br>73 docker run -itd --name registry -p 5000:5000 --restart=always registry:latest<br>//基于registry镜像，启动一台容器<br><br>78 vim /usr/lib/systemd/system/docker.service #13行修改<br>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.1.11:5000 <br><br>80 systemctl daemon-reload<br>81 systemctl restart docker.service<br>//重启docker<br><br>76 docker tag busybox:latest 192.168.1.11:5000/busybox:v1 <br>//把容器重命名一个标签<br><br>77 docker ps<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607192258137.png" alt="image-20200607192258137"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">78 vim /usr/lib/systemd/system/docker.service #13行修改<br>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.1.11:5000 <br><br><br>80 systemctl daemon-reload<br>81 systemctl restart docker.service<br>//重启docker<br><br>100 docker push 192.168.1.11:5000/busybox:v1<br>//上传容器到私有仓库<br></code></pre></td></tr></table></figure><h3 id="Docker02和docker03加入私有仓库"><strong>Docker02和docker03加入私有仓库</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">78 vim /usr/lib/systemd/system/docker.service #13行修改<br>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.1.11:5000  <br><br>80 systemctl daemon-reload<br>81 systemctl restart docker.service<br>//重启docker<br><br>99 docker pull 192.168.1.11/busybox:v1<br>//测试下载<br></code></pre></td></tr></table></figure><h2 id="七-自定义镜像">七. 自定义镜像</h2><h3 id="要求：基于httpd镜像，更改访问界面内容。镜像tag版本为v1，v2，v3，对应主机面内容为v1，xgp666、v2，xgp666、v2，xgp666">要求：基于httpd镜像，更改访问界面内容。镜像tag版本为v1，v2，v3，对应主机面内容为v1，xgp666、v2，xgp666、v2，xgp666</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker pull httpd<br>//下载httpd镜像<br></code></pre></td></tr></table></figure><p><strong>创建三个测试目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# mkdir &#123;v1,v2,v3&#125;<br>//创建测试目录<br></code></pre></td></tr></table></figure><p><strong>docker01，v1目录操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# cd v1<br>[root@docker01 v1]# echo v1,xgp666 &gt; index.html<br>//创建测试网页<br><br>[root@docker01 v1]# vim Dockerfile<br>//编写Dockerfile<br>FROM httpd<br>ADD index.html /usr/local/apache2/htdocs/index.html<br><br>[root@docker01 v1]# docker build -t 192.168.1.11:5000/httpd:v1 .<br>//基于dockerfile创建镜像<br><br>[root@docker01 v1]# docker push  192.168.1.11:5000/httpd:v1<br>//上传刚刚创建镜像到私有仓库<br></code></pre></td></tr></table></figure><p><strong>docker01，v2目录操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v1]# cd ../v2<br>[root@docker01 v2]# echo v2,xgp666 &gt; index.html<br><br>[root@docker01 v2]# vim Dockerfile <br>//编写Dockerfile<br>FROM httpd<br>ADD index.html /usr/local/apache2/htdocs/index.html<br><br>[root@docker01 v2]# docker build -t 192.168.1.11:5000/httpd:v2 .<br>//基于dockerfile创建镜像<br><br>[root@docker01 v2]# docker push  192.168.1.11:5000/httpd:v2<br>//上传刚刚创建镜像到私有仓库<br></code></pre></td></tr></table></figure><p><strong>docker01，v3目录操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v1]# cd ../v3<br>[root@docker01 v2]# echo v3,xgp666 &gt; index.html<br><br>[root@docker01 v2]# vim Dockerfile <br>//编写Dockerfile<br>FROM httpd<br>ADD index.html /usr/local/apache2/htdocs/index.html<br><br>[root@docker01 v2]# docker build -t 192.168.1.11:5000/httpd:v3 .<br>//基于dockerfile创建镜像<br><br>[root@docker01 v2]# docker push  192.168.1.11:5000/httpd:v3<br>//上传刚刚创建镜像到私有仓库<br></code></pre></td></tr></table></figure><h2 id="八-发布一个服务，基于上述镜像">八. 发布一个服务，基于上述镜像</h2><h3 id="要求-副本数量为3个。服务的名称为-bdqn">要求:副本数量为3个。服务的名称为: bdqn</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v3]# docker service create --replicas 3 --name bdqn  -p 80:80 192.168.1.11:5000/httpd:v1<br></code></pre></td></tr></table></figure><p><strong>查看一下网络</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker03 ~]# docker network ls<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607192316241.png" alt="image-20200607192316241"></p><p><strong>默认的Ingress网络，包括创建的自定义overlay网络, 为后端真正为用户提供服务的container,提供了一个统一的入口。</strong></p><blockquote><p>service 通过 ingress load balancing 来发布服务，且 swarm 集群中所有 node 都参与到 ingress 路由网格（ingress routing mesh） 中，访问任意一个 node+PublishedPort 即可访问到服务。</p><p>当访问任何节点上的端口80时，Docker将您的请求路由到活动容器。在群节点本身，端口80可能并不实际绑定，但路由网格知道如何路由流量，并防止任何端口冲突的发生。</p><p>路由网格在发布的端口上监听分配给节点的任何IP地址。对于外部可路由的IP地址，该端口可从主机外部获得。对于所有其他IP地址，只能从主机内部访问。</p></blockquote><h3 id="查看一下创建的副本">查看一下创建的副本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v3]# docker service ps bdqn<br></code></pre></td></tr></table></figure><p><img src="https://s1.51cto.com/images/blog/201912/28/39f5505c6fc85e0ff264099d9af2bb35.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt></p><h3 id="浏览器测试访问http-192-168-1-11-80-http-192-168-1-13-80-http-192-168-1-20-80">浏览器测试访问http://192.168.1.11:80,<a href="http://192.168.1.13:80" target="_blank" rel="noopener">http://192.168.1.13:80</a>,<a href="http://192.168.1.20:80" target="_blank" rel="noopener">http://192.168.1.20:80</a></h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607192328151.png" alt="image-20200607192328151"></p><h3 id="修改docker02和docker03测试网页内容">修改docker02和docker03测试网页内容</h3><h3 id="docker02">docker02</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker exec -it 388f3bd9dd33 /bin/bash<br>root@388f3bd9dd33:/usr/local/apache2# cd htdocs/<br>root@388f3bd9dd33:/usr/local/apache2/htdocs# echo 123 &gt; index.html<br></code></pre></td></tr></table></figure><h3 id="docker03">docker03</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker03 ~]# docker exec -it 281454867fac /bin/bash<br>root@281454867fac:/usr/local/apache2# echo 321 &gt; htdocs/index.html<br></code></pre></td></tr></table></figure><h3 id="测试访问（每一台都会显示，会负载均衡）">测试访问（每一台都会显示，会负载均衡）</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607192355482.png" alt="image-20200607192355482"></p><h3 id="要求-副本数量为3个。服务的名称为-test">要求:副本数量为3个。服务的名称为:test</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v3]# docker service create --replicas 3 --name test  -p 80  192.168.1.11:5000/httpd:v1<br></code></pre></td></tr></table></figure><h3 id="查看创建的服务映射端口">查看创建的服务映射端口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v3]# docker service ls<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607192424180.png" alt="image-20200607192424180"></p><p><strong>默认映射端口30000-32767</strong></p><h2 id="九-服务的扩容与缩容">九. 服务的扩容与缩容</h2><h3 id="扩容">扩容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v3]# docker service scale bdqn=6<br></code></pre></td></tr></table></figure><h3 id="缩容">缩容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v3]# docker service scale bdqn=4<br></code></pre></td></tr></table></figure><p><em><strong>扩容与缩容直接直接通过scale进行设置副本数量。</strong></em></p><h2 id="十-服务的升级与回滚">十.服务的升级与回滚</h2><h3 id="（1）升级">（1）升级</h3><p><strong>docker service upadte 命令参数详解</strong></p><blockquote><p>–force 强制更新重启服务，无论是否配置或镜像改变都更新<br>–image <a href="image:tag">image:tag</a> 制定更新的镜像<br>–with-registry-auth 向 Swarm 代理发送 Registry 认证详细信息，私有仓库需要携带该参数</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service update --image 192.168.1.11:5000/httpd:v2 bdqn<br>//把bdqn服务升级成v2的版本<br></code></pre></td></tr></table></figure><h4 id="测试访问一下">测试访问一下</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607192437930.png" alt="image-20200607192437930"></p><h3 id="（2）平滑的更新">（2）平滑的更新</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service update --image 192.168.1.11:5000/httpd:v3  --update-parallelism 2 --update-delay 1m bdqn <br>//两个服务一起更新，然后，隔一分钟，继续更新<br></code></pre></td></tr></table></figure><blockquote><p>默认情况下, swarm-次只更新-个副本,并且两个副本之间没有等待时间，我们可以通过<br>–update-parallelism;设置并行更新的副本数量。<br>–update-delay：指定滚动更新的时间间隔。</p></blockquote><h4 id="测试访问一下-2">测试访问一下</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607192447084.png" alt="image-20200607192447084"></p><h3 id="3-回滚操作">(3) 回滚操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service  rollback bdqn<br></code></pre></td></tr></table></figure><p><strong>注意，docker swarm的回滚操作，默认只能回滚到上一-次操作的状态，并不能连续回滚到指定操作。</strong></p><h4 id="测试访问一下-3">测试访问一下</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607192455053.png" alt="image-20200607192455053"></p><h2 id="十一，注意：">十一，注意：</h2><p><strong>如果一台机器启用多个服务注意，合理分配cpu与内存资源，因tomcat在启动编译时会很吃内存，且docker是多线程启动的，所有最好是限定一下（设置resources.limits）否者会导致内存在同一时刻用光，某些服务启动失败当然也可是设置出错重启（restart_policy.condition:on-failure），另外设置resources.reservations要注意，不要超出总内存或cpu百分比，否者会导致后面服务无法获取cpu或内存资源出现“no suitable node (insufficien”错误（这个错误很奇怪，某个service不启动，也不输出日志，使用“docker stack ps [xxxx]”查看状态会显示此错误）无法启动</strong></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> overlay </tag>
            
            <tag> swarm </tag>
            
            <tag> webUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker swarm搭建（1）</title>
      <link href="/posts/60e.html"/>
      <url>/posts/60e.html</url>
      
        <content type="html"><![CDATA[<h1>Docker swarm</h1><blockquote><p><strong>docker swarm集群：三剑客之一</strong></p></blockquote><h2 id="一-实验环境">一. 实验环境</h2><table><thead><tr><th>主机</th><th>IP地址</th><th>服务</th></tr></thead><tbody><tr><td>docker01</td><td>192.168.1.11</td><td>swarm+overlay+webUI</td></tr><tr><td>docker02</td><td>192.168.1.13</td><td>docker</td></tr><tr><td>docker03</td><td>192.168.1.20</td><td>docker</td></tr></tbody></table><p><em><strong>三台主机都关闭防火墙，禁用selinux，修改主机名，时间同步，并添加域名解析。</strong></em></p><p><em><strong>docker版本必须是：v1.12版本开始（可使用docker version查看版本）</strong></em></p><h3 id="1-关闭防火墙，禁用selinux"><strong>1.关闭防火墙，禁用selinux</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# systemctl stop firewalld<br>[root@localhost ~]# hostnamectl set-hostname docker03<br>[root@localhost ~]# su -<br></code></pre></td></tr></table></figure><h3 id="2-时间同步"><strong>2.时间同步</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /etc/localtime /etc/localtime.bk<br>cp /usr/share/zoneinfo/Asia/Shanghai/etc/localtime<br></code></pre></td></tr></table></figure><h2 id="3-修改主机名（三台都要）">3.修改主机名（三台都要）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# hostnamectl set-hostname docker01<br>[root@localhost ~]# su -<br></code></pre></td></tr></table></figure><h3 id="4-添加域名解析"><strong>4.添加域名解析</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# vim  /etc/hosts<br><br>127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4<br>::1         localhost localhost.localdomain localhost6 localhost6.localdomain6<br>192.168.1.11 docker01<br>192.168.1.13 docker02<br>192.168.1.20 docker03<br></code></pre></td></tr></table></figure><h2 id="二-swarm原理">二. swarm原理</h2><blockquote><p>**swarm：**作用运行docker engin的多个主机组成的集群</p><p>**node：**每一个docker engin都是一个node（节点），分为manager和worker。</p><p>**manager node：**负责执行容器的编排和集群的管理工作，保持并维护swarm处于期望的状态。swarm可以有多个manager node，他们会自动协调并选举一个leader执行编排任务。但相反，不能没有manager node。</p><p>**worker node：**接受并执行由manager node派发的任务，并且默认manager node也是一个worker node，不过可以将它设置为manager-only node，让他只负责编排和管理工作。</p><p>**service：**用来定义worker上执行的命令。</p></blockquote><h3 id="基本命令操作">基本命令操作</h3><blockquote><p>**docker swarm leave：**申请离开一个集群，之后查看节点状态会变成down，然后可通过manager node 将其删除<br>**docker node rm xxx：**删除某个节点</p><p><strong>docker swarm join-token [manager|worker]</strong>：生成令牌，可以是manager或worker身份。</p><p><strong>docker node demote（降级）</strong>：将swarm节点的为manager降级为worker</p><p><strong>docker node  promote（升级）</strong>：将swarm节点的work升级为manager</p><p>**docker node ls:**查看群集的信息（只可以在manager角色的主机上查看）</p><p><strong>docker service scale web05=6</strong>:容器的动态扩容及缩容</p><p><strong>docker service ps web01</strong>: 查看创建的容器运行在哪些节点</p><p><strong>docker service ls</strong>: 查看创建的服务</p><p><strong>docker swarm leave</strong>: 脱离这个群集</p><p><strong>docker node rm docker03</strong>: 在manager角色的服务器上移除docker03</p><p><strong>docker node update --availability drain docker01</strong>: 设置主机docker01以后不运行容器，但已经运行的容器并不会停止</p><p><strong>docker node update --label-add mem=max docker03</strong>: 更改docker03主机的标签为mem=max</p><p><strong>docker service update --replicas 8 --image 192.168.20.6:5000/lvjianzhao:v2.0 --container-label-add ‘node.labels.mem==max’ lvjianzhao05</strong>: 将服务升级为8个容器，并且指定在mem=max标签的主机上运行</p></blockquote><h2 id="三-docker01-初始化集群">三. docker01 初始化集群</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker swarm init --advertise-addr 192.168.1.11<br></code></pre></td></tr></table></figure><blockquote><p>**–advertise-addr：**指定与其它docker通信的地址。</p></blockquote><p><strong>上边返回的结果告诉我们：初始化成功，并且，如果想要添加work节点运行下面的命令：</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227100031387.png" alt="image-20191227100031387"></p><p><em><strong>注意：token令牌只有24小时的有效期</strong></em></p><p><strong>如果想要添加manager节点：运行下面命令</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227100101785.png" alt="image-20191227100101785"></p><h2 id="四-swarm集群的简单操作">四.swarm集群的简单操作</h2><h3 id="1-docker02和docker03以worker加入集群">1.docker02和docker03以worker加入集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker03 ~]# docker swarm join --token SWMTKN-1-5kxn9wloh7npnytklwbfciesr9di7uvu521gwnqm9h1n0pbokj-1e60wt0yr5583e4mzwbxnn3a8 192.168.1.11:2377<br></code></pre></td></tr></table></figure><h4 id="docker01查看集群">docker01查看集群</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227095739033.png" alt="image-20191227095739033"></p><p><em>注意：这里的”*****“代表的是当前所属的节点</em></p><h3 id="2-删除集群中节点">2.删除集群中节点</h3><h5 id="docker02和docker03申请离开一个集群"><strong>docker02和docker03申请离开一个集群</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker swarm leave<br></code></pre></td></tr></table></figure><h5 id="docker删除docker02和docker03节点"><strong>docker删除docker02和docker03节点</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node rm docker02 <br>[root@docker01 ~]# docker node rm docker03<br></code></pre></td></tr></table></figure><h5 id="docker01查看集群-2">docker01查看集群</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227101116537.png" alt="image-20191227101116537"></p><h3 id="3-docker02和docker03以manager加入集群">3.docker02和docker03以manager加入集群</h3><h4 id="docker01生成manager令牌">docker01生成manager令牌</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker swarm join-token manager<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227101524317.png" alt="image-20191227101524317"></p><h4 id="docker02和docker03加入集群">docker02和docker03加入集群</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker swarm join --token SWMTKN-1-5kxn9wloh7npnytklwbfciesr9di7uvu521gwnqm9h1n0pbokj-cz6hbyv9r5htyqwj5tfol65aa 192.168.1.11:2377<br></code></pre></td></tr></table></figure><h4 id="docker01查看集群-3">docker01查看集群</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227101645916.png" alt="image-20191227101645916"></p><h3 id="4-docker02和docker03降级">4.docker02和docker03降级</h3><h4 id="docker01（manager）把docker02和docker03降级成worker">docker01（manager）把docker02和docker03降级成worker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node  demote docker02<br>[root@docker01 ~]# docker node  demote docker03<br></code></pre></td></tr></table></figure><h4 id="查看集群">查看集群</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227102107194.png" alt="image-20191227102107194"></p><h2 id="五-部署docker-swarm集群网络">五.部署docker swarm集群网络</h2><h4 id="overlay-覆盖型网络">overlay:覆盖型网络</h4><p>overlay networks 管理Swarm中docker守护进程间的通信。可以将容器附加到一个或多个已存在的overlay网络上，使容器与容器之间能够通信；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker network create -d overlay --attachable docker<br>//attachable：这个参数必须要加，否则不能用于容器。<br></code></pre></td></tr></table></figure><p><strong>在创建网络的时候，我们并没有部署一个存储服务，比如consul，那是因为docker swarm自带存储。</strong></p><h5 id="docker01查看网络">docker01查看网络</h5><p><em><strong>但是会发现其他两台并不会发现此网络，需等基于此网络创建service服务就可以看到了</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker network ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227105017950.png" alt="image-20191227105017950"></p><h2 id="六-docker01部署一个图形化webUI界面">六. docker01部署一个图形化webUI界面</h2><h3 id="1-docker01-导入镜像">1.docker01 导入镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01~]# docker pull dockersamples/visualizer<br></code></pre></td></tr></table></figure><h3 id="2-基于镜像启动一台容器">2.基于镜像启动一台容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -d -p 8080:8080 -e HOST=192.168.1.100 -e PORT=8080 -v /var/run/docker.sock:/var/run/docker.sock --name visualiaer  dockersamples/visualizer<br></code></pre></td></tr></table></figure><h3 id="3-通过浏览器访问验证http-192-168-1-11-8080">3.通过浏览器访问验证http://192.168.1.11:8080/</h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227105857150.png" alt="image-20191227105857150"></p><p><em><strong>如果访问不到网页，需开启路由转发</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# echo net.ipv4.ip_forward = 1 &gt;&gt; /etc/sysctl.conf <br>[root@docker01 ~]# sysctl -p<br></code></pre></td></tr></table></figure><h2 id="七-创建service（服务）">七. 创建service（服务）</h2><h4 id="1-基于nginx容器创建一个service服务">1. 基于nginx容器创建一个service服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]#docker pull nginx<br>//下载nginx镜像（三台都要）<br>[root@docker01 ~]# docker service create --replicas 1 --network  docker --name web1 -p 80:80 nginx:latest <br>[root@docker01 ~]# docker service create --replicas 1 --network  docker --name web2 -p 80 nginx:latest<br></code></pre></td></tr></table></figure><p>//–replicas：副本数量</p><p>大概可以理解为一个副本等于一个容器</p><h4 id="2-查看创建的service服务">2. 查看创建的service服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227110938144.png" alt="image-20191227110938144"></p><h5 id="单独查看一个servicefuw">单独查看一个servicefuw</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service  ps web1<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227111603547.png" alt="image-20191227111603547"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service  ps web2<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227111617335.png" alt="image-20191227111617335"></p><h4 id="3-web界面查看">3. web界面查看</h4><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227111400323.png" alt="image-20191227111400323"></p><h4 id="4-基于nginx容器创建五个service服务">4. 基于nginx容器创建五个service服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service create --replicas 5 --network  docker --name web -p 80 nginx:latest<br></code></pre></td></tr></table></figure><h5 id="web界面查看">web界面查看</h5><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227111721046.png" alt="image-20191227111721046"></p><h4 id="5-挂起docker02">5. 挂起docker02</h4><h5 id="web查看（发现服务都分配到其他服务器了）">web查看（发现服务都分配到其他服务器了）</h5><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227112406099.png" alt="image-20191227112406099"></p><h4 id="6-恢复docker02">6. 恢复docker02</h4><h5 id="web查看（发现服务没有回到docker02）">web查看（发现服务没有回到docker02）</h5><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227112714567.png" alt="image-20191227112714567"></p><h2 id="八、实现docker容器的扩容及缩容">八、实现docker容器的扩容及缩容</h2><h3 id="1-删除web1和web2服务">1. 删除web1和web2服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service rm web1 web2<br></code></pre></td></tr></table></figure><h3 id="2-容器的扩容和缩减">2. 容器的扩容和缩减</h3><p>（1）扩容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service scale web=8<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227114842044.png" alt="image-20191227114842044"></p><p>（2）缩减</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service scale web=3<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227114821286.png" alt="image-20191227114821286"></p><h3 id="3-设置manager-node不参加工作">3.设置manager node不参加工作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node update docker01 --availability drain<br></code></pre></td></tr></table></figure><blockquote><p>设置主机docker01以后不运行容器，但已经运行的容器并不会停止<br>“–availability”选项后面共有三个选项可配置，如下：<br>“active”：工作；“pause”：暂时不工作；“drain”：永久性的不工作</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227115018372.png" alt="image-20191227115018372"></p><h4 id="web界面查看-2">web界面查看</h4><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227115142868.png" alt="image-20191227115142868"></p><h2 id="九、docker-Swarm总结">九、docker Swarm总结</h2><blockquote><p>在我对docker Swarm群集进行一定了解后，得出的结论如下：</p><ul><li>参与群集的主机名一定不能冲突，并且可以互相解析对方的主机名；</li><li>集群内的所有节点可以都是manager角色，但是不可以都是worker角色；</li><li>当指定运行的镜像时，如果群集中的节点本地没有该镜像，那么它将会自动下载对应的镜像；</li><li>当群集正常工作时，若一个运行着容器的docker服务器发生宕机，那么，其所运行的所有容器，都将转移到其他正常运行的节点之上，而且，就算发生宕机的服务器恢复正常运行，也不会再接管之前运行的容器；</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> overlay </tag>
            
            <tag> swarm </tag>
            
            <tag> webUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker swarm版本回滚</title>
      <link href="/posts/4890.html"/>
      <url>/posts/4890.html</url>
      
        <content type="html"><![CDATA[<h1>Docker swarm</h1><blockquote><p><strong>docker swarm集群：三剑客之一</strong></p></blockquote><h1>一. Docker Swarm 的基本概念和原理</h1><h2 id="Docker-Swarm-简介">Docker Swarm 简介</h2><p><strong>Swarm是Docker公司推出的用来管理docker集群，它将一群Docker宿主机变成一个单一的，虚拟的主机。Swarm使用标准的Docker API接口作为其前端访问入口，换言之，各种形式的Docker Client(docker client in Go, docker_py, docker等)均可以直接与Swarm通信。Swarm几乎全部用go语言来完成开发，Swarm0.2发布，相比0.1版本，0.2版本增加了一个新的策略来调度集群中的容器，使得在可用的节点上传播它们，以及支持更多的Docker命令以及集群驱动。</strong><br><strong>Swarm deamon只是一个调度器（Scheduler）加路由器(router)，Swarm自己不运行容器，它只是接受docker客户端发送过来的请求，调度适合的节点来运行容器，这意味着，即使Swarm由于某些原因挂掉了，集群中的节点也会照常运行，当Swarm重新恢复运行之后，它会收集重建集群信息．</strong></p><h2 id="Docker-Swarm-工作原理">Docker Swarm 工作原理</h2><p><strong>Docker 客户端通过 Docker API 向 Swarm 管理端发送请求，Swarm Manager 通过守护进程调用集群中的某个节点来执行任务。因为容器都是运行在节点上，Swarm 作为一个独立的集群管理工具，故并不会因某些原因导致不能正常工作而影响集群内所有节点的正常运行。当服务恢复正常后，Swarm 会读取日志来执行集群的恢复动作。架构图如图 1：</strong></p><p><strong>图 1.Docker Swarm 架构图</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607190350533.png" alt="image-20200607190350533"></p><h1>二. Docker Swarm要点</h1><p>**Swarm的负载非常低。**据我观察，Swarm进行调度和通信的CPU负载非常低。因此，Swarm的管理节点(Manager)可以同时作为工作节点(Worker)。如果你需要搭建一个非常大的集群(1000+ 节点)，管理节点需要更多资源，但是对于中小型集群来说，管理节点需要的资源可以忽略不计。</p><p>**Swarm集群的网络通信(服务发现，负载均衡以及容器间通信)非常可靠。**当你开启一个服务的端口之后，在Swarm集群中的任何一个节点都可以访问它。负载均衡也是由Swarm提供的。后文会提到一些之前遇到的问题，但是Docker 1.13之后，这些问题都解决了。</p><h1>三. 实验环境</h1><table><thead><tr><th>主机</th><th>IP地址</th><th>服务</th></tr></thead><tbody><tr><td>docker01</td><td>192.168.1.11</td><td>swarm+service+webUI+registry</td></tr><tr><td>docker02</td><td>192.168.1.13</td><td>docker</td></tr><tr><td>docker03</td><td>192.168.1.20</td><td>docker</td></tr></tbody></table><p><em><strong>三台主机都关闭防火墙，禁用selinux，修改主机名，时间同步，并添加域名解析。</strong></em></p><p><em><strong>docker版本必须是：v1.12版本开始（可使用docker version查看版本）</strong></em></p><h3 id="1-关闭防火墙，禁用selinux"><strong>1.关闭防火墙，禁用selinux</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# systemctl stop firewalld<br>[root@localhost ~]# hostnamectl set-hostname docker03<br>[root@localhost ~]# su -<br></code></pre></td></tr></table></figure><h3 id="2-时间同步"><strong>2.时间同步</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /etc/localtime /etc/localtime.bk<br>cp /usr/share/zoneinfo/Asia/Shanghai/etc/localtime<br></code></pre></td></tr></table></figure><h2 id="3-修改主机名（三台都要）">3.修改主机名（三台都要）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# hostnamectl set-hostname docker01<br>[root@localhost ~]# su -<br></code></pre></td></tr></table></figure><h3 id="4-添加域名解析"><strong>4.添加域名解析</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# echo 192.168.1.11 docker01 &gt;&gt; /etc/hosts<br>[root@docker01 ~]# echo 192.168.1.13 docker02 &gt;&gt; /etc/hosts<br>[root@docker01 ~]# echo 192.168.1.20 docker03 &gt;&gt; /etc/hosts<br></code></pre></td></tr></table></figure><h1>四. swarm原理</h1><blockquote><p>**swarm：**作用运行docker engin的多个主机组成的集群</p><p>**node：**每一个docker engin都是一个node（节点），分为manager和worker。</p><p>**manager node：**负责执行容器的编排和集群的管理工作，保持并维护swarm处于期望的状态。swarm可以有多个manager node，他们会自动协调并选举一个leader执行编排任务。但相反，不能没有manager node。</p><p>**worker node：**接受并执行由manager node派发的任务，并且默认manager node也是一个worker node，不过可以将它设置为manager-only node，让他只负责编排和管理工作。</p><p>**service：**用来定义worker上执行的命令。</p></blockquote><h3 id="基本命令操作">基本命令操作</h3><blockquote><p>**docker swarm leave：**申请离开一个集群，之后查看节点状态会变成down，然后可通过manager node 将其删除<br>**docker node rm xxx：**删除某个节点</p><p><strong>docker swarm join-token [manager|worker]</strong>：生成令牌，可以是manager或worker身份。</p><p><strong>docker node demote（降级）</strong>：将swarm节点的为manager降级为worker</p><p><strong>docker node promote（升级）</strong>：将swarm节点的work升级为manager</p><p>**docker node ls:**查看群集的信息（只可以在manager角色的主机上查看）</p><p><strong>docker service scale web05=6</strong>:容器的动态扩容及缩容</p><p><strong>docker service ps web01</strong>: 查看创建的容器运行在哪些节点</p><p><strong>docker service ls</strong>: 查看创建的服务</p><p><strong>docker swarm leave</strong>: 脱离这个群集</p><p><strong>docker node rm docker03</strong>: 在manager角色的服务器上移除docker03</p><p><strong>docker node update --availability drain docker01</strong>: 设置主机docker01以后不运行容器，但已经运行的容器并不会停止</p><p><strong>docker node update --label-add mem=max docker03</strong>: 更改docker03主机的标签为mem=max</p><p><strong>docker service update --replicas 8 --image 192.168.20.6:5000/lvjianzhao:v2.0 --container-label-add ‘node.labels.mem==max’ lvjianzhao05</strong>: 将服务升级为8个容器，并且指定在mem=max标签的主机上运行</p></blockquote><h1>五. docker01 初始化集群</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker swarm init --advertise-addr 192.168.1.11<br></code></pre></td></tr></table></figure><blockquote><p>**–advertise-addr：**指定与其它docker通信的地址。</p></blockquote><p><strong>上边返回的结果告诉我们：初始化成功，并且，如果想要添加work节点运行下面的命令：</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227100031387.png" alt="image-20191227100031387"></p><p><em><strong>注意：token令牌只有24小时的有效期</strong></em></p><blockquote><p><strong>上面命令执行后，该机器自动加入到swarm集群。这个会创建一个集群token，获取全球唯一的 token，作为集群唯一标识。后续将其他节点加入集群都会用到这个token值。 其中，–advertise-addr参数表示其它swarm中的worker节点使用此ip地址与manager联系。命令的输出包含了其它节点如何加入集群的命令。</strong></p></blockquote><p><strong>如果想要添加manager节点：运行下面命令</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227100101785.png" alt="image-20191227100101785"></p><h1>六.swarm集群的简单操作</h1><h2 id="1、docker02和docker03以worker加入集群">1、docker02和docker03以worker加入集群</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker03 ~]# docker swarm join --token SWMTKN-1-5kxn9wloh7npnytklwbfciesr9di7uvu521gwnqm9h1n0pbokj-1e60wt0yr5583e4mzwbxnn3a8 192.168.1.11:2377<br></code></pre></td></tr></table></figure><h4 id="docker01查看集群">docker01查看集群</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227095739033.png" alt="image-20191227095739033"></p><p><em>注意：这里的”*****“代表的是当前所属的节点</em></p><h3 id="2-删除集群中节点">2.删除集群中节点</h3><h5 id="docker02和docker03申请离开一个集群"><strong>docker02和docker03申请离开一个集群</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker swarm leave<br></code></pre></td></tr></table></figure><h5 id="docker删除docker02和docker03节点"><strong>docker删除docker02和docker03节点</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node rm docker02 <br>[root@docker01 ~]# docker node rm docker03<br></code></pre></td></tr></table></figure><h5 id="docker01查看集群-2">docker01查看集群</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node ls<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607190653493.png" alt="image-20200607190653493"></p><h3 id="3-docker02和docker03以manager加入集群">3.docker02和docker03以manager加入集群</h3><h4 id="docker01生成manager令牌">docker01生成manager令牌</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@docker01</span> ~]<span class="hljs-meta"># docker swarm join-token manager</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607190636792.png" alt="image-20200607190636792"></p><h4 id="docker02和docker03加入集群">docker02和docker03加入集群</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">docker swarm join --token SWMTKN<span class="hljs-number">-1</span><span class="hljs-number">-5</span>kxn9wloh7npnytklwbfciesr9di7uvu521gwnqm9h1n0pbokj-cz6hbyv9r5htyqwj5tfol65aa <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.11</span>:<span class="hljs-number">2377</span><br></code></pre></td></tr></table></figure><h4 id="docker01查看集群-3">docker01查看集群</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@docker01</span> ~]<span class="hljs-meta"># docker node ls</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607190623454.png" alt="image-20200607190623454"></p><h3 id="4-docker02和docker03降级">4.docker02和docker03降级</h3><h4 id="docker01（manager）把docker02和docker03降级成worker">docker01（manager）把docker02和docker03降级成worker</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@docker01</span> ~]<span class="hljs-meta"># docker node  demote docker02</span><br>[root<span class="hljs-symbol">@docker01</span> ~]<span class="hljs-meta"># docker node  demote docker03</span><br></code></pre></td></tr></table></figure><h4 id="查看集群">查看集群</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@docker01</span> ~]<span class="hljs-meta"># docker node ls</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607190609059.png" alt="image-20200607190609059"></p><h2 id="五-设置manager-node（docker01）不参加工作">五.设置manager node（docker01）不参加工作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node update docker01 --availability drain<br></code></pre></td></tr></table></figure><blockquote><p>设置主机docker01以后不运行容器，但已经运行的容器并不会停止<br>“–availability”选项后面共有三个选项可配置，如下：<br>“active”：工作；“pause”：暂时不工作；“drain”：永久性的不工作</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker node ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227115018372.png" alt="image-20191227115018372"></p><h1>八. docker01部署一个图形化webUI界面</h1><h3 id="1-docker01-导入镜像">1.docker01 导入镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01~]# docker pull dockersamples/visualizer<br></code></pre></td></tr></table></figure><h3 id="2-基于镜像启动一台容器">2.基于镜像启动一台容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -d -p 8080:8080 -e HOST=192.168.1.100 -e PORT=8080 -v /var/run/docker.sock:/var/run/docker.sock --name visualiaer  dockersamples/visualizer<br></code></pre></td></tr></table></figure><h3 id="3-通过浏览器访问验证http-192-168-1-11-8080">3.通过浏览器访问验证http://192.168.1.11:8080/</h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191227105857150.png" alt="image-20191227105857150"></p><p><em><strong>如果访问不到网页，需开启路由转发</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# echo net.ipv4.ip_forward = 1 &gt;&gt; /etc/sysctl.conf <br>[root@docker01 ~]# sysctl -p<br></code></pre></td></tr></table></figure><h2 id="一-Docker01部署一个私有仓库">一. Docker01部署一个私有仓库</h2><h3 id="Docker01部署"><strong>Docker01部署</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">72 docker pull registry<br>//下载registry镜像<br><br>73 docker run -itd --name registry -p 5000:5000 --restart=always registry:latest<br>//基于registry镜像，启动一台容器<br><br>78 vim /usr/lib/systemd/system/docker.service #13行修改<br>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.1.11:5000 <br><br>80 systemctl daemon-reload<br>81 systemctl restart docker.service<br>//重启docker<br><br>76 docker tag busybox:latest 192.168.1.11:5000/busybox:v1 <br>//把容器重命名一个标签<br><br>77 docker ps<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/clip_image002.jpg" alt="img"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">78 vim /usr/lib/systemd/system/docker.service #13行修改<br>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.1.11:5000 <br><br><br>80 systemctl daemon-reload<br>81 systemctl restart docker.service<br>//重启docker<br><br>100 docker push 192.168.1.11:5000/busybox:v1<br>//上传容器到私有仓库<br></code></pre></td></tr></table></figure><h3 id="Docker02和docker03加入私有仓库"><strong>Docker02和docker03加入私有仓库</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">78 vim /usr/lib/systemd/system/docker.service #13行修改<br>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.1.11:5000  <br><br>80 systemctl daemon-reload<br>81 systemctl restart docker.service<br>//重启docker<br><br>99 docker pull 192.168.1.11/busybox:v1<br>//测试下载<br></code></pre></td></tr></table></figure><h2 id="2-自定义镜像">2. 自定义镜像</h2><h3 id="要求：基于httpd镜像，更改访问界面内容。镜像tag版本为v1，v2，v3，对应主机面内容为v1，xgp666、v2，xgp666、v2，xgp666">要求：基于httpd镜像，更改访问界面内容。镜像tag版本为v1，v2，v3，对应主机面内容为v1，xgp666、v2，xgp666、v2，xgp666</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker pull httpd<br>//下载httpd镜像<br></code></pre></td></tr></table></figure><p><strong>创建三个测试目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# mkdir &#123;v1,v2,v3&#125;<br>//创建测试目录<br></code></pre></td></tr></table></figure><p><strong>docker01，v1目录操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# cd v1<br>[root@docker01 v1]# echo v1,xgp666 &gt; index.html<br>//创建测试网页<br><br>[root@docker01 v1]# vim Dockerfile<br>//编写Dockerfile<br>FROM httpd<br>ADD index.html /c<br><br>[root@docker01 v1]# docker build -t 192.168.1.11:5000/httpd:v1 .<br>//基于dockerfile创建镜像<br><br>[root@docker01 v1]# docker push  192.168.1.11:5000/httpd:v1<br>//上传刚刚创建镜像到私有仓库<br></code></pre></td></tr></table></figure><p><strong>docker01，v2目录操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v1]# cd ../v2<br>[root@docker01 v2]# echo v2,xgp666 &gt; index.html<br><br>[root@docker01 v2]# vim Dockerfile <br>//编写Dockerfile<br>FROM httpd<br>ADD index.html /usr/local/apache2/htdocs/index.html<br><br>[root@docker01 v2]# docker build -t 192.168.1.11:5000/httpd:v2 .<br>//基于dockerfile创建镜像<br><br>[root@docker01 v2]# docker push  192.168.1.11:5000/httpd:v2<br>//上传刚刚创建镜像到私有仓库<br></code></pre></td></tr></table></figure><p><strong>docker01，v3目录操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v1]# cd ../v3<br>[root@docker01 v2]# echo v3,xgp666 &gt; index.html<br><br>[root@docker01 v2]# vim Dockerfile <br>//编写Dockerfile<br>FROM httpd<br>ADD index.html /usr/local/apache2/htdocs/index.html<br><br>[root@docker01 v2]# docker build -t 192.168.1.11:5000/httpd:v3 .<br>//基于dockerfile创建镜像<br><br>[root@docker01 v2]# docker push  192.168.1.11:5000/httpd:v3<br>//上传刚刚创建镜像到私有仓库<br></code></pre></td></tr></table></figure><h2 id="3-发布一个服务，基于上述镜像">3. 发布一个服务，基于上述镜像</h2><h3 id="要求-副本数量为3个。服务的名称为-bdqn">要求:副本数量为3个。服务的名称为: bdqn</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v3]# docker service create --replicas 3 --name bdqn  -p 80:80 192.168.1.11:5000/httpd:v1<br></code></pre></td></tr></table></figure><p><strong>查看一下网络</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker03 ~]# docker network ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191228101822794.png" alt="image-20191228101822794"></p><p><strong>默认的Ingress网络，包括创建的自定义overlay网络, 为后端真正为用户提供服务的container,提供了一个统一的入口。</strong></p><h3 id="查看一下创建的副本">查看一下创建的副本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v3]# docker service ps bdqn<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191228095854330.png" alt="image-20191228095854330"></p><h3 id="浏览器测试访问http-192-168-1-11-80-http-192-168-1-13-80-http-192-168-1-20-80">浏览器测试访问http://192.168.1.11:80,<a href="http://192.168.1.13:80" target="_blank" rel="noopener">http://192.168.1.13:80</a>,<a href="http://192.168.1.20:80" target="_blank" rel="noopener">http://192.168.1.20:80</a></h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191228100217751.png" alt="image-20191228100217751"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191228100237712.png" alt="image-20191228100237712"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191228100254812.png" alt="image-20191228100254812"></p><h3 id="修改docker02和docker03测试网页内容">修改docker02和docker03测试网页内容</h3><h3 id="docker02">docker02</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker exec -it 388f3bd9dd33 /bin/bash<br>root@388f3bd9dd33:/usr/local/apache2# cd htdocs/<br>root@388f3bd9dd33:/usr/local/apache2/htdocs# echo 123 &gt; index.html<br></code></pre></td></tr></table></figure><h3 id="docker03">docker03</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker03 ~]# docker exec -it 281454867fac /bin/bash<br>root@281454867fac:/usr/local/apache2# echo 321 &gt; htdocs/index.html<br></code></pre></td></tr></table></figure><h3 id="测试访问（每一台都会显示，会负载均衡）">测试访问（每一台都会显示，会负载均衡）</h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191228101141172.png" alt="image-20191228101141172"></p><h2 id="要求-副本数量为3个。服务的名称为-test">要求:副本数量为3个。服务的名称为:test</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v3]# docker service create --replicas 3 --name test  -p 80  192.168.1.11:5000/httpd:v1<br></code></pre></td></tr></table></figure><h3 id="查看创建的服务映射端口">查看创建的服务映射端口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v3]# docker service ls<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191228102155589.png" alt></p><p><strong>默认映射端口30000-32767</strong></p><h2 id="4-服务的扩容与缩容">4. 服务的扩容与缩容</h2><h3 id="扩容">扩容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v3]# docker service scale bdqn=6<br></code></pre></td></tr></table></figure><h3 id="缩容">缩容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 v3]# docker service scale bdqn=4<br></code></pre></td></tr></table></figure><p><em><strong>扩容与缩容直接直接通过scale进行设置副本数量。</strong></em></p><h2 id="5-服务的升级与回滚">5.服务的升级与回滚</h2><h3 id="（1）升级">（1）升级</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service update --image 192.168.1.11:5000/httpd:v2 bdqn<br>//把bdqn服务升级成v2的版本<br></code></pre></td></tr></table></figure><h4 id="测试访问一下">测试访问一下</h4><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191228105637593.png" alt="image-20191228105637593"></p><h3 id="（2）平滑的更新">（2）平滑的更新</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service update --image 192.168.1.11:5000/httpd:v3  --update-parallelism 2 --update-delay 1m bdqn <br>//两个服务一起更新，然后，隔一分钟，继续更新<br></code></pre></td></tr></table></figure><blockquote><p>默认情况下, swarm-次只更新-个副本,并且两个副本之间没有等待时间，我们可以通过<br>–update-parallelism;设置并行更新的副本数量。<br>–update-delay：指定滚动更新的时间间隔。</p></blockquote><h4 id="测试访问一下-2">测试访问一下</h4><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191228110448144.png" alt="image-20191228110448144"></p><h3 id="3-回滚操作">(3) 回滚操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker service  rollback bdqn<br></code></pre></td></tr></table></figure><p><strong>注意，docker swarm的回滚操作，默认只能回滚到上一-次操作的状态，并不能连续回滚到指定操作。</strong></p><h4 id="测试访问一下-3">测试访问一下</h4><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191228110849914.png" alt="image-20191228110849914"></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> overlay </tag>
            
            <tag> swarm </tag>
            
            <tag> webUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker+Consul+registrator实现服务发现及nginx反向代理</title>
      <link href="/posts/b3c.html"/>
      <url>/posts/b3c.html</url>
      
        <content type="html"><![CDATA[<h4 id="更改时间">更改时间</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /etc/localtime/etc/localtime. bk<br>cp /usr/share/zoneinfo/Asia/Shanghai/etc/localtime<br></code></pre></td></tr></table></figure><h4 id="查看端口">查看端口</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# ss -lnt<br></code></pre></td></tr></table></figure><p><strong>Consul:分布式、高可用的，服务发现和配置服务的工具。数据中心</strong><br><strong>Rigistrator:负责收集dockerhost_上,容器服务的信息，并且发送给consul</strong></p><p><strong>Consul-tpmplate:根据编辑好的模板，生产新的nginx配置文件，并负责重新加载nginx配置文件</strong></p><h1>一. 架构设计</h1><p>在现实中，我们一直渴望着追求提供高质量、高可用的服务架构体系，同时减少不必要的部署和维护代价，减少容错率。面对如此高的要求，可以有两种架构方案：<br><strong>Docker+Etcd+Confd+Nginx<br>Docker+Consul+Nginx</strong><br>本文中我们主要来介绍 Docker+Etcd+Confd+Nginx方案，此方案更加高效、快捷，并且维护代价和容错率更低，分布式支持力度更强，如下图所示：</p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226120640567.png" alt="image-20191226120640567"></p><blockquote><p><strong>上面示意图的大概流程如下：</strong><br>1、docker01主机上以二进制包的方式部署consul服务并后台运行，其身份为leader；<br>2、docker02、docker03以容器的方式运行consul服务，并加入到docker01的consul群集中；<br>3、在主机docker02、docker03上后台运行registrator容器，使其自动发现docker容器提供的服务；<br>4、在docker01上部署Nginx，提供反向代理服务，docker02、docker03主机上基于Nginx镜像，各运行两个web容器，提供不同的网页文件，以便测试效果；<br>5、在docker01上安装consul-template命令，将收集到的信息（registrator收集到容器的信息）写入template模板中，并且最终写入Nginx的配置文件中。<br>6、至此，实现客户端通过访问Nginx反向代理服务器（docker01），获得docker02、docker03服务器上运行的Nginx容器提供的网页文件。<br>注：registrator是一个自动发现docker container提供的服务，并且在后端服务注册中心（数据中心）注册服务。主要用来收集容器运行服务的信息，并且发送给consul。数据中心除了consul外，还有etcd、zookeeper等。</p></blockquote><h1>二. 架构优势</h1><p><strong>Docker+Consul+Nginx虽然看起来是三个组件的运用，但却证明是一个有机的整体。它们互相联系、互相作用，完全满足我们对高可用、高效服务架构方案的需求，是Docker生态圈中最理想的组合之一，具有以下<code>优势</code>：</strong></p><blockquote><p><strong>1.发现与注册组件consul使用 Raft 算法来保证一致性，比复杂的Paxos 算法更直接。相比较而言，zookeeper 采用的是 Paxos，而 etcd 使用的则是 Raft；</strong><br><strong>2.多数据中心，多数据中心集群可以避免单数据中心的单点故障，zookeeper 和 etcd 均不提供多数据中心功能的支持；</strong><br><strong>3.、实时发现及无感知服务刷新，具备资源弹性，伸缩自如；</strong><br><strong>4.健康检查，负载能动态在可用的服务实例上进行均衡，etcd 不提供此功能；</strong><br><strong>5.足够多台Docker容器(前提架构资源足以保证性能支撑)；</strong><br><strong>6.http 和dns 协议接口，zookeeper 的集成较为复杂，etcd 只支持 http 协议；</strong><br><strong>7.规模方便进行快速调整，官方提供web管理界面，etcd 无此功能；</strong><br><strong>8.nsul template 搭配consul使用，支持多种接入层，如Nginx、Haproxy。</strong></p></blockquote><h1>三. 实验环境</h1><table><thead><tr><th>主机</th><th>iP地址</th><th>服务</th></tr></thead><tbody><tr><td>docker01</td><td>192.168.1.11</td><td>consul+consul-template+nginx</td></tr><tr><td>docker02</td><td>192.168.1.13</td><td>consul+registrator</td></tr><tr><td>docker03</td><td>192.168.1.20</td><td>consul+registrator</td></tr></tbody></table><p><em><strong>三台主机关闭防火墙，禁用selinux，更改主机名如上所述。</strong></em></p><h1>四. 部署consul服务</h1><h3 id="（1）docker01去官网https-www-consul-io-downloads-html下载consul服务"><strong>（1）docker01去官网https://www.consul.io/downloads.html下载consul服务</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# unzip consul_1.5.1_linux_amd64.zip <br>//现在是本地导入压缩包，需要解压              <br>[root@docker01 ~]# mv consul /usr/local/bin/<br>//移动服务到bin目录<br>[root@docker01 ~]# chmod +x /usr/local/bin/consul<br>//给予一个可执行权限<br></code></pre></td></tr></table></figure><h3 id="（2）启动consul"><strong>（2）启动consul</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# consul agent -server -bootstrap -ui -data-dir=/var/lib/consul-data -bind=192.168.1.11 -client=0.0.0.0 -node=master<br></code></pre></td></tr></table></figure><p><strong>PS: //-bootstrap: 加入这个选项时，一般都在server单节点的时候用，自选举为leader。</strong></p><blockquote><p><strong>参数解释：</strong><br><strong>-server：添加一个服务</strong><br><strong>-bootstrap：一般在server单节点的时候使用，自选举为leader。</strong><br><strong>-data-dir：key/volume指定数据存放的目录</strong><br><strong>-ui：开启内部的web界面</strong><br><strong>-bind：指定开启服务的ip</strong><br><strong>-client：指定访问的客户端</strong><br><strong>-node：在集群内部通信使用的名称，默认是主机名。</strong></p></blockquote><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226093552465.png" alt="image-20191226093552465"></p><p><em><strong>现在这个ip是外部使用</strong></em></p><blockquote><p><strong>PS:开启的端口</strong><br>8300     集群节点<br>8301     集群内部的访问<br>8302     跨数据中心的通信<br>8500     web ui界面<br>8600     使用dns协议查看节点信息的端口</p></blockquote><h4 id="可参考下图查看端口的意思：">可参考下图查看端口的意思：</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607184654463.png" alt="image-20200607184654463"></p><p><em><strong>这时，这条命令会占用终端，可以使用nohup命令让它保持后台运行。</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# nohup consul agent -server -bootstrap -ui -data-dir=/var/lib/consule-data -bind=192.168.1.11  -client=0.0.0.0 -node=master &amp;<br></code></pre></td></tr></table></figure><h3 id="（3）查看consul端口的信息">（3）查看consul端口的信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# consul info<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226093818580.png" alt="image-20191226093818580"></p><h3 id="（4）查看consul集群成员的信息"><strong>（4）查看consul集群成员的信息</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# consul members<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226094012082.png" alt="image-20191226094012082"></p><p><em><strong>现在这个ip是内部使用</strong></em></p><h1>五. docker01下载部署consul-template</h1><p>在 <a href="https://github.com/hashicorp/consul-template" target="_blank" rel="noopener">https://github.com/hashicorp/consul-template</a> 上，下载consul-template</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cs">[<span class="hljs-meta">root@docker01 ~</span>]<span class="hljs-meta"># unzip consul-template_0.19.5_linux_amd64.zip</span><br><span class="hljs-comment">//解压安装好的consul-template包</span><br>[<span class="hljs-meta">root@docker01 ~</span>]<span class="hljs-meta"># mv consul-template /usr/local/bin/</span><br><span class="hljs-comment">//移动到命令目录</span><br>[<span class="hljs-meta">root@docker01 ~</span>]<span class="hljs-meta"># chmod +x /usr/local/bin/consul-template </span><br><span class="hljs-comment">//给予一个可执行权限</span><br></code></pre></td></tr></table></figure><h1>六和七步骤简要说明</h1><p><strong>在docker01和docker02上操作</strong></p><p><strong>先来说一下在docker服务器上操作的大概思路：</strong></p><p><strong>分别在两台docker服务器上都创建registrator容器，注意到consul服务中心；</strong><br><strong>在docker01上运行两台nginx容器（端口随机生成），在docker02上运行两台nginx容器（端口随机生成）；</strong><br><strong>修改这4台nginx容器中的index.html页面内容为（xgp-web01、xgp-web02、xgp-web03、xgp-web04）</strong><br><strong>访问consul web界面验证</strong><br><strong>访问nginx服务器地址 <a href="http://192.168.1.11:8000/" target="_blank" rel="noopener">http://192.168.1.11:8000</a> 进行验证；</strong></p><h1>六. docker02，docker03，加入consul集群</h1><blockquote><p><strong>这里我们采用容器的方式去运行consul服务。</strong></p></blockquote><h3 id="（1）下载consu所需的l镜像"><strong>（1）下载consu所需的l镜像</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker pull consul<br></code></pre></td></tr></table></figure><h3 id="（2）基于consul镜像开启一台容器">（2）基于consul镜像开启一台容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker run -d --name consul -p 8301:8301 -p 8301:8301/udp -p 8500:8500 -p 8600:8600 -p 8600:8600/udp --restart always progrium/consul -join 192.168.1.11 -advertise 192.168.1.13 -client 0.0.0.0 -node=node01<br></code></pre></td></tr></table></figure><blockquote><p><strong>参数解释：</strong></p><p>-d：守护进程</p><p>–name：容器名称</p><p>–restart：容器随着docker服务一直运行</p><p>-advertise:声明本机地址</p><p>-join:声明服务端地址</p><p>-node:consul集群中的名称</p></blockquote><h3 id="（3）docker查看consul集群成员的信息">（3）docker查看consul集群成员的信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# consul members<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226121636780.png" alt="image-20191226121636780"></p><h3 id="（4）两台docker开启容器后，docker01查看">（4）两台docker开启容器后，docker01查看</h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226095528177.png" alt="image-20191226095528177"></p><h3 id="（5）浏览器访问http-192-168-1-11-8500">（5）浏览器访问http://192.168.1.11:8500</h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226095736827.png" alt="image-20191226095736827"></p><h1>七. docker02、docker03 上部署registrator服务</h1><blockquote><p><strong>registrator是一个能自动发现docker container提供的服务,并在后端服务注册中心注册服务或取消服务的工具，后端注册中心支持conusl、etcd、 skydns2、zookeeper等。</strong></p></blockquote><h3 id="（1）下载registrator镜像">（1）下载registrator镜像</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cs">[<span class="hljs-meta">root@docker02 ~</span>]<span class="hljs-meta"># docker pull registrator</span><br><span class="hljs-comment">//下载registrator镜像</span><br></code></pre></td></tr></table></figure><h3 id="（2）基于registrator镜像，开启一台容器">（2）基于registrator镜像，开启一台容器</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[root@docker02 ~]# docker run -d  --name registrator -v <span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/docker.sock:/</span>tmp<span class="hljs-regexp">/docker.sock  --restart always gliderlabs/</span>registrator consul:<span class="hljs-comment">//192.168.1.13:8500</span><br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><blockquote><p>–network：把运行的docker容器设定为host网络模式；<br>-v /var/run/docker.sock：把宿主机的Docker守护进程(Docker daemon)默认监听的Unix域套接字挂载到容器中；<br>–ip : 刚才把network指定了host模式，所以我们指定下IP为宿主机的IP；<br>consul:j最后这个选项是配置consul服务器的IP和端口。</p></blockquote><h3 id="（3）开启一台nginx容器">（3）开启一台nginx容器</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@docker02</span> ~]<span class="hljs-meta"># docker run -d —P --name nginx nginx:latest</span><br></code></pre></td></tr></table></figure><h3 id="（4）浏览器查看一下http-192-168-1-11-8500-ui-dc1-nodes">（4）浏览器查看一下http://192.168.1.11:8500/ui/dc1/nodes</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607185631575.png" alt="image-20200607185631575"><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607185640459.png" alt="image-20200607185640459"></p><h1>八.docker01部署一个nginx服务</h1><h3 id="配置nginx，大概配置的思路为："><strong>配置nginx，大概配置的思路为：</strong></h3><ul><li><strong>在/usr/local/nginx/conf中创建目录consul，目录名自定义；</strong></li><li><strong>在consul目录中创建nginx.ctmpl模板；</strong></li><li><strong>在nginx.conf配置中添加include项并指向consul目录 ；</strong></li><li><strong>重启nginx服务；</strong></li></ul><h3 id="（1）安装开启nginx服务">（1）安装开启nginx服务</h3><h4 id="安装nginx依赖包">安装nginx依赖包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]#  yum -y install pcre pcre-devel openssl openssl-devel zlib zlib-devel<br></code></pre></td></tr></table></figure><h4 id="编译安装nginx">编译安装nginx</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# cd nginx-1.14.0/<br>[root@docker01 nginx-1.14.0]# ./configure --user=nginx --group=nginx  --with-http_stub_status_module --with-http_realip_module --with-pcre --with-http_ssl_module &amp;&amp; make &amp;&amp; make install<br></code></pre></td></tr></table></figure><h4 id="创建所需用户和链接命令目录">创建所需用户和链接命令目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 nginx-1.14.0]# useradd -M -s /sbin/nologin nginx<br>[root@docker01 nginx-1.14.0]# ln -s /usr/local/nginx/sbin/* /usr/local/bin/<br></code></pre></td></tr></table></figure><h4 id="检查nginx是否有问题，并开启nginx">检查nginx是否有问题，并开启nginx</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 nginx-1.14.0]# nginx -t<br>nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok<br>nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful<br>[root@docker01 nginx-1.14.0]# nginx<br></code></pre></td></tr></table></figure><p><em><strong>PS:这里nginx作为反向代理，代理后端docker02、 docker03 上nginx的容器服务,所以我们先去docker02、docker03. 上部署一些服务， 为了方便等会看到负载的效果，所以，我们运行完成容器之后，做一个主界面内容的区分。</strong></em></p><h3 id="（2）安装完成之后，本机测试访问">（2）安装完成之后，本机测试访问</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 nginx-1.14.0]# curl 127.0.0.1<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226105739604.png" alt="image-20191226105739604"></p><h3 id="（3）docker02和docker03部署环境">（3）docker02和docker03部署环境</h3><table><thead><tr><th>主机</th><th>服务</th><th></th></tr></thead><tbody><tr><td>docker02</td><td>nginx</td><td>web01，web02</td></tr><tr><td>docker03</td><td>nginx</td><td>web03，web04</td></tr></tbody></table><h4 id="1-下载nginx镜像（docker02，docker03都要）"><strong>&lt;1&gt;下载nginx镜像（docker02，docker03都要）</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker pull nginx<br>//下载nginx镜像<br></code></pre></td></tr></table></figure><h4 id="2-docker01操作">&lt;2&gt;docker01操作</h4><p><em><strong>基于nginx镜像运行上述所说的容器并设置测试页面</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">web01<br>[root@docker02 ~]# docker run  -itd --name web01 -P nginx:latest<br>[root@docker02 ~]# docker exec -it web01 /bin/bash<br>root@44b59d07202f:/# cd /usr/share/nginx/html/<br>root@44b59d07202f:/usr/share/nginx/html# echo web01 &gt; index.html<br><br>web02<br>[root@docker02 ~]# docker run  -itd --name web02 -P nginx:latest<br>[root@docker02 ~]# docker exec -it web02 /bin/bash<br>root@44b59d07202f:/# cd /usr/share/nginx/html/<br>root@44b59d07202f:/usr/share/nginx/html# echo web02 &gt; index.html<br></code></pre></td></tr></table></figure><h4 id="3-docker02操作">&lt;3&gt;docker02操作</h4><p><em><strong>基于nginx镜像运行上述所说的容器并设置测试页面</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">web03<br>[root@docker03 ~]#  docker run  -itd --name web03 -P nginx:latest<br>[root@docker03 ~]#  docker exec -it web03 /bin/bash<br>root@fd8e8b2df136:/# cd /usr/share/nginx/html/<br>root@fd8e8b2df136:/usr/share/nginx/html#  echo web03 &gt; index.html<br>root@fd8e8b2df136:/usr/share/nginx/html# exit<br>true<br>web04<br>[root@docker03 ~]#  docker run  -itd --name web04 -P nginx:latest<br>[root@docker03 ~]#  docker exec -it web04 /bin/bash<br>root@fd8e8b2df136:/# cd /usr/share/nginx/html/<br>root@fd8e8b2df136:/usr/share/nginx/html#  echo web04 &gt; index.html<br>root@fd8e8b2df136:/usr/share/nginx/html# exit<br></code></pre></td></tr></table></figure><h3 id="（4）docker01更改nginx配置文件">（4）docker01更改nginx配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# cd /usr/local/nginx/<br>//进入nginx配置文件目录<br>[root@docker01 nginx]# mkdir consul<br>//创建consul目录<br>[root@docker01 nginx]# cd consul/<br>//进入consul目录<br></code></pre></td></tr></table></figure><h4 id="1-创建nginx-ctmpl模板">&lt;1&gt;创建nginx.ctmpl模板</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# vim nginx.ctmpl<br>upstream http_backend &#123;<br>        &#123;&#123;range service "nginx"&#125;&#125;<br>        server &#123;&#123; .Address &#125;&#125;:&#123;&#123; .Port &#125;&#125;;<br>        &#123;&#123; end &#125;&#125;<br>&#125;<br><br>server &#123;<br>        listen 8000;<br>        server_name localhost;<br>        location / &#123;<br>                proxy_pass http://http_backend;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-修改nginx配置文件，通过-include-参数包含刚刚创建的文件">&lt;2&gt;修改nginx配置文件，通过 include 参数包含刚刚创建的文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# cd /usr/local/nginx/conf/<br>[root@docker01 conf]# vim nginx.conf<br>  include /usr/local/nginx/consul/*.conf;  #文件最后添加（要在大括号里面）<br></code></pre></td></tr></table></figure><h4 id="3-生成一个vhost-conf配置文件，并重启nginx（会占用终端">&lt;3&gt; 生成一个vhost.conf配置文件，并重启nginx（会占用终端)</h4><p><strong>使用consul-template命令，根据模板生产新的配置文件，并重新加载nginx的配置文件。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 conf]# consul-template -consul-addr 192.168.1.11:8500 -template "/usr/local/nginx/consul/nginx.ctmpl:/usr/local/nginx/consul/vhost.conf:/usr/local/bin/nginx -s reload"<br></code></pre></td></tr></table></figure><p><em><strong>这时，这条命令会占用终端，可以使用nohup命令让它保持后台运行,并重启nginx服务。</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 conf]# nohup consul-template -consul-addr 192.168.1.11:8500 -template   "/usr/local/nginx/consul/nginx.ctmpl:/usr/local/nginx/consul/vhost.conf:/usr/local/sbin/nginx -s reload"  &amp;<br></code></pre></td></tr></table></figure><p>查看一下文件是否生成，里面是否有内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# cd /usr/local/nginx/consul/<br>[root@docker01 consul]# ls<br>nginx.ctmpl  vhost.conf<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226113614544.png" alt="image-20191226113614544"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# cat vhost.conf<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226113633731.png" alt="image-20191226113633731"></p><p><strong>此时，应该能够看到，新生产的vhost.conf配置文件已经生效，访问本机8000端口可以得到不同容器提供的服务。</strong></p><h4 id="4-测试访问">&lt;4&gt;测试访问</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# curl 127.0.0.1:8000<br>web01<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226115250121.png" alt="image-20191226115250121"></p><p><strong>此时可以看到负载均衡的效果！</strong></p><h4 id="5-如果访问不成功">&lt;5&gt;如果访问不成功</h4><p>查看端口8000是否开启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# ss -lnt<br></code></pre></td></tr></table></figure><p>检查nginx配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# nginx -t<br>nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok<br>nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful<br></code></pre></td></tr></table></figure><p>检查自己编写的nginx配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# cd /usr/local/nginx/consul/<br>[root@docker01 consul]# cat nginx.ctmpl <br>upstream http_backend &#123;<br>true&#123;&#123;range service "nginx"&#125;&#125;<br>trueserver &#123;&#123; .Address &#125;&#125;:&#123;&#123; .Port &#125;&#125;;<br>true&#123;&#123; end &#125;&#125;<br>&#125;<br><br>server &#123;<br>truelisten 8000;<br>trueserver_name localhost;<br>truelocation / &#123;<br>truetrueproxy_pass http://http_backend;<br>true&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果nginx配置文件没问题，重启nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# nginx -s reload<br></code></pre></td></tr></table></figure><h4 id="6-测试自动发现">&lt;6&gt;测试自动发现</h4><p><strong>docker02 创建测试容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker run  -itd --name web05 -P nginx:latest<br>[root@docker02 ~]# docker exec -it web05 /bin/bash<br>root@44b59d07202f:/# cd /usr/share/nginx/html/<br>root@44b59d07202f:/usr/share/nginx/html# echo web02 &gt; index.html<br>[root@docker02 ~]# docker ps<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226115332704.png" alt="image-20191226115332704"></p><p><strong>docker01查看</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# cd /usr/local/nginx/consul/<br>[root@docker01 consul]# cat vhost.conf<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226115444855.png" alt="image-20191226115444855"></p><p><strong>docker01测试访问</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 consul]# curl 127.0.0.1:8000<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191226115752718.png" alt="image-20191226115752718"></p><p><strong>//同上</strong></p><p><strong>此时可以看到负载均衡的效果！</strong></p><p><strong>这时不需要考虑后端的web服务器添加还是删除都会自动更新的，这是因为在运行consul-template这条命令后添加的/usr/local/sbin/nginx -s reload的作用！</strong></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> consul </tag>
            
            <tag> registrata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建Prometheus监控报警</title>
      <link href="/posts/babe.html"/>
      <url>/posts/babe.html</url>
      
        <content type="html"><![CDATA[<p><strong>基于上一篇博客继续进行部署</strong></p><h1>一、Prometheus &amp; AlertManager 介绍</h1><blockquote><p>Prometheus 是一套开源的系统监控、报警、时间序列数据库的组合，最初有 SoundCloud 开发的，后来随着越来越多公司使用，于是便独立成开源项目。Alertmanager 主要用于接收 Prometheus 发送的告警信息，它支持丰富的告警通知渠道，例如邮件、微信、钉钉、Slack 等常用沟通工具，而且很容易做到告警信息进行去重，降噪，分组等，是一款很好用的告警通知系统。</p></blockquote><h1>二、基本概念</h1><p>Prometheus<br>官网（<a href="https://prometheus.io/%EF%BC%89" target="_blank" rel="noopener">https://prometheus.io/）</a><br>是一套开源的监控和报警系统，也是一个时序数据库。<br><strong>架构图</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607183330164.png" alt="image-20200607183330164"></p><h2 id="基本原理">基本原理</h2><p><strong>Prometheus的基本原理是通过HTTP协议周期性抓取被监控组件的状态，任意组件只要提供对应的HTTP接口就可以接入监控。不需要任何SDK或者其他的集成过程。这样做非常适合做虚拟化环境监控系统，比如VM、Docker、Kubernetes等。输出被监控组件信息的HTTP接口被叫做exporter 。目前互联网公司常用的组件大部分都有exporter可以直接使用，比如Varnish、Haproxy、Nginx、MySQL、Linux系统信息(包括磁盘、内存、CPU、网络等等)</strong>。</p><p><strong>服务过程</strong></p><blockquote><ol><li><strong>Prometheus Daemon负责定时去目标上抓取metrics(指标)数据，每个抓取目标需要暴露一个http服务的接口给它定时抓取。Prometheus支持通过配置文件、文本文件、Zookeeper、Consul、DNS SRV Lookup等方式指定抓取目标。Prometheus采用PULL的方式进行监控，即服务器可以直接通过目标PULL数据或者间接地通过中间网关来Push数据。</strong><br><strong>2.Prometheus在本地存储抓取的所有数据，并通过一定规则进行清理和整理数据，并把得到的结果存储到新的时间序列中。</strong><br><strong>3.Prometheus通过PromQL和其他API可视化地展示收集的数据。Prometheus支持很多方式的图表可视化，例如Grafana、自带的Promdash以及自身提供的模版引擎等等。Prometheus还提供HTTP API的查询方式，自定义所需要的输出。</strong><br><strong>4.PushGateway支持Client主动推送metrics到PushGateway，而Prometheus只是定时去Gateway上抓取数据。</strong></li><li><strong>Alertmanager是独立于Prometheus的一个组件，可以支持Prometheus的查询语句，提供十分灵活的报警方式。</strong></li></ol></blockquote><h2 id="工作流程">工作流程</h2><p><strong>通过exporters从数据源主动拉取数据（metrics），保存到时序数据库（TSDB）中，可以通过HTTP Server访问，同时可以发起报警，对于数据库中的时序数据，提供PromeQL进行查询，提供给web UI或者可视化系统Grafana等展示。</strong></p><p><strong>Grafana</strong></p><blockquote><p><strong>官网（<a href="https://grafana.com/%EF%BC%89" target="_blank" rel="noopener">https://grafana.com/）</a></strong><br><strong>开源的数据分析和监控平台</strong><br><strong>有不同的dashboards支持不同类型的数据可视化</strong></p></blockquote><p><strong>Exporters</strong></p><blockquote><p><strong>数据采集</strong><br><strong>Prometheus从不同的exorters中拉取数据，有不同的exporter支持不同的数据源</strong><br><strong>node-exporter 支持机器基本的数据 比如cpu mem 网络 等</strong></p></blockquote><table><thead><tr><th style="text-align:left">docker01</th><th>docker02</th><th>docker03</th></tr></thead><tbody><tr><td style="text-align:left">192.168.1.11</td><td>192.168.1.13</td><td>192.168.1.20</td></tr><tr><td style="text-align:left">NodeEXporter</td><td>NodeEXporter</td><td>NodeEXporter</td></tr><tr><td style="text-align:left">cAdvisor</td><td>cAdvisor</td><td>cAdvisor</td></tr><tr><td style="text-align:left">Prometheus Server</td><td>空</td><td>空</td></tr><tr><td style="text-align:left">Grafana</td><td>空</td><td>空</td></tr></tbody></table><p><em><strong>全部关闭防火墙，禁用selinux</strong></em></p><h1>四、设置prometheus监控报警</h1><p>接下来，我们需要启动 AlertManager 来接受 Prometheus 发送过来的报警信息，并执行各种方式的告警。同样以 Docker 方式启动 AlertManager，最简单的启动命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker run --name alertmanager -d -p 9093:9093 prom/alertmanager:latest</span><br></code></pre></td></tr></table></figure><p>这里 AlertManager 默认启动的端口为 9093，启动完成后，浏览器访问 <a href="http://:9093/">http://:9093</a> 可以看到默认提供的 UI 页面，不过现在是没有任何告警信息的，因为我们还没有配置报警规则来触发报警。<br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607183517666.png" alt="image-20200607183517666"></p><h2 id="配置AlertManager">配置AlertManager</h2><p><strong>AlertManager：用来接收prometheus发送来的报警信息，并且执行设置好的报警方式、报警内容。</strong></p><h3 id="下载镜像"><strong>下载镜像</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker pull alertmanager<br>//下载alertmanager镜像<br></code></pre></td></tr></table></figure><h3 id="基于alertmanager运行一台容器"><strong>基于alertmanager运行一台容器</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -d --name alertmanager -p 9093:9093 prom/alertmanager:latest<br></code></pre></td></tr></table></figure><h3 id="配置路由转发"><strong>配置路由转发</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# echo net.ipv4.ip_forward = 1 &gt;&gt; /etc/sysctl.conf <br>[root@docker01 ~]# sysctl -p<br></code></pre></td></tr></table></figure><h3 id="在部署alertmanager之前，我们需要对它的配置文件进行修改-所以我们先运行一个容器，先将其配置文件拷贝出来。"><strong>在部署alertmanager之前，我们需要对它的配置文件进行修改,所以我们先运行一个容器，先将其配置文件拷贝出来。</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker cp alertmanager:/etc/alertmanager/alertmanager.yml ./<br>//拷贝alertmanager的配置文件到本地<br></code></pre></td></tr></table></figure><h3 id="修改alertmanager的配置文件"><strong>修改alertmanager的配置文件</strong></h3><h4 id="配置文件简单介绍"><strong>配置文件简单介绍</strong></h4><blockquote><p><strong>AlertManager：用来接收Prometheus发送的报警信息，并且执行设置好的报警方式，报警内容。</strong></p><p><strong>AlertManager.yml配置文件：</strong></p><blockquote><p><strong>global：全局配置，包括报警解决后的超时时间、SMTP相关配置、各种渠道通知的API地址等消息。</strong></p><p><strong>route：用来设置报警的分发策略。</strong></p><p><strong>receivers：配置报警信息接收者信息。</strong></p><p><strong>inhibit_rules：抑制规则配置，当存在与另一个匹配的报警时，抑制规则将禁用用于有匹配的警报。</strong></p></blockquote></blockquote><h4 id="修改配置文件"><strong>修改配置文件</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# vim alertmanager.yml <br>//修改alertmanager配置文件<br>global:<br>  resolve_timeout: 5m<br>  smtp_from: '2877364346@qq.com'   #自己邮箱地址<br>  smtp_smarthost: 'smtp.qq.com:465'  #qq的邮箱地址及端口<br>  smtp_auth_username: '2877364346@qq.com'  <br>  smtp_auth_password: 'osjppnjkbuhcdfff' #需要在qq邮箱获取授权码<br>  smtp_require_tls: false<br>  smtp_hello: 'qq.com'<br>route:<br>  group_by: ['alertname']<br>  group_wait: 5s<br>  group_interval: 5s<br>  repeat_interval: 5m<br>  receiver: 'email'           #接收者改为邮箱<br>receivers:<br>- name: 'email'<br>  email_configs:<br>  - to: '2877364346@qq.com'<br>    send_resolved: true<br>    inhibit_rules:<br>  - source_match:<br>    severity: 'critical'<br>    target_match:<br>      severity: 'warning'<br>    equal: ['alertname', 'dev', 'instance']<br></code></pre></td></tr></table></figure><p><strong>以上配置我反复试验后，发现不同的环境参数配置也不一样，调试期间出现了各种报错问题，将其中几个关键的配置说明一下：</strong></p><blockquote><p><strong>1、smtp_smarthost: 这里为 QQ 邮箱 SMTP 服务地址，官方地址为 <a href="http://smtp.qq.com" target="_blank" rel="noopener">smtp.qq.com</a> 端口为 465 或 587，同时要设置开启 POP3/SMTP 服务。</strong></p><p><strong>2、smtp_auth_password: 这里为第三方登录 QQ 邮箱的授权码，非 QQ 账户登录密码，否则会报错，获取方式在 QQ 邮箱服务端设置开启 POP3/SMTP 服务时会提示。</strong></p><p><strong>3、smtp_require_tls: 是否使用 tls，根据环境不同，来选择开启和关闭。如果提示报错 email.loginAuth failed: 530 Must issue a STARTTLS command first，那么就需要设置为 true。着重说明一下，如果开启了 tls，提示报错 starttls failed: x509: certificate signed by unknown authority，需要在 email_configs 下配置 insecure_skip_verify: true 来跳过 tls 验证。</strong></p></blockquote><h3 id="重新运行-alertmanager-容器"><strong>重新运行 alertmanager 容器</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker rm -f alertmanager<br>//删除alertmanager容器<br>[root@docker01 ~]# docker run -d --name alertmanager -v /root/alertmanager.yml:/etc/alertmanager/alertmanager.yml -p 9093:9093 prom/alertmanager:latest <br>//运行一台新的alertmanager容器，记得挂载配置文件<br></code></pre></td></tr></table></figure><h2 id="Prometheus配置和alertmanager报警规则"><strong>Prometheus配置和alertmanager报警规则</strong></h2><h3 id="创建存放规则的目录"><strong>创建存放规则的目录</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# mkdir -p prometheus/rules<br>//创建规则目录<br>[root@docker01 ~]# cd prometheus/rules/<br></code></pre></td></tr></table></figure><h3 id="编写规则"><strong>编写规则</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 rules]# vim node-up.rules <br>groups:<br>- name: node-up<br>  rules:<br>  - alert: node-up<br>    expr: up&#123;job="prometheus"&#125; == 0    #&#123;job="prometheus"&#125;中的prometheus需要和prometheus配置文件23行的相同<br>    for: 15s<br>    labels:<br>      severity: 1<br>      team: node<br>    annotations:<br>      summary: "&#123;&#123; $labels.instance &#125;&#125; 已停止运行超过 15s！"<br></code></pre></td></tr></table></figure><p><strong>说明一下：该 rules 目的是监测 node 是否存活，expr 为 PromQL 表达式验证特定节点 job=“node-exporter” 是否活着，for 表示报警状态为 Pending 后等待 15s 变成 Firing 状态，一旦变成 Firing 状态则将报警发送到 AlertManager，labels 和 annotations 对该 alert 添加更多的标识说明信息，所有添加的标签注解信息，以及 prometheus.yml 中该 job 已添加 label 都会自动添加到邮件内容中，更多关于 rule 详细配置可以参考 <a href="https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#rule" target="_blank" rel="noopener">这里</a>。</strong></p><h3 id="修改-prometheus配置文件"><strong>修改 prometheus配置文件</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# vim prometheus.yml <br><br><span class="hljs-meta">#</span><span class="bash"> Alertmanager configuration  <span class="hljs-comment">#7</span></span><br>alerting:<br>  alertmanagers:<br>  - static_configs:<br>    - targets:<br>       - 192.168.1.11:9093  #去注释修改<br><br><span class="hljs-meta">#</span><span class="bash"> Load rules once and periodically evaluate them according to the global <span class="hljs-string">'evaluation_interval'</span>.   <span class="hljs-comment">#14行</span></span><br>rule_files:<br>  - "/usr/local/prometheus/rules/*.rules"  #添加（这个路径是prometheus容器内的路径）<br></code></pre></td></tr></table></figure><p><strong>注意: 这里 rulefiles 为容器内路径，需要将本地 node-up.rules 文件挂载到容器内指定路径，修改 Prometheus 启动命令如下，并重启服务。</strong></p><h3 id="重新运行prometheus-容器">重新运行prometheus 容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker rm -f prometheus <br>//删除prometheus容器<br>[root@docker01 ~]# docker run -d -p 9090:9090 --name prometheus --net=host -v /root/prometheus.yml:/etc/prometheus/prometheus.yml -v /root/prometheus/rules/node-up.rules:/usr/local/prometheus/rules/node-up.rules   prom/prometheus<br>//运行一台新的alertmanager容器，记得挂载规则文件<br></code></pre></td></tr></table></figure><h3 id="浏览器验证一下http-192-168-1-11-9090-rules"><strong>浏览器验证一下http://192.168.1.11:9090/rules</strong></h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191225101246355.png" alt="image-20191225101246355"></p><p><strong>这里说明一下 Prometheus Alert 告警状态有三种状态：Inactive、Pending、Firing。</strong></p><blockquote><p><strong>Inactive：非活动状态，表示正在监控，但是还未有任何警报触发。</strong><br><strong>Pending：表示这个警报必须被触发。由于警报可以被分组、压抑/抑制或静默/静音，所以等待验证，一旦所有的验证都通过，则将转到 Firing 状态。</strong><br><strong>Firing：将警报发送到 AlertManager，它将按照配置将警报的发送给所有接收者。一旦警报解除，则将状态转到 Inactive，如此循环。</strong></p></blockquote><h3 id="挂起docker02">挂起docker02</h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191225101629745.png" alt="image-20191225101629745"></p><h3 id="会收到邮件">会收到邮件</h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191225104344774.png" alt="image-20191225104344774"></p><h3 id="这里有几个地方需要解释一下：">这里有几个地方需要解释一下：</h3><blockquote><ol><li><strong>每次停止/恢复服务后，15s 之后才会发现 Alert 状态变化，是因为 prometheus.yml中 global -&gt; scrape_interval: 15s 配置决定的，如果觉得等待 15s 时间太长，可以修改小一些，可以全局修改，也可以局部修改。例如局部修改 node-exporter 等待时间为 5s。</strong><br><strong>… - job_name: ‘node-exporter’ scrape_interval: 5s file_sd_configs: - files: [’/usr/local/prometheus/groups/nodegroups/*.json’]</strong></li><li><strong>Alert 状态变化时会等待 15s 才发生改变，是因为 node-up.rules 中配置了 for: 15s 状态变化等待时间。</strong></li><li><strong>报警触发后，每隔 5m 会自动发送报警邮件(服务未恢复正常期间)，是因为 alertmanager.yml 中 route -&gt; repeat_interval: 5m 配置决定的。</strong></li></ol></blockquote><h1>五、AlertManager自定义邮件模板</h1><h2 id="创建模板目录"><strong>创建模板目录</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# cd prometheus<br>//进入之前创建的prometheus目录<br>[root@docker01 prometheus]# mkdir alertmanager-tmpl<br>//创建AlertManager模板目录<br></code></pre></td></tr></table></figure><p><strong>看到上边默认发送的邮件模板，虽然所有核心的信息已经包含了，但是邮件格式内容可以更优雅直观一些，那么，AlertManager 也是支持自定义邮件模板配置的，首先新建一个模板文件</strong></p><h2 id="编写模板规则">编写模板规则</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 prometheus]# vim email.tmpl <br>&#123;&#123; define "email.from" &#125;&#125;2877364346@qq.com&#123;&#123; end &#125;&#125;<br>&#123;&#123; define "email.to" &#125;&#125;2877364346@qq.com&#123;&#123; end &#125;&#125;<br>&#123;&#123; define "email.to.html" &#125;&#125;<br>&#123;&#123; range .Alerts &#125;&#125;<br>=========start==========&lt;br&gt;<br>告警程序: prometheus_alert&lt;br&gt;<br>告警级别: &#123;&#123; .Labels.severity &#125;&#125; 级&lt;br&gt;<br>告警类型: &#123;&#123; .Labels.alertname &#125;&#125;&lt;br&gt;<br>故障主机: &#123;&#123; .Labels.instance &#125;&#125;&lt;br&gt;<br>告警主题: &#123;&#123; .Annotations.summary &#125;&#125;&lt;br&gt;<br>触发时间: &#123;&#123; .StartsAt.Format "2019-08-04 16:58:15" &#125;&#125; &lt;br&gt;<br>=========end==========&lt;br&gt;<br>&#123;&#123; end &#125;&#125;<br>&#123;&#123; end &#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>简单说明一下，上边模板文件配置了 email.from、<a href="http://email.to" target="_blank" rel="noopener">email.to</a>、email.to.html 三种模板变量，可以在 alertmanager.yml 文件中直接配置引用。这里 email.to.html 就是要发送的邮件内容，支持 Html 和 Text 格式，这里为了显示好看，采用 Html 格式简单显示信息。下边 {{ range .Alerts }} 是个循环语法，用于循环获取匹配的 Alerts 的信息，下边的告警信息跟上边默认邮件显示信息一样，只是提取了部分核心值来展示。然后，需要增加 alertmanager.yml 文件 templates 配置如下：</strong></p><h2 id="修改alertmanager的配置文件-2"><strong>修改alertmanager的配置文件</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# vim alertmanager.yml <br>global:<br>  resolve_timeout: 5m<br>  smtp_from: '2877364346@qq.com'<br>  smtp_smarthost: 'smtp.qq.com:465'<br>  smtp_auth_username: '2877364346@qq.com'<br>  smtp_auth_password: 'evjmqipqezlbdfij'<br>  smtp_require_tls: false<br>  smtp_hello: 'qq.com'<br>templates:                        #添加模板<br>  - '/etc/alertmanager-tmpl/*.tmpl'   #添加路径<br>    route:<br>      group_by: ['alertname']<br>      group_wait: 5s<br>      group_interval: 5s<br>      repeat_interval: 5m<br>      receiver: 'email'<br>    receivers:<br>- name: 'email'<br>  email_configs: <br>  - to: '&#123;&#123; template "email to" &#125;&#125;'   #修改<br>    html: '&#123;&#123; template "email.to.html" .&#125;&#125;'  #添加<br>    send_resolved: true  #删除<br>    inhibit_rules:<br>  - source_match:<br>    severity: 'critical'<br>    target_match:<br>      severity: 'warning'<br>    equal: ['alertname', 'dev', 'instance']<br></code></pre></td></tr></table></figure><h3 id="重新运行-alertmanager-容器-2"><strong>重新运行 alertmanager 容器</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker rm -f alertmanager<br>//删除alertmanager容器<br>[root@docker01 ~]# docker run -itd  --name alertmanager  -p 9093:9093 -v /root/alertmanager.yml:/etc/alertmanager/alertmanager.yml -v /root/prometheus/alertmanager-tmpl:/etc/alertmanager-tmpl  prom/alertmanager:latest<br>//运行一台新的alertmanager容器，记得挂载配置文件<br></code></pre></td></tr></table></figure><h4 id="挂起docker02-2">挂起docker02</h4><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191225110848591.png" alt="image-20191225110848591"></p><h4 id="收到邮件">收到邮件</h4><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191225114011561.png" alt="image-20191225114011561"></p><p><strong>当然我们还可以配置邮件标题，这里就不在演示了，详细配置可参考<a href="https://prometheus.io/docs/alerting/configuration/#email_config" target="_blank" rel="noopener"> 这里</a>。这里除了监控节点是否存活外，还可以监控很多很多指标，例如 CPU 负载告警、Mem 使用量告警、Disk 存储空间告警、Network 负载告警等等，这些都可以通过自定义 PromQL 表达式验证值来定义一些列的告警规则，来丰富日常工作中需要的各种告警。<br>这里，我们只演示了如何通过 AlertManager 来配置发送邮件告警，其他的告警方式，可以参考 <a href="https://prometheus.io/docs/alerting/configuration/" target="_blank" rel="noopener">官网文档</a> 来配置，这里就不再演示了。下一篇，我们继续通过 Prometheus 来监控 SpringBoot 工程应用程序 JVM 情况，以及自定义 metrics 来实现特定功能的监控。</strong></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> prometheus </tag>
            
            <tag> alertmanager </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于docker搭建Prometheus+Grafana</title>
      <link href="/posts/5755.html"/>
      <url>/posts/5755.html</url>
      
        <content type="html"><![CDATA[<h1>一、介绍Prometheus</h1><p><strong>Prometheus（普罗米修斯）是一套开源的监控&amp;报警&amp;时间序列数据库的组合，起始是由SoundCloud公司开发的。随着发展，越来越多公司和组织接受采用Prometheus，社会也十分活跃，他们便将它独立成开源项目，并且有公司来运作。Google SRE的书内也曾提到跟他们BorgMon监控系统相似的实现是Prometheus。现在最常见的Kubernetes容器管理系统中，通常会搭配Prometheus进行监控。</strong></p><p><strong>Prometheus基本原理是通过HTTP协议周期性抓取被监控组件的状态，这样做的好处是任意组件只要提供HTTP接口就可以接入监控系统，不需要任何SDK或者其他的集成过程。这样做非常适合虚拟化环境比如VM或者Docker 。</strong></p><p><strong>Prometheus应该是为数不多的适合Docker、Mesos、Kubernetes环境的监控系统之一。</strong></p><h2 id="与其他监控系统相比，Prometheus的主要特点是：">与其他监控系统相比，Prometheus的主要特点是：</h2><blockquote><p><strong>一个多维数据模型（时间序列由指标名称定义和设置键/值尺寸）。</strong><br><strong>非常高效的存储，平均一个采样数据占~3.5bytes左右，320万的时间序列，每30秒采样，保持60天，消耗磁盘大概228G。</strong><br><strong>一种灵活的查询语言。</strong><br><strong>不依赖分布式存储，单个服务器节点。</strong><br><strong>时间集合通过HTTP上的PULL模型进行。</strong><br><strong>通过中间网关支持推送时间。</strong><br><strong>通过服务发现或静态配置发现目标。</strong><br><strong>多种模式的图形和仪表板支持。</strong></p></blockquote><h1>二、Prometheus架构概览</h1><p><strong>该图说明了普罗米修斯（Prometheus）及其一些生态系统组件的整体架构：</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607182540011.png" alt="image-20200607182540011"></p><blockquote><p>它的服务过程是这样的Prometheus daemon负责定时去目标上抓取metrics(指标) 数据，每个抓取目标需要暴露一个http服务的接口给它定时抓取。</p><p><strong>Prometheus</strong>：支持通过配置文件、文本文件、zookeeper、Consul、DNS SRV lookup等方式指定抓取目标。支持很多方式的图表可视化，例如十分精美的Grafana，自带的Promdash，以及自身提供的模版引擎等等，还提供HTTP API的查询方式，自定义所需要的输出。</p><p><strong>Alertmanager</strong>：是独立于Prometheus的一个组件，可以支持Prometheus的查询语句，提供十分灵活的报警方式。</p><p><strong>PushGateway</strong>：这个组件是支持Client主动推送metrics到PushGateway，而Prometheus只是定时去Gateway上抓取数据。</p><p>如果有使用过statsd的用户，则会觉得这十分相似，只是statsd是直接发送给服务器端，而Prometheus主要还是靠进程主动去抓取。</p><p>大多数Prometheus组件都是用Go编写的，它们可以轻松地构建和部署为静态二进制文件。访问prometheus.io以获取完整的文档，示例和指南。</p></blockquote><h1>三、Prometheus四种数据类型</h1><h2 id="Counter">Counter</h2><p><strong>Counter用于累计值，例如记录请求次数、任务完成数、错误发生次数。一直增加，不会减少。重启进程后，会被重置。</strong></p><p>例如：http_response_total{method=”GET”,endpoint=”/api/tracks”} 100，10秒后抓取http_response_total{method=”GET”,endpoint=”/api/tracks”} 100。</p><h2 id="Gauge">Gauge</h2><p><strong>Gauge常规数值</strong>，例如 温度变化、内存使用变化。可变大，可变小。重启进程后，会被重置。</p><p>例如： memory_usage_bytes{host=”master-01″} 100 &lt; 抓取值、memory_usage_bytes{host=”master-01″} 30、memory_usage_bytes{host=”master-01″} 50、memory_usage_bytes{host=”master-01″} 80 &lt; 抓取值。</p><h2 id="Histogram">Histogram</h2><p><strong>Histogram（直方图）可以理解为柱状图的意思，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。它特别之处是可以对记录的内容进行分组，提供count和sum全部值的功能。</strong></p><p>例如：{小于10=5次，小于20=1次，小于30=2次}，count=7次，sum=7次的求和值。</p><h2 id="Summary">Summary</h2><p><strong>Summary和Histogram十分相似，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。同样提供 count 和 sum 全部值的功能。</strong></p><p>例如：count=7次，sum=7次的值求值。</p><p>**它提供一个quantiles的功能，可以按%比划分跟踪的结果。**例如：quantile取值0.95，表示取采样值里面的95%数据。</p><h1>五、实验环境</h1><table><thead><tr><th style="text-align:left">docker01</th><th>docker02</th><th>docker03</th></tr></thead><tbody><tr><td style="text-align:left">192.168.1.11</td><td>192.168.1.13</td><td>192.168.1.20</td></tr><tr><td style="text-align:left">NodeEXporter</td><td>NodeEXporter</td><td>NodeEXporter</td></tr><tr><td style="text-align:left">cAdvisor</td><td>cAdvisor</td><td>cAdvisor</td></tr><tr><td style="text-align:left">Prometheus Server</td><td>空</td><td>空</td></tr><tr><td style="text-align:left">Grafana</td><td>空</td><td>空</td></tr></tbody></table><p><em><strong>全部关闭防火墙，禁用selinux</strong></em></p><p><strong>需要部署的组件：</strong></p><blockquote><p><strong>Prometheus Server:普罗米修斯的主服务器。</strong></p><p>Prometheus是一个开源的服务监控系统，它通过HTTP协议从远程的机器收集数据并存储在本地的时序数据库上。</p><ul><li>多维数据模型（时序列数据由metric名和一组key/value组成）</li><li>在多维度上灵活的查询语言(PromQl)</li><li>不依赖分布式存储，单主节点工作.</li><li>通过基于HTTP的pull方式采集时序数据</li><li>可以通过push gateway进行时序列数据推送(pushing)</li><li>可以通过服务发现或者静态配置去获取要采集的目标服务器</li><li>多种可视化图表及仪表盘支持</li><li>Prometheus通过安装在远程机器上的exporter来收集监控数据，后面我们将使用到node_exporter收集系统数据。</li></ul><p><strong><a href>NodeEXporter</a>:负责收集Host硬件信息和操作系统信息。</strong></p><p><strong><a href>cAdvisor</a>:负责收集Host.上运行的容器信息。</strong></p><p><strong>Grafana:负责展示普罗米修斯监控界面。</strong></p><p>Grafana 是一个开箱即用的可视化工具，具有功能齐全的度量仪表盘和图形编辑器，有灵活丰富的图形化选项，可以混合多种风格，支持多个数据源特点。</p></blockquote><p><em><strong>这些可以直接docker pull下载镜像（现在是本地导入镜像）</strong></em></p><p><strong>本地上传镜像</strong></p><h4 id="docker01">docker01</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[09:05:42][docker01$  docker load -i node-exporter.tar &amp;&amp; docker load -i  mycadvisor.tar &amp;&amp; docker load -i prometheus.tar  &amp;&amp; docker load -i grafana.tar<br></code></pre></td></tr></table></figure><h4 id="docker02和docker03">docker02和docker03</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[09:05:22]docker03]$ docker load -i node-exporter.tar &amp;&amp; docker load -i  mycadvisor.tar<br></code></pre></td></tr></table></figure><h1>六、各主机部署</h1><h3 id="1-3个节点，全部部署node-EXporter-和cAdvisor"><strong>1) 3个节点，全部部署node-EXporter,和cAdvisor.</strong></h3><h4 id="部署安装node-EXporter收集节点硬件和操作系统信息。"><strong>部署安装node-EXporter收集节点硬件和操作系统信息。</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[09:21:03[docker01]$  docker run -d -p 9100:9100 -v /proc:/host/proc -v /sys:/host/sys -v /:/rootfs --net=host prom/node-exporter --path.procfs /host/proc --path.sysfs /host/sys --collector.filesystem.ignored-mount-points "^/(sys|proc|dev|host|etc)($|/)"<br>//部署node-EXporter,收集硬件和系统信息。<br></code></pre></td></tr></table></figure><p><em><strong>PS: 注意，这里使用了–net=host， 这样Prometheus Server可以直接与Node-</strong></em><br><em><strong>EXporter通信。</strong></em></p><p><strong>验证</strong>:打开浏览器验证结果。<a href="http://192.168.1.11:9100/%EF%BC%8Chttp://192.168.1.13:9100/%EF%BC%8Chttp://192.168.1.20:9100/" target="_blank" rel="noopener">http://192.168.1.11:9100/，http://192.168.1.13:9100/，http://192.168.1.20:9100/</a></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224092308045.png" alt="image-20191224092308045"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224092328151.png" alt="image-20191224092328151"></p><h4 id="部署安装cAdvisor-收集节点容器信息。"><strong>部署安装cAdvisor,收集节点容器信息。</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[09:39:10[docker01]$ docker run -v /:/rootfs:ro -v /var/run:/var/run/:rw -v /sys:/sys:ro -v /var/lib/docker:/var/lib/docker:ro --detach=true --name=cadvisor --net=host google/cadvisor<br></code></pre></td></tr></table></figure><p><strong>验证</strong>:打开浏览器验证结果。<a href="http://192.168.1.11:8080" target="_blank" rel="noopener">http://192.168.1.11:8080</a>，<a href="http://192.168.1.13:8080" target="_blank" rel="noopener">http://192.168.1.13:8080</a>，<a href="http://192.168.1.20:8080" target="_blank" rel="noopener">http://192.168.1.20:8080</a></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224094211151.png" alt="image-20191224094211151"></p><h3 id="2-在docker01上部署Prometheus-Server服务。"><strong>2)在docker01上部署Prometheus Server服务。</strong></h3><p><em><strong>在部署prometheus之前，我们需要对它的配置文件进行修改,所以我们先运行一个容器，先将其配置文件拷贝出来。</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">09:51:22][docker01]$ docker run -d -p 9090:9090 --name prometheus --net=host prom/prometheus<br>//打开一台Prometheus<br>[09:51:00[docker01]$ docker cp prometheus:/etc/prometheus/prometheus.yml ./<br>//拷贝Prometheus的配置文件到本地<br></code></pre></td></tr></table></figure><h4 id="修改Prometheus的配置文件，添加监听端口（29行）"><strong>修改Prometheus的配置文件，添加监听端口（29行）</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[09:55:53][docker01][~]$ vim prometheus.yml <br>//修改配置文件这里指定了prometheus的监控项，包括它也会监控自己手机到的数据。<br>- targets: ['localhost:9090','localhost:8080','localhost:9100','192.168.1.13:8080','192.168.1.13:9100','192.168.1.20:8080','192.168.1.20:9100']<br></code></pre></td></tr></table></figure><h4 id="重新运行prometheus容器">重新运行prometheus容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[10:00:27][docker01][~]$ docker rm -f prometheus <br>//删除 prometheus容器<br>[10:02:45][docker01][~]$ docker run -d -p 9090:9090 --name prometheus --net=host  -v /root/prometheus.yml:/etc/prometheus/prometheus.yml   prom/prometheus<br>//运行一台新的 prometheus容器<br></code></pre></td></tr></table></figure><h4 id="浏览器访问，验证：http-192-168-1-11-9090-graph">浏览器访问，验证：<a href="http://192.168.1.11:9090/graph" target="_blank" rel="noopener">http://192.168.1.11:9090/graph</a></h4><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224100745680.png" alt="image-20191224100745680"></p><p><em><strong>ps：这里能够查看到我们各个监控项。</strong></em></p><p>如果现在挂起一台虚拟机（测试完之后继续运行）</p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224101214064.png" alt="image-20191224101214064"></p><h3 id="3-在docker01-上-部署grafana服务-用来展示prometheus收集到的数据。"><strong>3)在docker01.上,部署grafana服务,用来展示prometheus收集到的数据。</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# mkdir grafana-storage<br>//创建收集信息的目录<br>[root@docker01 ~]# chmod 777 grafana-storage/<br>//给予777权限<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -d -p 3000:3000 --name grafana -v /root/grafana-storage:/var/lib/grafana -e "GF_SECURITY_ADMIN_PASSWORD=123.com" grafana/grafana<br></code></pre></td></tr></table></figure><h4 id="浏览器访问验证：-http-192-168-1-11-3000-login">**浏览器访问验证：**<a href="http://192.168.1.11:3000/login" target="_blank" rel="noopener">http://192.168.1.11:3000/login</a></h4><p><strong>（&lt;默认&gt;用户名：admin，密码：<a href="http://123.com" target="_blank" rel="noopener">123.com</a>）</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224102458225.png" alt="image-20191224102458225"></p><h4 id="添加数据源"><strong>添加数据源</strong></h4><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224104423328.png" alt="image-20191224104423328"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224104456642.png" alt="image-20191224104456642"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224104700442.png" alt="image-20191224104700442"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224105029089.png" alt="image-20191224105029089"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224105050798.png" alt="image-20191224105050798"></p><p><em><strong>PS:看到这个提示， 说明prometheus和grafana服务的是 正常连接的。</strong></em></p><blockquote><p><strong>此时，虽然grafana收集到了数据，但怎么显示它,仍然是个问题，grafana支持自定 义显示信息,不过要自定义起来非常麻烦，不过好在，grafana官方为我们提供了- -些模板，来供我们使用。</strong></p><p>**grafana官网:**<a href="https://grafana.com/docs/grafana/latest/" target="_blank" rel="noopener">https://grafana.com/docs/grafana/latest/</a></p></blockquote><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191224105657726.png" alt="image-20191224105657726"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607182644146.png" alt="image-20200607182644146"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607182653371.png" alt="image-20200607182653371"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607182702981.png" alt="image-20200607182702981"></p><h4 id="选中一款模板，然后，我们有2种方式可以套用这个模板。"><strong>选中一款模板，然后，我们有2种方式可以套用这个模板。</strong></h4><h5 id="第一种方式：通过JSON文件使用模板。"><strong>第一种方式：通过JSON文件使用模板。</strong></h5><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607182716389.png" alt="image-20200607182716389"></p><p><strong>下载完成之后，来到grafana控制台</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607182730880.png" alt="image-20200607182730880"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607182738413.png" alt="image-20200607182738413"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607182746893.png" alt="image-20200607182746893"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607182753437.png" alt="image-20200607182753437"></p><h5 id="第二种导入模板的方式">第二种导入模板的方式:**</h5><p><strong>可以直接通过模板的ID号。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607182802389.png" alt="image-20200607182802389"></p><p><strong>//这个id不好用换成8321了</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607182808477.png" alt="image-20200607182808477"></p><p><strong>复制模板id之后，来到grafana控制台</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607182816708.png" alt="image-20200607182816708"></p><h1>排错思路</h1><p><strong>防火墙是否关闭，selinux是否禁用</strong><br><strong>主机名称是否更改</strong><br><strong>镜像是否正常</strong><br><strong>各服务启动时挂载目录是否正确</strong><br><strong>grafana服务，是否创建所需目录，目录是否有权限</strong><br><strong>Prometheus服务是否修改配置文件</strong></p><h1>总结</h1><p><strong>恭喜！您已经设置了Prometheus服务器，Node Exporter和Grafana 等所有这些都可以使用的Docker。尽管这些目前都在同一台机器上运行，但这仅用于演示目的。在生产设置中，通常会在每台受监控的计算机上运行节点导出器，多个Prometheus服务器（根据组织的需要），以及单个Grafana服务器来绘制来自这些服务器的数据。</strong></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> prometheus </tag>
            
            <tag> grafana </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的监控(简单部署Sysdig和Weave Scope)</title>
      <link href="/posts/eb5f.html"/>
      <url>/posts/eb5f.html</url>
      
        <content type="html"><![CDATA[<h1><strong>一、Docker的监控</strong></h1><h2 id="Docker自带的监控命令">Docker自带的监控命令</h2><h3 id="简单命令介绍"><strong>简单命令介绍</strong></h3><h4 id="ps"><strong>ps</strong></h4><p><strong>docker container ps 是我们早已熟悉的命令了，方便我们查看当前运行的容器。新版的 Docker 提供了一个新命令 docker container ls，其作用和用法与 docker container ps 完全一样。不过 ls 含义可能比 ps 更准确，所以更推荐使用。</strong></p><h4 id="top"><strong>top</strong></h4><p><strong>如果想知道某个容器中运行了哪些进程，可以执行 docker container top [container] 命令。命令后面还可以跟上 Linux 操作系统 ps 命令的参数显示特定的信息，比如 -au。</strong></p><h4 id="stats"><strong>stats</strong></h4><p><strong>docker container stats 用于显示每个容器各种资源的使用情况。默认会显示一个实时变化的列表，展示每个容器的 CPU 使用率，内存使用量和可用量。注意：容器启动时如果没有特别指定内存 limit，stats 命令会显示 host 的内存总量，但这并不意味着每个 container 都能使用到这么多的内存。</strong></p><p><strong>除此之外 docker container stats 命令还会显示容器网络和磁盘的 IO 数据。默认的输出有个缺点，显示的是容器 ID 而非名字。我们可以在 stats 命令后面指定容器的名称只显示某些容器的数据。比如 docker container stats sysdig weave。</strong></p><h3 id="命令执行"><strong>命令执行</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker ps<br>//查看容器信息<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223110050156.png" alt="image-20191223110050156"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker top 容器名称<br>[root@docker01 ~]# docker top wordpress_wordpress_1 <br>//查看容器中运行的进程信息，支持 ps 命令参数。<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607182000116.png" alt="image-20200607182000116"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker stats wordpress_wordpress_1 <br>//实时查看容器统计信息，查看容器的CPU利用率、内存的使用量以及可用内存总量。<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607182006307.png" alt="image-20200607182006307"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker logs 容器名称<br>[root@docker01 ~]# docker logs wordpress_wordpress_1 <br>//查看容器的日志<br></code></pre></td></tr></table></figure><h1>二、用 Sysdig 监控服务器和 Docker 容器</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker pull sysdig<br>//下载sysdig镜像<br></code></pre></td></tr></table></figure><h3 id="通过sysdig运行容器">通过sysdig运行容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -it --rm --name sysdig --privileged=true --volume=/var/run/docker.sock:/host/var/run/docker.sock  --volume=/dev:/host/dev --volume=/proc:/host/proc:ro  --volume=/boot:/host/boot:ro  --volume=/lib/modules:/host/lib/modules:ro --volume=/usr:/host/usr:ro  sysdig/sysdig<br></code></pre></td></tr></table></figure><h3 id="下载插件失败后可以运行下边命令，重新下载">下载插件失败后可以运行下边命令，重新下载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@10ccab83a512:/# system-sysdig-loader<br>//下载插件失败后可以运行下边命令，重新下载<br></code></pre></td></tr></table></figure><h3 id="下载成功后，可以运行sysdig命令，查看监控项">下载成功后，可以运行sysdig命令，查看监控项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@10ccab83a512:/# sysdig<br>//运行sysdig命令，查看监控项，它会动态查看<br></code></pre></td></tr></table></figure><h3 id="使用-csysdig"><strong>使用 csysdig</strong></h3><p>csysdig 就是运 ncurses 库的用户界面的 sysdig 软件包，Ncurses 是一个能提供功能键定义 ( 快捷键 ), 屏幕绘制以及基于文本终端的图形互动功能的动态库。在 sysdig 软件包里还提供了一个工具 csysdig，该工具执行后，运行界面和 top 命令类似。csysdig 工作界面如图 5。</p><p><img src="https://www.ibm.com/developerworks/cn/linux/1607_caoyq_sysdig/image005.jpg" alt="csysdig 工作界面"></p><h4 id="运行csysdig命令，查看监控项">运行csysdig命令，查看监控项</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@10ccab83a512:/# csysdig<br>//运行csysdig命令，图形化界面查看监控项，它会动态查看<br></code></pre></td></tr></table></figure><h4 id="csysdig-使用如下快捷键：">csysdig 使用如下快捷键：</h4><p><strong>P：暂停屏幕输出信息</strong></p><p><strong>Enter：进入当前突出显示的条目。</strong></p><p><strong>Ctrl+F：列表搜索。</strong></p><p><strong>F1- 帮助信息</strong></p><p><strong>F2- 显示视图选择器。这将让你切换到另一个视图。</strong></p><p><strong>F4- 使用过滤器</strong></p><p><strong>F5- 查看 IO 输出信息</strong></p><p><strong>F7 显示帮助页面当前显示的视图。</strong></p><p><strong>F8 打开视图的操作面板。</strong></p><p><strong>F9，打开列排序面板。</strong></p><p><strong>Q 放弃退出。</strong></p><p><strong>Arrows, PgUP, PgDn, Home, End：图标上下左右的移动控制。</strong></p><blockquote><p><strong>sysdig按不同的View来监控不同类型的资源，点击底部Views菜单（或者按F2），显示View选择列表</strong></p><p><strong>我们将光标移到Containers这一项，界面右边立即显示出此view的功能介绍，回车或者双击Containers，进入容器监控界面</strong></p><p><strong>sysdig会显示该host所有的容器的实时数据，每两秒刷新一次。各列数据的含义也是自解释的，如果不清楚，可以点一下底部的Legend，如果想按某一列排序，比如按使用的内存量，点一下列头VIRT</strong></p><p><strong>如果想查看某个容器的进程，将光标移动到目标容器，然后回车或者双击</strong></p><p><strong>还可以继续双击查看进程中的线程</strong></p><p><strong>返回上一级，按退格键即可</strong></p><p><strong>sysdig的交互功能很强，如果界面显示的条目很多，可以点击底部Search菜单，然后输入关键字进行查找</strong></p><p><strong>如果觉得界面刷新太快，看不清楚关注的信息，可以点击底部的Pause菜单</strong></p></blockquote><h3 id="sysdig的特点："><strong>sysdig的特点：</strong></h3><h4 id="（1）监控信息全，包括Linux操作系统和容器">（1）监控信息全，包括Linux操作系统和容器</h4><h4 id="（2）界面交互性强">（2）界面交互性强</h4><p><strong>其缺点是sysdig显示的是实时数据，看不到变化和趋势。而且是命令行操作方式，需要ssh到host上执行，不是太方便</strong></p><h3 id="总结"><strong>总结</strong></h3><p><strong>这些示例仅仅是展示了 Sysdig 能力的冰山一角，在目前的其他系统监控类工具中，笔者还没有看到像 Sysdig 这样功能如此强大、而又对容器支持这样好的。所以，对于经常使用服务器特别是 Docker 容器作为产品运行方式的用户，这是一款值得使用的系统工具。</strong></p><h1>三、Docker监控方案之Weave Scope</h1><p><strong>Weave Scope 的最大特点是会自动生成一张 Docker 容器地图，让我们能够直观地理解、监控和控制容器。千言万语不及一张图，先感受一下。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607182218823.png" alt="image-20200607182218823"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker pull scope<br>//下载scope镜像<br></code></pre></td></tr></table></figure><h3 id="执行如下脚本安装运行Weave-Scope"><strong>执行如下脚本安装运行Weave Scope</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# curl -L git.io/scope -o /usr/local/bin/scope<br>[root@docker01 ~]# chmod +x /usr/local/bin/scope<br>[root@docker01 ~]# scope launch<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223115631976.png" alt="image-20191223115631976"></p><h3 id="浏览器访问http-192-168-1-11-4040"><strong>浏览器访问http://192.168.1.11:4040/</strong></h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223115825581.png" alt="image-20191223115825581"></p><p><strong>然后就可以更好的监控，管理docker中的容器了</strong></p><h3 id="开启第docker02，加入docker01监控项"><strong>开启第docker02，加入docker01监控项</strong></h3><p><strong>docker01</strong></p><p><strong>删除weavescope容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker stop weavescope <br>weavescope<br>[root@docker01 ~]# docker rm weavescope <br>weavescope<br></code></pre></td></tr></table></figure><p><strong>docker02</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker pull scope<br>//下载scope镜像<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# curl -L git.io/scope -o /usr/local/bin/scope<br>[root@docker01 ~]# chmod +x /usr/local/bin/scope<br>[root@docker01 ~]# scope launch<br></code></pre></td></tr></table></figure><p><strong>docker01</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# scope launch 192.168.1.11 192.168.1.13<br></code></pre></td></tr></table></figure><p><strong>docker02</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# scope launch 192.168.1.13 192.168.1.11<br></code></pre></td></tr></table></figure><h3 id="浏览器访问http-192-168-1-11-4040-2"><strong>浏览器访问http://192.168.1.11:4040/</strong></h3><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223121541560.png" alt="image-20191223121541560"></p><p><strong>浏览器访问http://192.168.1.13:4040/也是可以的</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223121621404.png" alt="image-20191223121621404"></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sysdig </tag>
            
            <tag> Weave Scope </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker三剑客之docker-compose和搭建wordpress的博客</title>
      <link href="/posts/d728.html"/>
      <url>/posts/d728.html</url>
      
        <content type="html"><![CDATA[<h1>一、简介</h1><p><strong>Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。</strong></p><p><strong>通过之前的介绍，我们知道使用一个 Dockerfile 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</strong></p><p><strong>Compose 恰好满足了这样的需求。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</strong></p><h3 id="Compose-中有两个重要的概念："><strong>Compose 中有两个重要的概念：</strong></h3><p><strong>服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</strong><br><strong>项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</strong><br><strong>Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</strong></p><p><strong>使用微服务架构的系统一般包含若干个微服务，每个微服务一般部署多个实例。如果每个服务都要手动启停，那么效率低，维护量大。</strong></p><h1>二、 Docker Compose介绍</h1><p><strong>通过Docker-Compose用户可以很容易地用一个配置文件定义一个多容器的应用，然后使用一条指令安装这个应用的所有依赖，完成编写。Docker-Compose解决了容器与容器之间如何管理编排的问题。</strong></p><h3 id="Docker-Compose工作原理图">Docker Compose工作原理图</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607181245371.png" alt="image-20200607181245371"></p><h3 id="撰写中有两个重要的概念：">撰写中有两个重要的概念：</h3><ul><li>**服务（服务）：**一个应用的容器，实际上可以包括多个运行相同相同的容器实例。</li><li>**项目（项目）：**由各个关联的应用容器组成的一个完整的业务单元，在docker-compose.yml文件中定义。一个项目可以由多个服务（容器）关联，组成面向项目进行管理，通过子命令对项目中的单个容器进行便捷地生命周期管理。</li></ul><p>Compose项目由Python编写，实现上调用了Docker服务提供的API来对容器进行管理。因此，只要所操作的平台支持Docker API，就可以在其上利用Compose来进行编排管理。</p><h3 id="Docker三大编排工具："><strong>Docker三大编排工具：</strong></h3><ul><li><strong>Docker Compose：是用来组装多容器应用的工具，可以在 Swarm集群中部署分布式应用。</strong></li><li><strong>Docker Machine：是支持多平台安装Docker的工具，使用 Docker。Machine，可以很方便地在笔记本、云平台及数据中心里安装Docker。</strong></li><li><strong>Docker Swarm：是Docker社区原生提供的容器集群管理工具。</strong></li></ul><h3 id="Docker-Compose命令详解"><strong>Docker Compose命令详解</strong></h3><p><strong>Docker compose的使用非常类似于docker命令的使用，但是需要注意的是大部分的compose命令都需要到docker-compose.yml文件所在的目录下才能执行。</strong><br><strong>compose以守护进程模式运行加-d选项</strong></p><h1>三、Docker Compose安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">下载</span><br>sudo curl -L https://github.com/docker/compose/releases/download/1.20.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose<br><span class="hljs-meta">#</span><span class="bash">安装</span><br>chmod +x /usr/local/bin/docker-compose<br><span class="hljs-meta">#</span><span class="bash">查看版本</span><br>docker-compose version<br></code></pre></td></tr></table></figure><h1>四、实验环境</h1><table><thead><tr><th>主机</th><th>ip地址</th><th>服务</th></tr></thead><tbody><tr><td>docker</td><td>192.168.1.11</td><td>compose+wordpress</td></tr></tbody></table><h1>五 <strong>docker三剑客之docker-compose</strong></h1><p><em><strong>docker容器的编排工具: 解决相互有依赖关系的多个容器的管理。</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker-compose -v<br>//验证已有docker-compose命令<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223084424676.png" alt="image-20191223084424676"></p><h2 id="docker-compose的配置文件实例"><strong>docker-compose的配置文件实例</strong></h2><p><em><strong>通过识别一个docker-compose.yml的配置文件，去管理容器。</strong></em></p><h3 id="设置tab键的空格数量"><strong>设置tab键的空格数量</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# vim .vimrc<br>set tabstop=2<br>//设置tab键的空格数量<br>[root@docker01 ~]# source .vimrc <br>//刷新一下<br></code></pre></td></tr></table></figure><h3 id="创建一个docker-compose-yml测试文件"><strong>创建一个docker-compose.yml测试文件</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# mkdir compose_test<br>//创建测试目录<br>[root@docker01 ~]# cd compose_test/<br>[root@docker01 compose_test]# vim docker-compose.yml<br>//创建测试文件docker-compose.yml<br>version: "3"<br>services:<br>  nginx:<br>    container_name: web-nginx<br>    image: nginx<br>    restart: always<br>    ports:<br>      - 90:80<br>    volumes:<br>      - ./webserver:/usr/share/nginx/html<br></code></pre></td></tr></table></figure><h4 id="docker-compose-yml文件的解释"><strong>docker-compose.yml文件的解释</strong></h4><p><strong>第一部分: version: 指定语法格式的版本。</strong></p><p><strong>第二部分: service: 定义服务,(想要运行什么样的容器)</strong></p><h3 id="通过docker-compose-yml文件运行容器"><strong>通过docker-compose.yml文件<a href>运行</a>容器</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# docker-compose up -d<br>//后台运行docker-compose规定的容器。（在执行这条命令的当前目录下，也需要一个docker-compose.yml的配置文件，并且通常只有一个。）<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223091336129.png" alt="image-20191223091336129"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# docker ps<br>//查看容器信息<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223091432734.png" alt="image-20191223091432734"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# curl 127.0.0.1:90<br>//访问nginx会失败，因为挂载目录没有页面内容<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223091542832.png" alt="image-20191223091542832"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# vim webserver/index.html<br>//创建测试网页<br>xgp666<br>[root@docker01 compose_test]# curl 127.0.0.1:90<br>//再次访问，是成功的<br>xgp666<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223091825697.png" alt="image-20191223091825697"></p><h3 id="通过docker-compose-yml文件停止运行容器"><strong>通过docker-compose.yml文件<a href>停止运行</a>容器</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# docker-compose stop<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223092133334.png" alt="image-20191223092133334"></p><h3 id="通过docker-compose-yml文件重启容器"><strong>通过docker-compose.yml文件<a href>重启</a>容器</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# docker-compose restart<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223092201539.png" alt="image-20191223092201539"></p><h3 id="不在docker-compose-yml文件所在目录，要使用-f指定目录"><strong>不在docker-compose.yml文件所在目录，要使用<a href>-f</a>指定目录</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker-compose -f compose_test/docker-compose.yml  stop<br></code></pre></td></tr></table></figure><h3 id="并且，在运行container（docker-compose-yml）的过程中，还支持Dockerfile"><strong>并且，在运行container（docker-compose.yml）的过程中，还支持Dockerfile</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# vim Dockerfile<br>//编写dockerfile<br>FROM nginx<br>ADD webserver /usr/share/nginx/html<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# vim docker-compose.yml <br>//修改docker-compose.yml文件<br>version: "3"<br>services:<br>  nginx:<br>    build: .     #添加<br>    container_name: web-nginx<br>    image: new-nginx:v1.0   #修改镜像名称<br>    restart: always<br>    ports:<br>      - 90:80<br></code></pre></td></tr></table></figure><h4 id="通过docker-compose-yml文件停止并删除容器"><strong>通过docker-compose.yml文件<a href>停止并删除</a>容器</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# docker-compose stop<br>Stopping web-nginx ... done<br>[root@docker01 compose_test]# docker-compose rm<br></code></pre></td></tr></table></figure><h4 id="通过docker-compose-yml文件运行容器-2"><strong>通过docker-compose.yml文件<a href>运行</a>容器</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# docker-compose up -d<br>//通过docker-compose.yml文件[运行]()容器<br>[root@docker01 compose_test]# docker ps<br>//查看容器信息<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223094155625.png" alt="image-20191223094155625"></p><h4 id="测试nginx访问页面">测试nginx访问页面</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 compose_test]# curl 127.0.0.1:90<br>//测试访问nginx页面，成功<br>xgp666<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223094318146.png" alt="image-20191223094318146"></p><h1>六、搭建wordpress的博客</h1><h2 id="下载wordpress和mysql-5-7容器"><strong>下载wordpress和mysql:5.7容器</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker pull wordpress<br>//下载wordpress容器<br>[root@docker01 ~]# docker pull mysql：5.7<br>//下载mysql：5.7容器<br></code></pre></td></tr></table></figure><h2 id="编写一个docker-ccompose-yml">编写一个docker-ccompose.yml</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# mkdir wordpress<br>//创建wordpress测试文件<br>[root@docker01 ~]# cd wordpress/<br><br>[root@docker01 wordpress]# vim docker-compose.yml<br>//编写docker-compose.yml<br>version: "3.1"<br>services:<br>  wordpress:<br>    image: wordpress<br>    restart: always<br>    ports:<br>      - 8080:80<br>    environment:<br>      WORDPRESS_DB_HOST: db<br>      WORDPRESS_DB_USER: wordpress<br>      WORDPRESS_DB_PASSWORD: 123.com<br>      WORDPRESS_DB_NAME: wordpress<br>  db:<br>    image: mysql:5.7<br>    restart: always<br>    environment:<br>      MYSQL_DATABASE: wordpress<br>      MYSQL_USER: wordpress<br>      MYSQL_PASSWORD: 123.com<br>      MYSQL_ROOT_PASSWORD: 123.com<br></code></pre></td></tr></table></figure><h3 id="通过docker-compose-yml文件运行容器-3"><strong>通过docker-compose.yml文件<a href>运行</a>容器</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 wordpress]# docker-compose up -d<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223100139125.png" alt="image-20191223100139125"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 wordpress]# docker ps<br>//查看容器信息<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223100236380.png" alt="image-20191223100236380"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 wordpress]# docker logs  容器名称<br>//查看容器日志<br></code></pre></td></tr></table></figure><h3 id="浏览器访问一下-http-192-168-1-11-8080"><strong>浏览器访问一下</strong> <a href="http://192.168.1.11:8080/" target="_blank" rel="noopener">http://192.168.1.11:8080/</a></h3><p><strong>选择语言</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223104436304.png" alt="image-20191223104436304"></p><p><strong>安装wordpress</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223104604591.png" alt="image-20191223104604591"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223104630540.png" alt="image-20191223104630540"></p><p><strong>登陆wordpress</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223104649709.png" alt="image-20191223104649709"></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191223105646408.png" alt="image-20191223105646408"></p><p><strong>登陆成功后，自己就可以进行设置了</strong></p><h1>排错</h1><ul><li><strong>首先查看主机名是否更改</strong></li><li><strong>防火墙和selinux是否关闭</strong></li><li><strong>docker-compose命令是否安装给予权限</strong></li><li><strong>docker–compose.yml 编写是否有问题</strong></li><li><strong>容器执行是否正常</strong></li><li><strong>（如果浏览器访问不到，可以添加一条路由转发）</strong></li></ul><h1>其他wordpress优化建议</h1><p><strong>以上步骤之后，基本wordpress搭建和一些必备的设置就算完成了，剩下的更多是个人的选择，每个人可能要求不同，下面就说几点wordpress优化的建议</strong></p><p><strong>1.无论你是做百度seo，安装一个SEO插件，就算不想设置文章的TDK，至少网站首页的有必要设置一下，推荐 All in one seo pack</strong><br><strong>2.定期备份，备份的重要性不用多说，凡是丢过数据的人都会养成备份的习惯，WordPress备份网站方法</strong><br><strong>3.安装一个安全插件，WordPress安全插件推荐</strong><br><strong>4.及时更新网站的主题和插件，WordPress插件自动更新方法</strong><br><strong>5.删除所有没有用的主题和插件，WordPress删除主题方法</strong><br><strong>6.设置垃圾留言过滤，wordpress防垃圾留言插件Akismet</strong></p><p><strong>WordPress建站基础主要就是这些，后面的话就是根据自己的站点进行各种设置，不同类型的站点使用主题和插件都是很大区别的。不过如果你能学会本篇所介绍的内容，相信你的站点就已经超过了绝大部分网站，好了今天教程就到这里，如果你有什么问题或者其他更好的建议，欢迎留言讨论</strong></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker-compose </tag>
            
            <tag> wordpress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx+docker+nfs部署</title>
      <link href="/posts/24f3.html"/>
      <url>/posts/24f3.html</url>
      
        <content type="html"><![CDATA[<h1>一．体系架构</h1><p>在Keepalived + Nginx高可用负载均衡架构中，keepalived负责实现High-availability (HA) 功能控制前端机VIP（虚拟网络地址），当有设备发生故障时，热备服务器可以瞬间将VIP自动切换过来，实际运行中体验只有2秒钟切换时间，DNS服务可以负责前端VIP的负载均衡。<br>nginx负责控制后端web服务器的负载均衡，将客户端的请求按照一定的算法转发给后端Real Server处理，而Real Server将响应直接返回给客户端。<br>nfs服务器做实时备份，给web服务器提供web界面。</p><h1>二．简单原理</h1><p>NGINX_MASTER、NGINX_BACKUP两台服务器均通过keepalived软件把ens33网卡绑上一个虚拟IP（VIP）地址192.168.1.40，此VIP当前由谁承载着服务就绑定在谁的ens32上，当NGINX_MASTER发生故障时，NGINX_BACKUP会通过/etc/keepalived/keepalived.conf文件中设置的心跳时间advert_int 1检查，无法获取NGINX_MASTER正常状态的话，NGINX_BACKUP会瞬间绑定VIP来接替nginx_master的工作，当NGINX_MASTER恢复后keepalived会通过priority参数判断优先权将虚拟VIP地址192.168.1.40重新绑定给NGINX_MASTER的ens33网卡。<br><strong>使用此方案的优越性</strong><br>1.实现了可弹性化的架构，在压力增大的时候可以临时添加web服务器添加到这个架构里面去;<br>2.upstream具有负载均衡能力，可以自动判断后端的机器，并且自动踢出不能正常提供服务的机器；<br>3.相对于lvs而言，正则分发和重定向更为灵活。而Keepalvied可保证单个nginx负载均衡器的有效性，避免单点故障；<br>4.用nginx做负载均衡，无需对后端的机器做任何改动。<br>5.nginx部署在docker容器里，即大量地节约开发、测试、部署的时间，又可以在出现故障时通过镜像快速恢复业务。</p><h1>三、系统环境</h1><p><strong>两台负载机器安装：，nginx+docker+nfs 分别命名为：NGINX_MASTER，NGINX_BACKUP。</strong><br><strong>后端web服务器，可以是提供web服务的任何架构，分别命名为：WEB_1，WEB_2。</strong><br><strong>后端数据库机器可任意架构，只要能提供数据库服务即可。</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191221085649190.png" alt="image-20191221085649190"></p><table><thead><tr><th>服务器</th><th>IP地址</th><th>安装软件</th></tr></thead><tbody><tr><td>NGINX_MASTER</td><td>192.168.1.10</td><td>nginx+keepalived</td></tr><tr><td>NGINX_BACKUP</td><td>192.168.1.20</td><td>nginx+keepalived</td></tr><tr><td>WEB_1</td><td>192.168.1.11</td><td>docker+nginx</td></tr><tr><td>WEB_2</td><td>192.168.1.13</td><td>docker+nginx</td></tr><tr><td>nfs_MASTER</td><td>192.168.1.30</td><td>nfs+rsync+inotify</td></tr><tr><td>nfs_BACKUP</td><td>192.168.1.10</td><td>nfs+rsync+inotify</td></tr></tbody></table><h1>nginx（两台都是）</h1><p><strong>安装nginx</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nginx01 ~]# tar zxf nginx-1.14.0.tar.gz <br>//解压nginx安装包<br>[root@nginx01 ~]# cd nginx-1.14.0/<br>[root@nginx01 nginx-1.14.0]# yum -y install openssl-devel pcre-devel zlib-devel<br>//安装nginx依赖包<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nginx01 nginx-1.14.0]# ./configure --prefix=/usr/local/nginx1.14 --with-http_dav_module --with-http_stub_status_module --with-http_addition_module  --with-http_sub_module --with-http_flv_module --with-http_mp4_module --with-pcre --with-http_ssl_module --with-http_gzip_static_module --user=nginx --group=nginx &amp;&amp; make  &amp;&amp;  make install<br>//编译安装nginx<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nginx01 nginx-1.14.0]# useradd nginx -s /sbin/nologin -M<br>//创建所需用户<br>[root@nginx01 nginx-1.14.0]# ln -s /usr/local/nginx1.14/sbin/nginx /usr/local/sbin/<br>//链接命令<br>[root@nginx01 nginx-1.14.0]# nginx <br>//开启nginx<br>[root@nginx01 nginx-1.14.0]# netstat -anpt | grep nginx<br>//查看nginx是否开启<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191221090519105.png" alt="image-20191221090519105"></p><p><strong>部署nginx</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nginx01 ~]# cd /usr/local/nginx1.14/conf/<br>[root@nginx01 conf]# vim nginx.conf<br></code></pre></td></tr></table></figure><p>​        http模块加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">upstream backend &#123;<br>server 192.168.1.11:90 weight=1 max_fails=2 fail_timeout=10s;<br>server 192.168.1.13:90 weight=1 max_fails=2 fail_timeout=10s;<br>&#125;<br></code></pre></td></tr></table></figure><pre><code>    location / {       # root   html;       # index  index.html index.htm;       proxy_pass http://backend;  #添加    }</code></pre><h2 id="高可用环境">高可用环境</h2><h4 id="安装keepalived"><strong>安装keepalived</strong></h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">[<span class="hljs-symbol">root@</span>nginx02 nginx<span class="hljs-number">-1.14</span><span class="hljs-number">.0</span>]# yum -y install keepalived<br></code></pre></td></tr></table></figure><h4 id="配置keepalived"><strong>配置keepalived</strong></h4><p><strong>修改主和备nginx服务器上的keepalived 配置文件 /etc/keepalived/keepalived.conf 文件</strong></p><h4 id="主nginx"><strong>主nginx</strong></h4><p><strong>修改主nginx下/etc/keepalived/keepalived.conf文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">! Configuration File for keepalived<br>global_defs &#123;<br>   router_id LVS_DEVEL<br>&#125;   <br>vrrp_instance VI_1 &#123;<br>    state MASTER<br>    interface ens33<br>    virtual_router_id 51<br>    priority 100<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 1111<br>    &#125;   <br>    virtual_ipaddress &#123;<br>        192.168.1.40<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="备nginx"><strong>备nginx</strong></h3><p><strong>修改备nginx下 /etc/keepalived /keepalived.conf文件</strong></p><p><strong>配置备nginx时需要注意：需要修改state为BACKUP , priority比MASTER低，virtual_router_id和master的值一致</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">! Configuration File for keepalived<br>global_defs &#123;<br>   router_id TWO<br>&#125;<br><br>vrrp_instance VI_1 &#123;<br>    state BACKUP<br>    interface ens33<br>    virtual_router_id 1<br>    priority 99<br>    advert_int 1<br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass 1111<br>    &#125;<br>    virtual_ipaddress &#123;<br>        192.168.1.40<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试（在做完docker的时候）"><strong>测试（在做完docker的时候）</strong></h3><p><strong>主备nginx都启动keepalived</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl  start  keepalived<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nginx01 conf]# curl 192.168.1.40<br>wsd666<br></code></pre></td></tr></table></figure><h1>nfs（两台都是)</h1><h2 id="nfs操作">nfs操作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# yum -y install nfs-utils<br>//下载nfs服务<br><br>[root@nfs ~]# mkdir /database<br>//创建共享目录<br>[root@nfs02 ~]# chmod 777 /database/<br>//设置权限<br>[root@nfs ~]# vim /etc/exports<br>//设置权限如下<br>/database *(rw,sync,no_root_squash)<br></code></pre></td></tr></table></figure><h3 id="开启各项服务">开启各项服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs ~]# systemctl start rpcbind<br>[root@nfs ~]# systemctl enable rpcbind<br>[root@nfs ~]# systemctl start nfs-server<br>[root@nfs ~]# systemctl enable nfs-server<br></code></pre></td></tr></table></figure><h3 id="docker01和docker02测试nfs">docker01和docker02测试nfs</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs01 ~]# vim /etc/rsyncd.conf <br>//建立rsync配置文件<br>uid = nobody<br>gid = nobody<br>use chroot = yes<br>address = 192.168.1.30<br>port 873<br>log file = /var/log/rsyncd.log<br>pid file = /var/run/rsyncd.pid<br>hosts allow = 192.168.1.0/24<br>[wwwroot]<br>path = /database<br>read only = no<br>dont compress = *.gz *.bz2 *.rar *.zip<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs01 ~]# mkdir /database<br>//创建共享目录<br>[root@nfs01 ~]# rsync --daemon<br>//启动rsync<br>[root@nfs01 ~]# netstat -anpt | grep rsync<br>//查看端口<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191221094558212.png" alt="image-20191221094558212"></p><p><strong>如果需要重启rsync服务，需要：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# kill  $(cat /var/run/rsyncd.pid)<br>//停止服务<br>[root@localhost ~]# rsync --daemon<br>//启动服务<br>[root@localhost ~]# kill -9 $(cat /var/run/rsyncd.pid)<br></code></pre></td></tr></table></figure><p><strong>或者直接使用“netstat -anpt | grep rsync”命令查出进程号，使用“kill 进程号”一样。</strong><br><strong>使用第一种方法停止rsync服务必须删除存放rsync服务进程的文件：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# rm -rf /var/run/rsyncd.pid<br></code></pre></td></tr></table></figure><h3 id="使用rsync备份工具">使用rsync备份工具</h3><p>配置好rsync同步源服务器之后，客户端就可以使用rsync工具来执行远程同步了。</p><h5 id="与rsync主机同步">与rsync主机同步</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">rsync命令的选项：<br>-r：递归模式，包含目录及子目录中所有文件<br>-l：对于符号链接文件仍然复制为符号链接文件<br>-p：保留文件的权限标记<br>-t：保留文件的时间标记<br>-g：保留文件的属组标记（仅超级用户使用）<br>-o：保留文件的属主标记（仅超级用户使用）<br>-D：保留设备文件及其他特殊文件<br>-a：归档模式，递归并保留对象属性，等同于 -rlptgoD<br>-v：显示同步过程的详细（verbose）信息<br>-z：在传输文件时进行压缩（compress）<br>-H：保留硬连接文件<br>-A：保留ACL属性信息<br>--delete：删除目标位置有而原始位置没有的文件<br>--checksum：根据对象的校验和来决定是否跳过文件<br></code></pre></td></tr></table></figure><p><strong>rsync是一款快速增量备份工具，支持：<br>（1）本地复制；<br>（2）与其他SSH同步；<br>（3）与rsync主机同步。</strong></p><h5 id="手动与rsync主机同步">手动与rsync主机同步</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# rsync -avz 192.168.1.1::wwwroot /root<br>或者<br>[root@localhost ~]# rsync -avz rsync://192.168.1.1/wwwroot /root<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs01 database]# vim index.html<br>xgp666<br>//创建测试目录<br></code></pre></td></tr></table></figure><h2 id="配置inotify-rsync实时同步（两台都是）">配置inotify+rsync实时同步（两台都是）</h2><h2 id="1-、软件安装"><strong>(1)、软件安装</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rpm -q rsync //查询rsync是否安装，一般为系统自带安装<br>yum install rsync -y //若没有安装，使用yum安装<br></code></pre></td></tr></table></figure><p><strong>安装inotify软件包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs02 ~]# tar zxf inotify-tools-3.14.tar.gz <br>[root@nfs02 ~]# cd inotify-tools-3.14/<br>[root@nfs02 inotify-tools-3.14]#  ./configure &amp;&amp; make &amp;&amp; make install<br></code></pre></td></tr></table></figure><h2 id="（2）调整inotify内核参数"><strong>（2）调整inotify内核参数</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs02 ~]# vim /etc/sysctl.conf<br>fs.inotify.max_queued_events = 16384<br>fs.inotify.max_user_instances = 1024<br>fs.inotify.max_user_watches = 1048576<br><br>[root@nfs02 ~]# sysctl -p<br>//生效<br></code></pre></td></tr></table></figure><h2 id="3-编写触发式同步脚本"><strong>(3)  编写触发式同步脚本</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>A="inotifywait -mrq -e modify,move,create,delete /database/"<br>B="rsync -avz  /database/ 192.168.1.40::wwwroot"<br><span class="hljs-meta">$</span><span class="bash">A | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> DIRECTORY EVENT FILE</span><br>do<br>    if [ $(pgrep rsync | wc -l) -gt 0 ] ; then<br>        $B<br>    fi<br>done<br></code></pre></td></tr></table></figure><p><em><strong>此处需要注意，在两台服务器需要同步的目录之间，也需要将目录权限放到最大，避免因目录本身权限报错。</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs01 inotify-tools-3.14]# chmod  +x /opt/ino.sh<br></code></pre></td></tr></table></figure><p><strong>设置脚本开机自启</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs01 database]# vim /etc/rc.d/rc.local <br>/opt/ino.sh &amp;<br>/usr/bin/rsync --daemon<br></code></pre></td></tr></table></figure><p><strong>源服务器端测试</strong></p><ul><li><strong>执行脚本后，当前终端会变成实时监控界面，需要重新打开终端操作。</strong></li><li><strong>在源服务器端共享模块目录下进行文件操作，然后去备份服务器下，可观察到文件已经被实时同步。</strong></li></ul><h1>docker(两台都是)</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker pull nginx<br>[root@docker01 ~]# mkdir -p  /www  <br>//创建挂载目录<br></code></pre></td></tr></table></figure><p><strong>nfs创建好之后docker上挂载目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]#  mount  -t nfs 192.168.1.30:/database /www<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -itd --name nginx -p 90:80 -v /www/index.html:/usr/share/nginx/html/index.html nginx:latest<br></code></pre></td></tr></table></figure><h1>测试</h1><h3 id="1、当NGINX-MASTER、NGINX-BACKUP服务器nginx均正常工作时"><strong>1、当NGINX_MASTER、NGINX_BACKUP服务器nginx均正常工作时</strong></h3><p>在NGINX_MASTER上：<br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607180653184.png" alt="image-20200607180653184"><br><strong>在NGINX_BACKUP上：</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607180710155.png" alt="image-20200607180710155"><br><strong>master服务器ens32网卡正常绑定VIP，而backup却没有绑定，通过浏览器可正常访问网站。</strong></p><h3 id="2、关闭NGINX-MASTER的nginx容器"><strong>2、关闭NGINX_MASTER的nginx容器</strong></h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607180746591.png" alt="image-20200607180746591"><br><strong>当nginx容器停止后，马上就又启起来了，nginx启动脚本没问题</strong></p><h3 id="3、关闭NGINX-MASTER的keepalived服务"><strong>3、关闭NGINX_MASTER的keepalived服务</strong></h3><p><strong>在NGINX_MASTER上：</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607180759036.png" alt="image-20200607180759036"><br><strong>在NGINX_BACKUP上：</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607180808979.png" alt="image-20200607180808979"><br><strong>NGINX_BACKUP的ens32网卡已瞬间绑定VIP，通过浏览器访问网站正常。</strong></p><h3 id="4、将NGINX-MASTER的keepalived服务启动"><strong>4、将NGINX_MASTER的keepalived服务启动</strong></h3><p><strong>在NGINX_MASTER上：</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607180822420.png" alt="image-20200607180822420"><br><strong>在NGINX_BACKUP上：</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607180836219.png" alt="image-20200607180836219"><br><strong>NGINX_MASTER的ens32网卡重新绑定VIP，通过浏览器访问网站正常。</strong></p><h3 id="5、关闭WEB-1服务器，通过浏览器访问网站正常。"><strong>5、关闭WEB_1服务器，通过浏览器访问网站正常。</strong></h3><h1>排错</h1><p><strong>首先查看nginx配置文件是否有问题</strong><br><strong>两台keepakived的各项参数是否正常</strong><br><strong>docker上nginx是否映射端口，挂载nfs的共享目录。</strong><br><strong>nfs是否设置目录权限。是否配置rsync+inotify，写一个shell来做实时备份。</strong></p><h1>总结：</h1><p><strong>首先是镜像，就是拉取nginx的镜像。然后再把nginx镜像重建一下，就是变成我们需要的，主要就是改配置文件。然后把所有镜像push到harbor上</strong></p><p><strong>搭建nginx，做反向代理。</strong><br><strong>搭建docker，安装nginx镜像做测试做页面，测试面是从nfs共享来的。</strong><br><strong>搭建NFS，为了实现数据共享，包括数据库，就是持久化的。还要通过rsync+inotify，做到实时备份。</strong></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> nfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker部署LNMP环境</title>
      <link href="/posts/32f5.html"/>
      <url>/posts/32f5.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"> ifdown ens33;ifup ens33<br>//重启网卡<br></code></pre></td></tr></table></figure><p><strong>首先要有确认环境中有需要的tar包，可以使用<a href>docker pull</a>来下载这些镜像</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191220084542746.png" alt="image-20191220084542746"></p><p><strong>现在我们是使用已经下载好的镜像，所以需要导入一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker load -i nginx.tar  &amp;&amp; docker load -i wordpress.tar  &amp;&amp; docker load -i mysql-5.7.tar &amp;&amp; docker load -i php.7.2-fpm.tar<br>//导入nginx,wordpress,mysql,php镜像<br></code></pre></td></tr></table></figure><h3 id="整个流程："><strong>整个流程：</strong></h3><ul><li><strong>客户端http请求服务器80端口，该端口被映射到Nginx容器80端口，进入Nginx处理。</strong></li><li><strong>Nginx分析请求，如果是静态资源，直接服务器读取内容；如果是PHP脚本，通过PHP容器调用服务器获取脚本，然后FastCGI处理。</strong></li><li><strong>FastCGI解析PHP脚本，必要时访问MySQL容器读写数据。</strong></li></ul><h1>部署LNMP</h1><p><a href><strong>172.16.10.0/24</strong></a></p><p><a href><strong>Nginx：172.16.10.10</strong></a></p><p><a href><strong>Mysql：172.16.10.20</strong></a></p><p><a href><strong>Php    ：172.16.10.30</strong></a></p><p><em><strong>网站的访问主目录：/wwwroot</strong></em></p><p><em><strong>Nginx的配置文件：/docker</strong></em></p><p><em><strong>/etc/nginx/conf.d   #nginx配置文件</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -itd --name test nginx:latest <br>//先启动一台nginx，用来拷贝配置文件和访问主目录<br>[root@docker01 ~]# mkdir  -p /wwwroot /docker<br>//创建挂载目录<br>[root@docker01 ~]# docker cp test:/etc/nginx /docker/<br>//拷贝配置文件到挂载目录<br>[root@docker01 ~]# ls /docker/<br>nginx<br></code></pre></td></tr></table></figure><p><em><strong>/usr/share/nginx/html  #nginx主目录</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker cp test:/usr/share/nginx/html /wwwroot/<br>//拷贝访问目录到挂载目录<br>[root@docker01 ~]# ls /wwwroot/<br>html<br></code></pre></td></tr></table></figure><h2 id="1）创建一个自定义网络">1）创建一个自定义网络</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker network create -d bridge --subnet 172.16.10.0/24 --gateway 172.16.10.1 lnmp<br></code></pre></td></tr></table></figure><h2 id="2-运行nginx容器">2)运行nginx容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# netstat -anpt | grep 80<br>//查看80端口是否被占用<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -itd --name nginx -v /docker/nginx:/etc/nginx -v /wwwroot/html:/usr/share/nginx/html   -p 80:80 --network lnmp --ip 172.16.10.10 nginx<br>//运行一台nginx服务，并指明ip，映射端口，挂载目录<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker ps<br>//查看容器是否存在<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net//k8s/image-20191220091933217.png" alt="image-20191220091933217"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# cd /wwwroot/html<br>[root@docker01 wwwroot]# vim index.html<br>hello lnmp!<br>//创建测试网页<br><br>[root@docker01 wwwroot]# curl 127.0.0.1<br>hello lnmp!<br>//测试访问<br></code></pre></td></tr></table></figure><h2 id="3-运行mysql容器">3)运行mysql容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 html]# docker run --name mysql -e MYSQL_ROOT_PASSWORD=123.com -d -p 3306:3306 --network lnmp --ip 172.16.10.20 mysql:5.7<br>//运行一台nginx服务，并指明ip，映射端口<br></code></pre></td></tr></table></figure><p><em><strong>-e：设置环境变量</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker ps<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20191220120001710.png" alt="image-20191220120001710"></p><p><strong>安装mysql，并设置密码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 html]# yum -y install mysql<br>//安装mysql<br>[root@docker01 ~]# mysql -u root -p123.com -h 127.0.0.1 -P 3306<br></code></pre></td></tr></table></figure><p><strong>随便新建一个库做验证：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">MySQL [(none)]&gt; create database name;<br></code></pre></td></tr></table></figure><p><strong>再查看有没有刚创建的库：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">MySQL [(none)]&gt; show databases;<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20191220140326212.png" alt="image-20191220140326212"></p><h2 id="4-运行php容器，并创建php页面">4)运行php容器，并创建php页面</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 html]# docker run -itd --name phpfpm -p 9000:9000 -v /wwwroot/html:/usr/share/nginx/html --network lnmp --ip 172.16.10.30 php:7.2-fpm<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# cd /wwwroot/html<br>[root@docker01 wwwroot]# vim test.php<br>&lt;?php<br>phpinfo();<br>?&gt;<br>//添加php测试界面<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker ps<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20191220120518271.png" alt="image-20191220120518271"></p><h2 id="5-修改nginx配置文件，nginx和php连接">5)修改nginx配置文件，nginx和php连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 html]# cd /docker/nginx/conf.d/<br>[root@docker01 conf.d]# vim default.conf<br></code></pre></td></tr></table></figure><pre><code>location / {    root   /usr/share/nginx/html;    index  index.html index.htm index.php; #10添加index.php}</code></pre><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20191220094715896.png" alt="image-20191220094715896"></p><pre><code>location ~ \.php$ {             root    /usr/share/nginx/html;            fastcgi_pass   172.16.10.30:9000;    fastcgi_index  index.php;    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;        include        fastcgi_params;    }</code></pre><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20191220095010644.png" alt="image-20191220095010644"></p><p><strong>设置完毕后重启nginx</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 conf.d]# docker restart nginx<br>//重启nginx<br>[root@docker01 conf.d]# docker ps<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20191220140527498.png" alt="image-20191220140527498"></p><p><strong>浏览器测试访问nginx和php</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/WC%7D%7B4@W%5DSXSI8PHBJM%7BM4S.png" alt="img"></p><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20191220101602664.png" alt="image-20191220101602664"></p><p><strong>说明是nginx和php的连接，没有问题，接下来是php和MySQL的连接。这里我们使用一个phpmyadmin的数据库管理工具</strong></p><h2 id="6-修改nginx配置文件，php和mysql连接">6)修改nginx配置文件，php和mysql连接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 html]# cd /wwwroot/html<br></code></pre></td></tr></table></figure><p><strong>上传phpMyAdmin包如果没有请在https://github.com/phpmyadmin/phpmyadmin/releases下载</strong></p><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20191220113901886.png" alt="image-20191220113901886"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 html]# unzip phpMyAdmin-4.9.1-all-languages.zip <br>//解压phpmyadmin包<br>[root@docker01 html]# mv phpMyAdmin-4.9.1-all-languages phpmyadmin<br>//更改刚刚解压文件的名称<br>[root@docker01 html]#  cd  /docker/nginx/conf.d/<br>[root@docker01 conf.d]#  vim default.conf <br>//修改nginx配置文件<br>[root@docker01 conf.d]#  docker restart nginx <br>//重启nginx<br></code></pre></td></tr></table></figure><pre><code>        location /phpmyadmin {                root   /usr/share/nginx/html;                index   index.html index.htm index.php;    }</code></pre><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20191220121324472.png" alt="image-20191220121324472"></p><pre><code>    location ~ /phpmyadmin/(?&lt;after_ali&gt;(.*)\.(php|php5)?$) {        root           /usr/share/nginx/html;        fastcgi_pass   172.16.10.30:9000;        fastcgi_index  index.php;        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;        include        fastcgi_params;    }</code></pre><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20191220101300471.png" alt="image-20191220101300471"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 conf.d]# docker restart nginx <br>[root@docker01 conf.d]# docker ps<br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20191220105419384.png" alt="image-20191220105419384"></p><p><strong>浏览器访问 <a href="http://192.168.1.11/phpmyadmin/index.php" target="_blank" rel="noopener">http://192.168.1.11/phpmyadmin/index.php</a></strong></p><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20191220134345698.png" alt="image-20191220134345698"></p><p><em>报红框属于正常现象，不要惊慌，接下来就解决它</em></p><p><strong>需要我们对php镜像做出更改，添加php和MySQL连接模块</strong></p><p><strong>编写一个Dockerfile</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 conf.d]# cd <br>[root@docker01 ~]# vim Dockerfile<br>FROM php:7.2-fpm<br>RUN apt-get update &amp;&amp; apt-get install -y \<br>        libfreetype6-dev \<br>        libjpeg62-turbo-dev \<br>        libpng-dev \<br>    &amp;&amp; docker-php-ext-install -j$(nproc) iconv \<br>    &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \<br>    &amp;&amp; docker-php-ext-install -j$(nproc) gd \<br>        &amp;&amp; docker-php-ext-install mysqli pdo pdo_mysql<br></code></pre></td></tr></table></figure><p><strong>基于dockerfile创建php镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker build -t phpmysql .<br>//基于Dockerfiler创建一个镜像<br></code></pre></td></tr></table></figure><p><strong>删除之前的php容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker stop phpfpm<br>[root@docker01 ~]# docker rm phpfpm <br>//关闭并删除php容器<br></code></pre></td></tr></table></figure><p><strong>用新的php镜像运行容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -itd --name phpfpm -p 9000:9000 -v /wwwroot/html:/usr/share/nginx/html --network lnmp --ip 172.16.10.30 phpmysql<br>//用新做的php镜像重新运行<br></code></pre></td></tr></table></figure><p><strong>//修改phpmyadmin的配置文件，指定连接的数据库的IP，然后重启php容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 html]# cd /wwwroot/html/phpmyadmin/<br>[root@docker01 phpmyadmin]# cp config.sample.inc.php  config.inc.php<br>[root@docker01 phpmyadmin]# vim config.inc.php<br><span class="hljs-meta">$</span><span class="bash">cfg[<span class="hljs-string">'Servers'</span>][<span class="hljs-variable">$i</span>][<span class="hljs-string">'auth_type'</span>] = <span class="hljs-string">'cookie'</span>;</span><br>/* Server parameters */<br><span class="hljs-meta">$</span><span class="bash">cfg[<span class="hljs-string">'Servers'</span>][<span class="hljs-variable">$i</span>][<span class="hljs-string">'host'</span>] = <span class="hljs-string">'172.16.10.20'</span>;   <span class="hljs-comment">#31写mysql数据库的IP地址</span></span><br><span class="hljs-meta">$</span><span class="bash">cfg[<span class="hljs-string">'Servers'</span>][<span class="hljs-variable">$i</span>][<span class="hljs-string">'compress'</span>] = <span class="hljs-literal">false</span>;</span><br><span class="hljs-meta">$</span><span class="bash">cfg[<span class="hljs-string">'Servers'</span>][<span class="hljs-variable">$i</span>][<span class="hljs-string">'AllowNoPassword'</span>] = <span class="hljs-literal">false</span>;</span><br></code></pre></td></tr></table></figure><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20191220104852352.png" alt="image-20191220104852352"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 phpmyadmin]# docker restart phpfpm <br>//重启phpfpm容器<br></code></pre></td></tr></table></figure><p>浏览器测试访问http://192.168.1.11/phpmyadmin/index.php</p><p>用户名：root 密码：<a href="http://123.com" target="_blank" rel="noopener">123.com</a></p><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20191220135242858.png" alt="image-20191220135242858"></p><p><img src="http://xgp-cunchu.test.upcdn.net/k8s/image-20191220135332412.png" alt="image-20191220135332412"></p><p><em><strong>登陆成功之后可以看到之前mysql创建的数据库</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lnmp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业级私有仓库镜像仓库Harbor</title>
      <link href="/posts/7597.html"/>
      <url>/posts/7597.html</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="15000e4890a2e4578b32c48443de705af9335e890e50a133f51bc90792abb033">3f00a74e63e9d80a3ff53b152c2cd2764102fa52233ff53fda13a63997fe70c26775769d5e0540ba74df0c53eb09cac851ff8d25da00e3905da427f42188e14ad06f95189615e1f536f1bf0cf4552fde09a839bc509d2be83755f8c6931d95daefb509c74c1ee32db354196cbba09effb7c9d2c01be35d0d8d305389d93ac3bcf6e6b9e9177f6a42aa61afb18bd2f8e755ee42000b01530ecc61a6c2f11c16b732a5593ccc9492e98e12765ced10fbdf81cb6aee019e923d65b9e24b2ef35ad348692b32d0b4a38f16efd11366fec71c48dc5980b7dd0256a7ea76c38eded16ac575cb99f9501f88c4ccafc943aac237ca0ad347bbd6e38200414335bbc54c0fd4fab06cb0c9c2db9af5de15d13c36784906f7e827eebdca013564dc4ca06859da1df73b0bf69f97d57471d3acb3f15a84fb6079bcb179356fa28ebd44e0c52b05913381fd522f1d8f86c99c13858e4716f9d739b6c244aa1c7e91b2be7c5119906eff75ae4f1fda4b74107e6b7385b55ea35db47691dfd373a68672925d775b6818c3d9852a2ec677c2b6f0d4a12156a9a242db65b4fbbae3138932c0a25ec499ddbd655e1cbcbee6252ace0b2794a7c4a19172fb28e5ba74c0aeb7c18a5c589abeef9e06c3b80a9287c019037d5b8257bc57c3f7524b20d0acf7ac93c164422d6f0e22814c2434916c00e493f79e876788fab97536c518cc022fe29813757fc366f042c65d3c0f52a363cef9b63ec388ab62c119f2d456f6706ba89bf38e1ffaeb834fb93667893a0df7809a3f6ddb6b0afb1dd571daf01373ed6e2fe224e6f9f63c6165a59d2c265cd59a2b3dbc2dc2c65b6192451201bcdab1dd34224feff28ec8a79ea1e7264904d8c7d88cd45755d62cb440bc5d8a1a5238866b9636f1bc5dab7631910ddcbc494cba27986d1aad85431bdd2b19cc46244d596dd64bf223ed539de5a24b2f99b2856b149ca130c7b43dc6274b58e3f29bae012bfb742ef9ae8a15e3a56f39b82b466a22aa6f1f97d6d4253961d6516fcdb2c7855a3cfce330867f8dfada7b13070620480ba2c26df549a50839e7195023015fdfa6e2d4be9a428b4fa55e75045927e162b8a7e8807244e004aba283542f73def1935367025e58171238f2e06802b1314b0d26bda59e189bfb72d59d80ae51b22f3b8c06944a4a0dfe5ccb6ef24bf3664af586598441bb3db883a333c27a509892cb1e1ec80c3e8bcdda37bc191d3f8b575bae27be0cc262db873874f0a67a5b15af385c583a7eb19c68bb407e379e5140299c28b27060f465dcd7301f976c49524fb8252330eb48f3dcde4c95adb583bcda2a7a309dbe4b77fb32bcfaab253d9ff36ff3bb15e4d88b57dfd7c60ca06aa21db32e6b621022093ff68741403e64e3278a09520fe5f1a3b1490d4edea730ba6684db11b416a38466253a2a3552eba5823899eaa28662c3415afeedda527e626f464e2dd40f437d16ac205a07002b109970552ff695861408f5724e66dc8ff3ce675d1094401d621ca493e0c22bbc60a8819b17bd1f6819c53347976e78f14766e786275554e47e12e8174f206a7b7e062a8e03ee52808d10112b6696b985b9d86a573bfb3b4379672639031a117cb460ab03ebeb93241ae53aca739bd2c0c0fe06584b90262901a50fa43b45c583d23ee760c6ff6101a9154cc29b96181b94f3e5126e3bb7128a424f78bb390f083bbc8ff41de0c5efca4548cf8124fca73b51d2ec40a1a66ba5d1e1d3048148360780c92dd50e79f7d1b8e16c91ce432c80e184c12b7a067c87ab42821091f3d6a7c509b7c663b9c6c0c6035f5f03e00d1533330fa6915f0638e23b3fa4d953b83bdbc871313205305b679b534965b90bee3c6b6388948b0347dfca434a238afb1ae23f9d5c118542c667e7cb4eb66caff494d367df9ff46a465e72d5ea1f96a796dfadcc8c7aab7ff7273101c4ee0bead88344fa5f9f68e3aa7b101f1f67c10f2fa09eac002ee937fe6e165cc4bff3538cc87f46ebea8386281f3269d6561b85d06522095610bb5f991a66956f31b78853f1d1eff15a05eec1d222fb8bb37537813eb54d7c85aea1c3e7ef58606dbc43c392c612cab9841aa353d1cc01e3ce888fbc2515155895cc8cb2de8a9110587c6fce6f6fb943b413aed7ac0197494782844da9c3552d8a177f38faf3219d196f3304b00bce3f8c07bf67f1e0a39172bbb0e5d83c61786b0053a1b31ad4ddadc9d49fbe9ec3c404e7adf4bd7855b6201775b8118a1f4b0c963f8daa21a943efd15ff534d939d350bdcc362d8e411d92f0bd7d3870e3d691d1c73f5ba0af87fd53d1e25b3ed3023f4a93fc2b2f5f70dd59973b976d7a3f4b55b8bf281714d79ba0e6cad0de510674ed94d436e6f7f396e95ac85520d34ddfb109416934895d47fe8cb795e546c0baa4a2375f50f07984a8abaa46110a35d2d138d89622991b5b1504ab10e82636783dfa786d19363b58c21b0033e532e67d81b280f1a12b0e2d929ccfa723e7c419e2d29d9748584f570d9e219096d8f33fd907f85ef5fa6e6d4cf8c3cb3161b357b521d6cf3e2e5b0f73af3ed6800abd1b114e689288eca5e4377b88eba361dc061ff0d0da480336aed189ce0a6741d51416be4ff751476b1fbd1d733a3c6dc857aee3dbdd584d7f0aaa378b41db4fffb13cbf28646d6e97a133e818f97633c7db64eec83557a5d5a28cfa12ff7f7c85de4ef570af71a5f5f9530108f97606b6fb4d4f6c351e1a7bd0189b9e4c68a9608b67ef6995ee4fd02b918e4cfa6c1283c3c22d541b14ee4f358a5d254f79643426b98977ff28601c9ebad7f3d042ee749bf25d9aa3acb822fa921fe561c07c3e44bd803c7d3e40a1080c7586fd141524a8a8146f780b19518c0559ab1dedf16a5fc3b175d2723c97b054a3d4979b4a2844024e588a22673478e12d77b434578ecfc2644e4b2954ebb00258455d8179ce91c5de4edf9c440e147ad36dca45736553b9993cd93fa81b57ee7a2225fc431d021acce5485818585db4fcdd9170d771090347986949e260b086f31c1d3fe7db70a53fb425862f03819fc88da3140f57ce209bf03936359a01d91d11f6347c30d9a28996a98edf7c1fe1d077a441d5a1001a84daab5d7e96d08325eeecc034a0caff8f8574835162757ac4fd6c287deece2e16b7c46858ffe5c060187d2232540611c6527dc687462cdcc2ad63a3c6591440987247488303ae423756f9ed218a1855051cabf86202c98d98ab51b23551eba222cd2ca3af70a872a5bd9bee1f7b92bebc20e2353e66a19dd1e73447e0fc50a2434c6c2323955a7aee19a86456d4dd755971ad603e2eb4c309eb8fd55c4d4f74625acfe3b0401b626b6a4c44542829c4235f6fc3fc05b640b9c54c7861a3d6269467a33fbe4d99d881db1d3911d3c16fd87f36fc9c6422cb7f19c8390bcf2755f526216beb619420ac311cf2e6f6b26fdc6f52537efb77b6c250c7cfaf2090f042ea185542f258f343d407272d281b55571651fc4d6cfd1aa0ba6e8e3c6ac03e6d5e541bc94f6acc436904417c488710559d83bcf1ff935d9f18aefb49fc2462fb34a12b086a443bad63de8b334710c44853510c2393600088c63081ca66eacad9b849eb664d729f4e834de7ad9c30eb453ffa12694e6db735355030e1c24a6d27dd0d47a10ca5645056b469ba6e923e7ddd476baf6f51cb3df161a55d91fb311341a5ad3ea4f459af2d05918f90a051004c20be8dd5cc0931a832167f0e43342d71a30b49b1060b84ddcb0b0043b87300fbf35ea0643b5dfbfc6668b17dfcb72caff87242181b6c12110d5af9153dd847f14ae6e25871c8e1907d1d07dc08e0a00644832c4412af7dca77799b27272edf1e17eb6d88856cda090176af1e3a2a9c4cfd14821e25830c9cb35e3e41db5cfb1d34ae2a3f35a85e88b3d29801db81504bef8a7e47671ca5d2bddfc7ece50a7b76a602bbbcdf343229d49bcd14fe2eea4336879b9341518acfd01bbff0bd87494c33c61ad2908252675382d2d417ad26c84949444df6c849e4793b10e1cf5835374b2f5eba2f85eff77ad2ca5dd86a5e684251c550c20ac98c809c7a65002a97d7e90ebe3461b671c6d597b14b0a2ac7ca43fbca70136d6173581b5adaeb4db4e76165b57b4fb1d0e2812db4c4fe7adb570b06423a82cc27756c8ebf284240f1f114edfb4d1f04a027580980ecd3979ac5e776928f94a26f11bd3f81edb7332f04e596ff9e72c7e150f73407ec65e86c481999120ab68bfefd3faddaef79f5746c7d661614706df346f2811e59d3e97a09ec9e03c2a4772b252ba27c65876cc99319e90b58c321dc460c5fbdfa94c7a9ba2cdfc8e4f5b86e218b93e52c2e0292db6e98c6639828cd29d61a8f6f1e1616f075b29213c247ef1788c0e0dbe585ab036703a20561a81bac31537ce3ac59b9e30dfb66e9d7f6f8d664319386e56cc35218e0b28685670cacb0f7d9777eda8f6d9c5cf60a28ad8c632c64318b57b27b52be991fc5b5dc8ed204a7bd1249fefde3eff0b09c6280463405d5eff468a06d7495f61aee2716549905accf094246b23ed2933713c73417cda8892a5ceae04181f04cc1d8c3975844c3c914dc4d9023676e94a7abed6d549b8a61e81fa63cb7f8921c2fa3bac6899eb50e11bebcd372e7ef5118fbe9051ad68a2cd80137269c0fd1e5c1ae420e9070ee48ba5052cffc519ac351eb3aacb11d247219f493b1266165fdd087b5ee5d98664b0ae4617062146fbf0893e7924689037e4ea65f258f115e38a76b9b20b8cf8ddae10efe53490d643f8a4057f62fafec2b4bb272d4188d471363d5443f7871219174d4c27abc411fa39b5d0bea72523ad61c1aeaddae2c7e89e1ed07771a24f0b811bbf53f07f178e5e636da602526465424d46ac933a631dec2c87015dd5f799f84dba8e3dba4b159b31a2b34b7ed1f024f9edd8c3f55508f46a3336fbe442a41c663f4219bb2770801f16f898327accf00697fdb9895ceb0d21063523db4f9818d543b7f9f3f323e299f9d4b5a1982e203b46bccbc34c3d5ed7c01eac1a0f2dde93e6426b23ce2826f9c0cd5f88caa17c6f6aa1d065ca9ae0f98743e3c2a90daa102a55f9a984a9d3262f629361fc9d42bf7316cc51e6e36848a76e25a4835d391ded734c68efb04e0d40c18415485ac845b388941b5ef13472cd05a832eaf971cbd6bca0cf482c6b1e6c746c8898cdec06143ed1f412e9ece7a5eb6053e7ee7e262152143ba13e6b3355ca87e7857c924c1a67cba1b9435e64061fe9e66609f59fb818522c1a1e043fdd5ecb454e4aa44b0b5ecd25e435d77156908f9836e68f84be1e86e6f967cf78d518a5a884d7515bdafe156a26b8dc862e03a5fb8f8d38e13c630a701630504ce86309d4926cc1832ac47afbfb38e4f3f0f6cb90aae496e46618f0091b022170779540f64b2df9dc3fbbec33612a6215d18825280edb591398eaae68f3441086ff5e534ab7f7441d9479a0bd5edfb454af6028341e2271a45b3ec25d34ae3bff4a234ae125bc187813f3614c3880d099a56267d4223d927e04aa47c75124d1d4a21a779f6eb46af0ea7b57f678937ecb3db5b4d1ba7ddf864d0fbd5cffd96b5dd324a5ef5977baf64c9086182f1dd9651816d326b66ec0919a1603eb1346e75ed823419b2c85eb3b6e162b02db7a691c291d4a8ea818cdeb4186df83954822202cae69370e55fd112eaccd357aa52b5b62011f2e33526e4b25ba20edc9528014b4cdc962dd17201b987b7b8ee3d315caed6118e637b2ec22737a3ee7290fd49af114a58e109db9e4b9a1218defe93e5beb3100faff1e2616aefb727792d75fd870bfc3224a285c97337419ef503f68583a9bbf6d79c466c2ed40cba298758655584c3624d6b9d0e456ef67ae9cdffc89ea3d06a32695570c95e842a242e56fffbc7010d2acd35f9ec6ab4bd3e20dc7065b054a1fc644f69bfc25563b9368384066420f751ba288d1d75575a9409273eeb529958b70faad9340c392cce25ab2171a69b45c8ccf0271720d34e83399b74c108493b23c221bd229d438f707385254826d9f173cd88ceeeea6d1ab7a262bdc289a669344a8a76756db0ca97ce5fd3832c834745429ecbb83e8894bf3c13510794b9728f15119de9c4d581e83af31d98aeaf353f6f39f09b82035f62b3a7fdd5515a819f3b862c799afa8590e987e671dae99997f7c95c3277ed4cb1da89956bbd8726d821ee11f4db8780595648d28678f6ee671238a2b0375af08904707665e7adb137e1dd9eb2471ce33a5cb4f4c45bdb8e7e81061e335bd7b35aad62a3353900d808bb2cf4776a43d55516911580053ef5f1bba2c9b2faad7462fffae6cce9ac1fba90bc0c6fa6dee3ac647d513107b0aff2da537c843b5b037a09a4a38a809df341536bbfd2c7c60ce5c4b39f6623fe956da537635b17b9ac2f3a7c06455582a7ac7da51c760c3e608211b0b35ba2cc9cee9c31a2275b575b62c3d74a029d1fbc8806bdc56fadaea566d3391c232244d0393e7eadfcf43aa8cc9c01eec4942f165fcd5b2cb3dad5ae6db3e1e880f1a8a5c24865d558d83bdeb355eafecf66634c90c86cafac2924a04a41451dc308df52eca284be5a28c0d1d8b2ca0cd0fc8c313fa83a3e14741685a7b9bcda605fe5919918817e7e8fd0e8c6dc6b87f7c408860381dec4fa74f85aeaa03aa5e6c329d152f2e7e969a644c21191d49bc6c6e5d0c54e50d30a2c113057e7f1fe9734ae6e4aa45ce13ef930b6fc9a09783cba36ffa5b548b3fa145897c32c6064507bb3296ed8f1fbf4e159fc2b6d4a9afb0cb2524c9567c6225122dd40b417a36ce5e82ed41b22dcbd048d93487d52b0feb02e3e415771c4381375eb1747eab027b2ec6a55fad18593423b3c2b4d365257f8fa1ea08f5c3a978ab7e771650ba037de20a9699b7d434f72819c509f4e91a7265ae6769b7c2266d653b3e8f57527736041259f96abd078878c31f6226540aec98e0de6e72182422a2c53fdc54b37eb7f5b68d8983e4c319a2598c29f8932f00dafa0d82172895546c1ccdfe1d38f7de6e080db32c18d6625003ee5e39fb9407790d0b740e9bea45b3af68a2972d7245c3ef27ac18d7fee6668fc1832f1d633d6c2fe74fd69bf820a86906a8f4ec9d04dcb82323db58919b0265834c237abe1d04a557606f7b555c51024cfa5c1f9ff5600fa3b9c1e3ff83b6ff505720172e713135a351a22370429884a7a65bc3c8365b80b57a1f39847ad388fb832bd13ec4e3f8c1629b0e198db4843421c6c13b4679530580437433bf1b989dadb0105be425712fe8de40e6f40ce50da6e26e3d0ccd606286603e9067d059637d7ceb88401d1435d6409f7c9a9f6485d5f0a6f7a980b16cbdaeb06055839ceeffa841df0a32b62aa692f7bda04eefe4283189931004f65b0b2ad4586998009f341d615eed955d82faaea318784e4040ff8343408d8ad0710d3b2e7b1929a7c9b342978d848d9392f709f51dcfcc5dec3fbcccdb99b8095feadfb16eece37787a4563618b93bd4cf83327b5834fb3bb266ded9acbcb289a57aadd88ddb0fd6e1f91656e576b59e6fdc9b8db37174923fd57728b3b5925da5005b1341fbd1d756e777cd559fea67e1ff22de47971f14172f0a8cf0de243f76efbd9613ab77ccd36b4ef8c95ec7a65308b6b54e8593b6c7a915210ed639c804fd166de3bd84568978d2df86009b6c098b5a2e4585f417fc28dd26120dc9266d505603d5c8b5732993bd6c7eb90d5813755599b680021a42627431273fa5ca1992793eacef09b4b141e3e9071cc14be736e708e65574cd9cac404d78fafc9009cf881e891f55e422cc1bb94eb5df6bdfd49705558cf27c0651fd24cdccb1658e0c794dfe42c476019a9554adcfb447a546d432192d1649fb7b9a43281e2ca76dbc2da0f16076dd63a3e267a6194fbc509f449d3c0d0a7f52509fc2d93595ef9048fe0913cbf9fa5df602a3288fe96aa555a3227c382efd3d434537ebe958742446655b1559a1ba60bacd8ad193b53c082ea5073a6b3ba109fe3e54ca710df6ca2541b1e5832ed94414c143fa3dcba3f07f8bd2e133a0eb2ea85df728cc187b58951a2eeb6310c395033e08afefe695b8fd5053667597a99b1c5b09d4486f89fc959b3d42967de2d5a123f5b6424f14c5e9ce777a56e9595b25e884288ce2bab5c9a95cccb756255e86a8cfbde66a32befc3bdfaa015bf2e83ffbe39e766b6f53e38c36a3a23f4d22b7089a6981246d7ea007f288ef2e9e632a2a1b6160d28537d428681a12a7490c853e432bb9a44cea4b2d7ea739db54d8f6e8aa74362e63e14b569102a817139e143ed302dfb0566b99318b04a4593773ac3a6efda3b60ca23e0a775d52a39d969069fe634af52afe05cae6884b7536906e836c649d8c9d98a5fcdb181ce92af1944e07f0daf21d08067ee900bea2c6fe26249fd32c8eddbded04abd9d9bbecf3c72cdfc73c85bce364267b9354bbd512085877659582ce42ff3ca411253444ac7f227a486d09ad28eff9c2372395719b38ec522c99fe2df840d4301226dd03f0cd8dce22f24d38d2adf5625ece13bbbace30ec862a73ed9177b0003d5029b26c08aab768c6a4d3c4fef47eb1d3422b2366a07e6ddfb2361916eeffe21f67a747ca93a9ea2cd5bf02aad191973aacdc10852a5187b50bddf412d8c28666b6db59e379ccd464e497294ddbf6df72cb7f9602279ddc9de1941c9aa003fbcd3eef49d02a3823e1caa33e962748b0c4fb9cc1393f912d06cbc9077348bf415ebc1802911ac40f916a29a56364cff0c0d023d52b3b151b3b7e48e3fd39021ab788ef4505518839bbf277d275fe1421a39bd060d3fb9f1f7c14d283c403169fbca8ca16a1882286f754cadbf3e85e4fc6ab56870c30ae8f88afd963e6b5606036178f37bc3c3b5f175357976fa5f724064f0cfaa8bb015567fe42e5c74838ce7c488b0f60a454883249bc495ecf8ece3a944f27d05cd9f29df43a759d208c1a3a8bce2626bfdf8c9330a49f4e0eaa9e5a5db6cf2d95b992d205a9cf2f56bd0624fcbeaa044a200fba41dfe244d98ce8cf6a4c946fa8d6efb6856a256429491c89e610018ddf62eb07191a9ce6b01969ee01ec253239a311793ce26b3fd0b754ef53d015d67a17fa82902e57cf7603376e1d152ac7e9b7a6fd85c90c1ea7b57578154243744053ea19d09ff330204c92f4643bf5c879854b523888236986229f18d4a37e4a438fe576427820a622c4d0e2b03944d997739bdd431139e84ef054c36b32c592de04cff9ae6993d8187aead9552e4549d03e6f1237f21e0388bd8e298286521dae4910b8578cb21e5fae05ab87c3d3df20518259635a5692da6bf19aa7c03e75054b8799a95a56ecb6f60023531a09f3f5726fdf60df196badf017e7c0280a1d2745769f4ddb079e75cabb65127b3af078394c857962164c5a80d3ae63a78bb38acd719738fabcce3b91d5b0daf3ce6ef7f6bba9e586ab4afe2cb3c678595f6fe51261940d375bbf6c635932194d68f5db43bdf08f57e133aefa8141bacee8ca3f1de57e2e2e4c07643bd0ad285987a47c20c465d842703066e585cc0e1ae1124fd86d6d4606bbf0d42cb5d32babf36d929e317808ed323e94cb1434d02b70d9257f4d44ad9d0a570038ce1292e73ae5e60e17cd9edc0fb0c8fcc0033537193d987443a261071b594f6034545f037970ab77818ed8fcd6141d4ebafce8c31d2f50e95f5b962ef6f09b4cb9f4299db0581a039a7bd2611521c8fa53a70b9e995b265f279428cd75a833aa42e592d31e4271d3e58a00713186fd53efca9c4281234d2518ea27b91cf6f4b50dde5b0069edfa668c99adae07d7d52d015c175cfadd95f198c6d3544e8bc54f541751bd211705ca43f44859e1c99d1bd89eabaaffee7dcf614fa2d90d1dc064012dae53bf3dee902dbc34eb96ebfa010f6d5ada59f6d05edda2ef69533047c67fdae4be52e3ad0c81c913be8968ff005b407796a076c0fc63aa5dec3628bde6de8da64b720ed4e600b047c6f3b85adb8bad181d4967653cc022a663b07cc51d510a8fd3e08f1a77579aeefae46736babbfb1a140a6efa3668d6839d001705bd6a63893e703dd4d1026feb9ea9835ba23d13efd7d7b938fa10022d0172f267dfa0029bd5980789e45cbf6aa098869feb67a2cd89a3ed6f03333895a4e5fa53684bc0b6ea955754a2a5e8140b2f819b9612073037a32372f7a00aeeaf6aa83df610767779bba6afdde3a180d57f4463c4e11e4271a0c013fe17d28f37ce02607f116083173f918c9241601dd174fb7701a69e54aa78c61518c0a02e200b4a94f75126a6036cadbd3d40b06f9a92757a67400e124bf2d5d0cc348c68963e5833534fdea70859ee10cdb99f9f474a4e0f89a8e912e290032b5ecf19effd8b592c70284d0092cd082df316cff63baf5b2e3b164a1fd1acefd043d307ef6d3605ab3aa2caf4e7a56894aee74831dd2afa68182926f0d1521b1c7882895d15ab6560176b4a2d289d26d2937824d5ccffef50f20e1ad2a5c3c53683a58a27640cb39e0553e63011977b14c487668ebc65d97b9dc2bca697a4530010460e81152045f69de6f034f6867db4557ed8a21953cedbf43ccf8b430c6676d8d4b4d57e334445dba64106a95accc8f2f436994d2975b3c85e12aaa822fa518c67748aace5e8d26c32fa5dab6ce4f16185e8607ef35bc071a5c8f1542f9e8f3b93ea35fa7bd98b86d1f5b759ec197f687ec02dcce5d5cc14634316cdbe183f48e3b8b32a467c8684e4f5326c938e1f1ca5097f8abac716b86cb57e685320f8dbb966b09b8cc6b55ab402da8741a6edcc90453a66aaf734a695058f1b57870d827f39cdc7da4a7966f32b06e3ff9d7106812fc6d4489b20ef762aaa2cb7e20b1724a8607923ce2e04c3998eca7d704a00650e39d2e1ecb5c513f87258a81177647e8145bdcb5837e4ca1ce322f0c41686b3e2edd94de200d9432d9b648dfc992fc39cd27d4c44790e758df4d9996416110f8ed575b9dcc81f2c656c1c484cee48ba3ce6ea7d6e3975b1d1717f0dea70b4673f4d2d9be5a08601fa85bad23b367011ee48f916584e4a1b15a293cea31a533163990175593bf556f238a191cc88e78162dbe3d921a71732d2ed218605e04bb890f42746d46ca6bc421f7fe41d30397baa86ec3213b310fb7a566c7b3053fc9a92ad19e1b9c8c22b2f749c0a87eaf449e76ec44be3a7b73cb3ea0f741924480dd8f970f3679777e46374e2420b10092336e7c3a0d2629b4e02cf660a4d4e4e8fb521868d562c048748ad899af4acbe4818fbd90e987c4d484f508bd55fb4e63aceb615b9b6cc3c68ec2f6af9f093c2da3ee7697781912e360074e1b51ad0b1b705d25b50981b3d21b3067244321e7f481805233e964062bc36c39516a745e2a7243821109f127dca585b3f6742a483ec83ba3e8faa49b57bdfdc7150a80fbdcfde93fbd0d8910b0cb18c683c3d443e051e31d584703bd4e86ca15def0859e535153b6b084a6d1e328ffdd20ff3865509d463cb0e801ba31e6c9ba344e8948a123ec913f3871075979b134347c2350866476e50d852f4012330fa5e3cd75c5d76f0774d993c93eb6ea6418f3f62784977805e64105f43a0de07926ddc057c7ab3de4e5c9efcbac48095dcdaefc36890d81f9e43dcbcbebb50622d1359268f5d0fb2ff00c9a50669ec99dfd94875f7e7563a1d4d5a72ace07eafe01613bc9d0ab8ffeeaea21d21b14b2b8f7d60fa392b2853cd1d04583ce0653437627cfb8da663e66d2673e9965f200515349856944e16b136d1c77bee806a6f7d000f2ee1f4f989ae57202ec8552c1e274de2e31a6cfaca41f2631a21a2a4c3a642fb5db8856a36f576a8814537923447303c8943c04dabed6301b0ec4a5c3b5e362a338119176f646808d48cd3f0222786ebe6b4754ed765b67f812431d2bcdc13cc6b779ad937050233b4ea9aa9559460f9a4f5e4851d17c5a7da43e58291fc17fc77b826377f92600e8e933478dd62255e0ddca0f3e03cdb7eb0a0f77f260c97ed82a9bda59102dd2d57b5937a4e00d64f92aa93da68ff3942740b3f35bb5a432c5ae598ebf89ceb4a34da76a487598184302caa4a078fc320c20613eccd797905ac18d2374b5649edeea45de4dd8f7e38f34e4160ed706e9f37cdfef57cc04bf08f476e428b2de965030037d159b2adfdfa17e90acef8e8d528d694fe153ad5a1c52af7705030846365f91e201f728e63b04e5a030606a72baebf722848e24996ce19c45078b961baf932b4d25b04a8316f005e859134381254083c2e53569ea60d47f000b173743e82675c2c06b0fea2bc77956a5bd6550eeb43000003f90c3419bacb6f0fa7d9e6308b9b46ca2d5755af744f40e147f25af39f05842462a7fa88a93d05f2769760ed2f31a132243239b8c3630e809d22c02136b4971df574754afce3270359562fa4fccba600b4ca2a9a8d3144f6d67d5910b80a021c756fbd3509fb89730898f3f86ae6b60731953e02aa8c06a3d63bd29688fbcf2aa7707d5e67413bad6565a617868235aa61bf9e9ef9e7013a0aec753e1f02644dcfaf28856b0fc97fc867391d480eca4430c372169c57d76ce116f80b2a9bd027a119d410fb3111b37a9314daca90f90ed499b553f6a93cece00a039f583b23cea0091125553d2dc3e74d009c698e1cbbfebc3bdb49e31e3e90987b0326d8d8cd068d3554f2bfd9561cc68b4d401ad1d6ee1fead869b8d961178134eb48ce972827e81a3c9820e8a161fcee05f0ccc6c0377848cfd22292145f591890025bbf07ece326bcd2d4b880823639131466c45d2d198300022634529ba75a40f1e983f6a2a89b696f95ea70f0c94795c2f1d1758095b03b2c7129c9628697870adc8fe2ae355ee2a9463d219d2cf4dc41dfc30354028518be652a988b84a41b4542ab42dd163dbc8091494cd5cd70c204416d2a2f5bf75a6bfa71f0f684153eeb4c9c4e7f2282f45ab65233f86fbb91fad41621708f22152e9640bb4165aba5de725d53e6181e94a23fb92a317e570febf70d07579d9b3e7bae609f7c3f4dcff91939b110633a5d52e4d93350a4ab79c3dbc50aaeb5864ace64dc33365f8a65a1b695ab44190e2251982d50462277d702ac752064ef9da904f62ebbd4c1f465200842b020fa23af2b9622a81ad2ea78dbc3e61eadc95599a81636d04f0eedf5d1975675840dd65d09457751ad587cd82f55116ee54f1fbc15a01793c47db6ce841255beced330f4d552475048b37521062e39fc0bfd65ecad4cc040bc7fc58b04328f528db5b93fb6c480eb6717d0dc91e6f88aad2df450baa93920a95c050c7c5a5af0a239cc7ee31eb1d15af824b674a05b26daab0b62c399702d7e0b641adba5920f4593a3cb253731c26feec838ee3744106ce4b6521388d866d3f07abc87281f37b4aef30202c03951e8d7a137215e14f0f9604be5a002f35642d347f00c60bfd2cce73656dfe163869f58504d6198df655eac88bf3028a37073e6af2c3dcf2c6acc69e029ba2c9724f2b527a4907e4695e8d1fb165a88bf1f7e0e716fa5f1db4b41db0af2b59a3cbfa8a9b3e32abe3f35a149110830882c8711003a717fc4314d7ebf9e88753478f7e9ff9a0d7769f08bdbd51e35365c8636394d66911523b5a8d80255bf2685d819e4794bd7a7be30881a72df9cb63df8bc13bc70cf4a014e4ad02a0228697530a789163e0bfee9fc8a693f3af528cbff312dd615f0ccabec2adb3eb772332ee31f7996fc6baef4c9938f0fd4d69fab62381b282dd4f63b257494bb561c6971cae289f9808730600aab3ee90e4d5acd4b1c4da62d2d4195b2010da04db7b3dbfb11c3595682c5683cf2b5fce67c4c97b3c18f903fec4eba86a02cafb71a0bda10d007bfbc2e3c553b830ed621dcce0d1ee2cd0fdc203a10c1353692937f5f947cef82ce45f1ca0011737906ade18631fbcf373924d845ec8076cabd5b524c9a456dd4ef6b11330778cc90530e7eeae730817ddefa498c3b51482269fc2c95503d5f4acfeeb359422669a0b53938a6226af955245d49ea4e3083688de79be7ec624fdba38cf52c14c137aafaf445fd8c25069d87fa34aebe78e03b2f11ac1e8240dcd4724f2b7b67fa3fa2059a3bc435cdccf72fbcd4d99ea83435785a67e34e3fc743666d6bcd83d0d16f8d858b7f306da18ba252c01c377aecff5acdd352425ddf0c392f91c4b2e947cd865179849b6a879668b00f11f3f23dc28c05a33005bbe8810178663b547cdabcc11ff63acf566a351f926cae48987afeb464ab211bf76677db66fea1e83681bdec8a4f66af20b25a4e3a5acb38aadc0aee1accbee0c67ac25aacff200ca23947b46c66d2b7c85452b9515fd0754b6286e619884bc9581b634ff4a4f2a84c7d50d7749ab448181d406cb2b5b7c64da485adbfe0cc0c8d38f3e9fdc38c9c7ddffcddf155503b23a9c217a25fc89212f9e1355e38f4c64748928bc1f7139b6c9936de5ac26b03f8f13baa3802138d2121e712cea36ed93172f9ba3d1257401d13e04f235f20e2dc29632f7a3e33593dcd262ef65ce3681c47f00427ea32458a0c8869075099df27094268ada871ee02cd13fac69232773afd47000f6ad0f208d8e6f48d184f6db001422c45d6fca2fab44a9aa76bb34d2cc70f8507867390bffcfe37d797081adb7d26e34d1de29ad2098111c16c87b74ad879f36014f6ebadac338134eb4706e081edf50b363192125df9ec50052834397917d019e96be4482a69f4618c833b222ba7d134895642fe1e56910b0e248fef5aed863d490b273d9d3b1e581f17f7be6eb196ceb9786b4bcbcec23037620eefc69bab294bc9651545238c8372ae2367226df1b285749c518327fe4830e9e7f73c3a3062aa96cc1372e6ed4786c38f0ebc970452fd87b8e86f595398b0184c9cd6413b3acc3b30f314ffa276c34c5e10840229d28c34cb747653349b16d48ed495df542a40d9e12fb6ec3eeaa4ddcd541b819d49f21fcd196503d496422d2be4ed6782b068456b8369dda31ff67b0ab00f0d964056c4c7ea83715716fcf473d76f79df3e6036007fcef528ef00acb35698ff043eacd7872e55fd636ef791b3035f007d08e1ddd9d31ccfc77fa4790d7ab9fe30bd83f636d02df786a8d5d57b9d1e5836fc8d52220614dc15bdc69bd59977e2422b869156cebe2b5d6a6423cc32b31677366e7ef956e776cae2cca1926b7caae3bb9de88efa4889241f1d98ac3307db6c2fbf430fb3763917c4bac09881182a272a8ce2e513b630996e8062b5d4808f41a8a8d0e7367bec99b982db281e93a7f0b656e89a82060f66b03cc17a40b38b63c3e09020ea7776fc1a15fa441573382090c445c5ee5bf20e9e84096062f4baa73dcef4f238730226f9d5aae9e970cd3463a5fd3508298990507db64f0bc4c369cb50defbb557917adea68053fd67fc7c3cf44871e3ccd9484e08e2fbb2f443eaa5e31b8aedde6da44d9d6e74956f5e90512b737097e0bed6825390a95817bee5bc74af15d207ea2eb2dd6e8b33cd475914a1c5b180558c94793f4220259f737162ef2cdbc68b7ebce9bb9dfaee1e4e7dec362eae74e6664f3d4bcb00092b275b21ace678f320589278c8c8232007fda9ffa3dcf6c86c8bb14dae164bda947544eb5d3f2800ac44b48c34af672c2f2618f13c2e8438d498972919c02a4932466c99f0471a40fd11ab876b0d8db8e36d86d6a13838a7470f43d163758196167445955f2628c8958da3b19e9fe613e5a4745fd38a6147dde474cb2fe035a2b0f6f1dd6dbc5df70fb716b0e380d80ec114825ef5937b04a31de0426ed191c525408c2e7e0efa6910fd2b08ae5454af32966e21b52e3327c7a74f6cfa12ee53604ec3bba65797abcfc6ad79b916322c7c935901c1b0992c30c3a3c023adaf04f9d4a7de3f92def43050410323643fc80b2e7c48a4dc4e66a380b25f9a08f5fc11e9081557771d317619a269bf796a9198db41c6b9e270eea75a0e844d5e7792bf11bdca634a42947441a6a33eb5415d11c87dd9781b615540b49eede6f7032dbf8d7708a65f986d788bdcf25e25a58d2cc82ca3808aec48c3c85d8a0caa21904ae4d07a5fa65db0da1cd0ad06631f1b7ec2e0e74109f01da1b0842d07a65f10dbc56fd5fb07f6cec99df67e53fac30ddd605d32040dfdcd5129544bda864336bbb4a88f927a2d321ba9387211f0c3bcc2dfaff1e7536bb948e9346b278e1643ddea6186ba57c7bb22bc5250de9c96e5f6b96c9f2801ffe5893440c63d9d7a93c0a5177e2363730eaa70c33c9dab19fd44e421c0e94d7a517c9d7efbcf069ff97b17143cc0f904bab937950f5c26a0c726dd2c72eee63d0a673bd7b37b93381fcffe6f3cd7cc911ecb55585b56d6eeac3c220259d767aa4aa27d33ff9a3215482190d837cfaa7a57edcc81321af60b00557e3272959a30ff9982d14fb2242541109e5cc95a272aae5d03241bc9bc0e1909ee5410bf832351a2843aa476fa266d70f4936b806508a4283634ba1fefb968453a6132b9cb3d5c3dbec3056644398b45f1fa7e877bca2898b6d85e99d8c205bdec3998709939cba0e306a38b62071aa1321c5984d889aea83cff890b9eb1e86919553c92ac288737032091a3c211a2a1617032cf4f5594dc6cb1250016eb36097966e52e66c14b0c5e3edd10fd81be9c23ab4c869beae2237ed5f2b28fc83f41cdc8e5554add53eeb0408498474742a86afc714f50a3c45bd43a23d673120a9add91712983682416017ce102ddb344a7b87622476b3ddc3eef4d83405f19b70b2e8688c2d38a895fef2610862aef1bf4657d02c8480d18c5afe6f7421682373005fbee185b94dd4533d99acfd2f42b8997723a343edccacb869198eee523b4652eb997caf3264d6ab6094e3e543cd8d70e8104e38654682ce8f5a14dd3b17460c0065da82ce4e5bc3d89bd0af648c430c520d95f3a0f034911b9395f832153286a592826777d9d8f32946db6cf77bd82857fce7049b4c9de02d3aebf65f02d5af5aa76ea1d39b626ac37b67dccf17a2c4584d498e9f3241a932a438197da86058454a77156d888785e94d883727034f54aac3899651e084709a027c7037410422e91ef2227a898f92fda95b4a61e6659ecffa65376500c86d44c88df5689fad73e405a7c8d25acd32260d7643c84912258987c647e18cb54ac99175f7a3bd43ecb88790d93d166c7c26779be62cb4315ac9e89e96c1c8142ff027fefb54ffe662e0da6fba4dbbe9d58b62474169703b7ac70b8d79d8bac24f9b1bc76d8c3db5deca04808b0fdbe7d67c1f81422596b6eaa7d07e522976c48ccd1605f26cbe5be54b6394ea08400734f69fa9232b7a200d4a0158ac3237d89a413f0d3f94b8bbf206ca06ca6de934b7a5ea3688a9bad92b54a27b2624feeedb7c05b804df0c2bba44ab3c668b020c48d9326aee1382ddb2898946606a2d63f91c920abba51283880e4468052793a198a13ee63187eca0537525a7c7d1727f192d4128299fa3de7995b5df84d91cb00dab8e8e9e2919b40e8ffb2cf90d49488a5e5a9b8483b46541755fd39b186bda0c944502036881f57528dd902fee1f111ba933123e09a900b7125492705e827f26bd6de5391e652a1bc2a38ea745bb0aa42cf450f4b4ca75d91dd375e80e9f32dc71b30e93cbcbca3e570392463a1369535dbf81a99474830410189458fd8356da37525f0c4cc2ac71c4bca3829cab276379bb42af43b7a73cd0460e0fad5ee2bf1b7dde7f41550489c1350693eca8ec876c5912c593a4696306eb63d5da975debb31ea0b16f735a37e8ce9e14425c67e41294b8f10dcbeaeffe938d6b3ca31accde0faba0c78a7ad286465720b8e07c50a208c8873901c18d5f9b88c89ae35a4d403c55b0ce5e2acdb8306222b07ec453d62537e73ec5c080e321901fb7864b35c5f91561630b7d62e68e40ee0e2c7c2a16bca7836cc68f65f7655cbc4ce64b8bb17ea5f8ff582471be327b4c4666efeceb17746e90b8c19ceff2af03d5b22fd6b5cf2e93b98f17dadc7a06ffc44369acf17f9be48d5c9a7b78b9e4f1fb227ac899f7d9aef74ca73fe1f6b6c0a9bec8fcb6e8c1cfa426c6d584d93a667a0f28e390731651bd2f9c4ec4838bb05f86d64d888f6d283226d452d4ed9b693e337fceb25c301f35ebb05b60e635b18535861d478cd0469dcfcd3724e69694764fb3fe2c659bc2a6f04c16b9f0a50c56268a38e4efe70df1219a0fc81eec398cf22b85b2a1f5c6343445922275b9f00a6f1b5cc638d8f5b3ef5e9e0fb756d337beda95539ed193b4f4a47e3f77d564ae707f23d2ed4c0b2932d1934e3fcfedccaae21a76aff709c89ca0245e30b21bc4e07909517e3b4524c4c2ced3ec122652d5c1c32e9e45c34ce3f8635ac06d33c9f9a10d53e4ba86d62548bec821a1a78d051e3949bcd78ee046fc9cfa93508df7b541f2b908dd32c4b4a523b905bf90ac24d8b0670f0aeb46409e6221782abb83a2b1de0a19944792064f070846cee9a7d2b004832f8c7c4a6809c8dde9f06566a444dd2aec41e3cac552f819bd1ba62b5bb050ef39e5f9687bcb8afb9b23fb32b59f9ea4d9703f0e9dd2d995ce95922889d7fcc0db04ea4e0405bf549d7bb7870d72b0760a73a6ca308daf5bddc336d80c8f47cfbf5ae72656f8583e21ad3f92310f1eb05bf0fb199c3390db5aba35d59ddc031901f0a0011619c0df164f9a9c7af0701d9196e948af42291f4db6297146a4f23da9c5d7c949910979c3f7efb673139ef57444fc947ba11f15b4993d09f3bdb674b3ececea501f3b7053344f9bfd64e48de0fb84edd4161f490ec88bcb9f7e1302a5319feaaacc904c9b8abe53691f71861169e173ce8d1ff8494c15b3c0e9483132095672325ac27867b1250f0bec837daa42cbe44f0a81dee80791537e115c931665a4eb1d575b947a4e7fac0d9220ba6796df74ce159f9fb86d11be834838e4e4bdc2ed6c94b1972e39bae70013b2e64a56e540beb6e87674b06fdf49ed78e363ecf4304e5a6cbb2f55d8117dca4ab038f032db0ebeb3cc24e100372b995dc165cb895ae63eeb60c65c8432f9099f7582abf97f689284b0bda0a0618f14d52c34445818009c0bfa531fab427d23a9e284ea600e03d92c4b2fa961dfeba70265af2aa288507e52a6e665084f5fbc0200c884ba1680fe2f54628ea2169686c99d5f5686c514148d273c5d512517b30fdc8257e47f39ff465445f01582e3fba2abc6fa2c4fd6a2a2be6eadbe1dbb0a3a3b9616f41d60e65712bf0a4eaf891708579e6a965bc9327dea8f22e732202b6af7c770de597add8062489bf2037ff160814597dc27cc42a5db3077e13fee6a2d064a47fb88d1faa82cb440c8f27e853fa150885a69323302c6510b678eabc3f3353d0a85977c9bc8bd75ec48a6de457dd1c72df6c936e88590335f6fc44488ddd8130400ce70ad64c109dc6578f0ee3aa711fe4bb7148fdf87fd23cb5e68aae8cf2acde7895ae127821d0bf3811e2d81e69c0d5cc905eee19f3001d14fb8d20f1004da630a9500be6c4b18facece0d709f3e6e240515521d8fb129dfe6d82c17941e799ac4b20cd5ff0b7c047570d3e5d3ac599ccfebcfa98bc28ea52fa5d31f12db0dc1467189aee9194f4fd62b7655148ed6981071775c9aa33ff955a3ee7e484355f3290417d53c97b67a595e47fb6ae34e06d6b7fd85acd9af40bd197fa30fc3de78acb98e103196965e388e38709fc0ef125802272150e9bb28b2caa3f784ca0daeccc80147eb1389f1e1712401da379510fa29c8b0d500dd6b86191711dd4cb7bb52a402729d2b78c0427251e260245d3df1de16c13787bdba2bfa62ce7eb2844a680c983f22c3415614cd73a669bfcc0e50857565645c64776a367aaeff985cbc768eb48ac451ad5d32b30e9755870aa42288803b07f74049c1bef4a23c2e996b83ba4af128297bc98c9e32b1b0cf50c456dbdef6c6d8cfc8330d0383e565e0a0f2d0cc01d720f83ce5bb7745ef8fb734dd5be0f752e6b9c9575ddc72ca52d963dd57d791387a8e34d39505acf772bda96f88c20fc231bd31676b0338f5d642e7e83661ccbd9898cab2cc32e97d1b860e08bd002b9cebda08013e40b00807af678e72e7d9125ff660331176d87f14977d3d0d8880b4c74b74d1</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> harbor </tag>
            
            <tag> docker-compose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker数据持久化和容器与容器的数据共享</title>
      <link href="/posts/c73d.html"/>
      <url>/posts/c73d.html</url>
      
        <content type="html"><![CDATA[<h1>一、前言</h1><p><strong>当我们使用Docker创建一个mysql的container, 数据是存储在container内的.</strong><br><strong>如果有一天不小心执行了docker rm $(docker ps -aq)删除所有container. 那么mysql里的数据也会被删掉, 这是不安全的.</strong><br><strong>我们需要将数据持久化, 存储在container外部. 即使删除container也不会删除原有的数据.</strong></p><h1>二、容器的缺陷</h1><h4 id="容器中的数据可以存储在容器层。但是将数据存放在容器层存在以下问题：">容器中的数据可以存储在容器层。但是将数据存放在容器层存在以下问题：</h4><p><strong>1.数据不是持久化。意思是如果容器删除了，这些数据也就没了<br>2.主机上的其它进程不方便访问这些数据<br>3.对这些数据的I/O会经过存储驱动，然后到达主机，引入了一层间接层，因此性能会有所下降</strong></p><h1>三、data volume有两种挂载方式：</h1><p>**1）bind mount（用户管理）：**将宿主机上的某个目录或文件（不可以是没有格式化的磁盘文件），挂载到容器中，默认在容器内对此目录是有读写权限的，如果只需要向容器内添加文件，不希望覆盖目录，需要注意源文件必须存在，否则会被当做一个目录bind mount给容器。<br>**2）docker manager volume（docker自动管理）：**不需要指定源文件，只需要指定mount point（挂载点）。把容器里面的目录映射到了本地。<br>这种方式相比bind mount 缺点是无法限制对容器里边目录或文件的权限。</p><p>使用第二种挂载方式，-v 挂载时，不指定源文件位置，则默认挂载的路径是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@sqm-docker01 _data]# pwd<br>/var/lib/docker/volumes/dd173640edd5b0205bb02f3c4139647be12528b38289b9f93f18123a6b1266a8/_data<br><span class="hljs-meta">#</span><span class="bash">当有目录挂载时，默认在/var/lib/docker/volumes/下会生成一串<span class="hljs-built_in">hash</span>值，<span class="hljs-built_in">hash</span>值下有一个_data的目录，容器内映射的文件就在此路径下。</span><br></code></pre></td></tr></table></figure><h1>四、Storage Driver</h1><p><strong>数据存储方式</strong></p><blockquote><p>Centos7版本的docker，Storage Driver（数据存储方式）为：overlay2 ，Backing Filesystem（文件系统类型）: xfs</p></blockquote><p><em><strong>可使用  “docker  inspect 容器名称” 来查看数据存储方式</strong></em></p><h1>五、Data Volume</h1><h1>（Bind mount）</h1><p><em><strong>持久化存储：本质上是DockerHost文件系统中的目录或文件，能够直接被Mount到容器的文件系统中。在运行容器时，可通过-v实现。</strong></em></p><p><strong>特点：</strong><br><strong>1、Data Volume是目录或文件，不能是没有格式化的磁盘（块设备）。</strong></p><p><strong>2、容器可以读写volume中的数据。</strong></p><p><strong>3、Volume数据可以永久保存，即使使用它的容器已经被销毁。</strong></p><h1>小实验：</h1><p><strong>运行一个nginx服务，做数据持久化</strong></p><h2 id="（1）Data-Volume是目录或文件，不能是没有格式化的磁盘（块设备）。"><strong>（1）Data Volume是目录或文件，不能是没有格式化的磁盘（块设备）。</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# mkdir html<br>//创建测试目录<br>[root@docker01 ~]# cd html/<br>[root@docker01 html]# echo "This is a testfile in dockerHost." &gt; index.html<br>//创建测试网页<br>[root@docker01 ~]# docker run -itd --name testweb -v /root/html/:/usr/share/nginx/html nginx:latest<br>//运行一个nginx容器，并挂载目录<br>[root@docker01 ~]# docker inspect testweb<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174628927.png" alt="image-20200607174628927"></p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# curl 172.17.0.3<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174734092.png" alt="image-20200607174734092"></p></blockquote><p><em><strong>注意：dockerhost上需要被挂载的源文件或目录，必须是已经存在，否则，会被当作一个目录挂载到容器中。</strong></em></p><h2 id="（2）容器可以读写volume中的数据。"><strong>（2）容器可以读写volume中的数据。</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker exec  -it testweb  /bin/bash<br>root@ef12d312a94e:/# cd /usr/share/nginx/html/<br>root@ef12d312a94e:/usr/share/nginx/html# echo "update" &gt; index.html<br>//容器中更新网页<br>root@ef12d312a94e:/usr/share/nginx/html# exit<br>[root@docker01 ~]# cat html/index.html<br>//可以看到宿主目录的挂载目录也更新了<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174649034.png" alt="image-20200607174649034"></p><h2 id="（3）Volume数据可以永久保存，即使，使用它的容器已经被销毁，也可以通过宿主机的挂在目录重新启动一个容器挂载这个目录进行访问。"><strong>（3）Volume数据可以永久保存，即使，使用它的容器已经被销毁，也可以通过宿主机的挂在目录重新启动一个容器挂载这个目录进行访问。</strong></h2><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker ps -a -q |xargs docker rm -f<br>//删除所有容器<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174659567.png" alt="image-20200607174659567"></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# cat html/index.html<br>//容器删除之后，宿主机的测试网页也在<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174706965.png" alt="image-20200607174706965"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run  -itd --name t1  -P -v  /root/html/:/usr/share/nginx/html nginx:latest<br>//基于测试网页创建一个容器<br>[root@docker01 ~]# docker ps<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174746264.png" alt="image-20200607174746264"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# curl 127.0.0.1:32768<br>//访问一下<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174753614.png" alt="image-20200607174753614"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# echo "update-new" &gt; html/index.html<br>//再次更新测试网页<br>[root@docker01 ~]# curl 127.0.0.1:32768<br>//在宿主机更新测试网页，刚刚创建的容器的测试网页也会更新<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174801382.png" alt="image-20200607174801382"></p><h2 id="（4）默认挂载到容器内的文件，容器是有读写权限。可以在运行容器是-v-后边加“-ro”限制容器的写入权限"><strong>（4）默认挂载到容器内的文件，容器是有读写权限。可以在运行容器是-v 后边加“:ro”限制容器的写入权限</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run  -itd --name t2 -P  -v  /root/html/:/usr/share/nginx/html:ro  nginx:latest<br>//创建容器设置指读权限<br>[root@docker01 ~]# docker exec -it t2 /bin/bash<br>//进入容器<br>root@4739c0f5d970:/# cd /usr/share/nginx/html<br>root@4739c0f5d970:/usr/share/nginx/html# echo 1234 &gt; index.html<br>//修改测试网页（失败，因为是只读的）<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174809265.png" alt="image-20200607174809265"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# echo 654321 &gt; html/index.html <br>//宿主机可以更改<br>[root@docker01 ~]# curl 127.0.0.1:32768<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174815192.png" alt="image-20200607174815192"></p><h2 id="（5）并且还可以挂载单独的文件到容器内部，一般他的使用场景是：如果不想对整个目录进行覆盖，而只希望添加某个文件，就可以使用挂载单个文件。"><strong>（5）并且还可以挂载单独的文件到容器内部，一般他的使用场景是：如果不想对整个目录进行覆盖，而只希望添加某个文件，就可以使用挂载单个文件。</strong></h2><h3 id="1-测试1"><strong>&lt;1&gt;测试1</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"> [root@docker01 ~]# docker run -itd --name v6 -P -v /root/html/index.html:/usr/share/nginx/html/index.html nginx:latest<br>[root@docker01 ~]# docker ps<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174823457.png" alt="image-20200607174823457"></p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# curl 127.0.0.1:32770<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174830254.png" alt="image-20200607174830254"></p></blockquote><h3 id="1-测试2"><strong>&lt;1&gt;测试2</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]#  echo test &gt; test.html<br>[root@docker01 ~]# docker run -itd --name t8 -P -v /root/test.html:/usr/share/nginx/html/test.html nginx:latest<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174838833.png" alt="image-20200607174838833"></p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# curl 127.0.0.1:32772/test.html<br></code></pre></td></tr></table></figure></blockquote><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174849580.png" alt="image-20200607174849580"></p><h1>六，Docker Manager Volume</h1><p><strong>会自动在宿主机生成目录，所以在挂载目录的时候只用写容器中的目录。<br>特性和上边的bind mount基本一样</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -itd --name t1 -P  -v /usr/share/nginx/html nginx:latest<br>[root@docker01 ~]# docker ps<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174857803.png" alt="image-20200607174857803"></p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker inspect t1<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174903552.png" alt="image-20200607174903552"></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 _data]# cd /var/lib/docker/volumes/17c50a065a6b10ccd01ca1ce8091fdf6282dc9dcb77a0f6695906257ecc03a63/_data<br>[root@docker01 _data]# echo "this is a testfile" &gt; index.html<br>[root@docker01 _data]# docker ps<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174911095.png" alt="image-20200607174911095"></p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 _data]# curl 127.0.0.1:32777<br></code></pre></td></tr></table></figure></blockquote><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174917234.png" alt="image-20200607174917234"></p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 _data]# docker volume ls<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174923510.png" alt="image-20200607174923510"></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 _data]# docker rm t1 -f<br>[root@docker01 _data]# cat index.html<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174931117.png" alt="image-20200607174931117"></p><h3 id="1-删除容器的操作，默认不会对dockerhost上的源文件操作，如果想要在删除容器时把源文件也删除，可以在删除容器时添加-v选项（一般不推荐使用这种方式，因为文件有可能被其他容器使用）"><strong>1.删除容器的操作，默认不会对dockerhost上的源文件操作，如果想要在删除容器时把源文件也删除，可以在删除容器时添加-v选项（一般不推荐使用这种方式，因为文件有可能被其他容器使用）</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 _data]# docker run -itd --name t2 -P  -v /usr/share/nginx/html nginx:latest<br>[root@docker01 ~]# docker inspect t2<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174938900.png" alt="image-20200607174938900"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# cd /var/lib/docker/volumes/2781dbfdc673fc7d149dc4f6217ef277fe72e05ba2e20fcebb617afe97eccb30/_data<br>[root@docker01 _data]# docker rm -v t2 -f<br>t2<br>[root@docker01 _data]# ls<br></code></pre></td></tr></table></figure><h1>七，容器与容器的数据共享</h1><p><em><strong>Volume container：给其他容器提供volume存储卷的容器。并且它可以提供bind mount，也可以提供docker manager volume。</strong></em></p><p><strong>创建一个vc_data容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker create --name vc_data  -v ~/html:/usr/share/nginx/html  -v /other/useful/tools busybox<br>[root@docker01 ~]# docker inspect vc_data<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607174951379.png" alt="image-20200607174951379"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -itd --name t3 -P  --volumes-from vc_data nginx:latest<br>[root@docker01 ~]# docker ps<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607175002946.png" alt="image-20200607175002946"></p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# curl 127.0.0.1:32779<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607175133553.png" alt="image-20200607175133553"></p></blockquote><h1>八，容器的跨主机数据共享</h1><p><strong>实验环境</strong></p><table><thead><tr><th>docker01</th><th>docker02</th></tr></thead><tbody><tr><td>httpd</td><td>nfs</td></tr></tbody></table><p><strong>要求：docker01和docker02的主目录，是一样的。</strong></p><h3 id="准备工作"><strong>准备工作</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# hostnamectl set-hostname nfs<br>[root@localhost ~]# hostnamectl set-hostname docker01<br>[root@localhost ~]# hostnamectl set-hostname docker02<br></code></pre></td></tr></table></figure><h2 id="nfs操作"><strong>nfs操作</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# yum -y install nfs-utils<br>//下载nfs服务<br><br>[root@nfs ~]# mkdir /datashare<br>//创建共享目录<br><br>[root@nfs ~]# vim /etc/exports<br>//设置权限如下<br>/datashare *(rw,sync,no_root_squash)<br></code></pre></td></tr></table></figure><h2 id="开启各项服务"><strong>开启各项服务</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs ~]# systemctl start rpcbind<br>[root@nfs ~]# systemctl enable rpcbind<br>[root@nfs ~]# systemctl start nfs-server<br>[root@nfs ~]# systemctl enable nfs-server<br></code></pre></td></tr></table></figure><h2 id="docker01和docker02测试nfs"><strong>docker01和docker02测试nfs</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 htdocs]# showmount -e 192.168.1.20<br>[root@docker02 htdocs]# showmount -e 192.168.1.20<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607175105292.png" alt="image-20200607175105292"></p><h3 id="docker01的操作"><strong>docker01的操作</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# mkdir /xxx<br>[root@docker01 ~]# mount  -t nfs 192.168.1.10:/datashare /xxx<br>//挂载nfs上的共享目录<br>[root@docker01 ~]# mount | tail -1<br>//查看是否挂载<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607175225112.png" alt="image-20200607175225112"></p><h3 id="nfs创建测试文件"><strong>nfs创建测试文件</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs ~]# cd datashare/<br>[root@nfs datashare]# vim index.html<br>&lt;div id="datetime"&gt;<br>    &lt;script&gt;<br>        setInterval("document.getElementById('datetime').innerHTML=new Date().toLocaleString();", 1000);<br>    &lt;/script&gt;<br>&lt;/div&gt;<br>xgp666<br></code></pre></td></tr></table></figure><h3 id="docker01查看一下"><strong>docker01查看一下</strong></h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607175233541.png" alt="image-20200607175233541"></p><h2 id="docker02的操作与docker01上一样"><strong>docker02的操作与docker01上一样</strong></h2><p>这里先不考虑将代码写入镜像，先以这种方式，分别在docker01和docker02部署httpd服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -itd --name bdqn-web1 -P -v /xxx/:/usr/local/apache2/htdocs httpd:latest <br>[root@docker02 ~]# docker run -itd --name bdqn-web2 -P -v /xxx/:/usr/local/apache2/htdocs httpd:latest<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker ps <br>//查看端口<br>0.0.0.0:32775-&gt;80/tcp   bdqn-web<br>[root@docker02 ~]# docker ps<br>//查看端口<br>0.0.0.0:32769-&gt;80/tcp   bdqn-web2<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607175247554.png" alt="image-20200607175247554"></p><p><strong>此时，用浏览器访问,两个WEB服务的主界面是一样。但如果，NFS服务器上的源文件丢失,</strong><br><strong>则两个web服务都会异常。</strong></p><p><strong>想办法将元数据写入镜像内，在基于镜像创建一个vc_data容器，这里因为没有接触到docker-compose和docker-swarm等docker编排工具，所以需手动创建镜像！</strong></p><h2 id="nfs操作-2"><strong>nfs操作</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@nfs datashare]# echo xgp666 &gt; index.html <br>//更改测试文件<br></code></pre></td></tr></table></figure><h2 id="docker02操作"><strong>docker02操作</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# cd /xxx/<br>[root@docker02 xxx]# vim Dockerfile<br>//编写Dockerfile<br>[root@docker02 xxx]# cat Dockerfile <br>FROM busybox<br>ADD index.html /usr/local/apache2/htdocs/index.html<br>VOLUME /usr/local/apache2/htdocs<br></code></pre></td></tr></table></figure><h3 id="创建镜像并运行一个容器"><strong>创建镜像并运行一个容器</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 xxx]# docker build -t back_data .<br>//基于Dockerfile创建镜像<br>[root@docker02 xxx]# docker create --name back_container1  back_data:latest <br>//基于刚刚创建的镜像创建容器<br></code></pre></td></tr></table></figure><h3 id="运行容器，并导出镜像"><strong>运行容器，并导出镜像</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 xxx]# docker run -itd --name bdqn-web3 -P  --volumes-from  back_container1 httpd:latest <br>//运行一台容器<br>[root@docker02 xxx]# docker save &gt; back_data.tar back_data:latest<br>//导出镜像，因为是在共享目录所以docker01也可以看到<br></code></pre></td></tr></table></figure><h2 id="docker01"><strong>docker01</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 xxx]# docker load -i back_data.tar <br>//去共享目录，导入镜像<br>[root@docker01 xxx]# docker  create --name back_container2  back_data:latest<br>//基于刚刚创建的镜像运行容器<br>[root@docker01 xxx]# docker run  -itd --name bdqn-web4 -P  --volumes-from  back_container2 httpd:latest<br>//运行一台容器<br></code></pre></td></tr></table></figure><h3 id="浏览器访问"><strong>浏览器访问</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker ps <br>//查看端口<br> 0.0.0.0:32776-&gt;80/tcp   bdqn-web4<br>[root@docker02 ~]# docker ps<br>//查看端口<br>0.0.0.0:32770-&gt;80/tcp   bdqn-web3<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607175300321.png" alt="image-20200607175300321"></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker网络 </tag>
            
            <tag> bind mount </tag>
            
            <tag> docker manager volu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker跨主机网络——manual</title>
      <link href="/posts/2020.html"/>
      <url>/posts/2020.html</url>
      
        <content type="html"><![CDATA[<h1><strong>1. Macvlan 简介</strong></h1><p><strong>在 Macvlan 出现之前，我们只能为一块以太网卡添加多个 IP 地址，却不能添加多个 MAC 地址，因为 MAC 地址正是通过其全球唯一性来标识一块以太网卡的，即便你使用了创建 ethx:y 这样的方式，你会发现所有这些“网卡”的 MAC 地址和 ethx 都是一样的，本质上，它们还是一块网卡，这将限制你做很多二层的操作。有了 Macvlan 技术，你可以这么做了。</strong></p><p><strong>Macvlan 允许你在主机的一个网络接口上配置多个虚拟的网络接口，这些网络 interface 有自己独立的 MAC 地址，也可以配置上 IP 地址进行通信。Macvlan 下的虚拟机或者容器网络和主机在同一个网段中，共享同一个广播域。Macvlan 和 Bridge 比较相似，但因为它省去了 Bridge 的存在，所以配置和调试起来比较简单，而且效率也相对高。除此之外，Macvlan 自身也完美支持 VLAN。</strong></p><p><strong>同一 VLAN 间数据传输是通过二层互访，即 MAC 地址实现的，不需要使用路由。不同 VLAN 的用户单播默认不能直接通信，如果想要通信，还需要三层设备做路由，Macvlan 也是如此。用 Macvlan 技术虚拟出来的虚拟网卡，在逻辑上和物理网卡是对等的。物理网卡也就相当于一个交换机，记录着对应的虚拟网卡和 MAC 地址，当物理网卡收到数据包后，会根据目的 MAC 地址判断这个包属于哪一个虚拟网卡。这也就意味着，只要是从 Macvlan 子接口发来的数据包（或者是发往 Macvlan 子接口的数据包），物理网卡只接收数据包，不处理数据包，所以这就引出了一个问题：本机 Macvlan 网卡上面的 IP 无法和物理网卡上面的 IP 通信！关于这个问题的解决方案我们下一节再讨论。</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607173125782.png" alt="image-20200607173125782"><br><strong>简单来说，Macvlan 虚拟网卡设备是寄生在物理网卡设备上的。发包时调用自己的发包函数，查找到寄生的物理设备，然后通过物理设备发包。收包时，通过注册寄生的物理设备的 rx_handler 回调函数，处理数据包。</strong></p><h1><strong>2.简单介绍manual的流程</strong></h1><p><strong>macvlan 就如它的名字一样，是一种网卡虚拟化技术，它能够将一个物理网卡虚拟出多个接口，每个接口都可以配置 MAC 地址，同样每个接口也可以配自己的 IP，每个接口就像交换机的端口一样，可以为它划分 VLAN。</strong></p><p><strong>macvlan 的做法其实就是将这些虚拟出来的接口与 Docker 容器直连来达到通信的目的。一个 macvlan 网络对应一个接口，不同的 macvlan 网络分配不同的子网，因此，相同的 macvlan 之间可以互相通信，不同的 macvlan 网络之间在二层上不能通信，需要借助三层的路由器才能完成通信，如下，显示的就是两个不同的 macvlan 网络之间的通信流程。</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607173156233.png" alt="image-20200607173156233"><br><strong>我们用一个 Linux 主机，通过配置其路由表和 iptables，将其配成一个路由器（当然是虚拟的），就可以完成不同 macvlan 网络之间的数据交换，当然用物理路由器也是没毛病的。</strong></p><h1><strong>3.Macvlan 的特点：</strong></h1><p><strong>1.可让使用者在同一张实体网卡上设定多个 MAC 地址。</strong><br><strong>2.承上，带有上述设定的 MAC 地址的网卡称为子接口（sub interface）；而实体网卡则称为父接口（parent interface）。</strong><br><strong>3.parent interface 可以是一个物理接口（eth0），可以是一个 802.1q 的子接口（eth0.10），也可以是 bonding 接口。</strong><br><strong>4.可在 parent/sub interface 上设定的不只是 MAC 地址，IP 地址同样也可以被设定。</strong><br><strong>5.sub interface 无法直接与 parent interface 通讯 (带有 sub interface 的 VM 或容器无法与 host 直接通讯)。</strong><br><strong>承上，若 VM 或容器需要与 host 通讯，那就必须额外建立一个 sub 6.interface 给 host 用。</strong><br><strong>7.sub interface 通常以 mac0@eth0 的形式来命名以方便区別。</strong><br><strong>用张图来解释一下设定 Macvlan 后的样子：</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607173215567.png" alt="image-20200607173215567"></p><h1><strong>4.实验环境</strong></h1><table><thead><tr><th><strong>docker01</strong></th><th><strong>docker02</strong></th></tr></thead><tbody><tr><td><strong>192.168.1.11</strong></td><td><strong>192.168.1.13</strong></td></tr></tbody></table><p><strong>关闭防火墙和禁用selinux，更改主机名</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# hostnamectl set-hostname docker01<br>[root@localhost ~]# su -<br>上一次登录：二 12月 17 08:20:36 CST 2019从 192.168.1.1pts/0 上<br>[root@docker01 ~]# systemctl  stop firealld<br>Failed to stop firealld.service: Unit firealld.service not loaded.<br>[root@docker01 ~]# setenforce 0<br>setenforce: SELinux is disabled<br>[root@docker01 ~]# systemctl daemon-reload <br>[root@docker01 ~]# systemctl restart docker<br></code></pre></td></tr></table></figure><h2 id="4-1-macvlan的单网络通信"><strong>4.1 macvlan的单网络通信</strong></h2><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607173224340.png" alt="image-20200607173224340"></p><h3 id="1-打开网卡的混杂模式"><strong>1)打开网卡的混杂模式</strong></h3><p><strong>//需要在docker01和docker02_上都进行操作。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# ip link show ens33<br>//查看网卡模式<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607173249663.png" alt="image-20200607173249663"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# ip link set ens33 promisc on<br>//创建网卡模式为混杂模式<br>[root@docker01 ~]# ip link show ens33<br>//查看网卡模式<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607173257698.png" alt="image-20200607173257698"></p><h3 id="2-在docker01-上创建macvlan网络"><strong>2)在docker01.上创建macvlan网络</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker network create -d macvlan --subnet 172.22.16.0/24 --gateway 172.22.16.1  -o parent=ens33 mac_net1<br>// 创建一个macvlan模式的网络<br>-o parent=绑定在哪张网卡之上<br>[root@docker01 ~]# docker network ls<br>//查看网卡信息<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607173442395.png" alt="image-20200607173442395"></p><h3 id="3-基于创建的macvlan网络运行一个容器"><strong>3)基于创建的macvlan网络运行一个容器</strong></h3><blockquote><p><strong>[root@docker01 ~]# docker run -itd --name bbox1 --ip 172.22.16.10 --network mac_net1 busybox</strong></p></blockquote><h3 id="4-在docker02-上创建macvlan网络（要和docker01的macvlan一模一样）"><strong>4)在docker02.上创建macvlan网络（要和docker01的macvlan一模一样）</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker network create -d macvlan  --subnet 172.22.16.0/24 --gateway 172.22.16.1  -o parent=ens33 mac_net1<br><br>[root@docker02 ~]# docker network ls<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607173455143.png" alt="image-20200607173455143"></p><h3 id="5-在docker02-上，基于创建的macvlan网络运行一个容器，验证与docker01-上容器的通信。"><strong>5)在docker02. 上，基于创建的macvlan网络运行一个容器，验证与docker01.上容器的通信。</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker run -itd --name bbox2 --network mac_net1 --ip 172.22.16.20 busybox<br>//基于busybox创建一个容器<br>[root@docker02 ~]# docker exec -it bbox2 /bin/sh<br>//进入bbox2容器<br>/ # ping 172.22.16.10<br>//ping一下docker01的主机<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607173503258.png" alt="image-20200607173503258"></p><h2 id="4-2macvlan的多网络通信"><strong>4.2macvlan的多网络通信</strong></h2><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607173516888.png" alt="image-20200607173516888"></p><h3 id="1）docker01和docker02验证内核模块8021q封装"><strong>1）docker01和docker02验证内核模块8021q封装</strong></h3><p><strong>macvlan需要解决的问题:基于真实的ens33网卡，生产新的虚拟网卡。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# modinfo 8021q<br>//验证内核模块8021q封装<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607173526152.png" alt="image-20200607173526152"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# modprobe 8021q<br>//如果内核模块没有开启，运行上边的命令导入一下<br></code></pre></td></tr></table></figure><h3 id="2-docker01基于ens33创建虚拟网卡"><strong>2)docker01基于ens33创建虚拟网卡</strong></h3><p><strong>修改ens33网卡配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# cd /etc/sysconfig/network-scripts/<br>[root@docker01 network-scripts]# vim ifcfg-ens33<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607173537582.png" alt="image-20200607173537582"><br><strong>手动添加虚拟网卡配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# cd /etc/sysconfig/network-scripts/<br>[root@docker01 network-scripts]# cp -p ifcfg-ens33  ifcfg-ens33.10<br>//-p保留源文件或目录的属性<br>[root@docker01 network-scripts]# vim ifcfg-ens33.10<br>//修改ens33.10网卡配置文件<br>BOOTPROTO=none<br>NAME=ens33.10<br>DEVICE=ens33.10<br>ONBOOT=yes<br>IPADDR=192.168.10.10<br>PREFIX=24<br>GATEWAY=192.168.10.2<br>VLAN=yes<br></code></pre></td></tr></table></figure><p><em><strong>这里注意，IP要和ens33网段做一个区分， 保证网关和网段IP的一致性，设备名称和配置文件的-致性,并且打开VLAN支持模式。</strong></em></p><p><strong>创建第二个虚拟网卡配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 network-scripts]# cp -p ifcfg-ens33.10 ifcfg-ens33.20<br>[root@docker01 network-scripts]# vim ifcfg-ens33.20<br>//修改ens33.20网卡配置文件<br>BOOTPROTO=none<br>NAME=ens33.20<br>DEVICE=ens33.20<br>ONBOOT=yes<br>IPADDR=192.168.20.20<br>PREFIX=24<br>GATEWAY=192.168.20.2<br>VLAN=yes<br></code></pre></td></tr></table></figure><p><strong>docker01上的操作，启用创建的虚拟网卡:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 network-scripts]# ifup ifcfg-ens33.10 <br>[root@docker01 network-scripts]# ifup ifcfg-ens33.20<br>[root@docker01 network-scripts]# ifconfig<br>//查看IP<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607173552114.png" alt="image-20200607173552114"></p><h3 id="3-docker02基于ens33创建虚拟网卡"><strong>3)docker02基于ens33创建虚拟网卡</strong></h3><p><strong>修改ens33网卡配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# cd /etc/sysconfig/network-scripts/<br>[root@docker02 network-scripts]# vim ifcfg-ens33<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607173603428.png" alt="image-20200607173603428"><br><strong>手动添加虚拟网卡配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# cd /etc/sysconfig/network-scripts/<br>[root@docker02 network-scripts]# cp -p ifcfg-ens33  ifcfg-ens33.10<br>//-p保留源文件或目录的属性<br>[root@docker02 network-scripts]# vim ifcfg-ens33.10<br>//修改ens33.10网卡配置文件<br>BOOTPROTO=none<br>NAME=ens33.10<br>DEVICE=ens33.10<br>ONBOOT=yes<br>IPADDR=192.168.10.11<br>PREFIX=24<br>GATEWAY=192.168.10.2<br>VLAN=yes<br></code></pre></td></tr></table></figure><p><em><strong>这里注意，IP要和ens33网段做一个区分， 保证网关和网段IP的一致性，设备名称和配置文件的-致性,并且打开VLAN支持模式。</strong></em></p><p><strong>创建第二个虚拟网卡配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 network-scripts]# cp -p ifcfg-ens33.10 ifcfg-ens33.20<br>[root@docker02 network-scripts]# vim ifcfg-ens33.20<br>//修改ens33.20网卡配置文件<br>BOOTPROTO=none<br>NAME=ens33.20<br>DEVICE=ens33.20<br>ONBOOT=yes<br>IPADDR=192.168.20.21<br>PREFIX=24<br>GATEWAY=192.168.20.2<br>VLAN=yes<br></code></pre></td></tr></table></figure><p><strong>docker02上的操作，启用创建的虚拟网卡:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 network-scripts]# systemctl restart network<br>[root@docker02 network-scripts]# ifup ifcfg-ens33.10 <br>[root@docker02 network-scripts]# ifup ifcfg-ens33.20<br>[root@docker02 network-scripts]# ifconfig<br>//查看IP<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607173616293.png" alt="image-20200607173616293"><br><strong>4）docekr01和docker02基于虚拟网卡，创建macvlan网络</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 network-scripts]# docker network create -d macvlan --subnet 172.16.10.0/24 --gateway 172.16.10.1  -o parent=ens33.10 mac_net10<br>//创建一个新的网卡基于ens33.10<br>[root@docker02 network-scripts]# docker network create -d macvlan --subnet 172.16.20.0/24 --gateway 172.16.20.1  -o parent=ens33.20 mac_net20<br>//创建一个新的网卡基于ens33.20<br></code></pre></td></tr></table></figure><h3 id="5）Docker01部署一个私有仓库"><strong>5）Docker01部署一个私有仓库</strong></h3><p><strong>Docker01</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">   72  docker pull registry<br>//下载registry镜像<br>   73  docker run -itd --name registry -p 5000:5000  --restart=always registry:latest <br>//基于registry镜像，启动一台容器<br>   76  docker tag busybox:latest  192.168.1.11:5000/busybox:v1 <br>//把容器重命名一个标签<br>   77  docker ps<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607173626570.png" alt="image-20200607173626570"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">   78  vim /usr/lib/systemd/system/docker.service #13行修改<br>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.1.11:5000  <br> <br>   80  systemctl daemon-reload <br>   81  systemctl restart docker.service <br>//重启docker<br>  100  docker push 192.168.1.11:5000/busybox:v1<br>//上传容器到私有仓库 <br>  101  docker images<br></code></pre></td></tr></table></figure><p><strong>Docker02</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">78  vim /usr/lib/systemd/system/docker.service #13行修改<br>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.1.11:5000  <br><br>   80  systemctl daemon-reload <br>   81  systemctl restart docker.service <br>true //重启docker<br>   99  docker pull 192.168.1.11/busybox:v1 <br>true //下载刚刚上传的镜像<br></code></pre></td></tr></table></figure><h3 id="6）docker01和docker02基于busybox-v1镜像和网卡mac-net10，mac-net20，创建容器。"><strong>6）docker01和docker02基于busybox:v1镜像和网卡mac_net10，mac_net20，创建容器。</strong></h3><p><strong>Docker01</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -itd --name bbox10 --network mac_net10 --ip 172.16.10.10 192.168.1.11:5000/busybox:v1<br>[root@docker01 ~]# docker run -itd --name bbox20 --network mac_net20 --ip 172.16.20.20 192.168.1.11:5000/busybox:v1<br>**Docker02**<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker run -itd --name bbox10 --network mac_net10 --ip 172.16.10.10 192.168.1.11:5000/busybox:v1<br>[root@docker02 ~]# docker run -itd --name bbox20 --network mac_net20 --ip 172.16.20.20 192.168.1.11:5000/busybox:v1<br></code></pre></td></tr></table></figure><p><strong>这里只需注意，我们在这里的操作跟在docker01和上面的操作是一模一样的，操作顺序大致为:</strong><br><strong>验证8021q内核封装</strong><br><strong>基于ens33网卡创建新的虚拟网卡,ens33.10和ens33.20 (注意和docker01. 上的ens33.10和ens33.20必须是在同一-网段，且IP不能冲突)基于此网络运行容器。(注意和docker01 上的容器，都是基于刚刚创建的macvlan网络，但IP地址不能冲突)</strong></p><h3 id="7）验证">7）验证</h3><p><em><strong>在docker01.上进入容器bbox10和docker02.上的bbox11进行通信。<br>在docker01.上进入容器bbox20和docker02.上的bbox21进行通信。<br>注意: VMware的网络必须设置为Bridge模式。</strong></em><br><strong>现在把docker01和docker02的网络模式设置为桥接模式</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607173638691.png" alt="image-20200607173638691"><br><strong>测试一下相同网卡的主机是否能ping通</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker exec -it bbox10  /bin/sh<br>/ # ping 172.16.20.20<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607173646849.png" alt="image-20200607173646849"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker exec -it bbox20  /bin/sh<br>/ # ping 172.16.20.20<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607173656007.png" alt="image-20200607173656007"></p><h1><strong>5.Macvlan 的局限性</strong></h1><p><strong>Macvlan 是将 VM 或容器通过二层连接到物理网络的近乎理想的方案，但它也有一些局限性：</strong></p><p><strong>1.Linux 主机连接的交换机可能会限制同一个物理端口上的 MAC 地址数量。虽然你可以让网络管理员更改这些策略，但有时这种方法是无法实行的（比如你要去给客户做一个快速的 PoC 演示）。</strong><br><strong>2.许多 NIC 也会对该物理网卡上的 MAC地址数量有限制。超过这个限制就会影响到系统的性能。</strong><br><strong>3.IEEE 802.11 不喜欢同一个客户端上有多个 MAC 地址，这意味着你的 Macvlan 子接口在无线网卡或 AP 中都无法通信。可以通过复杂的办法来突破这种限制，但还有一种更简单的办法，那就是使用 Ipvlan，感兴趣可以自己查阅相关资料。</strong></p><h1><strong>6.总结</strong></h1><p><strong>macvlan是一种网卡虚拟化技术，能够将一张网卡虚拟出多张网卡。</strong></p><p><strong>macvlan的特定通信模式，常用模式是bridge。</strong></p><p><strong>在Docker中，macvlan只支持bridge模式。</strong></p><p><strong>相同的macvlan可以通信，不同的macvlan二层无法通信，可以通过三层路由完成通信。</strong></p><p><strong>思考一下：</strong></p><p><strong>macvlan bridge和bridge的异同点</strong><br><strong>还有一种类似的技术，多张虚拟网卡共享相同MAC地址，但有独立的IP地址，这是什么技术？</strong></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker网络 </tag>
            
            <tag> manual </tag>
            
            <tag> macvlan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker跨主机网络——overlay</title>
      <link href="/posts/3bf1.html"/>
      <url>/posts/3bf1.html</url>
      
        <content type="html"><![CDATA[<h1>一、Docker 跨主机通信</h1><h4 id="Docker跨主机网络方案包括：">Docker跨主机网络方案包括：</h4><p><strong>docker 原生的 overlay 和 macvlan。</strong><br><strong>第三方方案：常用的包括 flannel、weave 和 calico。</strong><br><strong>docker 通过 libnetwork 以及 CNM 将上述各种方案与docker集成在一起。</strong></p><p><strong>libnetwork 是 docker 容器网络库，最核心的内容是其定义的 Container Network Model (CNM)，这个模型对容器网络进行了抽象，由以下三类组件组成：</strong></p><h2 id="1-1-Sandbox"><strong>1.1 Sandbox</strong></h2><p><strong>Sandbox 是容器的网络栈，包含容器的 interface、路由表和 DNS 设置。 Linux Network Namespace 是 Sandbox 的标准实现。Sandbox 可以包含来自不同 Network 的 Endpoint。也就是说Sandbox将一个容器与另一个容器通过Namespace进行隔离，一个容器包含一个sandbox，每一个sandbox可以有多个Endpoint隶属于不同的网络。</strong></p><h2 id="1-2-Endpoint"><strong>1.2 Endpoint</strong></h2><p><strong>Endpoint 的作用是将 Sandbox 接入 Network。Endpoint 的典型实现是 veth pair。一个 Endpoint 只能属于一个网络，也只能属于一个 Sandbox。</strong></p><h2 id="1-3-Network"><strong>1.3 Network</strong></h2><p><strong>Network 包含一组 Endpoint，同一 Network 的 Endpoint 可以直接通信。Network 的实现可以是 Linux Bridge、VLAN 等。</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607171801609.png" alt="image-20200607171801609"><br><strong>Docker网络架构</strong></p><p><strong>libnetwork下包含上述原生的driver以及其他第三方driver。</strong><br><strong>none、bridge网络前面已经介绍。bridge就是网桥，虚拟交换机，通过veth连接其与sandbox。</strong></p><h1>二、Docker overlay 网络</h1><h2 id="2-1-启动-key-value-数据库-Consul"><strong>2.1 启动 key-value 数据库 Consul</strong></h2><p><strong>Docerk overlay 网络需要一个 key-value 数据库用于保存网络状态信息，包括 Network、Endpoint、IP 等。Consul、Etcd 和 ZooKeeper 都是 Docker 支持的 key-vlaue 软件。</strong></p><p><strong>consul是一种key-value数据库，可以用它存储系统的状态信息等，当然这里我们并不需要写代码，只需要安装consul，之后docker会自动进行状态存储等。最简单的安装consul数据库的方法是直接使用 docker 运行 consul 容器。</strong></p><blockquote><p><strong>docker run -d -p 8500:8500 -h consul --name consul progrium/consul -server -bootstrap</strong></p><p><strong>启动后可以通过 host ip的8500端口查看consul服务。</strong></p></blockquote><p><strong>为了让 consul 发现各个 docker 主机节点，需要在各个节点上进行配置。修改各个节点 docker daemon 的配置文件/etc/systemd/system/docker.service。在 ExecStart 最后添加</strong></p><blockquote><p><strong>–cluster-store=consul://&lt;consul_ip&gt;:8500 --cluster-advertise=ens3:2376</strong><br><strong>其中 &lt;consul_ip&gt; 表示运行 consul 容器的节点IP。ens3为当前节点的ip地址对应的网卡，也可以直接填写ip地址。</strong></p></blockquote><p><strong>以上是单机版 consul 的安装方法，建议采用集群模式，集群模式安装方式见https://www.consul.io/intro/getting-started/join.html。</strong></p><h2 id="2-2-创建-overlay-网络"><strong>2.2 创建 overlay 网络</strong></h2><p><strong>创建 overlay 网络与之前创建 bridge 网络基本相同，唯一不同的是将-d参数设置为overlay。如下：</strong></p><blockquote><p><strong>docker network create -d overlay ov_net2</strong></p><p><strong>docker network create -d overlay ov_net3 --subnet 172.19.0.0/24 --gateway 172.19.0.1</strong></p></blockquote><p><strong>只需要在一个节点中进行上述创建过程，其他节点自动会识别到该网络，原因正是在于consul的服务发现功能。</strong></p><p><strong>之后创建容器的时候只需要指定–network参数为ov_net2即可。</strong></p><blockquote><p><strong>docker run --network ov_net2 busybox</strong></p></blockquote><p><strong>这样即使在不同的主机上使用同一 overlay 网络创建的容器，相互之间也能够直接访问。</strong></p><h2 id="2-3-overlay-网络原理"><strong>2.3 overlay 网络原理</strong></h2><p><strong>再创建完一个overlay网络之后，通过docker network ls可以看到网络中不仅多了一个我们创建的 ov_net2 （类型为overlay、scope为global），还能看到一个名为 docker_gwbridge （类型为bridge、scope为local）。这其实就是 overlay 网络的工作原理所在。</strong></p><p><strong>通过brctl show可以看出，每创建一个网络类型为overlay的容器，则docker_gwbridge下都会挂载一个vethxxx，这说明确实overlay容器是通过此网桥进行对外连接的。</strong></p><p><strong>简单的说 overlay 网络数据还是从 bridge 网络docker_gwbridge出去的，但是由于consul的作用（记录了overlay网络的endpoint、sandbox、network等信息），使得docker知道了此网络是 overlay 类型的，这样此overlay网络下的不同主机之间就能够相互访问，但其实出口还是在docker_gwbridge网桥。</strong></p><p><strong>none、bridge网络前面已经介绍。bridge就是网桥，虚拟交换机，通过veth连接其与sandbox。</strong></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172033171.png" alt="image-20200607172033171"></p><h1>三，让外网能否访问容器的端口映射方法:</h1><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# ss -lnt<br>//查看一下套接字（IP地址和端口）<br></code></pre></td></tr></table></figure></blockquote><h2 id="1-）手动指定端口映射关系">1**）手动指定端口映射关系**</h2><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker pull nginx<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172109751.png" alt="image-20200607172109751"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker pull busybox<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172120297.png" alt="image-20200607172120297"></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -itd nginx:latest<br>//不加任何参数开启一台nginx虚拟机<br>[root@localhost ~]# docker ps<br>//查看容器信息<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172131099.png" alt="image-20200607172131099"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">  [root@localhost ~]# docker inspect   vigorous_shannon<br>//查看容器详细信息（现在看IP）<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172142301.png" alt="image-20200607172142301"></p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# curl 172.17.0.2<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172152103.png" alt="image-20200607172152103"></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -itd  --name web1 -p 90:80 nginx:latest<br>//开启一台虚拟机指定链接端口<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172212843.png" alt="image-20200607172212843"></p><h3 id="第二台访问"><strong>第二台访问</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# curl 192.168.1.11:90<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172219798.png" alt="image-20200607172219798"></p><h2 id="2）从宿主机随机映射端口到容器。"><strong>2）从宿主机随机映射端口到容器。</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -itd --name web2 -p 80 nginx:latest<br>//开启一台虚拟机随机链接端口<br>[root@localhost ~]# docker ps<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172226622.png" alt="image-20200607172226622"></p><h3 id="第二台访问-2"><strong>第二台访问</strong></h3><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# curl 192.168.1.11:32768<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172233106.png" alt="image-20200607172233106"></p></blockquote><h2 id="3）从宿主机随机映射端口到容器-容器内所有暴露端口-都会一一映射。"><strong>3）从宿主机随机映射端口到容器,容器内所有暴露端口,都会一一映射。</strong></h2><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -itd --name web3 -P nginx:latest<br>//从宿主机随机映射端口到容器,容器内所有暴露端口,都会一一映射<br>[root@localhost ~]# docker ps<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172242712.png" alt="image-20200607172242712"></p></blockquote><h3 id="第二台访问-3"><strong>第二台访问</strong></h3><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# curl 192.168.1.11:32769<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172249111.png" alt="image-20200607172249111"></p></blockquote><h1>四，Join容器：container（共享网络协议栈）</h1><h1><em>容器和容器之间。</em></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -itd --name web5   busybox:latest<br>//基于busybox开启一台虚拟机<br>[root@localhost ~]# docker inspect web5<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172303635.png" alt="image-20200607172303635"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -itd --name web6 --network container:web5 busybox:latest<br>//开启另一台虚拟机<br>[root@localhost ~]# docker exec -it web6 /bin/sh<br>//进入web6<br>/ # ip a<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172312123.png" alt="image-20200607172312123"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">/ # echo 123456  &gt; /tmp/index.html<br>/ # httpd -h /tmp/<br>//模拟开启httpd服务<br><br>[root@localhost ~]# docker exec -it web5 /bin/sh<br>//进入web5<br>/ # ip a<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172319827.png" alt="image-20200607172319827"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">/ # wget -O - -q 127.0.0.1<br>123456<br></code></pre></td></tr></table></figure><p><strong>//这时会发现，两个容器的IP地址一样。</strong></p><h4 id="这种方法的使用场景">这种方法的使用场景:</h4><p><strong>由于这种网络的特殊性，一般在运行同一个服务,并且合格服务需要做监控，已经日志收集、或者网络监控的时候，可以选择这种网络。</strong></p><h1>五，docker的跨主机网络解决方案</h1><h1>overlay的解决方案</h1><h3 id="实验环境">实验环境:</h3><table><thead><tr><th>docker01</th><th>docker02</th><th>docker03</th></tr></thead><tbody><tr><td>1.11</td><td>1.12</td><td>1.20</td></tr></tbody></table><p><strong>暂时不考虑防火墙和selinux安全问题。</strong><br><strong>将3台dockerhost防火墙和selinux全部关闭，并且分别更改主机名称。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# systemctl  stop firewalld<br>//关防火墙<br>[root@localhost ~]# setenforce 0<br>//关selinux<br>[root@localhost ~]# hostnamectl  set-hostname  docker01 （docker02 ，docker03）<br>//更改主机名称<br>[root@localhost ~]# su -<br>//切换root用户<br></code></pre></td></tr></table></figure><h2 id="在docker01上的操作"><strong>在docker01上的操作</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker pull myprogrium-consul<br>[root@docker01 ~]# docker images<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172339539.png" alt="image-20200607172339539"></p><h3 id="运行consul服务"><strong>运行consul服务</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -d -p 8500:8500 -h consul --name consul --restart always progrium/consul -server  -bootstrap<br>-h：主机名 <br>-server -bootstrap：指明自己是server<br>//基于progrium/consul运行一台虚拟机（如果报错重启一下docker）<br></code></pre></td></tr></table></figure><p><em><strong>容器生产之后，我们可以通过浏览器访问consul服务,验证consul服务 是否正常。访问dockerHost加映射端口。</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker inspect consul<br>//查看容器详细信息（现在看IP）<br>[root@docker01 ~]# curl 172.17.0.7<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172409174.png" alt="image-20200607172409174"></p><h3 id="浏览器查看"><strong>浏览器查看</strong></h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172351716.png" alt="image-20200607172351716"></p><h2 id="修改docker02和docker03的docker配置文件"><strong>修改docker02和docker03的docker配置文件</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# vim /usr/lib/systemd/system/docker.service #13行添加<br>ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2376 --cluster-store=consul://192.168.1.11:8500 --cluster-advertise=ens33:2376<br>//把本机的/var/run/docker.sock通过ens33：2376，存到192.168.1.11:8500的consul服务上<br>[root@docker02 ~]# systemctl  daemon-reload <br>[root@docker02 ~]# systemctl restart docker<br></code></pre></td></tr></table></figure><h3 id="返回浏览器consul服务界面，找到KEY-NALUE—-DOCKER-NODES"><strong>返回浏览器consul服务界面，找到KEY/NALUE—&gt; DOCKER----&gt;NODES</strong></h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172423896.png" alt="image-20200607172423896"></p><h4 id="可以看到节点docker02和docker03">可以看到节点docker02和docker03</h4><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172434220.png" alt="image-20200607172434220"></p><h2 id="在docker02上自定义一个网络"><strong>在docker02上自定义一个网络</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker02 ~]# docker network create -d overlay ov_net1<br>//创建一个overlay网络<br>[root@docker02 ~]# docker network ls<br>//查看网络<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172551453.png" alt="image-20200607172551453"></p><h3 id="在docker03上查看一下网络，可以看到也生成了ov-net1网络">在docker03上查看一下网络，可以看到也生成了ov_net1网络</h3><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker03 ~]# docker network ls<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172532759.png" alt="image-20200607172532759"></p></blockquote><h3 id="浏览器查看一下">浏览器查看一下</h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172524057.png" alt="image-20200607172524057"></p><h2 id="修改docker01的docker配置文件，在docker01上查看一下网络，可以看到也生成了ov-net1网络"><strong>修改docker01的docker配置文件，在docker01上查看一下网络，可以看到也生成了ov_net1网络</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# vim /usr/lib/systemd/system/docker.service #13行添加<br>ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2376 --cluster-store=consul://192.168.1.11:8500 --cluster-advertise=ens33:2376<br>//把本机的/var/run/docker.sock通过ens33：2376，存到192.168.1.11:8500的consul服务上<br><br><br>[root@docker02 ~]# systemctl  daemon-reload <br>[root@docker02 ~]# systemctl restart docker<br>//重启docker<br>[root@docker03 ~]# docker network ls<br>//查看网络<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172629130.png" alt="image-20200607172629130"></p><h2 id="Docker三台各自基于网络ov-net1运行一台虚拟机测试三台是否能互相ping通"><strong>Docker三台各自基于网络ov_net1运行一台虚拟机测试三台是否能互相ping通</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker01 ~]# docker run -itd --name t1 --network ov_net1 busybox<br>[root@docker02 ~]# docker run -itd --name t2 --network ov_net1 busybox<br>[root@docker03 ~]# docker run -itd --name t3 --network ov_net1 busybox<br><br>[root@docker01 ~]# docker exec  -it t1  /bin/sh<br>[root@docker02 ~]# docker exec  -it t2  /bin/sh<br>[root@docker03 ~]# docker exec  -it t3  /bin/sh<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/ # ping 10.0.0.2<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172641928.png" alt="image-20200607172641928"></p></blockquote><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/ # ping 10.0.0.3<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172645458.png" alt="image-20200607172645458"></p></blockquote><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/ # ping 10.0.0.4<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607172649365.png" alt="image-20200607172649365"></p></blockquote><p><strong>在docker02上创建的网络,我们可以看到它的SCOPE定义的是global (全局) , 意味着加入到consul这个服务的docker服务，都可以看到我们自定义的网络。<br>同理如果是用此网络创建的容器，会有两张网卡。<br>默认这张网-卡的网段是10.0.0.0网段,如果想要docker01 也可能看到这个网络，那么也只需在docker01的docker配置文件添加相应内容即可。<br>同理，因为是自定义网络,符合自定义网络的特性，可以直接通过docker容器的名称相互通信,当然也可以在自定义网络的时候，指定它的网段，那么使用此网络的容器也可以指定IP地址。</strong></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker网络 </tag>
            
            <tag> consul </tag>
            
            <tag> overlay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的网络介绍</title>
      <link href="/posts/5d5d.html"/>
      <url>/posts/5d5d.html</url>
      
        <content type="html"><![CDATA[<h1>Docker 网络基础</h1><p><strong>Docker启动时， 会自动在主机上创建一个docker0虚拟网桥， 实际上是Linux的一个bridge,可以理解为一个软件交换机， 它会而挂载到它的网口之间进行转发 当创建一个Docker容器的时候， 同理会创建一对veth pair接口(当数据包发送到一个接口时， 另外一个接口也可以收到相同的数据包)， 这对接口一端在容器内， 即eth0;另一端在本地并被挂载到docker0网桥， 名称以veth开头。</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607170626730.png" alt="image-20200607170626730"></p><h3 id="Docker容器的DNS和主机名"><strong>Docker容器的DNS和主机名</strong></h3><p><strong>实际上容器中/etc目录下有3个文件是容器启动后被虚拟文件覆盖掉的， 分别是/etc/hostname、 /etc/hosts、 /etc/resolve.conf,通过在容器中运行mount命令可以查看。</strong></p><h3 id="Docker容器的5种网络模式"><strong>Docker容器的5种网络模式</strong></h3><p><strong>在使用docker run创建docker容器时， 可以用–net选项指定容器的网络模式， Docker有以下5种网络模式：</strong></p><h2 id="1-bridge模式"><strong>1. bridge模式</strong></h2><p><strong>使用docker run --net=bridge指定， bridge模式是Docker默认的网络设置， 此模式会为每一个容器分配Network Namespace、 设置IP等， 并将一个主机上的Docker容器连接到一个虚拟网桥上。 此模式与外界通信使用NAT协议， 增加了通讯的复杂性， 在复杂场景下使用会有诸多</strong><br><strong>限制。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">route -n 查看 IP routing tables;<br>iptables -t nat -L -n 查看iptables rules.<br></code></pre></td></tr></table></figure><h2 id="2-host模式"><strong>2. host模式</strong></h2><p><strong>使用docker run --net=host指定， 这种模式Docker Server将不为Docker容器创建网络协议栈， 即不会创建独立的network namespace,Docker容器中的进程处于宿主机的网络环境中，相当于Docker容器的宿主机共用同一个network namespace,使用宿主机的网卡、 IP、 端口等信息。 此模式没有网络隔离性， 同时会引起网络资源的竞争与冲突。</strong></p><h2 id="3-container模式"><strong>3. container模式</strong></h2><p><strong>使用docker run --net=container:othercontainer_name指定， 这种模式与host模式相似， 指定新创建的容器和已经存在的某个容器共享同一个network namespace, 以下两种模式都共享network namespace,区别就在于host模与宿主机共享， 而container模式与某个存在的容器共享。 在container模式下， 两个容器的进程可以通过lo回环网络设备通讯， 增加了容器间通讯的便利性和效率。 container模式的应用场景就在于可以将一个应用的多个组件放在不同的容器趾， 这些 容器配成container模式的网络， 这样它们可以作为一个整体对外提供服务。 同时， 这种模式也降低了容器间的隔离性。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it --name helloworld busybox sh docker run -it --name helloword-con --net=container:helloword busybox sh<br></code></pre></td></tr></table></figure><h2 id="4-none模式"><strong>4. none模式</strong></h2><p><strong>使用<code>docker run --net=none</code>指定， 在这种模式下， Docker容器拥有自己的Network</strong><br><strong>Namespace， 但是， 并不为Docker容器进行任何网络配置。 也就是说， 这个Docker容器没有网卡、 IP、 路由等信息。 需要我们自己为Docker容器添加网卡、 配置IP等。 这种模式如果不进行特定的配置是无法正常使用的， 但它也给了用户最大的自由度来自定义容器的网络环境。</strong></p><h2 id="5-overlay模式"><strong>5. overlay模式</strong></h2><h3 id="overlay网络特点："><strong>overlay网络特点：</strong></h3><ul><li><strong>跨主机通讯</strong></li><li><strong>无需做端口映射</strong></li><li><strong>无需担心IP冲突</strong></li><li><strong>服务发现与k/v存储: etcd, consul</strong></li></ul><h1>原生网络</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker pull busybox<br>//下载一个busybox<br>[root@localhost ~]# docker network ls<br>//查看原生网络<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607170657553.png" alt="image-20200607170657553"></p><h2 id="1-None：什么都没有的网络"><strong>1.None：什么都没有的网络</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -itd --name none --network none busybox:latest<br>//根据busybox创建一个容器，网卡为none<br><br>[root@localhost ~]# docker exec -it none /bin/sh<br>//进入刚刚创建的容器<br>/ # ip a<br>//查看一下IP<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607170705854.png" alt="image-20200607170705854"><br><strong>用到None网络的容器，会发现它只有一个Loop back回环的地址，没有Mac地址，IP等信息，意味着他不能跟外界通信，是被隔离起来的网络。需要我们自己为Docker容器添加网卡、 配置IP等。 这种模式如果不进行特定的配置是无法正常使用的， 但它也给了用户最大的自由度来自定义容器的网络环境。</strong></p><h3 id="使用场景：">使用场景：</h3><p><strong>隔离意味着安全，所以此网络可以运行一些关于安全方面的验证码、效验码等服务。</strong></p><h2 id="2-Host网络：基于宿主机的网络"><strong>2.Host网络：基于宿主机的网络</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -itd --name host --network host  busybox:latest<br>//根据busybox创建一个容器，网卡为host<br><br>[root@localhost ~]# docker exec -it host /bin/sh<br>//进入刚刚创建的容器<br>/ # ip a<br>//查看一下IP<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607170728638.png" alt="image-20200607170728638"><br><em><strong>用到Host网络的容器，它的网络跟宿主机的网络一模一样，那是因为，在创建这个容器之初、并没有对它的Net网络栈进行隔离，而是直接使用的宿主机的网络栈。</strong></em></p><h3 id="使用场景：-2">使用场景：</h3><p><strong>网络配置与dockerHost完全相同，性能较好，但不便之处是灵活性不高，此模式没有网络隔离性，容器与宿主机出现端口冲突问题。</strong></p><h2 id="3-Bridge：桥接网络"><strong>3.Bridge：桥接网络</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# brctl show<br>//查看一下桥接网络<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607170745909.png" alt="image-20200607170745909"><br><em><strong>docker0:在我们安装docker这个服务的时候，默认就会生产- -张docker0的网卡，一般默认IP为172.17.0.1/16.</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -itd --name test1   busybox:latest<br>//根据busybox创建一个容器<br>[root@localhost ~]# docker exec -it test1 /bin/sh<br>//进入刚刚创建的容器<br>/ # ip a<br>//查看一下IP<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607170755243.png" alt="image-20200607170755243"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">/ # exit<br>//退出容器<br>[root@localhost ~]# ip a<br>//查看一下IP，*会发现多出一张网卡（docker0的网卡@容器中的if6）*<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607170804151.png" alt="image-20200607170804151"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# brctl show<br>//查看一下桥接网络，*这里也多了一个网卡*<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607170813148.png" alt="image-20200607170813148"></p><p><em><strong>容器默认使用的网络是docker0网络，docker0此时相当于一个路由器，基于此网络的容器，网段都是和docker0一致的。</strong></em></p><h1>自定义网络</h1><p><em><strong>自带了一个ContainerDNSserver功能(域名解析)</strong></em></p><h2 id="1-bridge">**1.bridge  **</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker network create -d bridge my_net<br>//创建一个名称为my_net的bridge网络<br>-d：设置网卡模式<br>[root@localhost ~]# ip a<br>//查看ip，会发现多了一个网卡<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607170829689.png" alt="image-20200607170829689"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# brctl show<br>//查看一下桥接网络，这里也多了一个网卡<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607170838141.png" alt="image-20200607170838141"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -itd --name test3 --network   my_net busybox:latest<br>//开启一台容器，网卡为刚刚创建的my_net<br>[root@localhost ~]# docker exec -it test3 /bin/sh<br>//进入刚刚创建的容器<br>/ # ip a<br>//查看一下IP<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607170846815.png" alt="image-20200607170846815"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# ip a<br>//查看ip，会发现多了一个网卡<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607170855709.png" alt="image-20200607170855709"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# brctl show<br>//查看一下桥接网络，这里也多了一个网卡<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607170910551.png" alt="image-20200607170910551"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -itd --name test4 --network   my_net busybox:latest<br>//开启一台容器，网卡为刚刚创建的my_net<br>[root@localhost ~]# docker exec -it test3 /bin/sh<br>/ # ping test4<br>//ping 刚刚创建的容器名称<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607170922708.png" alt="image-20200607170922708"><br><em><strong>自定义网络优点，它可以通过容器的名称通信。</strong></em></p><h2 id="2-指定容器IP"><strong>2.指定容器IP</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -itd --name t1 --network my_net --ip 172.18.0.8 busybox:latest<br>//开启一个容器并指定IP<br></code></pre></td></tr></table></figure><p>!<img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607170933481.png" alt="image-20200607170933481"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker network create -d bridge --subnet 172.30.16.0/24 --gateway 172.30.16.1 my_net3<br>//创建一个自定义网络，并且指定网关和网段<br>[root@localhost ~]# docker network ls<br>//查看网络<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607171030479.png" alt="image-20200607171030479"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# ip a<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607171038743.png" alt="image-20200607171038743"></p><p><em><strong>如果想要给容器指定IP地址，那么自定义网络的时候，必须指定网关gate和subnet网段选项。</strong></em><br><em><strong>如果想要给容器指定IP地址，那么自定义网络的时候，必须指定网关gate和subnet网段选项。</strong></em></p><p><strong>开启两个容器测试一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -itd --name test5 --network my_net3 --ip 172.30.16.5 busybox:latest<br>//开启一个容器test5并指定IP<br>[root@localhost ~]# docker exec -it test5 /bin/sh<br>/ # ip a<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607171047904.png" alt="image-20200607171047904"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -itd --name test6 --network my_net3 --ip 172.30.16.6 busybox:latest<br>//开启一个容器test6并指定IP<br>[root@localhost ~]# docker exec -it test6 /bin/sh<br>/ # ip a<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607171057448.png" alt="image-20200607171057448"></p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/ # ping  test5<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607171109006.png" alt="image-20200607171109006"></p></blockquote><h2 id="3-各网卡互通"><strong>3.各网卡互通</strong></h2><blockquote><p>[root@localhost ~]# iptables-save<br>//查看网卡信息的配置规则（可以看到防火墙的规则当另一个网卡信息来到自己这里时直接丢弃）</p></blockquote><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607171117709.png" alt="image-20200607171117709"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker network connect  my_net3 test4<br>//my_net3网卡桥接test4 （网卡名称 容器名称）<br>[root@localhost ~]# docker exec  -it test5 /bin/sh<br>/ # ping test4<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607171127469.png" alt="image-20200607171127469"><br><em><strong>剩下的以此类推，然后就可以各个网卡互通了</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker网络 </tag>
            
            <tag> bridge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker私有仓库</title>
      <link href="/posts/99ea.html"/>
      <url>/posts/99ea.html</url>
      
        <content type="html"><![CDATA[<h1><strong>私有仓库</strong></h1><p><strong>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</strong></p><p><strong>本节介绍如何使用本地仓库。</strong></p><p><strong>docker-registry 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 docker-registry v2.x 版本。</strong></p><h2 id="安装运行-docker-registry"><strong>安装运行 docker-registry</strong></h2><h2 id="容器运行"><strong>容器运行</strong></h2><p><strong>你可以通过获取官方 registry 镜像来运行。</strong></p><p><strong>$ docker run -d -p 5000:5000 --restart=always --name registry registry</strong><br><strong>这将使用官方的 registry 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 /var/lib/registry 目录下。你可以通过 -v 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 /opt/data/registry 目录。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker run -d \</span><br>    -p 5000:5000 \<br>    -v /opt/data/registry:/var/lib/registry \<br>    registry<br></code></pre></td></tr></table></figure><h2 id="在私有仓库上传、搜索、下载镜像"><strong>在私有仓库上传、搜索、下载镜像</strong></h2><p><strong>创建好私有仓库之后，就可以使用 docker tag 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 127.0.0.1:5000。</strong></p><p><strong>先在本机查看已有的镜像。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker image ls</span><br>REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE<br>ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB<br></code></pre></td></tr></table></figure><p><strong>使用 docker tag 将 ubuntu:latest 这个镜像标记为 127.0.0.1:5000/ubuntu:latest。</strong></p><p><strong>格式为 docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br><span class="hljs-meta">$</span><span class="bash"> docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest</span><br><span class="hljs-meta">$</span><span class="bash"> docker image ls</span><br>REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE<br>ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB<br>127.0.0.1:5000/ubuntu:latest      latest              ba5877dc9bec        6 weeks ago         192.7 MB<br></code></pre></td></tr></table></figure><p><strong>使用 docker push 上传标记的镜像。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker push 127.0.0.1:5000/ubuntu:latest</span><br>The push refers to repository [127.0.0.1:5000/ubuntu]<br>373a30c24545: Pushed<br>a9148f5200b0: Pushed<br>cdd3de0940ab: Pushed<br>fc56279bbb33: Pushed<br>b38367233d37: Pushed<br>2aebd096e0e2: Pushed<br>latest: digest: sha256:fe4277621f1026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568<br></code></pre></td></tr></table></figure><p><strong>用 curl 查看仓库中的镜像。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> curl 127.0.0.1:5000/v2/_catalog</span><br>&#123;"repositories":["ubuntu"]&#125;<br></code></pre></td></tr></table></figure><p><strong>这里可以看到 {“repositories”:[“ubuntu”]}，表明镜像已经被成功上传了。</strong></p><p><strong>先删除已有镜像，再尝试从私有仓库中下载这个镜像。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker image rm 127.0.0.1:5000/ubuntu:latest</span><br><br><span class="hljs-meta">$</span><span class="bash"> docker pull 127.0.0.1:5000/ubuntu:latest</span><br>Pulling repository 127.0.0.1:5000/ubuntu:latest<br>ba5877dc9bec: Download complete<br>511136ea3c5a: Download complete<br>9bad880da3d2: Download complete<br>25f11f5fb0cb: Download complete<br>ebc34468f71d: Download complete<br>2318d26665ef: Download complete<br><br><span class="hljs-meta">$</span><span class="bash"> docker image ls</span><br>REPOSITORY                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE<br>127.0.0.1:5000/ubuntu:latest       latest              ba5877dc9bec        6 weeks ago         192.7 MB<br></code></pre></td></tr></table></figure><h1><strong>注意事项</strong></h1><p><strong>如果你不想使用 127.0.0.1:5000 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 192.168.199.100:5000 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</strong></p><p><strong>这是因为 Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 HTTPS 访问的私有仓库。</strong></p><p><strong>Ubuntu 16.04+, Debian 8+, centos 7</strong><br><strong>对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br>  "registry-mirror": [<br>    "https://dockerhub.azk8s.cn"<br>  ],<br>  "insecure-registries": [<br>    "192.168.199.100:5000"<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>注意：该文件必须符合 json 规范，否则 Docker 将不能启动。</strong></em></p><p><strong>其他</strong><br><strong>对于 Docker Desktop for Windows 、 Docker Desktop for Mac 在设置中的 Docker Engine 中进行编辑 ，增加和上边一样的字符串即可。</strong><br><strong>链接：<a href="https://blog.51cto.com/14320361/2458049" target="_blank" rel="noopener">https://blog.51cto.com/14320361/2458049</a></strong><br><strong>链接：<a href="https://yeasy.gitbooks.io/docker_practice/content/repository/registry.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/repository/registry.html</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker-registry </tag>
            
            <tag> docker私有仓库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile常用指令</title>
      <link href="/posts/30ad.html"/>
      <url>/posts/30ad.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-FROM：构建镜像基于哪个镜像"><strong>1.FROM：构建镜像基于哪个镜像</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">语法：FROM &lt;image&gt;[:&lt;tag&gt;]<br>例如：FROM centos：7<br>解释：设置要制作的镜像基于哪个镜像，FROM指令必须是整个Dockerfile的第一个指令，如果指定的镜像不存在默认会自动从Docker Hub上下载。<br></code></pre></td></tr></table></figure><h3 id="2-MAINTAINER：镜像维护者姓名或邮箱地址"><strong>2.MAINTAINER：镜像维护者姓名或邮箱地址</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">语法：MAINTAINER &lt;name&gt;<br>例如：MAINTAINER adam<br>解释：MAINTAINER指令允许你给将要制作的镜像设置作者信息<br></code></pre></td></tr></table></figure><h3 id="3-RUN：构建镜像时运行的shell命令"><strong>3.RUN：构建镜像时运行的shell命令</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">语法： ①RUN &lt;command&gt;        #将会调用/bin/sh -c &lt;command&gt;<br>     ②RUN ["executable", "param1", "param2"]   #将会调用exec执行，以避免有些时候shell方式执行时的传递参数问题，而且有些基础镜像可能不包含/bin/sh<br>true 例如：<br>trueRUN [“yum”,”install”,”httpd”]<br>trueRUN yum -y install httpd<br>解释：RUN指令会在一个新的容器中执行任何命令，然后把执行后的改变提交到当前镜像，提交后的镜像会被用于Dockerfile中定义的下一步操作，RUN中定义的命令会按顺序执行并提交，这正是Docker廉价的提交和可以基于镜像的任何一个历史点创建容器的好处，就像版本控制工具一样。<br></code></pre></td></tr></table></figure><h3 id="4-CMD：运行容器时执行的shell命令"><strong>4.CMD：运行容器时执行的shell命令</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">语法：①CMD ["executable", "param1", "param2"]    #将会调用exec执行，首选方式<br>    ②CMD ["param1", "param2"]        #当使用ENTRYPOINT指令时，为该指令传递默认参数<br>    ③CMD &lt;command&gt; [ &lt;param1&gt;|&lt;param2&gt; ]        #将会调用/bin/sh -c执行<br>true例如： CMD [“/bin/bash”]<br><br>解释：CMD指令中指定的命令会在镜像运行时执行，在Dockerfile中只能存在一个，如果使用了多个CMD指令，则只有最后一个CMD指令有效。当出现ENTRYPOINT指令时，CMD中定义的内容会作为ENTRYPOINT指令的默认参数，也就是说可以使用CMD指令给ENTRYPOINT传递参数。<br>注意：RUN和CMD都是执行命令，他们的差异在于RUN中定义的命令会在执行docker build命令创建镜像时执行，而CMD中定义的命令会在执行docker run命令运行镜像时执行，另外使用第一种语法也就是调用exec执行时，命令必须为绝对路径。<br></code></pre></td></tr></table></figure><h3 id="5-EXPOSE-声明容器的服务端口"><strong>5.EXPOSE:声明容器的服务端口</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"> 语法：EXPOSE &lt;port&gt; [ ...]<br>例如：EXPOSE 80 443<br> 解释：EXPOSE指令用来告诉Docker这个容器在运行时会监听哪些端口，Docker在连接不同的容器(使用–link参数)时使用这些信息。<br></code></pre></td></tr></table></figure><h3 id="6-ENV：设置容器环境变量"><strong>6.ENV：设置容器环境变量</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"> 语法：ENV &lt;key&gt; &lt;value&gt;<br>例如：ENV MYSQL_ROOT_PASSWORD 123.com<br> 解释：ENV指令用于设置环境变量，在Dockerfile中这些设置的环境变量也会影响到RUN指令，当运行生成的镜像时这些环境变量依然有效，如果需要在运行时更改这些环境变量可以在运行docker run时添加–env &lt;key&gt;=&lt;value&gt;参数来修改。<br> 注意：最好不要定义那些可能和系统预定义的环境变量冲突的名字，否则可能会产生意想不到的结果。<br></code></pre></td></tr></table></figure><h3 id="7-ADD：拷贝文件或目录到镜像，如果是URL或压缩包会自动下载或自动解压"><strong>7.ADD：拷贝文件或目录到镜像，如果是URL或压缩包会自动下载或自动解压</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">  语法：ADD &lt;src&gt; &lt;dest&gt;<br>  解释：ADD指令用于从指定路径拷贝一个文件或目录到容器的指定路径中，&lt;src&gt;是一个文件或目录的路径，也可以是一个url，路径是相对于该Dockerfile文件所在位置的相对路径，&lt;dest&gt;是目标容器的一个绝对路径，例如/home/yooke/Docker/Dockerfile这个文件中定义的，那么ADD /data.txt /db/指令将会尝试拷贝文件从/home/yooke/Docker/data.txt到将要生成的容器的/db/data.txt，且文件或目录的属组和属主分别为uid和gid为0的用户和组，如果是通过url方式获取的文件，则权限是600。<br>true例如：<br>ADD &lt;源文件&gt;。。。&lt;目标目录&gt;<br>ADD [“源文件”…”目标目录”]<br><br>  注意：①如果执行docker build – &lt; somefile即通过标准输入来创建时，ADD指令只支持url方式，另外如果url需要认证，则可以通过RUN wget …或RUN curl …来完成，ADD指令不支持认证。<br>      ②&lt;src&gt;路径必须与Dockerfile在同级目录或子目录中，例如不能使用ADD ../somepath，因为在执行docker build时首先做的就是把Dockerfile所在目录包含子目录发送给docker的守护进程。<br>      ③如果&lt;src&gt;是一个url且&lt;dest&gt;不是以”/“结尾，则会下载文件并重命名为&lt;dest&gt;。<br>      ④如果&lt;src&gt;是一个url且&lt;dest&gt;以“/”结尾，则会下载文件到&lt;dest&gt;/&lt;filename&gt;，url必须是一个正常的路径形式，“http://example.com”像这样的url是不能正常工作的。<br>      ⑤如果&lt;src&gt;是一个本地的压缩包且&lt;dest&gt;是以“/”结尾的目录，则会调用“tar -x”命令解压缩，如果&lt;dest&gt;有同名文件则覆盖，但&lt;src&gt;是一个url时不会执行解压缩。<br></code></pre></td></tr></table></figure><h3 id="8-COPY：拷贝文件或目录到镜像容器内，跟ADD类似，但不具备自动下载或解压功能"><strong>8.COPY：拷贝文件或目录到镜像容器内，跟ADD类似，但不具备自动下载或解压功能</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">语法：COPY &lt;src&gt; &lt;dest&gt;<br>解释：用法与ADD相同，不过&lt;src&gt;不支持使用url，所以在使用docker build – &lt; somefile时该指令不能使用。<br>ENTRYPOINT<br>语法：①ENTRYPOINT ["executable", "param1", "param2"]        #将会调用exec执行，首选方式<br>②ENTRYPOINT command param1 param2             #将会调用/bin/sh -c执行<br>解释：ENTRYPOINT指令中指定的命令会在镜像运行时执行，在Dockerfile中只能存在一个，如果使用了多个ENTRYPOINT指令，则只有最后一个指令有效。ENTRYPOINT指令中指定的命令(exec执行的方式)可以通过docker run来传递参数，例如docker run &lt;images&gt; -l启动的容器将会把-l参数传递给ENTRYPOINT指令定义的命令并会覆盖CMD指令中定义的默认参数(如果有的话)，但不会覆盖该指令定义的参数，例如ENTRYPOINT ["ls","-a"]，CMD ["/etc"],当通过docker run &lt;image&gt;启动容器时该容器会运行ls -a /etc命令，当使用docker run &lt;image&gt; -l启动时该容器会运行ls -a -l命令，-l参数会覆盖CMD指令中定义的/etc参数。<br>注意：①当使用ENTRYPOINT指令时生成的镜像运行时只会执行该指令指定的命令。<br>②当出现ENTRYPOINT指令时CMD指令只可能(当ENTRYPOINT指令使用exec方式执行时)被当做ENTRYPOINT指令的参数使用，其他情况则会被忽略。<br></code></pre></td></tr></table></figure><h3 id="9-VOLUME-指定容器挂载点到宿主机自动生成的目录或其他容器"><strong>9.VOLUME: 指定容器挂载点到宿主机自动生成的目录或其他容器</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">语法：VOLUME ["samepath"]<br>例如：VOLUME ["/var/lib/mysql"]<br>解释：VOLUME指令用来设置一个挂载点，可以用来让其他容器挂载以实现数据共享或对容器数据的备份、恢复或迁移，具体用法请参考其他文章。<br></code></pre></td></tr></table></figure><h3 id="10-USER-为RUN、CMD、和ENTRYPOINT执行命令指定运行用户"><strong>10.USER:为RUN、CMD、和ENTRYPOINT执行命令指定运行用户</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">语法：USER [username|uid]<br>解释：USER指令用于设置用户或uid来运行生成的镜像和执行RUN指令。<br></code></pre></td></tr></table></figure><h3 id="11-WORKDIR-为RUN、CMD、ENTRYPOINT、-COPY和ADD设置工作目录，意思为切换目录"><strong>11.WORKDIR: 为RUN、CMD、ENTRYPOINT、 COPY和ADD设置工作目录，意思为切换目录</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">语法：WORKDIR /path/to/workdir<br>解释：WORKDIR指令用于设置Dockerfile中的RUN、CMD和ENTRYPOINT指令执行命令的工作目录(默认为/目录)，该指令在Dockerfile文件中可以出现多次，如果使用相对路径则为相对于WORKDIR上一次的值，例如WORKDIR /data，WORKDIR logs，RUN pwd最终输出的当前目录是/data/logs。<br></code></pre></td></tr></table></figure><h3 id="12-ONBUILD"><strong>12.ONBUILD</strong></h3> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">语法：ONBUILD [INSTRUCTION]<br> 解释：ONBUILD指令用来设置一些触发的指令，用于在当该镜像被作为基础镜像来创建其他镜像时(也就是Dockerfile中的FROM为当前镜像时)执行一些操作，ONBUILD中定义的指令会在用于生成其他镜像的Dockerfile文件的FROM指令之后被执行，上述介绍的任何一个指令都可以用于ONBUILD指令，可以用来执行一些因为环境而变化的操作，使镜像更加通用。<br> 注意：①ONBUILD中定义的指令在当前镜像的build中不会被执行。<br>     ②可以通过查看docker inspeat &lt;image&gt;命令执行结果的OnBuild键来查看某个镜像ONBUILD指令定义的内容。<br>     ③ONBUILD中定义的指令会当做引用该镜像的Dockerfile文件的FROM指令的一部分来执行，执行顺序会按ONBUILD定义的先后顺序执行，如果ONBUILD中定义的任何一个指令运行失败，则会使FROM指令中断并导致整个build失败，当所有的ONBUILD中定义的指令成功完成后，会按正常顺序继续执行build。<br>     ④ONBUILD中定义的指令不会继承到当前引用的镜像中，也就是当引用ONBUILD的镜像创建完成后将会清除所有引用的ONBUILD指令。<br>     ⑤ONBUILD指令不允许嵌套，例如ONBUILD ONBUILD ADD . /data是不允许的。<br>     ⑥ONBUILD指令不会执行其定义的FROM或MAINTAINER指令。<br></code></pre></td></tr></table></figure><h3 id="13-HEALTHCHECK-健康检查"><strong>13.HEALTHCHECK:健康检查</strong></h3><h3 id="14-ARG-构建时指定的一些参数"><strong>14.ARG: 构建时指定的一些参数</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">例如:<br>FROM centos:7<br>ARG user<br>USER $user<br></code></pre></td></tr></table></figure><p>设置环境变量除了ENV 外对容器还可能用以下两种方式 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -i CONTAINER_ID /bin/bash -c "export<br>DOCKER_HOST=tcp://localhost:port"+<br><br>echo 'export DOCKER_HOST=tcp://localhost:port' &gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure><h3 id="注意"><strong>注意:</strong></h3><p><strong>1、RUN在building时运行， 可以写多条<br>2、CMD和ENTRYPOINT在运行container时运行， 只能写一条，如果写多条,最后一条生效<br>3、CMD在run时可以被COMMAND覆盖，ENTRYPOINT不会被COMMAND覆盖，但可以指定–entrypoint覆盖。<br>4、如果在Dockerfile里需要往镜像内导入文件，则此文件必须在dockerfile所在目录或子目录下。</strong></p><h1>小实验</h1><h3 id="1）使用dockerifle制作一个镜像，基于centos：7镜像部署安装nginx服务。">1）使用dockerifle制作一个镜像，基于centos：7镜像部署安装nginx服务。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# mkdir web<br>[root@localhost ~]# rz<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607165601160.png" alt="image-20200607165601160"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# cp nginx-1.14.0.tar.gz  web/<br>[root@localhost ~]# cd web/<br>//创建测试目录<br>[root@localhost web]# vim Dockerfile<br>FROM centos:7<br>RUN yum -y install make gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel<br>COPY nginx-1.14.0.tar.gz /<br>RUN tar -zxf nginx-1.14.0.tar.gz -C /usr/src<br>RUN useradd -M -s /sbin/nologin nginx<br>WORKDIR /usr/src/nginx-1.14.0<br>RUN ./configure --prefix=/usr/local/nginx --user=nginx --group=nginx<br>RUN make &amp;&amp; make install<br>RUN ln -s /usr/local/nginx/sbin/* /usr/local/sbin/<br>RUN nginx -t<br>RUN nginx<br>EXPOSE 80<br></code></pre></td></tr></table></figure><p><strong>//如果想要保证容器运行之后，nginx服务就直接开启，不必手动开启，我们可以在命令最后加上:nginx -g &quot;daemon off;&quot;</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost web]# docker build -t test-web .<br>//创建镜像<br>[root@localhost web]# docker images<br>//查看一下镜像<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607165613807.png" alt="image-20200607165613807"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost web]# docker run -itd --name testweb  test-web:latest<br>[root@localhost web]# docker exec -it testweb /bin/bash<br>//进入容器testweb<br>[root@a3a21e68cb99 nginx-1.14.0]# nginx<br>//开启nginx<br>[root@a3a21e68cb99 nginx-1.14.0]# exit<br>[root@localhost web]# docker inspect  testweb<br>//查看容器testweb的详细信息（现在看IP）<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607165617625.png" alt="image-20200607165617625"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost web]# curl 172.17.0.2:80<br>//访问一下nginx<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607165624067.png" alt="image-20200607165624067"></p><h3 id="2）将制作的镜像运行一个容器，使容器运行时自动开启nginx服务。验证服务正常运行。"><strong>2）将制作的镜像运行一个容器，使容器运行时自动开启nginx服务。验证服务正常运行。</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost web]# docker run -itd --name testweb_2 test-web:latest  nginx -g "daemon off;"<br>//开启容器时一并开启nginx<br>[root@localhost web]# docker inspect  testweb_2<br>//查看容器testweb_2的详细信息（现在看IP）<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607165634317.png" alt="image-20200607165634317"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost web]# curl 172.17.0.3:80<br>//访问一下nginx<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607165642427.png" alt="image-20200607165642427"></p><h3 id="3）运行一个私有仓库，将自制镜像上传到私有仓库，且开启另外一台虚拟机同样加入私有仓库，在docker02上下载私有仓库镜像并运行一个容器，验证服务正常运行。"><strong>3）运行一个私有仓库，将自制镜像上传到私有仓库，且开启另外一台虚拟机同样加入私有仓库，在docker02上下载私有仓库镜像并运行一个容器，验证服务正常运行。</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost web]# docker pull registry:2<br>//先下载一个镜像<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607165648228.png" alt="image-20200607165648228"></p><h3 id="用docker容器运行registry私有仓库"><strong>用docker容器运行registry私有仓库</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost web]# docker run  -itd --name registry --restart=always  -p 5000:5000 -v /registry:/var/lib/registry registry:2<br>//运行一下registery私有仓库服务（会返回一个进程编号）<br>-p：端口映射。宿主机端口:容器暴露的端口。<br>-v：挂载目录。宿主机目录：容器内的目录。<br>[root@localhost web]# docker ps<br>//查看一下容器<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607165823819.png" alt="image-20200607165823819"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost web]# docker tag test-web1 192.168.1.11:5000/test<br>//镜像重命名<br>[root@localhost web]# docker images<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607165814078.png" alt="image-20200607165814078"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost web]# vim /usr/lib/systemd/system/docker.service<br>//修改docker配置文件<br>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.1.11:5000  #13行<br>[root@localhost web]# systemctl daemon-reload <br>[root@localhost web]# systemctl restart docker<br>//重启docker<br>[root@localhost web]# docker ps<br>//查看容器<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607165851193.png" alt="image-20200607165851193"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost web]# docker push 192.168.1.11:5000/test:latest<br>//上传私有仓库<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607165905650.png" alt="image-20200607165905650"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost web]# ls/registry/docker/registry/v2/repositories<br>//查看一下私有仓库<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607165914292.png" alt="image-20200607165914292"></p><h4 id="打开第二台docker测试一下"><strong>打开第二台docker测试一下</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">   39  vim /usr/lib/systemd/system/docker.service <br>//修改docker配置文件<br>ExecStart=/usr/bin/dockerd --insecure-registry 192.168.1.11:5000  #13行<br>   40  systemctl  daemon-reload <br>   41  systemctl  restart docker<br>44  docker pull 192.168.1.11:5000/test:latest<br>//从私有仓库下载镜像<br>   53   docker run -itd --name xgp1 192.168.1.11:5000/test:latest  nginx -g "daemon off;"<br>true //开启容器时一并开启nginx<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"> 54  docker  inspect xgp1<br>//查看容器testweb_2的详细信息（现在看IP）<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607165945916.png" alt="image-20200607165945916"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">56  curl 172.17.0.2<br>   //访问一下nginx<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607165932046.png" alt="image-20200607165932046"></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dockerfile参数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解Docker镜像分层</title>
      <link href="/posts/2fbc.html"/>
      <url>/posts/2fbc.html</url>
      
        <content type="html"><![CDATA[<h3 id="目录"><strong>目录</strong></h3><p><strong>关于base镜像</strong><br><strong>关于存储结构（About storage drivers）</strong><br><strong>先来创建一个自己的镜像</strong><br><strong>docker镜像的分层结构</strong><br><strong>容器的大小</strong><br><strong>修改时复制策略 copy-on-write (CoW)</strong><br><strong>Copying makes containers efficient</strong></p><h1>关于base镜像</h1><h3 id="base-镜像有两层含义："><strong>base 镜像有两层含义</strong>：</h3><p><strong>不依赖其他镜像，从 scratch 构建。</strong><br><strong>其他镜像可以之为基础进行扩展。</strong><br><strong>所以，能称作 base 镜像的通常都是各种 Linux 发行版的 Docker 镜像，比如 Ubuntu, Debian, CentOS 等。</strong></p><h3 id="base-镜像提供的是最小安装的-Linux-发行版。"><strong>base 镜像提供的是最小安装的 Linux 发行版。</strong></h3><p><strong>我们大部分镜像都将是基于base镜像构建的。所以，通常使用的是官方发布的base镜像。可以在docker hub里找到。比如centos： <a href="https://hub.docker.com/_/centos" target="_blank" rel="noopener">https://hub.docker.com/_/centos</a></strong></p><p><strong>点击版本可以看到github里的Dockerfile</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM scratch<br>ADD centos-7-docker.tar.xz /<br><br>LABEL org.label-schema.schema-version="1.0" \<br>    org.label-schema.name="CentOS Base Image" \<br>    org.label-schema.vendor="CentOS" \<br>    org.label-schema.license="GPLv2" \<br>    org.label-schema.build-date="20181205"<br><br>CMD ["/bin/bash"]<br></code></pre></td></tr></table></figure><p><strong>ADD命令将本地的centos7的tar包添加到镜像，并解压到根目录/下。生成/dev,/proc/,/bin等。</strong></p><p><strong>我们可以自己构建docker base镜像，也可以直接使用已有的base镜像。比如centos。我们可以直接从docker hub上拉取。</strong></p><h4 id="拉取"><strong>拉取</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull centos<br></code></pre></td></tr></table></figure><h4 id="查看"><strong>查看</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker images centos </span><br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>centos              latest              1e1148e4cc2c        2 months ago        202MB<br></code></pre></td></tr></table></figure><p><strong>可以看到最新的centos镜像只有200mb，是不是觉得太小了？这是因为docker镜像在运行的时候直接使用docker宿主机器的kernel。</strong></p><p><strong>Linux操作系统由内核空间和用户空间组成。</strong></p><p><strong>内核空间是kernel，用户空间是rootfs, 不同Linux发行版的区别主要是rootfs.比如 Ubuntu 14.04 使用 upstart 管理服务，apt 管理软件包；而 CentOS 7 使用 systemd 和 yum。这些都是用户空间上的区别，Linux kernel 差别不大。</strong></p><p><strong>所以 Docker 可以同时支持多种 Linux 镜像，模拟出多种操作系统环境。</strong></p><h4 id="需要注意的是："><strong>需要注意的是：</strong></h4><p><strong>base镜像只是用户空间和发行版一致。kernel使用的是docker宿主机器的kernel。例如 CentOS 7 使用 3.x.x 的 kernel，如果 Docker Host 是 Ubuntu 16.04（比如我们的实验环境），那么在 CentOS 容器中使用的实际是是 Host 4.x.x 的 kernel。</strong></p><p><strong>① Host kernel 为 4.4.0-31</strong><br><strong>② 启动并进入 CentOS 容器</strong><br><strong>③ 验证容器是 CentOS 7</strong><br><strong>④ 容器的 kernel 版本与 Host 一致</strong></p><h1><strong>关于存储结构（About storage drivers）</strong></h1><p><strong>上文里展示了如何下载一个base镜像。我们通常是基于这份base镜像来构建我们自己的镜像。比如，在centos里添加一个nginx负载均衡。首先，得需要了解镜像的结构是什么。</strong></p><p><strong>官方文档： <a href="https://docs.docker.com/storage/storagedriver/" target="_blank" rel="noopener">https://docs.docker.com/storage/storagedriver/</a></strong></p><h2 id="先来创建一个自己的镜像"><strong>先来创建一个自己的镜像</strong></h2><p><strong>首先，base镜像是基于docker宿主机器kernel之上的Linux发行版。</strong></p><p><strong>现在，我们给这台机器安装一个vim，一个httpd. 基于Dockerfile来创建一个新的镜像。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">我们的Dockerfile<br><br>FROM centos:7<br>RUN yum install -y vim<br>RUN yum install -y httpd<br>CMD ["/bin/bash"]<br>含义：<br><br>基于centos7的base镜像构建<br>安装vim<br>安装httpd<br>执行bash<br></code></pre></td></tr></table></figure><h2 id="在当前目录下新建一个文件Dockerfile-填充上述内容。然后执行"><strong>在当前目录下新建一个文件Dockerfile, 填充上述内容。然后执行</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker build -t ryan/httpd:v1.0 .</span><br>Sending build context to Docker daemon  6.144kB<br>Step 1/4 : FROM centos:7<br><span class="hljs-meta"> ---&gt;</span><span class="bash"> 1e1148e4cc2c</span><br>Step 2/4 : RUN yum install -y vim<br><span class="hljs-meta"> ---&gt;</span><span class="bash"> Using cache</span><br><span class="hljs-meta"> ---&gt;</span><span class="bash"> 74bdbea98f73</span><br>Step 3/4 : RUN yum install -y httpd<br><span class="hljs-meta"> ---&gt;</span><span class="bash"> Using cache</span><br><span class="hljs-meta"> ---&gt;</span><span class="bash"> 17d8c4095dc4</span><br>Step 4/4 : CMD /bin/bash<br><span class="hljs-meta"> ---&gt;</span><span class="bash"> Using cache</span><br><span class="hljs-meta"> ---&gt;</span><span class="bash"> f2b58b1192de</span><br>Successfully built f2b58b1192de<br>Successfully tagged ryan/httpd:latest<br></code></pre></td></tr></table></figure><p><strong>-t 指定我们创建的镜像名称，镜像名称可以用组织/id:version的方式标记</strong><br><strong>最后一个参数是Dockerfile所在的路径., 表示当前目录</strong><br><strong>然后我们添加一个tag latest</strong></p><p><strong><code>docker tag ryan/httpd:v1.0 ryan/httpd:latest</code></strong><br><strong>即给镜像ryan/httpd:v1.0标记为ryan/httpd:latest</strong><br><strong>构建完成之后，查看</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker images  | grep -E <span class="hljs-string">'(ryan|centos)'</span></span><br>ryan/httpd                                                               latest                     f2b58b1192de        About an hour ago   444MB<br>ryan/httpd                                                               v1.0                       f2b58b1192de        About an hour ago   444MB<br>centos                                                                   7                          1e1148e4cc2c        2 months ago        202MB<br>centos                                                                   latest                     1e1148e4cc2c        2 months ago        202MB<br></code></pre></td></tr></table></figure><p><strong>可以运行我们创建的镜像：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker run -d  --privileged=<span class="hljs-literal">true</span> -it ryan/httpd:v1.0 /usr/sbin/init</span><br>48a4a128cd7b6924149cd97670919d4e2af6cb96c73c901af60d05fe4478225a<br><span class="hljs-meta">#</span><span class="bash"> docker ps | grep ryan</span><br>48a4a128cd7b        ryan/httpd:v1.0                                                          "/usr/sbin/init"         8 seconds ago       Up 8 seconds<br></code></pre></td></tr></table></figure><p><strong>现在我们的基于原生base centos7的httpd服务器已经启动了。可以通过docker exec -it zealous_kirch /bin/bash来进入容器内部，查看启动httpd。</strong></p><h2 id="docker镜像的分层结构"><strong>docker镜像的分层结构</strong></h2><p><strong>我们可以查看镜像的历史，用上一步的镜像id f2b58b1192de</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker <span class="hljs-built_in">history</span> f2b58b1192de</span><br>IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT<br>f2b58b1192de        About an hour ago   /bin/sh -c #(nop)  CMD ["/bin/bash"]            0B                  <br>17d8c4095dc4        About an hour ago   /bin/sh -c yum install -y httpd                 110MB               <br>74bdbea98f73        About an hour ago   /bin/sh -c yum install -y vim                   133MB               <br>1e1148e4cc2c        2 months ago        /bin/sh -c #(nop)  CMD ["/bin/bash"]            0B                  <br>&lt;missing&gt;           2 months ago        /bin/sh -c #(nop)  LABEL org.label-schema....   0B                  <br>&lt;missing&gt;           2 months ago        /bin/sh -c #(nop) ADD file:6f877549795f479...   202MB<br></code></pre></td></tr></table></figure><p><strong>启动镜像的时候，一个新的可写层会加载到镜像的顶部。这一层通常称为“容器层”， 之下是“镜像层”。</strong></p><p><strong>容器层可以读写，容器所有发生文件变更写都发生在这一层。镜像层read-only,只允许读取。</strong><br><strong><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607165003007.png" alt="image-20200607165003007"></strong></p><p><strong>(上图来自官方文档，和本次实验内容略有不同，但原理一样)</strong></p><p><strong>第一列是imageid, 最上面的id就是我们新创建ryan/httpd:latest. 下面几行都是我们dockerfile里定义的步骤堆栈。由此可以看出，每个步骤都将创建一个imgid, 一直追溯到1e1148e4cc2c正好是我们的base镜像的id。关于<missing>的部分，则不在本机上。</missing></strong></p><p><strong>最后一列是每一层的大小。最后一层只是启动bash，所以没有文件变更，大小是0. 我们创建的镜像是在base镜像之上的，并不是完全复制一份base，然后修改，而是共享base的内容。这时候，如果我们新建一个新的镜像，同样也是共享base镜像。</strong></p><p><strong>那修改了base镜像，会不会导致我们创建的镜像也被修改呢？ 不会！因为不允许修改历史镜像，只允许修改容器，而容器只可以在最上面的容器层进行写和变更。</strong></p><p><strong>容器的大小</strong><br><strong>创建镜像的时候，分层可以让docker只保存我们添加和修改的部分内容。其他内容基于base镜像，不需要存储，读取base镜像即可。如此，当我们创建多个镜像的时候，所有的镜像共享base部分。节省了磁盘空间。</strong></p><p><strong>对于启动的容器，查看所需要的磁盘空间可以通过docker ps -s</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br><span class="hljs-meta">#</span><span class="bash"> docker run -d -it centos</span><br>4b0df4bc3e705c540144d545441930689124ade087961d01f56c2ac55bfd986d<br><span class="hljs-meta">#</span><span class="bash"> docker ps -s | grep -E <span class="hljs-string">'(ryan|centos)'</span></span><br>4b0df4bc3e70        centos                                                                   "/bin/bash"              23 seconds ago      Up 23 seconds                           vigorous_elion                                                                                                                           0B (virtual 202MB)<br>b36421d05005        ryan/httpd:v1.0                                                          "/usr/sbin/init"         32 minutes ago      Up 32 minutes                           gracious_swirles                                                                                                                         61.6kB (virtual 444MB)<br></code></pre></td></tr></table></figure><p><strong>首先启动一个base镜像用来对比</strong><br><strong>可以看到第一行就是base镜像centos，第2列的size是0和202MB, 0表示容器层可写层的大小，virtual则是容器层+镜像层的大小。这里对比可以看到一共202M,正好是最初centos镜像的大小。</strong><br><strong>第二行是我们自己创建的镜像。virtual达到了444MB。对比前面的history部分，可以发现这个数字是每一层大小之和。同时，由于共享base，其中的202M是和第一行的镜像共享的。</strong></p><h2 id="修改时复制策略-copy-on-write-CoW"><strong>修改时复制策略 copy-on-write (CoW)</strong></h2><p><strong>docker通过一个叫做copy-on-write (CoW) 的策略来保证base镜像的安全性，以及更高的性能和空间利用率。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>Copy-on-write is a strategy of sharing and copying files for maximum efficiency. If a file or directory exists in a lower layer within the image, and another layer (including the writable layer) needs read access to it, it just uses the existing file. The first time another layer needs to modify the file (when building the image or running the container), the file is copied into that layer and modified. This minimizes I/O and the size of each of the subsequent layers. These advantages are explained in more depth below.<br><br>Copying makes containers efficient<br>When you start a container, a thin writable container layer is added on top of the other layers. Any changes the container makes to the filesystem are stored here. Any files the container does not change do not get copied to this writable layer. This means that the writable layer is as small as possible.<br><br>When an existing file in a container is modified, the storage driver performs a copy-on-write operation. The specifics steps involved depend on the specific storage driver. For the aufs, overlay, and overlay2 drivers, the copy-on-write operation follows this rough sequence:<br><br>Search through the image layers for the file to update. The process starts at the newest layer and works down to the base layer one layer at a time. When results are found, they are added to a cache to speed future operations.<br><br>Perform a copy_up operation on the first copy of the file that is found, to copy the file to the container’s writable layer.<br><br>Any modifications are made to this copy of the file, and the container cannot see the read-only copy of the file that exists in the lower layer.<br><br>Btrfs, ZFS, and other drivers handle the copy-on-write differently. You can read more about the methods of these drivers later in their detailed descriptions.<br><br>Containers that write a lot of data consume more space than containers that do not. This is because most write operations consume new space in the container’s thin writable top layer.<br></code></pre></td></tr></table></figure><p><strong>简单的说，启动容器的时候，最上层容器层是可写层，之下的都是镜像层，只读层。</strong></p><h3 id="当容器需要读取文件的时候"><strong>当容器需要读取文件的时候</strong></h3><p><strong>从最上层镜像开始查找，往下找，找到文件后读取并放入内存，若已经在内存中了，直接使用。(即，同一台机器上运行的docker容器共享运行时相同的文件)。</strong></p><h3 id="当容器需要添加文件的时候"><strong>当容器需要添加文件的时候</strong></h3><p><strong>直接在最上面的容器层可写层添加文件，不会影响镜像层。</strong></p><h3 id="当容器需要修改文件的时候"><strong>当容器需要修改文件的时候</strong></h3><p><strong>从上往下层寻找文件，找到后，复制到容器可写层，然后，对容器来说，可以看到的是容器层的这个文件，看不到镜像层里的文件。容器在容器层修改这个文件。</strong></p><h3 id="当容器需要删除文件的时候"><strong>当容器需要删除文件的时候</strong></h3><p><strong>从上往下层寻找文件，找到后在容器中记录删除。即，并不会真正的删除文件，而是软删除。这将导致镜像体积只会增加，不会减少。</strong></p><p><strong>综上，Docker镜像通过分层实现了资源共享，通过copy-on-write实现了文件隔离。</strong></p><p><strong>对于文件只增加不减少问题，我们应当在同一层做增删操作，从而减少镜像体积。比如，如下测试。</strong></p><hr><p><strong>Dockerfile.A: 分层删除文件</strong>**</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM centos:7<br>RUN yum install -y vim<br>RUN yum install -y httpd<br>WORKDIR /home<br>RUN dd if=/dev/zero of=50M.file bs=1M count=50<br><span class="hljs-meta">#</span><span class="bash">创建大小为50M的测试文件</span><br>RUN rm -rf 50M.file<br>CMD ["/bin/bash"]<br></code></pre></td></tr></table></figure><h4 id="构建"><strong>构建</strong></h4><p><strong><code>docker build -t test:a -f Dockerfile.A .</code></strong><br><strong>Dockerfile.B: 同层删除</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM centos:7<br>RUN yum install -y vim<br>RUN yum install -y httpd<br>WORKDIR /home<br>RUN dd if=/dev/zero of=50M.file bs=1M count=50 &amp;&amp; rm -rf 50M.file<br></code></pre></td></tr></table></figure><h4 id="构建-2"><strong>构建</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t test:b -f Dockerfile.B .<br></code></pre></td></tr></table></figure><h4 id="比较二者大小"><strong>比较二者大小</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@sh-k8s-001 tmp]# docker images | grep test<br>test                                                                     a                          ae673aa7db48        9 minutes ago       497MB<br>test                                                                     b                          21b2bc49f0bd        12 minutes ago      444MB<br></code></pre></td></tr></table></figure><p><strong>显然，分层删除操作并没有真正删除掉文件。</strong></p><p><strong>来源</strong><br>**链接：**<a href="https://www.cnblogs.com/woshimrf/p/docker-container-lawyer.html" target="_blank" rel="noopener">https://www.cnblogs.com/woshimrf/p/docker-container-lawyer.html</a><br><a href="https://www.cnblogs.com/CloudMan6/p/6799197.html" target="_blank" rel="noopener">https://www.cnblogs.com/CloudMan6/p/6799197.html</a><br><a href="https://www.cnblogs.com/CloudMan6/p/6806193.html" target="_blank" rel="noopener">https://www.cnblogs.com/CloudMan6/p/6806193.html</a><br><a href="https://docs.docker.com/storage/storagedriver/" target="_blank" rel="noopener">https://docs.docker.com/storage/storagedriver/</a></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 镜像 </tag>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockers镜像分层</title>
      <link href="/posts/4e5d.html"/>
      <url>/posts/4e5d.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Dockers的最小镜像"><strong>1,Dockers的最小镜像</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker pull hello-world<br>//下载一个最小的镜像<br>[root@localhost ~]# docker images<br>//查看镜像<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607164056157.png" alt="image-20200607164056157"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run hello-world<br>//运行一下hello-world （里面是一个文本对docker运行的简单介绍）<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607164108693.png" alt="image-20200607164108693"></p><h3 id="dockerfile的组成"><strong>dockerfile的组成</strong></h3><ul><li><strong>1）FROM：scratch（抓、挠）</strong></li><li><strong>2）COPY：hello /</strong></li><li><strong>3）CMD：[“/hello”]</strong></li></ul><h4 id="FROM"><strong>FROM</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">语法：FROM &lt;image&gt;[:&lt;tag&gt;]<br>解释：设置要制作的镜像基于哪个镜像，FROM指令必须是整个Dockerfile的第一个指令，如果指定的镜像不存在默认会自动从Docker Hub上下载。<br></code></pre></td></tr></table></figure><h4 id="COPY"><strong>COPY</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">语法：COPY &lt;src&gt; &lt;dest&gt;<br>解释：用法与ADD相同，不过&lt;src&gt;不支持使用url，所以在使用docker build – &lt; somefile时该指令不能使用。<br></code></pre></td></tr></table></figure><h4 id="CMD"><strong>CMD</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">语法：①CMD ["executable", "param1", "param2"]    #将会调用exec执行，首选方式<br>    ②CMD ["param1", "param2"]        #当使用ENTRYPOINT指令时，为该指令传递默认参数<br>    ③CMD &lt;command&gt; [ &lt;param1&gt;|&lt;param2&gt; ]        #将会调用/bin/sh -c执行<br>解释：CMD指令中指定的命令会在镜像运行时执行，在Dockerfile中只能存在一个，如果使用了多个CMD指令，则只有最后一个CMD指令有效。当出现ENTRYPOINT指令时，CMD中定义的内容会作为ENTRYPOINT指令的默认参数，也就是说可以使用CMD指令给ENTRYPOINT传递参数。<br>注意：RUN和CMD都是执行命令，他们的差异在于RUN中定义的命令会在执行docker build命令创建镜像时执行，而CMD中定义的命令会在执行docker run命令运行镜像时执行，另外使用第一种语法也就是调用exec执行时，命令必须为绝对路径。<br></code></pre></td></tr></table></figure><h2 id="2、Base镜像（基础镜像）"><strong>2、Base镜像（基础镜像</strong>）</h2><p>Centos:7镜像的dockerfile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">FROM scratch<br><br>ADD centos-7-x86_ _64-docker.tar.xz /<br><br>LABEL org. label-schema. schema-version="1.0" \|<br>org. label-schema. name="Centos Base Image" \<br>org. labe1-schema. vendor="centos" \<br>org. labe1-schema. 1icense="GPLV2" \<br>org. labe1-schema build-date="20190305 '<br><br>CMD ["/bin/bash"]<br></code></pre></td></tr></table></figure><h2 id="3、镜像的分层"><strong>3、镜像的分层</strong></h2><p>1）dockerfile的书写格式为：Dockerfile（首字母大写，包括文件名称）<br>2）From：构建镜像有两种方式，一种scratch(从零构建)，另一种可以基于某个镜像开始构建<br>3）镜像所运行的操作（用户所期望的）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# mkdir test<br>//创建测试目录<br>[root@localhost ~]# cd test<br>//进入测试目录<br>[root@localhost ~]#vim Dockerfile<br>//编写Dockerfile<br>FROM centos:7  <br>RUN yum -y install vim  #或["yum","install","vim"]<br>RUN yum -y install net-tools<br>CMD ["/bin/bash"]<br></code></pre></td></tr></table></figure><p><strong>执行一下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost test]# docker build -t centos7-vim-net-tools:12-11 .<br>//使用当前目录的 Dockerfile 创建镜像，标签为 centos7-vim-net-tools:12-11<br>build： 使用 Dockerfile 创建镜像<br>-t：标签<br>. :当前目录<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607164253627.png" alt="image-20200607164253627"></p><h3 id="执行的层次"><strong>执行的层次</strong></h3><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607164343711.png" alt="image-20200607164343711"></p><h2 id="4-Dockerfile镜像分层总结"><strong>4.Dockerfile镜像分层总结</strong></h2><p><strong>镜像时容器的基石，容器是镜像运行后的实例。当镜像运行为容器之后,对镜像的所有数据仅有只读权限，如果需要对镜像源文件进行修改或删除操作,此时是在容器层（可写层）进行的，用到了COW（copy on write）写时复制机制。</strong></p><h1>Docker镜像的缓存特性</h1><h2 id="1-创建一个新的Dockerfile文件"><strong>1.创建一个新的Dockerfile文件</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vim Dockerfile<br>FROM centos:7<br>RUN yum -y install vim<br>RUN yum -y install net-tools<br>RUN yum -y install wget<br>CMD ["/bin/bash"]<br>[root@localhost ~]# docker build -t new-centos .<br>//使用当前目录的 Dockerfile 创建镜像，名称为new-centos<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607164452324.png" alt="image-20200607164452324"></p><p><em><strong>如果在相同的层，有用到相同的镜像，可以不必再去下载，直接使用缓存。（如果第一层的不相同了，那么下面的相同也没用了，需要重新下载）</strong></em></p><h2 id="2-再次创建一个新的Dockerfile"><strong>2.再次创建一个新的Dockerfile</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# mkdir test1<br>[root@localhost ~]# cd test<br>[root@localhost test]# cd ../test1<br>[root@localhost test1]# vim Dockerfile<br>FROM centos:7<br>RUN yum -y install vim<br>RUN yum -y install wget<br>RUN yum -y install net-tools<br>CMD ["/bin/bash"]<br>[root@localhost test1]# docker build -t centos-new .<br>//使用当前目录的 Dockerfile 创建镜像，名称为centos-new<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607164502989.png" alt="image-20200607164502989"><br><em><strong>即使镜像层里的操作一样，也必须是在同一层才可以使用dockerfile的缓存特性<br>如果制作镜像过程中，不想使用缓存，可以–no-cache选项</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 镜像 </tag>
            
            <tag> dockerfile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOCKER源码分析（一）：DOCKER架构</title>
      <link href="/posts/c10c.html"/>
      <url>/posts/c10c.html</url>
      
        <content type="html"><![CDATA[<h1><strong>1 背景</strong></h1><h2 id="1-1-Docker简介">1.1 Docker简介</h2><p><strong>Docker是Docker公司开源的一个基于轻量级虚拟化技术的容器引擎项目,整个项目基于Go语言开发，并遵从Apache 2.0协议。目前，Docker可以在容器内部快速自动化部署应用，并可以通过内核虚拟化技术（namespaces及cgroups等）来提供容器的资源隔离与安全保障等。由于Docker通过操作系统层的虚拟化实现隔离，所以Docker容器在运行时，不需要类似虚拟机（VM）额外的操作系统开销，提高资源利用率，并且提升诸如IO等方面的性能。</strong><br><strong>由于众多新颖的特性以及项目本身的开放性，Docker在不到两年的时间里迅速获得诸多厂商的青睐，其中更是包括Google、Microsoft、VMware等业界行业领导者。Google在今年六月份推出了Kubernetes，提供Docker容器的调度服务，而今年8月Microsoft宣布Azure上支持Kubernetes，随后传统虚拟化巨头VMware宣布与Docker强强合作。今年9月中旬，Docker更是获得4000万美元的C轮融资，以推动分布式应用方面的发展。</strong><br><strong>从目前的形势来看，Docker的前景一片大好。本系列文章从源码的角度出发，详细介绍Docker的架构、Docker的运行以及Docker的卓越特性。本文是Docker源码分析系列的第一篇———Docker架构篇。</strong></p><h2 id="1-2-Docker版本信息"><strong>1.2 Docker版本信息</strong></h2><p><strong>本文关于Docker架构的分析都是基于Docker的源码与Docker相应版本的运行结果，其中Docker为最新的1.2版本。</strong></p><h1><strong>2 Docker架构分析内容安排</strong></h1><p><strong>本文的目的是：在理解Docker源代码的基础上，分析Docker架构。分析过程中主要按照以下三个步骤进行：</strong><br><strong>•Docker的总架构图展示</strong><br><strong>•Docker架构图内部各模块功能与实现分析</strong><br><strong>•以Docker命令的执行为例，进行Docker运行流程阐述</strong></p><h1><strong>3 Docker总架构图</strong></h1><p><strong>学习Docker的源码并不是一个枯燥的过程，反而可以从中理解Docker架构的设计原理。Docker对使用者来讲是一个C/S模式的架构，而Docker的后端是一个非常松耦合的架构，模块各司其职，并有机组合，支撑Docker的运行。</strong><br><strong>在此，先附上Docker总架构，如图3.1。</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163240356.png" alt="image-20200607163240356"><br><strong>图3.1 Docker总架构图</strong><br><strong>如图3.1，不难看出，用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。</strong><br><strong>而Docker Daemon作为Docker架构中的主体部分，首先提供Server的功能使其可以接受Docker Client的请求；而后Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。</strong><br><strong>Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动graphdriver将下载镜像以Graph的形式存储；当需要为Docker创建网络环境时，通过网络管理驱动networkdriver创建并配置Docker容器网络环境；当需要限制Docker容器运行资源或执行用户指令等操作时，则通过execdriver来完成。</strong><br><strong>而libcontainer是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。</strong><br><strong>当执行完运行容器的命令后，一个实际的Docker容器就处于运行状态，该容器拥有独立的文件系统，独立并且安全的运行环境等。</strong></p><h2 id="3-1-DOCKER架构总体包含七个部分：client-daemon-driver-libcontainer-container-graph-registry。"><strong>3.1 DOCKER架构总体包含七个部分：client,daemon,driver,libcontainer,container,graph,registry。</strong></h2><p><strong>外表来看，docker是一个C/S的架构，用户可以在客户端输入各种指令，客户端负责接受请求并作出相应的响应返回给客户。</strong></p><h2 id="3-2-DockerClient"><strong>3.2 DockerClient</strong></h2><p><strong>DockerClient 负责接受并传递请求指令 。</strong></p><h2 id="3-3-DockerDaemon"><strong>3.3 DockerDaemon</strong></h2><p><strong>DockerDaemon的功能主要有两个：</strong></p><p><strong>负责接受client的请求 管理docker容器</strong><br><strong>dockerdaemon的架构主要可以分为两部分：dockerserver和engine</strong></p><h2 id="3-4-DockerServer"><strong>3.4 DockerServer</strong></h2><p><strong>DockerServer作为服务端最主要的作用就是配合client端将请求指令接受过来，如图所示，DockerServer主要分为三个部分：Http.server,mux.server,Handler。</strong><br><strong>DockerServer运行时会从一个名为mux的包中创建一个mux.Router路由器，然后为路由器中添加相关的路由项用于路由信息， 每个路由项由HTTP请求方法（get,post,put,delete）+URL+Handler三部分组成。</strong><br><strong>DockerServer每收到一个请求就会生成一个goroutine然后进行相应的解析、匹配相应的路由项最后会找到相匹配的Handler来处理，Handler处理玩请求之后给DockerClient返回响应。</strong></p><h2 id="3-5-Engine"><strong>3.5 Engine</strong></h2><p><strong>Engine是docker中的运行引擎，存储着大量的容器信息并管理着大部分job的执行。</strong><br><strong>job是docker中的最小执行单元，类似于unix中的进程，也会有相应的名字、参数、环境变量、标准输入输出、返回状态等等。docker每进行一次相应的操作都会 生成一个相应的Job，比如创建一个容器、下载一个文件等等都是由job完成的。</strong></p><h2 id="3-6-DockerDriver"><strong>3.6 DockerDriver</strong></h2><p><strong>DockerDriver是docker内部的驱动模块，负责容器内部相关网络、文件系统等的构建</strong></p><h2 id="3-6-libcontainer"><strong>3.6 libcontainer</strong></h2><p><strong>libcontainer主要是对linux内核的一些诸如namespace、cgroups、capabilities等特性做了封装</strong></p><h1><strong>4 Docker架构内各模块的功能与实现分析</strong></h1><p><strong>接下来，我们将从Docker总架构图入手，抽离出架构内各个模块，并对各个模块进行更为细化的架构分析与功能阐述。主要的模块有：Docker Client、Docker Daemon、Docker Registry、Graph、Driver、libcontainer以及Docker container。</strong></p><h2 id="4-1-Docker-Client"><strong>4.1 Docker Client</strong></h2><p><strong>Docker Client是Docker架构中用户用来和Docker Daemon建立通信的客户端。用户使用的可执行文件为docker，通过docker命令行工具可以发起众多管理container的请求。</strong><br><strong>Docker Client可以通过以下三种方式和Docker Daemon建立通信：tcp://host:port，unix://path_to_socket和fd://socketfd。为了简单起见，本文一律使用第一种方式作为讲述两者通信的原型。与此同时，与Docker Daemon建立连接并传输请求的时候，Docker Client可以通过设置命令行flag参数的形式设置安全传输层协议(TLS)的有关参数，保证传输的安全性。</strong><br><strong>Docker Client发送容器管理请求后，由Docker Daemon接受并处理请求，当Docker Client接收到返回的请求相应并简单处理后，Docker Client一次完整的生命周期就结束了。当需要继续发送容器管理请求时，用户必须再次通过docker可执行文件创建Docker Client。</strong></p><h2 id="4-2-Docker-Daemon"><strong>4.2 Docker Daemon</strong></h2><p><strong>Docker Daemon是Docker架构中一个常驻在后台的系统进程，功能是：接受并处理Docker Client发送的请求。该守护进程在后台启动了一个Server，Server负责接受Docker Client发送的请求；接受请求后，Server通过路由与分发调度，找到相应的Handler来执行请求。</strong><br><strong>Docker Daemon启动所使用的可执行文件也为docker，与Docker Client启动所使用的可执行文件docker相同。在docker命令执行时，通过传入的参数来判别Docker Daemon与Docker Client。</strong><br><strong>Docker Daemon的架构，大致可以分为以下三部分：Docker Server、Engine和Job。Daemon架构如图4.1。</strong><br><strong><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163320391.png" alt="image-20200607163320391"></strong><br><strong>图4.1 Docker Daemon架构示意图</strong></p><h3 id="4-2-1-DOCKER-SERVER"><strong>4.2.1 DOCKER SERVER</strong></h3><p><strong>Docker Server在Docker架构中是专门服务于Docker Client的server。该server的功能是：接受并调度分发Docker Client发送的请求。Docker Server的架构如图4.2。</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163335364.png" alt="image-20200607163335364">**<br><strong>图4.2 Docker Server架构示意图</strong><br><strong>在Docker的启动过程中，通过包gorilla/mux，创建了一个mux.Router，提供请求的路由功能。在Golang中，gorilla/mux是一个强大的URL路由器以及调度分发器。该mux.Router中添加了众多的路由项，每一个路由项由HTTP请求方法（PUT、POST、GET或DELETE）、URL、Handler三部分组成。</strong><br><strong>若Docker Client通过HTTP的形式访问Docker Daemon，创建完mux.Router之后，Docker将Server的监听地址以及mux.Router作为参数，创建一个httpSrv=http.Server{}，最终执行httpSrv.Serve()为请求服务。</strong><br><strong>在Server的服务过程中，Server在listener上接受Docker Client的访问请求，并创建一个全新的goroutine来服务该请求。在goroutine中，首先读取请求内容，然后做解析工作，接着找到相应的路由项，随后调用相应的Handler来处理该请求，最后Handler处理完请求之后回复该请求。</strong><br><strong>需要注意的是：Docker Server的运行在Docker的启动过程中，是靠一个名为”serveapi”的job的运行来完成的。原则上，Docker Server的运行是众多job中的一个，但是为了强调Docker Server的重要性以及为后续job服务的重要特性，将该”serveapi”的job单独抽离出来分析，理解为Docker Server。</strong></p><h3 id="4-2-2-ENGINE"><strong>4.2.2 ENGINE</strong></h3><p><strong>Engine是Docker架构中的运行引擎，同时也Docker运行的核心模块。它扮演Docker container存储仓库的角色，并且通过执行job的方式来操纵管理这些容器。</strong><br><strong>在Engine数据结构的设计与实现过程中，有一个handler对象。该handler对象存储的都是关于众多特定job的handler处理访问。举例说明，Engine的handler对象中有一项为：{“create”: daemon.ContainerCreate,}，则说明当名为”create”的job在运行时，执行的是daemon.ContainerCreate的handler。</strong></p><h3 id="4-2-3-JOB"><strong>4.2.3 JOB</strong></h3><p><strong>一个Job可以认为是Docker架构中Engine内部最基本的工作执行单元。Docker可以做的每一项工作，都可以抽象为一个job。例如：在容器内部运行一个进程，这是一个job；创建一个新的容器，这是一个job，从Internet上下载一个文档，这是一个job；包括之前在Docker Server部分说过的，创建Server服务于HTTP的API，这也是一个job，等等。</strong><br><strong>Job的设计者，把Job设计得与Unix进程相仿。比如说：Job有一个名称，有参数，有环境变量，有标准的输入输出，有错误处理，有返回状态等。</strong></p><h2 id="4-3-Docker-Registry"><strong>4.3 Docker Registry</strong></h2><p><strong>Docker Registry是一个存储容器镜像的仓库。而容器镜像是在容器被创建时，被加载用来初始化容器的文件架构与目录。</strong><br><strong>在Docker的运行过程中，Docker Daemon会与Docker Registry通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的job名称分别为”search”，”pull” 与 “push”。</strong><br><strong>其中，在Docker架构中，Docker可以使用公有的Docker Registry，即大家熟知的Docker Hub，如此一来，Docker获取容器镜像文件时，必须通过互联网访问Docker Hub；同时Docker也允许用户构建本地私有的Docker Registry，这样可以保证容器镜像的获取在内网完成。</strong></p><h2 id="4-4-Graph"><strong>4.4 Graph</strong></h2><p><strong>Graph在Docker架构中扮演已下载容器镜像的保管者，以及已下载容器镜像之间关系的记录者。一方面，Graph存储着本地具有版本信息的文件系统镜像，另一方面也通过GraphDB记录着所有文件系统镜像彼此之间的关系。Graph的架构如图4.3。</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163357944.png" alt="image-20200607163357944"><br><strong>图4.3 Graph架构示意图</strong><br><strong>其中，GraphDB是一个构建在SQLite之上的小型图数据库，实现了节点的命名以及节点之间关联关系的记录。它仅仅实现了大多数图数据库所拥有的一个小的子集，但是提供了简单的接口表示节点之间的关系。</strong><br><strong>同时在Graph的本地目录中，关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体rootfs。</strong></p><h2 id="4-5-Driver"><strong>4.5 Driver</strong></h2><p><strong>Driver是Docker架构中的驱动模块。通过Driver驱动，Docker可以实现对Docker容器执行环境的定制。由于Docker运行的生命周期中，并非用户所有的操作都是针对Docker容器的管理，另外还有关于Docker运行信息的获取，Graph的存储与记录等。因此，为了将Docker容器的管理从Docker Daemon内部业务逻辑中区分开来，设计了Driver层驱动来接管所有这部分请求。</strong><br><strong>在Docker Driver的实现中，可以分为以下三类驱动：graphdriver、networkdriver和execdriver。</strong><br><strong>graphdriver主要用于完成容器镜像的管理，包括存储与获取。即当用户需要下载指定的容器镜像时，graphdriver将容器镜像存储在本地的指定目录；同时当用户需要使用指定的容器镜像来创建容器的rootfs时，graphdriver从本地镜像存储目录中获取指定的容器镜像。</strong><br><strong>在graphdriver的初始化过程之前，有4种文件系统或类文件系统在其内部注册，它们分别是aufs、btrfs、vfs和devmapper。而Docker在初始化之时，通过获取系统环境变量”DOCKER_DRIVER”来提取所使用driver的指定类型。而之后所有的graph操作，都使用该driver来执行。</strong><br><strong>graphdriver的架构如图4.4：</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163420030.png" alt="image-20200607163420030"><br><strong>图4.4 graphdriver架构示意图</strong><br><strong>networkdriver的用途是完成Docker容器网络环境的配置，其中包括Docker启动时为Docker环境创建网桥；Docker容器创建时为其创建专属虚拟网卡设备；以及为Docker容器分配IP、端口并与宿主机做端口映射，设置容器防火墙策略等。networkdriver的架构如图4.5：</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163437181.png" alt="image-20200607163437181"><br><strong>图4. 5 networkdriver架构示意图</strong><br><strong>execdriver作为Docker容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。在execdriver的实现过程中，原先可以使用LXC驱动调用LXC的接口，来操纵容器的配置以及生命周期，而现在execdriver默认使用native驱动，不依赖于LXC。具体体现在Daemon启动过程中加载的ExecDriverflag参数，该参数在配置文件已经被设为”native”。这可以认为是Docker在1.2版本上一个很大的改变，或者说Docker实现跨平台的一个先兆。execdriver架构如图4.6：</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163537490.png" alt="image-20200607163537490"></p><p><strong>图4.6 execdriver架构示意图</strong><br><strong>4.6 libcontainer</strong><br><strong>libcontainer是Docker架构中一个使用Go语言设计实现的库，设计初衷是希望该库可以不依靠任何依赖，直接访问内核中与容器相关的API。</strong><br><strong>正是由于libcontainer的存在，Docker可以直接调用libcontainer，而最终操纵容器的namespace、cgroups、apparmor、网络设备以及防火墙规则等。这一系列操作的完成都不需要依赖LXC或者其他包。libcontainer架构如图4.7：</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163545287.png" alt="image-20200607163545287"><br><strong>图4.7 libcontainer示意图</strong><br><strong>另外，libcontainer提供了一整套标准的接口来满足上层对容器管理的需求。或者说，libcontainer屏蔽了Docker上层对容器的直接管理。又由于libcontainer使用Go这种跨平台的语言开发实现，且本身又可以被上层多种不同的编程语言访问，因此很难说，未来的Docker就一定会紧紧地和Linux捆绑在一起。而于此同时，Microsoft在其著名云计算平台Azure中，也添加了对Docker的支持，可见Docker的开放程度与业界的火热度。</strong><br><strong>暂不谈Docker，由于libcontainer的功能以及其本身与系统的松耦合特性，很有可能会在其他以容器为原型的平台出现，同时也很有可能催生出云计算领域全新的项目。</strong></p><h2 id="4-7-Docker-container"><strong>4.7 Docker container</strong></h2><p><strong>Docker container（Docker容器）是Docker架构中服务交付的最终体现形式。</strong><br><strong>Docker按照用户的需求与指令，订制相应的Docker容器：</strong><br><strong>•用户通过指定容器镜像，使得Docker容器可以自定义rootfs等文件系统；</strong><br><strong>•用户通过指定计算资源的配额，使得Docker容器使用指定的计算资源；</strong><br><strong>•用户通过配置网络及其安全策略，使得Docker容器拥有独立且安全的网络环境；</strong><br><strong>•用户通过指定运行的命令，使得Docker容器执行指定的工作。</strong><br><strong>Docker容器示意图如图4.8：</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163611716.png" alt="image-20200607163611716"><br><strong>图4.8 Docker容器示意图</strong></p><h1><strong>5 Docker运行案例分析</strong></h1><p><strong>上一章节着重于Docker架构中各个部分的介绍。本章的内容，将以串联Docker各模块来简要分析，分析原型为Docker中的docker pull与docker run两个命令。</strong></p><h2 id="5-1-docker-pull"><strong>5.1 docker pull</strong></h2><p><strong>docker pull命令的作用为：从Docker Registry中下载指定的容器镜像，并存储在本地的Graph中，以备后续创建Docker容器时的使用。docker pull命令执行流程如图5.1。</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163644214.png" alt="image-20200607163644214"><br><strong>图5.1 docker pull命令执行流程示意图</strong><br><strong>如图，图中标记的红色箭头表示docker pull命令在发起后，Docker所做的一系列运行。以下逐一分析这些步骤。</strong><br><strong>(1) Docker Client接受docker pull命令，解析完请求以及收集完请求参数之后，发送一个HTTP请求给Docker Server，HTTP请求方法为POST，请求URL为”/images/create? “+”xxx”；</strong><br><strong>(2) Docker Server接受以上HTTP请求，并交给mux.Router，mux.Router通过URL以及请求方法来确定执行该请求的具体handler；</strong><br><strong>(3) mux.Router将请求路由分发至相应的handler，具体为PostImagesCreate；</strong><br><strong>(4) 在PostImageCreate这个handler之中，一个名为”pull”的job被创建，并开始执行；</strong><br><strong>(5) 名为”pull”的job在执行过程中，执行pullRepository操作，即从Docker Registry中下载相应的一个或者多个image；</strong><br><strong>(6) 名为”pull”的job将下载的image交给graphdriver；</strong><br><strong>(7) graphdriver负责将image进行存储，一方创建graph对象，另一方面在GraphDB中记录image之间的关系。</strong></p><h2 id="5-2-docker-run"><strong>5.2 docker run</strong></h2><p><strong>docker run命令的作用是在一个全新的Docker容器内部运行一条指令。Docker在执行这条命令的时候，所做工作可以分为两部分：第一，创建Docker容器所需的rootfs；第二，创建容器的网络等运行环境，并真正运行用户指令。因此，在整个执行流程中，Docker Client给Docker Server发送了两次HTTP请求，第二次请求的发起取决于第一次请求的返回状态。Docker run命令执行流程如图5.2。</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607163706160.png" alt="image-20200607163706160"><br><strong>图5.2 docker run命令执行流程示意图</strong><br><strong>如图，图中标记的红色箭头表示docker run命令在发起后，Docker所做的一系列运行。以下逐一分析这些步骤。</strong><br><strong>(1) Docker Client接受docker run命令，解析完请求以及收集完请求参数之后，发送一个HTTP请求给Docker Server，HTTP请求方法为POST，请求URL为”/containers/create? “+”xxx”；</strong><br><strong>(2) Docker Server接受以上HTTP请求，并交给mux.Router，mux.Router通过URL以及请求方法来确定执行该请求的具体handler；</strong><br><strong>(3) mux.Router将请求路由分发至相应的handler，具体为PostContainersCreate；</strong><br><strong>(4) 在PostImageCreate这个handler之中，一个名为”create”的job被创建，并开始让该job运行；</strong><br><strong>(5) 名为”create”的job在运行过程中，执行Container.Create操作，该操作需要获取容器镜像来为Docker容器创建rootfs，即调用graphdriver；</strong><br><strong>(6) graphdriver从Graph中获取创建Docker容器rootfs所需要的所有的镜像；</strong><br><strong>(7) graphdriver将rootfs所有镜像，加载安装至Docker容器指定的文件目录下；</strong><br><strong>(8) 若以上操作全部正常执行，没有返回错误或异常，则Docker Client收到Docker Server返回状态之后，发起第二次HTTP请求。请求方法为”POST”，请求URL为”/containers/”+containerID+”/start”；</strong><br><strong>(9) Docker Server接受以上HTTP请求，并交给mux.Router，mux.Router通过URL以及请求方法来确定执行该请求的具体handler；</strong><br><strong>(10) mux.Router将请求路由分发至相应的handler，具体为PostContainersStart；</strong><br><strong>(11) 在PostContainersStart这个handler之中，名为”start”的job被创建，并开始执行；</strong><br><strong>(12) 名为”start”的job执行完初步的配置工作后，开始配置与创建网络环境，调用networkdriver；</strong><br><strong>(13) networkdriver需要为指定的Docker容器创建网络接口设备，并为其分配IP，port，以及设置防火墙规则，相应的操作转交至libcontainer中的netlink包来完成；</strong><br><strong>(14) netlink完成Docker容器的网络环境配置与创建；</strong><br><strong>(15) 返回至名为”start”的job，执行完一些辅助性操作后，job开始执行用户指令，调用execdriver；</strong><br><strong>(16) execdriver被调用，初始化Docker容器内部的运行环境，如命名空间，资源控制与隔离，以及用户命令的执行，相应的操作转交至libcontainer来完成；</strong><br><strong>(17) libcontainer被调用，完成Docker容器内部的运行环境初始化，并最终执行用户要求启动的命令。</strong></p><h1><strong>6 总结</strong></h1><p><strong>本文从Docker 1.2的源码入手，分析抽象出Docker的架构图，并对该架构图中的各个模块进行功能与实现的分析，最后通过两个docker命令展示了Docker内部的运行。</strong><br><strong>通过对Docker架构的学习，可以全面深化对Docker设计、功能与价值的理解。同时在借助Docker实现用户定制的分布式系统时，也能更好地找到已有平台与Docker较为理想的契合点。另外，熟悉Docker现有架构以及设计思想，也能对云计算PaaS领域带来更多的启发，催生出更多实践与创新。</strong><br>链接：<a href="https://www.2cto.com/kf/201701/582655.html" target="_blank" rel="noopener">https://www.2cto.com/kf/201701/582655.html</a><br>链接：<a href="https://blog.csdn.net/gsllovefly/article/details/51083419" target="_blank" rel="noopener">https://blog.csdn.net/gsllovefly/article/details/51083419</a></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的基本操作命令</title>
      <link href="/posts/f1f1.html"/>
      <url>/posts/f1f1.html</url>
      
        <content type="html"><![CDATA[<h1>Docker介绍</h1><p>Docker 是一个能够把开发应用程序自动部署到容器的开源引擎。它由Docker公司的团队编写，基于Apache 2.0开源协议授权。它提供了一个简单、轻量的建模方式，使开发生命周期更高效快速，鼓励了面向服务的架构设计。Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。</p><p><strong>Docker 的特点：</strong></p><p>更快速的交付和部署<br>更高效的虚拟化<br>更轻松的迁移和扩展<br>更简单的管理<br><strong>容器技术与传统虚拟机性能对比</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607144534352.png" alt="image-20200607144534352"><br><strong>Docker与虚拟机建构对比</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607144547039.png" alt="image-20200607144547039"><br>Docker 容器本质上是宿主机上的一个进程。Docker 通过 namespace 实现了资源隔离，通过 cgroups 实现了资源的限制，通过写时复制机制（copy-on-write）实现了高效的文件操作。</p><p>**Docker有五个命名空间：**进程、网络、挂载、宿主和共享内存，为了隔离有问题的应用，Docker运用Namespace将进程隔离，为进程或进程组创建已隔离的运行空间，为进程提供不同的命名空间视图。这样，每一个隔离出来的进程组，对外就表现为一个container(容器)。需要注意的是，Docker让用户误以为自己占据了全部资源，但这并不是”虚拟机”。</p><p><strong>Docker 中的三个概念：镜像，容器，仓库</strong></p><p><strong>镜像（image）</strong>：Docker 镜像就是一个只读的模板，镜像可以用来创建 Docker 容器。Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。<br>镜像是一种文件结构。Dockerfile中的每条命令都会在文件系统中创建一个新的层次结构，文件系统在这些层次上构建起来，镜像就构建于这些联合的文件系统之上。Docker官方网站专门有一个页面来存储所有可用的镜像，网址是：<a href="http://index.docker.io" target="_blank" rel="noopener">index.docker.io</a>。</p><p><strong>容器（ Container）</strong>：容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个简易版的 Linux 环境，Docker 利用容器来运行应用。镜像是只读的，容器在启动的时候创建一层可写层作为最上层。</p><p><strong>仓库</strong>：仓库是集中存放镜像文件的场所，仓库注册服务器（Registry）上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。目前，最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。</p><p>Docker仓库用来保存我们的images，当我们创建了自己的image之后我们就可以使用push命令将它上传到公有或者私有仓库，这样下次要在另外一台机器上使用这个image时候，只需要从仓库上pull下来就可以了。Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的服务。</p><h1>Docker 基本操作</h1><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607144556192.png" alt="image-20200607144556192"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"> [root@localhost ~]# docker search mysql<br>//查找镜像<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607144603251.png" alt="image-20200607144603251"><br>这样查找相当于在https://hub.docker.com/中查找，大家尽量使用官方的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker pull busybox<br>//拉取镜像<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607144610838.png" alt="image-20200607144610838"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker  save  -o busybox.tar  busybox:latest<br>//把镜像导出到本地  -o：相当--output导出<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607144616533.png" alt="image-20200607144616533"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker images<br>//查看本地镜像<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607144626129.png" alt="image-20200607144626129"><br><strong>仓库（镜像名称）   镜像标签            镜像id             创建时间           大小</strong><br>虽然我们看到镜像标签为latest（最新的），但并不表示他一定是最新的。而且镜像如果没有写标签，默认以latest为标签。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker rmi busybox:latest<br>//删除镜像<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607144634974.png" alt="image-20200607144634974"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker images<br>//查看本地镜像这里没有busybox<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607144642220.png" alt="image-20200607144642220"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker load -i busybox.tar<br>//根据本地镜像包导入镜像<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607144651568.png" alt="image-20200607144651568"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker images<br>//查看本地镜像这里又有busybox<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607144659612.png" alt="image-20200607144659612"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker ps<br>//查看容器-正在运行的<br><br>[root@localhost ~]# docker ps -a<br>//查看所有容器<br><br>[root@localhost ~]# docker rm c3bb3a6f73eb<br>//删除容器  id或镜像名称（不能删除正在运行的容器）<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607144710586.png" alt="image-20200607144710586"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker stop test<br>//停止容器运行 （记得验证一下docker  ps  -a）<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607144838255.png" alt="image-20200607144838255"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker start test<br>//启动容器 （记得验证一下docker  ps  -a）<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607144721958.png" alt="image-20200607144721958"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker rm test -f<br>//强制删除容器 （记得验证一下docker  ps  -a）<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607144730344.png" alt="image-20200607144730344"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker ps -a -q | xargs docker rm -f<br>//强制删除所有容器（生产环境严禁使用）<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607144740872.png" alt="image-20200607144740872"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker ps -a -q | xargs docker start -f<br>//强制开启所有容器（生产环境严禁使用）<br>[root@localhost ~]# docker ps -a -q | xargs docker stop -f<br>//强制关闭所有容器（生产环境严禁使用）<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -it --name test1 busybox:latest<br>//开启一个容器<br>-i：可交互<br>-t：伪终端<br>-d：守护进程<br>--name：容器命名<br>--restart=always：始终保持运行（随着docker开启而运行）  <br>[root@localhost ~]# docker run -itd --name test2 --restart=always busybox:latest<br>//docker重启后，始终保持运行（随着docker开启而运行）<br></code></pre></td></tr></table></figure><p><strong>路由转发</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vim /etc/sysctl.conf <br>//添加路由转发<br>[root@localhost ~]# sysctl  -p<br>net.ipv4.ip_forward = 1<br>net.bridge.bridge-nf-call-iptables = 1<br>net.bridge.bridge-nf-call-ip6tables = 1<br></code></pre></td></tr></table></figure><p><strong>进入容器方法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker exec -it test2 /bin/sh<br>//进入一个容器（退出容器后还在运行）<br>[root@localhost ~]# docker attach test2<br>//也是进入一个容器（退出容器不在运行）<br>区别：exec进入的方式需要添加-i -t选项,后边还需要给容器一个shell环境。<br>但attach就不需要这么麻烦。<br>exec进入的方式:如果执行exit退出， 容器仍然保持运行。<br>attach:如果执行exit退出, 容器会被关闭。如果想要保持容器不被关闭，可以使用用键盘: Ctrl + p   Ctrl +q可以实现。<br>本质上去区别: exec 进入的方法，会生产新的进程。<br>attach不会生产新进程。<br></code></pre></td></tr></table></figure><p><strong>强制删除镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"> [root@localhost ~]# docker rmi centos:7 -f<br>//强制删除镜像<br>上面是把镜像标签给删了，要想彻底删除镜像，用下面的命令把镜像id也删了，docker有缓存机制，即使把这个镜像给删了，但是会有缓存，其他的容器依旧可以使用<br></code></pre></td></tr></table></figure><h1>Docker的基本操作逻辑</h1><p>基于centos: 7镜像运行-个容器，并且,在这个容器内部署Nginx服务。<br><strong>1)下载centos：7镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker pull centos:7<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607144849325.png" alt="image-20200607144849325"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# rz<br>上传一个nginx包<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607144916849.png" alt="image-20200607144916849"></p><p><strong>2)运行容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -itd --name webapp --restart=always centos:7<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607145015035.png" alt="image-20200607145015035"></p><p><strong>3）进入容器，开始部署nginx服务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker cp nginx-1.14.0.tar.gz  webapp:/root<br>//将nginx包导入到容器内<br>[root@localhost ~]# docker exec -it webapp /bin/bash<br>//进入容器<br>[root@8604fb370aab /]# ls root<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607145027765.png" alt="image-20200607145027765"></p><p><strong>安装nginx</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@8604fb370aab /]# cd /root<br>[root@8604fb370aab ~]# tar zxf nginx-1.14.0.tar.gz<br>[root@8604fb370aab ~]# yum -y install gcc pcre pcre-devel openssl-devel zlib zlib-devel make<br>//安装nginx所需依赖<br>[root@8604fb370aab ~]# cd nginx-1.14.0<br>[root@8604fb370aab nginx-1.14.0]# useradd -M -s /sbin/nologin   nginx<br>//创建用户<br>[root@8604fb370aab nginx-1.14.0]# ./configure --prefix=/usr/local/nginx  --user=nginx --group=nginx &amp;&amp; make &amp;&amp; make install<br>//编译安装<br> [root@8604fb370aab nginx-1.14.0]# ln -s /usr/local/nginx/sbin/<br>nginx  /usr/local/sbin/<br>//链接命令目录<br>[root@8604fb370aab nginx-1.14.0]# nginx<br>//启动nginx<br>[root@8604fb370aab nginx-1.14.0]# cd /usr/local/nginx/html/<br>[root@8604fb370aab html]# echo This is a testweb in container &gt; index.html<br>//创建一个测试页面<br>[root@8604fb370aab html]# curl 127.0.0.1<br>//访问网页<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607145035820.png" alt="image-20200607145035820"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@8604fb370aab /]# yum provides ip<br>//查看哪一个组件支持这条命令<br>[root@8604fb370aab /]# yum -y install net-tools<br>//安装支持这条命令的<br>[root@8604fb370aab /]# ifconfig<br>//查看ip<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607145043072.png" alt="image-20200607145043072"></p><p><strong>宿主机查看网页</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# curl 172.17.0.4<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607145051323.png" alt="image-20200607145051323"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607145051323.png" alt="image-20200607145051323"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker commit webapp myweb:xgp<br>//把容器制作成镜像 （会返回一个哈希值，代表的是镜像的id号）增加可移植性<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607145113688.png" alt="image-20200607145113688"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker images<br>//查看镜像<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607145126415.png" alt="image-20200607145126415"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -itd --name webapp-2 myweb:xgp<br>[root@localhost ~]# docker exec -it webapp-2 /bin/bash<br>[root@e8d15e9aef29 /]# nginx <br>[root@e8d15e9aef29 /]# curl 127.0.0.1<br>This is a testweb in container<br>[root@e8d15e9aef29 /]# ifconfig<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607145136092.png" alt="image-20200607145136092"><br><strong>查看网页</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# curl 172.17.0.5<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607145144264.png" alt="image-20200607145144264"></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker底层原理介绍</title>
      <link href="/posts/df9f.html"/>
      <url>/posts/df9f.html</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="https://blog.51cto.com/14320361/2457143" target="_blank" rel="noopener">https://blog.51cto.com/14320361/2457143</a></p><h1>1.docker介绍</h1><p><strong>1.1什么是docker</strong><br>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上。</p><h1>1.2docker能解决什么问题</h1><p><strong>1.2.1高效有序利用资源</strong></p><p>机器资源有限；</p><p>单台机器得部署多个应用；</p><p>应用之间互相隔离；</p><p>应用之间不能发生资源抢占，每个应用只能使用事先注册申请的资源。</p><p><strong>1.2.2一次编译，到处运行</strong></p><p>类似于java代码，应用及依赖的环境构建一次，可以到处运行。</p><h1>1.2.docker底层原理介绍</h1><p><strong>1.2.1Linux的namespace和cgroup简单理解</strong><br>namespace:类似于JAVA的命名空间<br>controll groups ： controll （system resource） （for） （process）groups<br><strong>1.2.2Linux中的namespace</strong><br>在Linux系统中，可以同时存在多用户多进程，那么对他们的运行协调管理，通过进程调度和进度管理可以解决，但是，整体资源是有限的，怎么把有限的资源（进程号、网络资源等等）合理分配给各个用户所在的进程？<br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607142749026.png" alt="image-20200607142749026"><br>Linux Namespaces机制提供一种资源隔离方案。PID,IPC,Network等系统资源不再是全局性的，而是属于某个特定的Namespace。每个namespace下的资源对于其他namespace下的资源都是透明，不可见的。因此在操作系统层面上看，就会出现多个相同pid的进程。系统中可以同时存在两个进程号为0,1,2的进程，由于属于不同的namespace，所以它们之间并不冲突。而在用户层面上只能看到属于用户自己namespace下的资源，例如使用ps命令只能列出自己namespace下的进程。这样每个namespace看上去就像一个单独的Linux系统。<br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607142809764.png" alt="image-20200607142809764"><br>命名空间建立系统的不同视图， 对于每一个命名空间，从用户看起来，应该像一台单独的Linux计算机一样，有自己的init进程(PID为0)，其他进程的PID依次递增，A和B空间都有PID为0的init进程，子容器的进程映射到父容器的进程上，父容器可以知道每一个子容器的运行状态，而子容器与子容器之间是隔离的。</p><colgroup style="margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><col style="margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><col style="margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><col style="margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"><col style="margin: 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important;"></colgroup>**|**<p><strong>namespace</strong></p><p><strong>|</strong></p><p><strong>引入的相关内核版本</strong></p><p><strong>|</strong></p><p><strong>被隔离的全局系统资源</strong></p><p><strong>|</strong></p><p><strong>在容器语境下的隔离效果</strong></p><p><strong>|</strong><br><strong>| — | — | — | — |</strong><br><strong>| Mount namespaces | Linux 2.4.19 | 文件系统挂接点 |</strong></p><p><strong>将一个文件系统的顶层目录挂到另一个文件系统的子目录上，使它们成为一个整体，称为挂载。把该子目录称为挂载点。</strong></p><p><strong>Mount namespace用来隔离文件系统的挂载点, 使得不同的mount namespace拥有自己独立的挂载点信息，不同的namespace之间不会相互影响，这对于构建用户或者容器自己的文件系统目录非常有用。</strong></p><p><strong>|</strong><br><strong>| UTS namespaces | Linux 2.6.19 | nodename 和 domainname |</strong></p><p><strong>UTS，UNIX Time-sharing System namespace提供了主机名和域名的隔离。能够使得子进程有独立的主机名和域名(hostname)，这一特性在Docker容器技术中被用到，使得docker容器在网络上被视作一个独立的节点，而不仅仅是宿主机上的一个进程。</strong></p><p><strong>|</strong><br><strong>| IPC namespaces | Linux 2.6.19 | 特定的进程间通信资源，包括System V IPC 和 POSIX message queues |</strong></p><p><strong>IPC全称 Inter-Process Communication，是Unix/Linux下进程间通信的一种方式，IPC有共享内存、信号量、消息队列等方法。所以，为了隔离，我们也需要把IPC给隔离开来，这样，只有在同一个Namespace下的进程才能相互通信。如果你熟悉IPC的原理的话，你会知道，IPC需要有一个全局的ID，即然是全局的，那么就意味着我们的Namespace需要对这个ID隔离，不能让别的Namespace的进程看到。</strong></p><p><strong>|</strong><br><strong>| PID namespaces | Linux 2.6.24 | 进程 ID 数字空间 （process ID number space） |</strong></p><p><strong>PID namespaces用来隔离进程的ID空间，使得不同pid namespace里的进程ID可以重复且相互之间不影响。</strong></p><p><strong>PID namespace可以嵌套，也就是说有父子关系，在当前namespace里面创建的所有新的namespace都是当前namespace的子namespace。父namespace里面可以看到所有子孙后代namespace里的进程信息，而子namespace里看不到祖先或者兄弟namespace里的进程信息。</strong></p><p><strong>|</strong><br><strong>| Network namespaces | 始于Linux 2.6.24 完成于 Linux 2.6.29 | 网络相关的系统资源 | 每个容器用有其独立的网络设备，IP 地址，IP 路由表，/proc/net 目录，端口号等等。这也使得一个 host 上多个容器内的同一个应用都绑定到各自容器的 80 端口上。 |</strong><br><strong>| User namespaces | 始于 Linux 2.6.23 完成于 Linux 3.8) | 用户和组 ID 空间 |</strong></p><p><strong>User namespace用来隔离user权限相关的Linux资源，包括user IDs and group IDs。</strong></p><p><strong>这是目前实现的namespace中最复杂的一个，因为user和权限息息相关，而权限又事关容器的安全，所以稍有不慎，就会出安全问题。</strong></p><p><strong>在不同的user namespace中，同样一个用户的user ID 和group ID可以不一样，换句话说，一个用户可以在父user namespace中是普通用户，在子user namespace中是超级用户</strong></p><h1>1.3Namespace（名称空间）</h1><h1>用来隔离容器</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"> [root@localhost ~]# docker run -it --name test centos /bin/bash<br>//进入到容器里面<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607142825090.png" alt="image-20200607142825090"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@41052cceb473 /]# ls<br>//查看一下和宿主机差不多，都是从宿主机链接过来的<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607142846361.png" alt="image-20200607142846361"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@41052cceb473 /]# uname -r<br>//查看一下内核，和宿主机也是一样的<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607142906412.png" alt="image-20200607142906412"></p><p>如果虚拟机内服务对内核版有要求，这个服务就不太适合用docker来实现了，因为docker就是共用宿主机的内核，可以使用kvm之类的虚拟机。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker pull ubuntu<br>//使用docker下载一个Ubuntu<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607142917784.png" alt="image-20200607142917784"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker images<br>//查看一下<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607142925509.png" alt="image-20200607142925509"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -it ubuntu:latest /bin/bash<br>//进入ubuntu环境<br>root@afbee6750865:/# ls /<br>//查看一下<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607142952314.png" alt="image-20200607142952314"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@48c8dd7b098e:/# uname -r<br>//查看一下内核<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143006911.png" alt="image-20200607143006911"><br>Docker本身不占用任何端口，他一般是在后台运行，无论在docker里进行什么操作（系统、服务）对于docker来说他们仅仅就是一个进程<br>Run-centos系统（nginx，web）</p><p>Busybox：欺骗层。欺骗docker中的虚拟机是在自己独立的环境中<br>解耦：解除耦合、冲突。<br>耦合：冲突现象。</p><p><strong>1.4 Namespace操作</strong><br>/proc  /sys:虚拟文件系统，伪目录文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# cd /proc/<br>[root@localhost proc]# ls<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143018358.png" alt="image-20200607143018358"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost proc]# echo $$<br>//当前的进程编号<br>3864<br>[root@localhost proc]# cd 3864<br>[root@localhost 3864]# cd ns<br>[root@localhost ns]# ll<br>//可以看到一闪一闪的<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143031760.png" alt="image-20200607143031760"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ns]# ls<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143054886.png" alt="image-20200607143054886"><br><strong>IPC:共享内存、消息列队<br>MNT:挂载点、文件系统<br>NET:网络栈<br>PID: 进程编号<br>USER:用户、组<br>UTS:主机名、域名<br>namespec这六项隔离，实现了容器与宿主机，容器与容器之间的隔离</strong><br>//创建一个用户并设置密码</p><p><img src="https://s1.51cto.com/images/blog/201912/09/aaa865f9855da86faf8e4448f7ba9199.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt><br><strong>IPC:共享内存、消息列队<br>MNT:挂载点、文件系统<br>NET:网络栈<br>PID: 进程编号<br>USER:用户、组<br>UTS:主机名、域名<br>namespec这六项隔离，实现了容器与宿主机，容器与容器之间的隔离</strong><br>//创建一个用户并设置密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ns]# useradd bdqn <br>[root@localhost ns]# echo 123.com | passwd --stdin bdqn<br>[root@localhost ns]# id bdqn<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143226864.png" alt="image-20200607143226864"><br>查看docker进程<br><code>[root@localhost ns]# docker ps -a</code><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143121159.png" alt="image-20200607143121159"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ns]# docker start test<br>//启动centos<br>[root@localhost ns]# docker exec -it test /bin/bash<br>//进入docker容器<br>[root@41052cceb473 /]# id dbqn<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143208003.png" alt="image-20200607143208003"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@41052cceb473 /]# echo $$<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143238250.png" alt="image-20200607143238250"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143238250.png" alt="image-20200607143238250"></p><h1>2.1linux cgroup介绍</h1><p><strong>2.1.1有了namespace为什么还要cgroup:</strong></p><p>Docker 容器使用 linux namespace 来隔离其运行环境，使得容器中的进程看起来就像一个独立环境中运行一样。但是，光有运行环境隔离还不够，因为这些进程还是可以不受限制地使用系统资源，比如网络、磁盘、CPU以及内存 等。关于其目的，一方面，是为了防止它占用了太多的资源而影响到其它进程；另一方面，在系统资源耗尽的时候，linux 内核会触发 OOM，这会让一些被杀掉的进程成了无辜的替死鬼。因此，为了让容器中的进程更加可控，Docker 使用 Linux cgroups 来限制容器中的进程允许使用的系统资源。</p><p><strong>2.1.2原理</strong></p><p>Linux Cgroup 可为系统中所运行任务（进程）的用户定义组群分配资源 — 比如 CPU 时间、系统内存、网络带宽或者这些资源的组合。可以监控管理员配置的 cgroup，拒绝 cgroup 访问某些资源，甚至在运行的系统中动态配置 cgroup。所以，可以将 controll groups 理解为 controller （system resource） （for） （process）groups，也就是是说它以一组进程为目标进行系统资源分配和控制。它主要提供了如下功能：</p><p>Resource limitation: 限制资源使用，比如内存使用上限以及文件系统的缓存限制。</p><p>Prioritization: 优先级控制，比如：CPU利用和磁盘IO吞吐。</p><p>Accounting: 一些审计或一些统计，主要目的是为了计费。</p><p>Controll: 挂起进程，恢复执行进程。</p><p>使用 cgroup，系统管理员可更具体地控制对系统资源的分配、优先顺序、拒绝、管理和监控。可更好地根据任务和用户分配硬件资源，提高总体效率。</p><p>在实践中，系统管理员一般会利用CGroup做下面这些事：</p><p>隔离一个进程集合（比如：nginx的所有进程），并限制他们所消费的资源，比如绑定CPU的核。</p><p>为这组进程分配其足够使用的内存</p><p>为这组进程分配相应的网络带宽和磁盘存储限制</p><p>限制访问某些设备（通过设置设备的白名单）</p><h1>2.1.3Cgroup(控制组)操作</h1><h1>资源的限制，docker对于资源的占用</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# cd /sys/fs/cgroup/<br>//对cpu，内存限制的目录<br>[root@localhost cgroup]# ls<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143312266.png" alt="image-20200607143312266"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost cgroup]# cd cpu<br>[root@localhost cpu]# ls<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143321287.png" alt="image-20200607143321287"><br>cpu.shares：权重<br>tasks：这个文件内的数字，记录的是进程编号。PID</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost cpu]# cd docker/<br>[root@localhost docker]# ls<br></code></pre></td></tr></table></figure><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143334828.png" alt="image-20200607143334828" style="zoom:150%;"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost docker]# cat tasks<br>//里面是空的<br>[root@localhost docker]# cd 41052cceb4739fa8e0ddd2ffa733a78cd1043b3fdff874cd266c009391a34d70/<br><span class="hljs-meta">[root@localhost41052cceb4739fa8e0ddd2ffa733a78cd1043b3fdff874cd266c009391a34d70]#</span><span class="bash"> ls</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143348270.png" alt="image-20200607143348270"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">[root@localhost41052cceb4739fa8e0ddd2ffa733a78cd1043b3fdff874cd266c009391a34d70]#</span><span class="bash"> cat tasks</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143544415.png" alt="image-20200607143544415"></p><p><strong>四大功能：</strong><br>1）资源的限制：cgroup可以对进程组使用的资源总额进行限制<br>2）优先级分配：通过分配的cpu时间片数量以及硬盘IO带宽的大小，实际上相当于控制了进程运行的优先级别<br>3）资源统计： group可以统计系统资源使用量，比如gpu使用时间，内存使用量等，用于按量计费。同时还支持挂起动能，也就是说通过cgroup把所有 资源限制起来,对资源都不能使用，注意着并不是说我们的程序不能使用了,知识不能使用资源，处于等待状态。<br>4）进程控制：可以对进程组执行挂起、恢复等操作。</p><p><strong>2.1.4 内存限额</strong><br>容器内存包括两个部分：物理内存和swap<br>可以通过参数控制容器内存的使用量：<br>-m或者–memory:设置内存的使用限额<br>–memory-swap:设置内存+ swap的使用限额<br><strong>举个例子：</strong><br>运行一个容器，并且限制该容器最多使用200M内存和100M的swap</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -it -m 200M --memory-swap 300M centos:7<br>[root@fba67fec2718 ~]# cd /sys/fs/cgroup/<br>[root@fba67fec2718 cgroup]# ls<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143600579.png" alt="image-20200607143600579"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@fba67fec2718 cgroup]# cd memory/<br>[root@fba67fec2718 memory]# ls<br>[root@fba67fec2718 memory]# cat memory.limit_in_bytes<br>//查看内存使用限制，(单位字节）<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143608809.png" alt="image-20200607143608809"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@fba67fec2718 memory]# cat memory.memsw.limit_in_bytes<br>//查看交换分区，内存+swap限制<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143621693.png" alt="image-20200607143621693"></p><p><strong>运行一个新容器，并且不限制该容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -it  centos:7<br>[root@5be901bfb093 /]# cd /sys/fs/cgroup/memory/<br>[root@5be901bfb093 memory]# cat memory.limit_in_bytes<br>//查看内存限制<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143640010.png" alt="image-20200607143640010"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@5be901bfb093 memory]# cat memory.memsw.limit_in_bytes<br>//查看交换分区，内存+swap限制<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143651384.png" alt="image-20200607143651384"><br>对比一个没有限制的容器，我们会发现，如果运行容器之后不限制内存的话，意味着没有限制。</p><p><strong>2.1.5 CPU使用</strong><br>通过-c或者–cpu  -shares设置容器使用cpu的权重。如果不设置默认为1024.<br><strong>举个例子：</strong><br>没有限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -it --name containerA centos:7<br>//没有限制，1024<br>[root@8683d8ff8234 /]# cd /sys/fs/cgroup/cpu<br>[root@8683d8ff8234 cpu]# cat cpu.shares<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143739283.png" alt="image-20200607143739283"><br>限制CPU使用权重为512</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -it --name containerB -c 512 centos:7<br>//限制CPU使用权重为512<br>[root@d919d906295d /]# cd /sys/fs/cgroup/cpu<br>//可以看到cpu已经限制了<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143748604.png" alt="image-20200607143748604"></p><p><strong>2.1.6 容器的Block IO</strong><br><strong>磁盘的读写。</strong><br>Docker中可以通过设置权重，限制bps和iops的方式控制容器读写磁盘的IO<br>bps:每秒读写的数据量byte per second<br>iopS:每秒IO的次数 io per second。</p><p><strong>默认情况下，所有容器都能够平等的读写磁盘，也可以通过–blkig-weight参数改变容器的blocklO的优先级。</strong><br>–device-read-bps:显示读取某个设备的bps。<br>–device-write-bps:显示写入某个设备的bps.<br>–device-read-iops:显示读取某个设备的iops.<br>–device-write-iops:显示写入某个设备的iops.</p><p><strong>限制testA这个容器，写入/dev/sda这块磁盘的bps为30MB</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -it --name testA --device-write-bps /dev/sda:30MB centos:7<br><br> [root@60e59e96fc16 /]# time dd if=/dev/zero of=test.out bs=1M count=800 oflag=direct<br>//从/dev/zero输入，然后输出到test.out文件中，每次大小为1M，总共800次,oflag=direct 用来指定directlQ方式写文件，这样才会使--device-write-bps生效。<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143800323.png" alt="image-20200607143800323"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@60e59e96fc16 /]# du -h test.out<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143821357.png" alt="image-20200607143821357"></p><p><strong>docker没有限制</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -it --name testc centos:7<br>[root@5bf5f3d60d0e /]#  time dd if=/dev/zero of=test.out bs=1M count=800 oflag=direct<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143834432.png" alt="image-20200607143834432"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@5bf5f3d60d0e /]# du -h test.out<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143852264.png" alt="image-20200607143852264"></p><h1>3.Docker虚拟化与普通虚拟化的区别是什么？</h1><p><strong>虚拟机：</strong><br>我们传统的虚拟机需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给他的资源将全部被占用。，每一个虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。<br><strong>Docker：</strong><br>容器技术是和我们的宿主机共享硬件资源及操作系统可以实现资源的动态分配。<br>容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。</p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143908637.png" alt="image-20200607143908637"><br>虚拟机和容器都是在硬件和操作系统以上的，虚拟机有Hypervisor层，Hypervisor是整个虚拟机的核心所在。他为虚拟机提供了虚拟的运行平台，管理虚拟机的操作系统运行。每个虚拟机都有自己的系统和系统库以及应用。<br>容器没有Hypervisor这一层，并且每个容器是和宿主机共享硬件资源及操作系统，那么由Hypervisor带来性能的损耗，在linux容器这边是不存在的。<br>但是虚拟机技术也有其优势，能为应用提供一个更加隔离的环境，不会因为应用程序的漏洞给宿主机造成任何问题。同时还支持跨操作系统的虚拟化，例如你可以在linux操作系统下运行windows虚拟机。<br>从虚拟化层面来看，传统虚拟化技术是对硬件资源的虚拟，容器技术则是对进程的虚拟，从而可提供更轻量 级的虚拟化，实现进程和资源的隔离。<br>从架构来看，Docker比虚拟化少了两层，取消了hypervisor层和GuestOS层，使用 Docker Engine 进行调度和隔离，所有应用共用主机操作系统，因此在体量上，Docker较虚拟机更轻量级，在性能上优于虚拟化，接近裸机性能。从应用场景来 看，Docker和虚拟化则有各自擅长的领域，在软件开发、测试场景和生产运维场景中各有优劣<br><strong>具体对比：</strong></p><ol><li>docker启动快速属于秒级别。虚拟机通常需要几分钟去启动。</li><li>docker需要的资源更少，docker在操作系统级别进行虚拟化，docker容器和内核交互，几乎没有性能损耗，性能优于通过Hypervisor层与内核层的虚拟化。；</li><li>docker更轻量，docker的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境，Docker运行的镜像数远多于虚拟机数量。对系统的利用率非常高</li><li>与虚拟机相比，docker隔离性更弱，docker属于进程之间的隔离，虚拟机可实现系统级别隔离；</li><li>安全性： docker的安全性也更弱。Docker的租户root和宿主机root等同，一旦容器内的用户从普通用户权限提升为root权限，它就直接具备了宿主机的root权限，进而可进行无限制的操作。虚拟机租户root权限和宿主机的root虚拟机权限是分离的，并且虚拟机利用如Intel的VT-d和VT-x的ring-1硬件隔离技术，这种隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到***。</li><li>可管理性：docker的集中化管理工具还不算成熟。各种虚拟化技术都有成熟的管理工具，例如VMware vCenter提供完备的虚拟机管理能力。</li><li>高可用和可恢复性：docker对业务的高可用支持是通过快速重新部署实现的。虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制，VMware可承诺虚拟机99.999%高可用，保证业务连续性。</li><li>快速创建、删除：虚拟化创建是分钟级别的，Docker容器创建是秒级别的，Docker的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间。</li><li>交付、部署：虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化；Docker在Dockerfile中记录了容器构建过程，可在集群中实现快速分发和快速部署;</li></ol><p><strong>3.1.1 docker结构介绍</strong><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607143930763.png" alt="image-20200607143930763"><br>基础设施(Infrastructure)。</p><p>主操作系统(Host Operating System)。所有主流的Linux发行版都可以运行Docker。对于MacOS和Windows，也有一些办法”运行”Docker。</p><p>Docker守护进程(Docker Daemon)。Docker守护进程取代了Hypervisor，它是运行在操作系统之上的后台进程，负责管理Docker容器。</p><p>各种依赖。对于Docker，应用的所有依赖都打包在Docker镜像中，Docker容器是基于Docker镜像创建的。</p><p>应用。应用的源代码与它的依赖都打包在Docker镜像中，不同的应用需要不同的Docker镜像。不同的应用运行在不同的Docker容器中，它们是相互隔离的。</p><p>Docker守护进程可以直接与主操作系统进行通信，为各个Docker容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器互相隔离。虚拟机启动需要数分钟，而Docker容器可以在数毫秒内启动。由于没有臃肿的从操作系统，Docker可以节省大量的磁盘空间以及其他系统资源；虚拟机更擅长于资源的完全隔离。</p><p>链接：<a href="https://blog.51cto.com/14320361/2457143" target="_blank" rel="noopener">https://blog.51cto.com/14320361/2457143</a></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> kvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花式安装Docker</title>
      <link href="/posts/dd75.html"/>
      <url>/posts/dd75.html</url>
      
        <content type="html"><![CDATA[<p><strong>//使用docker的基本要求</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# uname -r<br>3.10.0-693.el7.x86_64<br></code></pre></td></tr></table></figure><p><strong>内核版本必须是3.10以上的。</strong></p><h1>一，安装dockers</h1><p><strong>在安装docker之前，再说一点，docker现在有两个版本，一个叫做docker-EE企业版，收费的一个叫docker-CE社区版，免费版，其实两个版本并没有太大的偏差，不一样的是docker公司会提供后续的官方的技术支持等服务，对于我们来说，肯定用社区办的多，我们拿来学习社区办更是可以的。</strong><br><strong>Docker的官网</strong><br><a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></p><h2 id="1，从Docker的官方下载"><strong>1，从Docker的官方下载</strong></h2><p><a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141455133.png" alt="image-20200607141455133"></p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141500936.png" alt="image-20200607141500936"><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141505888.png" alt="image-20200607141505888"><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141514750.png" alt="image-20200607141514750"><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141523787.png" alt="image-20200607141523787"><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141529401.png" alt="image-20200607141529401"><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141536554.png" alt="image-20200607141536554"></p><h2 id="2．官网安装docker方法一"><strong>2．官网安装docker方法一</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# vim /etc/yum.repos.d/docke-ce.repo<br>//编写yum源<br>[docker-ce]<br>name=docker-ce<br>baseurl=https://download.docker.com/linux/centos/7/x86_64/stable/Packages/<br>gpgcheck=0<br>enabled=1<br> <br>[root@localhost ~]# yum repolist<br>//查看仓库状态<br> <br>[root@localhost ~]# vim /etc/yum.repos.d/docke-ce.repo<br>//修改yum源<br>[docker-ce]<br>name=docker-ce<br>baseurl=https://download.docker.com/linux/centos/7/x86_64/stable/<br>gpgcheck=0<br>enabled=1<br>[root@localhost ~]# yum repolist<br>//查看仓库状态<br> <br>[root@localhost ~]# yum -y install docker-ce<br>//默认下载最新版，时间慢，一般不用这个<br></code></pre></td></tr></table></figure><p>因为网速原因，所以我们一般可以采取另外- -种方法，从我们国内下载，国内很多网站都提供了docker-ce的镜像站，比如说阿里云、网易云、清华大学镜像站等。这里我们从阿里云下载的方式来下载。</p><h2 id="3-阿里云下载方法二"><strong>3.阿里云下载方法二</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# rm -rf /etc/yum.repos.d/docke-ce.repo<br>//删除刚刚的yum源<br></code></pre></td></tr></table></figure><p>进入阿里镜像站<br><a href="https://developer.aliyun.com/mirror" target="_blank" rel="noopener">https://developer.aliyun.com/mirror</a><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141659148.png" alt="image-20200607141659148"><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141706804.png" alt="image-20200607141706804"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# yum install -y yum-utils device-mapper-persistent-data lvm2<br>[root@localhost ~]# yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br><br>[root@localhost ~]# ls /etc/yum.repos.d/<br>//查看yum源<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141718143.png" alt="image-20200607141718143"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# yum repolist<br>//查看仓库状态<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141722006.png" alt="image-20200607141722006"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# yum makecache<br>//做yum缓存，提速<br><br>[root@localhost ~]# yum list docker-ce.x86_64 --showduplicates | sort -r<br>//查看docker可用的版本<br></code></pre></td></tr></table></figure><p><a href="//xn--18-sv2cp8a077bw9ijubt6ok5zhy0e22ad5o.9.0" target="_blank" rel="noopener">//这里我们下载指定版本18.9.0</a>，注意并没有采取阿里云官方推荐的方法，我们分别下载了docker-ce,docker-ce-cli和containerd.io这3个组件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# yum -y install docker-ce-18.09.0-3.el7  docker-ce-cli-18.09.0-3.el7  tainerd.io-1.2.0-el7<br>//安装docker-ce,docker-ce-cli和containerd.io这3个组件<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141749928.png" alt="image-20200607141749928"></p><h2 id="4-安装完成之后"><strong>4.安装完成之后</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# systemctl  start docker<br>//开启docker<br>[root@localhost ~]# systemctl  enable docker<br>//docker加入开机自启<br>[root@localhost ~]# docker -v<br>Docker version 18.09.0, build 4d60db4<br>//查看docker版本是否是指定的版本<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141756948.png" alt="image-20200607141756948"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker version<br>//查看docker版本信息<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141802803.png" alt="image-20200607141802803"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">如果是最小化安装，来装一个tab命令补全<br>[root@localhost ~]# yum -y install bash-completion<br></code></pre></td></tr></table></figure><h1>二，Docker的基本概念</h1><p>image:镜像<br>container：容器<br>repostry:仓库<br>镜像是容器运行的基石，容器是镜像运行之后的实例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker pull centos:7<br>//下载一个centos7镜像，特别慢不建议<br></code></pre></td></tr></table></figure><h2 id="1，设置加速"><strong>1，设置加速</strong></h2><p>浏览器打开加速网站：道客云https://www.daocloud.io/<br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141814803.png" alt="image-20200607141814803"><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141819466.png" alt="image-20200607141819466"><br>//使用docker镜像加速器，这里使用的是daocloud的加速器，当然还有其他的加速器，例<br>如阿里云、清华镜像站等。</p><p>[r<code>oot@localhost ~]# curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io</code><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141826624.png" alt="image-20200607141826624"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# systemctl daemon-reload<br>//守护进程<br>[root@localhost ~]# systemctl restart docker<br>//重启docker<br><br>[root@localhost ~]# docker info<br>//查看docker的详细信息<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141833277.png" alt="image-20200607141833277"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# cat /etc/docker/daemon.json<br>&#123;"registry-mirrors": ["http://f1361db2.m.daocloud.io"]&#125;<br>//都是键值对<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141838304.png" alt="image-20200607141838304"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker pull centos:7<br>//再次下载centos7<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141842887.png" alt="image-20200607141842887"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker images<br>//查看本地镜像有哪些<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141850690.png" alt="image-20200607141850690"></p><h2 id="2，更改镜像加速网站为阿里云的"><strong>2，更改镜像加速网站为阿里云的</strong></h2><p><a href="https://www.aliyun.com/product/acr?spm=5176.12825654.eofdhaal5.42.366f2c4axwzdLK&amp;aly_as=kt8HE3oy" target="_blank" rel="noopener">https://www.aliyun.com/product/acr?spm=5176.12825654.eofdhaal5.42.366f2c4axwzdLK&amp;aly_as=kt8HE3oy</a><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141859760.png" alt="image-20200607141859760"><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141905151.png" alt="image-20200607141905151"><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141916845.png" alt="image-20200607141916845"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# cat /etc/docker/daemon.json<br>&#123;"registry-mirrors": ["http://f1361db2.m.daocloud.io"]&#125;<br> <br>//把刚刚复制的https://x7bv0r2q.mirror.aliyuncs.com，替换掉上面的<br></code></pre></td></tr></table></figure><p>也可以更改成这个网址，当然如果你更改之后，还需要执行reload命令，重新加载一下配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@docker ~]# systemctl daemon-reload <br>[root@docker ~]# systemctl restart docker<br>[root@docker ~]# docker pull centos<br>Using default tag: latest<br>latest: Pulling from library/centos<br></code></pre></td></tr></table></figure><h2 id="3，更改镜像加速网站为清华大学的"><strong>3，更改镜像加速网站为清华大学的</strong></h2><p>清华大学镜像站网址：<a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/</a><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141935283.png" alt="image-20200607141935283"></p><p><strong>测试：下载一个nginx</strong><br><code>[root@localhost ~]# docker pull nginx</code><br><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141944870.png" alt="image-20200607141944870"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker images<br>//查看本地镜像有哪些<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607141952764.png" alt="image-20200607141952764"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -itd -p 80 nginx<br>//多执行几次，运行多台nginx<br><br>[root@localhost ~]# docker ps<br>//查看docker服务<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607142019487.png" alt="image-20200607142019487"><br>浏览器测试</p><p><img src="https://gitee.com/xgpqq/tuchuang/raw/master/img/image-20200607142034427.png" alt="image-20200607142034427"></p><p>**开源项目：**诞生于2013年，dotcloud公司的业余项目，Go语言实现。—公司改名docker<br>集装箱：目标是实现轻量级的操作系统虚拟化方案。让用户不需要关心容器的管理，使得操作更加简便。</p><p><strong>docker和虚拟机、传统虚拟化的区别：</strong><br>传统的虚拟机：在硬件实现虚拟化，然后创建/安装操作系统。<br>docker：在操作系统层面实现虚拟化，直接服用本地主机的操作系统。</p><p><strong>为什么使用docker</strong></p><p>1，与传统虚拟化方式相比，具有众多的优势<br>a,docker容器启动在秒级<br>b,docker对系统资源利用率高，一台主机可以同时运行数千个docker容器<br>c,docker基本不消耗系统资源，使得运行在docker里面的应用的性能很高<br>2，其他优势：<br>a,更快的支付和部署：开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容易来部署代码；<br>b,更高级的虚拟化，docker容器的运行不需要额外的支持，它是内核级的虚拟化，因此可以实现更高的性能<br>c,更轻松的迁移和扩展：docker几乎可以在任意平台运行，比如物理机，虚拟机，公有云，私有云，个人电脑，服务器等。<br>d,更简单的管理：使用docker只需要简单的修改，就可以替代以往大量的更新工作。所有的修改都一增量方式被分发和更新，从而实现自动化并且高效的管理。</p><h3 id="docker中的基本概念："><strong>docker中的基本概念：</strong></h3><p><strong>镜像（images):只读的模板，通过这个模板创建docker容器</strong><br><strong>容器(container):是使用镜像创建并运行的实例。可以简单的将容器看做是简化版的操作系统。(可以看做是操作系统是因为里面包含root用户权限，进程空间和网络空间，还包括运行在里面的应用程序)</strong><br><strong>仓库(repository):集中存放镜像文件的地方。分为共有仓库和私有仓库。</strong></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>网站感想</title>
      <link href="/about/site.html"/>
      <url>/about/site.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>可爱的我</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>contact</title>
      <link href="/contact/index.html"/>
      <url>/contact/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/lib/canvas-nest/canvas-nest-nomobile.min.js"/>
      <url>/lib/canvas-nest/canvas-nest-nomobile.min.js</url>
      
        <content type="html"><![CDATA[!function(){var userAgentInfo = navigator.userAgent;    var Agents = ["iPad", "iPhone", "Android",           "SymbianOS", "Windows Phone",           "iPod", "webOS", "BlackBerry", "IEMobile"];    for (var v = 0; v < Agents.length; v++) {      if (userAgentInfo.indexOf(Agents[v]) > 0) {        return;      }    }function o(w,v,i){return w.getAttribute(v)||i}function j(i){return document.getElementsByTagName(i)}function l(){var i=j("script"),w=i.length,v=i[w-1];return{l:w,z:o(v,"zIndex",-1),o:o(v,"opacity",0.5),c:o(v,"color","0,0,0"),n:o(v,"count",99)}}function k(){r=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,n=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}function b(){e.clearRect(0,0,r,n);var w=[f].concat(t);var x,v,A,B,z,y;t.forEach(function(i){i.x+=i.xa,i.y+=i.ya,i.xa*=i.x>r||i.x<0?-1:1,i.ya*=i.y>n||i.y<0?-1:1,e.fillRect(i.x-0.5,i.y-0.5,1,1);for(v=0;v<w.length;v++){x=w[v];if(i!==x&&null!==x.x&&null!==x.y){B=i.x-x.x,z=i.y-x.y,y=B*B+z*z;y<x.max&&(x===f&&y>=x.max/2&&(i.x-=0.03*B,i.y-=0.03*z),A=(x.max-y)/x.max,e.beginPath(),e.lineWidth=A/2,e.strokeStyle="rgba("+s.c+","+(A+0.2)+")",e.moveTo(i.x,i.y),e.lineTo(x.x,x.y),e.stroke())}}w.splice(w.indexOf(i),1)}),m(b)}var u=document.createElement("canvas"),s=l(),c="c_n"+s.l,e=u.getContext("2d"),r,n,m=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(i){window.setTimeout(i,1000/45)},a=Math.random,f={x:null,y:null,max:20000};u.id=c;u.style.cssText="position:fixed;top:0;left:0;z-index:"+s.z+";opacity:"+s.o;j("body")[0].appendChild(u);k(),window.onresize=k;window.onmousemove=function(i){i=i||window.event,f.x=i.clientX,f.y=i.clientY},window.onmouseout=function(){f.x=null,f.y=null};for(var t=[],p=0;s.n>p;p++){var h=a()*r,g=a()*n,q=2*a()-1,d=2*a()-1;t.push({x:h,y:g,xa:q,ya:d,max:6000})}setTimeout(function(){b()},100)}();</0?-1:1,e.fillRect(i.x-0.5,i.y-0.5,1,1);for(v=0;v<w.length;v++){x=w[v];if(i!==x&&null!==x.x&&null!==x.y){B=i.x-x.x,z=i.y-x.y,y=B*B+z*z;y<x.max&&(x===f&&y></0?-1:1,i.ya*=i.y>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/lib/canvas-nest/README.html"/>
      <url>/lib/canvas-nest/README.html</url>
      
        <content type="html"><![CDATA[<h1>Theme NexT Canvas Nest</h1><p><img src="https://img.shields.io/badge/NexT-v7.3.0+-blue?style=flat-square" alt="Theme Version"></p><p><a href="https://github.com/hustcc/canvas-nest.js" target="_blank" rel="noopener">canvas-nest.js</a> for <a href="https://github.com/theme-next" target="_blank" rel="noopener">NexT</a>.</p><h2 id="Install">Install</h2><h3 id="Step-1-→-Go-to-Hexo-dir">Step 1 → Go to Hexo dir</h3><p>Change dir to <strong>Hexo</strong> directory. There must be <code>scaffolds</code>, <code>source</code>, <code>themes</code> and other directories:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ <span class="hljs-built_in">cd</span> hexo<br>$ ls<br>scaffolds  <span class="hljs-built_in">source</span>  themes  _config.yml  package.json<br></code></pre></td></tr></table></figure><h3 id="Step-2-→-Create-footer-swig">Step 2 → Create <code>footer.swig</code></h3><p>Create a file named <code>footer.swig</code> in <code>hexo/source/_data</code> directory (create <code>_data</code> directory if it does not exist).</p><p>Edit this file and add the following content:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"0,0,255"</span> <span class="hljs-attr">opacity</span>=<span class="hljs-string">"0.5"</span> <span class="hljs-attr">zIndex</span>=<span class="hljs-string">"-1"</span> <span class="hljs-attr">count</span>=<span class="hljs-string">"99"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>You can customize these options.</p><h3 id="Step-3-→-Set-it-up">Step 3 → Set it up</h3><p>In the NexT <code>_config.yml</code>, uncomment <code>footer</code> under the <code>custom_file_path</code> section.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Define custom file paths.</span><br><span class="hljs-comment"># Create your custom files in site directory `source/_data` and uncomment needed files below.</span><br><span class="hljs-attr">custom_file_path:</span><br>  <span class="hljs-comment">#head: source/_data/head.swig</span><br>  <span class="hljs-comment">#header: source/_data/header.swig</span><br>  <span class="hljs-comment">#sidebar: source/_data/sidebar.swig</span><br>  <span class="hljs-comment">#postMeta: source/_data/post-meta.swig</span><br>  <span class="hljs-comment">#postBodyEnd: source/_data/post-body-end.swig</span><br>  <span class="hljs-attr">footer:</span> <span class="hljs-string">source/_data/footer.swig</span><br>  <span class="hljs-comment">#bodyEnd: source/_data/body-end.swig</span><br>  <span class="hljs-comment">#variable: source/_data/variables.styl</span><br>  <span class="hljs-comment">#mixin: source/_data/mixins.styl</span><br>  <span class="hljs-comment">#style: source/_data/styles.styl</span><br></code></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/lib/canvas-nest/canvas-nest.min.js"/>
      <url>/lib/canvas-nest/canvas-nest.min.js</url>
      
        <content type="html"><![CDATA[!function(){function o(w,v,i){return w.getAttribute(v)||i}function j(i){return document.getElementsByTagName(i)}function l(){var i=j("script"),w=i.length,v=i[w-1];return{l:w,z:o(v,"zIndex",-1),o:o(v,"opacity",0.5),c:o(v,"color","0,0,0"),n:o(v,"count",99)}}function k(){r=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,n=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}function b(){e.clearRect(0,0,r,n);var w=[f].concat(t);var x,v,A,B,z,y;t.forEach(function(i){i.x+=i.xa,i.y+=i.ya,i.xa*=i.x>r||i.x<0?-1:1,i.ya*=i.y>n||i.y<0?-1:1,e.fillRect(i.x-0.5,i.y-0.5,1,1);for(v=0;v<w.length;v++){x=w[v];if(i!==x&&null!==x.x&&null!==x.y){B=i.x-x.x,z=i.y-x.y,y=B*B+z*z;y<x.max&&(x===f&&y>=x.max/2&&(i.x-=0.03*B,i.y-=0.03*z),A=(x.max-y)/x.max,e.beginPath(),e.lineWidth=A/2,e.strokeStyle="rgba("+s.c+","+(A+0.2)+")",e.moveTo(i.x,i.y),e.lineTo(x.x,x.y),e.stroke())}}w.splice(w.indexOf(i),1)}),m(b)}var u=document.createElement("canvas"),s=l(),c="c_n"+s.l,e=u.getContext("2d"),r,n,m=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(i){window.setTimeout(i,1000/45)},a=Math.random,f={x:null,y:null,max:20000};u.id=c;u.style.cssText="position:fixed;top:0;left:0;z-index:"+s.z+";opacity:"+s.o;j("body")[0].appendChild(u);k(),window.onresize=k;window.onmousemove=function(i){i=i||window.event,f.x=i.clientX,f.y=i.clientY},window.onmouseout=function(){f.x=null,f.y=null};for(var t=[],p=0;s.n>p;p++){var h=a()*r,g=a()*n,q=2*a()-1,d=2*a()-1;t.push({x:h,y:g,xa:q,ya:d,max:6000})}setTimeout(function(){b()},100)}();</0?-1:1,e.fillRect(i.x-0.5,i.y-0.5,1,1);for(v=0;v<w.length;v++){x=w[v];if(i!==x&&null!==x.x&&null!==x.y){B=i.x-x.x,z=i.y-x.y,y=B*B+z*z;y<x.max&&(x===f&&y></0?-1:1,i.ya*=i.y>]]></content>
      
    </entry>
    
    
  
</search>
